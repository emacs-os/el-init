;;; supervisor-test.el --- Tests for supervisor.el -*- lexical-binding: t -*-

;; Copyright (C) 2025 telecommuter <telecommuter@riseup.net>

;; This file is not part of GNU Emacs.

;;; Commentary:

;; ERT tests for supervisor.el.
;; Run with: make test
;; Run single test: make test-one TEST=test-name

;;; Code:

(require 'ert)
(require 'supervisor)

;;; Test Helpers

(defmacro supervisor-test-without-builtins (&rest body)
  "Execute BODY with built-in programs and timers suppressed."
  (declare (indent 0) (debug (body)))
  `(let ((supervisor--builtin-timers nil)
         (supervisor-seed-default-maintenance-units nil))
     (cl-letf (((symbol-function 'supervisor--builtin-programs)
                (lambda () nil)))
       ,@body)))

(defun supervisor-test--write-unit-files (dir programs)
  "Write PROGRAMS list as unit files in DIR.
Each entry in PROGRAMS is either a string (bare command) or
\(COMMAND . PLIST).  Generates one `.el' unit file per entry."
  (let ((idx 0))
    (dolist (entry programs)
      (let* ((cmd (if (stringp entry) entry (car entry)))
             (plist (if (stringp entry) nil (cdr entry)))
             (id (or (plist-get plist :id)
                     (format "entry%d" idx)))
             (file (expand-file-name (concat id ".el") dir)))
        ;; Build the unit-file plist
        (with-temp-file file
          (insert (format "(:id %S\n :command %S" id cmd))
          (let ((keys plist))
            (while keys
              (let ((key (car keys))
                    (val (cadr keys)))
                (unless (eq key :id)
                  (insert (format "\n %S %S" key val))))
              (setq keys (cddr keys))))
          (insert ")\n"))
        (cl-incf idx)))))

(defmacro supervisor-test-with-unit-files (programs &rest body)
  "Execute BODY with PROGRAMS written as unit files in a temp directory.
Binds `supervisor-unit-authority-path' and `supervisor-unit-directory'
to the temp dir, clears `supervisor--unit-file-invalid' and
`supervisor--programs-cache', suppresses built-in programs and timers,
and cleans up afterward."
  (declare (indent 1) (debug (form body)))
  `(supervisor-test-without-builtins
     (let* ((dir--temp (make-temp-file "units-" t))
            (supervisor-unit-authority-path (list dir--temp))
            (supervisor-unit-directory dir--temp)
            (supervisor--programs-cache :not-yet-loaded)
            (supervisor--unit-file-invalid (make-hash-table :test 'equal)))
       (supervisor-test--write-unit-files dir--temp ,programs)
       (unwind-protect
           (progn ,@body)
         (delete-directory dir--temp t)))))

(defmacro supervisor-test-with-authority-tiers (n &rest body)
  "Execute BODY with N authority tier directories.
Bind `dir1' through `dirN' to temp directories, set
`supervisor-unit-authority-path' to (dir1 ... dirN) (low to high
precedence), clear caches, suppress built-in programs and timers,
and clean up afterward."
  (declare (indent 1) (debug (form body)))
  (let ((dir-syms (cl-loop for i from 1 to n
                            collect (intern (format "dir%d" i)))))
    `(supervisor-test-without-builtins
       (let* (,@(mapcar (lambda (sym)
                          `(,sym (make-temp-file "tier-" t)))
                        dir-syms)
              (supervisor-unit-authority-path (list ,@dir-syms))
              (supervisor-unit-directory ,(car (last dir-syms)))
              (supervisor--programs-cache :not-yet-loaded)
              (supervisor--unit-file-invalid (make-hash-table :test 'equal)))
         (unwind-protect
             (progn ,@body)
           ,@(mapcar (lambda (sym)
                       `(delete-directory ,sym t))
                     dir-syms))))))

;;; Package structure tests

(ert-deftest supervisor-test-feature-provided ()
  "Verify the supervisor feature is provided."
  (should (featurep 'supervisor)))

(ert-deftest supervisor-test-module-load-core ()
  "Verify supervisor-core module loads and provides its feature."
  (should (featurep 'supervisor-core)))

(ert-deftest supervisor-test-module-load-dashboard ()
  "Verify supervisor-dashboard module loads and provides its feature."
  (should (featurep 'supervisor-dashboard)))

(ert-deftest supervisor-test-module-load-cli ()
  "Verify supervisor-cli module loads and provides its feature."
  (should (featurep 'supervisor-cli)))

(ert-deftest supervisor-test-module-core-standalone ()
  "Verify supervisor-core loads and works without dashboard, CLI, or timer.
Spawns a subprocess to test true standalone behavior.
Core guards timer calls with fboundp, so verify works without timer module."
  (let* ((default-directory (file-name-directory (locate-library "supervisor")))
         (result (call-process
                  "emacs" nil nil nil
                  "-Q" "--batch" "-L" "."
                  "--eval" "(require 'supervisor-core)"
                  "--eval" "(setq supervisor-unit-directory (make-temp-file \"units-\" t))"
                  "--eval" "(supervisor-verify)")))
    (should (= result 0))))

(ert-deftest supervisor-test-module-core-standalone-stop ()
  "Verify supervisor-stop works standalone without timer module.
Tests the stop path which was previously missing fboundp guard."
  (let* ((default-directory (file-name-directory (locate-library "supervisor")))
         (result (call-process
                  "emacs" nil nil nil
                  "-Q" "--batch" "-L" "."
                  "--eval" "(require 'supervisor-core)"
                  "--eval" "(setq supervisor-unit-directory (make-temp-file \"units-\" t))"
                  "--eval" "(supervisor-stop)")))
    (should (= result 0))))

(ert-deftest supervisor-test-module-core-standalone-start ()
  "Verify supervisor-start works standalone without timer module."
  (let* ((default-directory (file-name-directory (locate-library "supervisor")))
         (result (call-process
                  "emacs" nil nil nil
                  "-Q" "--batch" "-L" "."
                  "--eval" "(require 'supervisor-core)"
                  "--eval" "(setq supervisor-unit-directory (make-temp-file \"units-\" t))"
                  "--eval" "(supervisor-start)")))
    (should (= result 0))))

(ert-deftest supervisor-test-module-cli-standalone ()
  "Verify supervisor-cli loads and works without dashboard or timer.
Spawns a subprocess to test CLI dispatch without dashboard or timer module."
  (let* ((default-directory (file-name-directory (locate-library "supervisor")))
         (result (call-process
                  "emacs" nil nil nil
                  "-Q" "--batch" "-L" "."
                  "--eval" "(require 'supervisor-core)"
                  "--eval" "(require 'supervisor-cli)"
                  "--eval" "(setq supervisor-unit-directory (make-temp-file \"units-\" t))"
                  "--eval" "(supervisor--cli-dispatch '(\"status\"))")))
    (should (= result 0))))

(ert-deftest supervisor-test-module-no-cycles ()
  "Verify modules have no circular require chains.
Core must not require dashboard or cli.  This is checked by verifying
core symbols exist without dashboard/cli-specific dependencies."
  ;; Core should work standalone - key symbols should exist
  (should (fboundp 'supervisor--parse-entry))
  (should (fboundp 'supervisor--build-plan))
  (should (fboundp 'supervisor-start))
  ;; Dashboard-specific symbols should be in dashboard
  (should (fboundp 'supervisor-dashboard-mode))
  ;; CLI-specific symbols should be in cli
  (should (fboundp 'supervisor--cli-dispatch)))


;;; Entry parsing tests

(ert-deftest supervisor-test-parse-string-entry ()
  "Parse a simple string entry."
  (let ((parsed (supervisor--parse-entry "nm-applet")))
    (should (equal (supervisor-entry-id parsed) "nm-applet"))
    (should (equal (supervisor-entry-command parsed) "nm-applet"))
    (should (= (supervisor-entry-delay parsed) 0))
    (should (eq (supervisor-entry-enabled-p parsed) t))
    (should (eq (supervisor-entry-restart-policy parsed) 'always))
    (should (eq (supervisor-entry-logging-p parsed) t))
    (should-not (supervisor-entry-stdout-log-file parsed))
    (should-not (supervisor-entry-stderr-log-file parsed))
    (should (eq (supervisor-entry-type parsed) 'simple))
    (should (eq (supervisor-entry-stage parsed) 'stage3))))

(ert-deftest supervisor-test-parse-plist-entry ()
  "Parse a plist-style entry with options."
  (let ((parsed (supervisor--parse-entry
                 '("nm-applet" :type simple :delay 3 :restart nil))))
    (should (equal (supervisor-entry-id parsed) "nm-applet"))
    (should (= (supervisor-entry-delay parsed) 3))
    (should (eq (supervisor-entry-restart-policy parsed) 'no))
    (should (eq (supervisor-entry-type parsed) 'simple))
    (should (eq (supervisor-entry-stage parsed) 'stage3))))

(ert-deftest supervisor-test-parse-explicit-id ()
  "Parse entry with explicit :id."
  (let ((parsed (supervisor--parse-entry
                 '("/usr/bin/nm-applet" :id "network"))))
    (should (equal (supervisor-entry-id parsed) "network"))))

(ert-deftest supervisor-test-parse-oneshot ()
  "Parse oneshot entry."
  (let ((parsed (supervisor--parse-entry
                 '("xrdb ~/.Xresources" :type oneshot))))
    (should (eq (supervisor-entry-type parsed) 'oneshot))
    (should (eq (supervisor-entry-stage parsed) 'stage3))))

(ert-deftest supervisor-test-parse-enabled-disabled ()
  "Parse :enabled and :disabled flags."
  (let ((enabled (supervisor--parse-entry '("foo" :enabled t)))
        (disabled (supervisor--parse-entry '("foo" :disabled t)))
        (explicit-nil (supervisor--parse-entry '("foo" :enabled nil))))
    (should (eq (nth 3 enabled) t))
    (should (eq (nth 3 disabled) nil))
    (should (eq (nth 3 explicit-nil) nil))))

(ert-deftest supervisor-test-parse-restart-no-restart ()
  "Parse :restart and :no-restart flags."
  (let ((restart (supervisor--parse-entry '("foo" :restart t)))
        (no-restart (supervisor--parse-entry '("foo" :no-restart t)))
        (explicit-nil (supervisor--parse-entry '("foo" :restart nil))))
    (should (eq (nth 4 restart) 'always))
    (should (eq (nth 4 no-restart) 'no))
    (should (eq (nth 4 explicit-nil) 'no))))

(ert-deftest supervisor-test-parse-after-string ()
  "Parse :after as string."
  (let ((parsed (supervisor--parse-entry '("bar" :after "foo"))))
    (should (equal (supervisor-entry-after parsed) '("foo")))))

(ert-deftest supervisor-test-parse-after-list ()
  "Parse :after as list."
  (let ((parsed (supervisor--parse-entry '("baz" :after ("foo" "bar")))))
    (should (equal (supervisor-entry-after parsed) '("foo" "bar")))))

(ert-deftest supervisor-test-parse-stream-log-files ()
  "Parse per-stream log file options."
  (let ((parsed (supervisor--parse-entry
                 '("svc-cmd"
                   :stdout-log-file "/tmp/svc.out.log"
                   :stderr-log-file "/tmp/svc.err.log"))))
    (should (equal (supervisor-entry-stdout-log-file parsed)
                   "/tmp/svc.out.log"))
    (should (equal (supervisor-entry-stderr-log-file parsed)
                   "/tmp/svc.err.log"))))

(ert-deftest supervisor-test-validate-stream-log-files ()
  "Validate per-stream log file options."
  (should-not (supervisor--validate-entry
               '("svc-cmd"
                 :stdout-log-file "/tmp/svc.out.log"
                 :stderr-log-file "/tmp/svc.err.log")))
  (should (string-match-p ":stdout-log-file"
                          (supervisor--validate-entry
                           '("svc-cmd" :stdout-log-file ""))))
  (should (string-match-p ":stderr-log-file"
                          (supervisor--validate-entry
                           '("svc-cmd" :stderr-log-file 123)))))

;;; Restart policy tests

(ert-deftest supervisor-test-parse-restart-policy-symbols ()
  "All four restart policy symbols parse correctly."
  (let ((always (supervisor--parse-entry '("foo" :restart always)))
        (no (supervisor--parse-entry '("foo" :restart no)))
        (on-failure (supervisor--parse-entry '("foo" :restart on-failure)))
        (on-success (supervisor--parse-entry '("foo" :restart on-success))))
    (should (eq (nth 4 always) 'always))
    (should (eq (nth 4 no) 'no))
    (should (eq (nth 4 on-failure) 'on-failure))
    (should (eq (nth 4 on-success) 'on-success))))

(ert-deftest supervisor-test-parse-restart-policy-boolean-compat ()
  "Boolean :restart values are normalized to policy symbols."
  (let ((bool-t (supervisor--parse-entry '("foo" :restart t)))
        (bool-nil (supervisor--parse-entry '("foo" :restart nil)))
        (no-restart (supervisor--parse-entry '("foo" :no-restart t))))
    (should (eq (nth 4 bool-t) 'always))
    (should (eq (nth 4 bool-nil) 'no))
    (should (eq (nth 4 no-restart) 'no))))

(ert-deftest supervisor-test-validate-restart-invalid-symbol ()
  "Invalid :restart symbol is rejected by validation."
  (let ((reason (supervisor--validate-entry '("foo" :restart bogus))))
    (should reason)
    (should (string-match-p ":restart" reason))))

(ert-deftest supervisor-test-clean-exit-p ()
  "Clean exit predicate handles all cases."
  ;; Exit code 0 is always clean
  (should (supervisor--clean-exit-p 'exit 0))
  ;; Non-zero exit is not clean
  (should-not (supervisor--clean-exit-p 'exit 1))
  (should-not (supervisor--clean-exit-p 'exit 127))
  ;; Clean signals: HUP(1), INT(2), PIPE(13), TERM(15)
  (should (supervisor--clean-exit-p 'signal 1))
  (should (supervisor--clean-exit-p 'signal 2))
  (should (supervisor--clean-exit-p 'signal 13))
  (should (supervisor--clean-exit-p 'signal 15))
  ;; Non-clean signals: KILL(9), SEGV(11)
  (should-not (supervisor--clean-exit-p 'signal 9))
  (should-not (supervisor--clean-exit-p 'signal 11)))

(ert-deftest supervisor-test-should-restart-p ()
  "Full policy x exit-type matrix for restart decisions."
  ;; always: restart on any exit
  (should (supervisor--should-restart-p 'always 'exit 0))
  (should (supervisor--should-restart-p 'always 'exit 1))
  (should (supervisor--should-restart-p 'always 'signal 9))
  (should (supervisor--should-restart-p 'always 'signal 15))
  ;; no: never restart
  (should-not (supervisor--should-restart-p 'no 'exit 0))
  (should-not (supervisor--should-restart-p 'no 'exit 1))
  (should-not (supervisor--should-restart-p 'no 'signal 9))
  (should-not (supervisor--should-restart-p 'no 'signal 15))
  ;; on-failure: restart only on non-clean exit
  (should-not (supervisor--should-restart-p 'on-failure 'exit 0))
  (should (supervisor--should-restart-p 'on-failure 'exit 1))
  (should (supervisor--should-restart-p 'on-failure 'signal 9))
  (should-not (supervisor--should-restart-p 'on-failure 'signal 15))
  ;; on-success: restart only on clean exit
  (should (supervisor--should-restart-p 'on-success 'exit 0))
  (should-not (supervisor--should-restart-p 'on-success 'exit 1))
  (should-not (supervisor--should-restart-p 'on-success 'signal 9))
  (should (supervisor--should-restart-p 'on-success 'signal 15))
  ;; Legacy boolean compat
  (should (supervisor--should-restart-p t 'exit 1))
  (should-not (supervisor--should-restart-p nil 'exit 1)))

(ert-deftest supervisor-test-signal-to-number ()
  "Signal symbol to number lookup."
  (should (= 1 (supervisor--signal-to-number 'SIGHUP)))
  (should (= 9 (supervisor--signal-to-number 'SIGKILL)))
  (should (= 10 (supervisor--signal-to-number 'SIGUSR1)))
  (should (= 15 (supervisor--signal-to-number 'SIGTERM)))
  (should (= 17 (supervisor--signal-to-number 'SIGCHLD)))
  (should (= 31 (supervisor--signal-to-number 'SIGSYS)))
  (should-not (supervisor--signal-to-number 'SIGFAKE)))

(ert-deftest supervisor-test-signal-to-number-covers-known-signals ()
  "Every signal in `supervisor--known-signals' has a number mapping."
  (dolist (sig supervisor--known-signals)
    (should (integerp (supervisor--signal-to-number sig)))))

(ert-deftest supervisor-test-clean-exit-p-extra-codes ()
  "Extra exit codes from :success-exit-status are treated as clean."
  (let ((ses '(:codes (42 77) :signals nil)))
    ;; 42 is normally not clean
    (should-not (supervisor--clean-exit-p 'exit 42))
    ;; With extra codes, 42 is clean
    (should (supervisor--clean-exit-p 'exit 42 ses))
    (should (supervisor--clean-exit-p 'exit 77 ses))
    ;; Other codes still not clean
    (should-not (supervisor--clean-exit-p 'exit 99 ses))
    ;; Exit 0 still clean (baseline)
    (should (supervisor--clean-exit-p 'exit 0 ses))))

(ert-deftest supervisor-test-clean-exit-p-extra-signals ()
  "Extra signals from :success-exit-status are treated as clean."
  (let ((ses '(:codes nil :signals (SIGUSR1 SIGUSR2))))
    ;; SIGUSR1 (10) is normally not clean
    (should-not (supervisor--clean-exit-p 'signal 10))
    ;; With extra signals, SIGUSR1 is clean
    (should (supervisor--clean-exit-p 'signal 10 ses))
    ;; SIGUSR2 (12) is clean
    (should (supervisor--clean-exit-p 'signal 12 ses))
    ;; SIGKILL (9) still not clean
    (should-not (supervisor--clean-exit-p 'signal 9 ses))
    ;; Baseline clean signals still clean
    (should (supervisor--clean-exit-p 'signal 15 ses))))

(ert-deftest supervisor-test-should-restart-p-on-failure-extra-code ()
  "On-failure policy: extra success code suppresses restart."
  (let ((ses '(:codes (42) :signals nil)))
    ;; Without extra, exit 42 triggers restart under on-failure
    (should (supervisor--should-restart-p 'on-failure 'exit 42))
    ;; With extra, exit 42 is clean so no restart
    (should-not (supervisor--should-restart-p 'on-failure 'exit 42 ses))
    ;; Exit 1 still triggers restart
    (should (supervisor--should-restart-p 'on-failure 'exit 1 ses))))

(ert-deftest supervisor-test-should-restart-p-on-success-extra-code ()
  "On-success policy: extra success code triggers restart."
  (let ((ses '(:codes (42) :signals nil)))
    ;; Without extra, exit 42 does NOT trigger restart under on-success
    (should-not (supervisor--should-restart-p 'on-success 'exit 42))
    ;; With extra, exit 42 is clean so restart triggers
    (should (supervisor--should-restart-p 'on-success 'exit 42 ses))))

(ert-deftest supervisor-test-should-restart-p-on-failure-extra-signal ()
  "On-failure policy: extra success signal suppresses restart."
  (let ((ses '(:codes nil :signals (SIGUSR1))))
    ;; SIGUSR1 (10) normally triggers restart under on-failure
    (should (supervisor--should-restart-p 'on-failure 'signal 10))
    ;; With extra, SIGUSR1 is clean so no restart
    (should-not (supervisor--should-restart-p 'on-failure 'signal 10 ses))))

(ert-deftest supervisor-test-should-restart-p-always-no-unaffected ()
  "Always/no policies unaffected by :success-exit-status."
  (let ((ses '(:codes (42) :signals (SIGUSR1))))
    (should (supervisor--should-restart-p 'always 'exit 42 ses))
    (should-not (supervisor--should-restart-p 'no 'exit 42 ses))))

(ert-deftest supervisor-test-clean-exit-p-extra-signal-beyond-15 ()
  "Signals beyond the base 1-15 range work in :success-exit-status."
  (let ((ses '(:codes nil :signals (SIGCHLD))))
    ;; SIGCHLD (17) is not in the baseline clean set
    (should-not (supervisor--clean-exit-p 'signal 17))
    ;; With :success-exit-status, SIGCHLD is treated as clean
    (should (supervisor--clean-exit-p 'signal 17 ses))))

(ert-deftest supervisor-test-overrides-load-migrates-legacy-restart ()
  "Loading overrides with legacy enabled/disabled migrates to policy symbols."
  (let* ((temp-file (make-temp-file "supervisor-test-migrate-" nil ".eld"))
         (supervisor-overrides-file temp-file)
         (supervisor--enabled-override (make-hash-table :test 'equal))
         (supervisor--restart-override (make-hash-table :test 'equal))
         (supervisor--logging (make-hash-table :test 'equal))
         (supervisor--mask-override (make-hash-table :test 'equal))
         (supervisor--overrides-loaded nil))
    (unwind-protect
        (progn
          ;; Write file with legacy enabled/disabled restart values
          (with-temp-file temp-file
            (insert ";; test overrides\n")
            (prin1 `((version . 1)
                     (timestamp . "2025-01-01T00:00:00+0000")
                     (overrides . (("svc-a" :restart enabled)
                                   ("svc-b" :restart disabled))))
                   (current-buffer)))
          ;; Load
          (should (supervisor--load-overrides))
          ;; Legacy values should be migrated
          (should (eq 'always (gethash "svc-a" supervisor--restart-override)))
          (should (eq 'no (gethash "svc-b" supervisor--restart-override))))
      (delete-file temp-file))))

(ert-deftest supervisor-test-entry-restart-p-accessor ()
  "The restart-p accessor returns boolean from policy symbol."
  (let ((always-entry (list "id" "cmd" 0 t 'always t 'simple 'stage3 nil t 30 nil nil))
        (no-entry (list "id" "cmd" 0 t 'no t 'simple 'stage3 nil t 30 nil nil))
        (on-failure-entry (list "id" "cmd" 0 t 'on-failure t 'simple 'stage3 nil t 30 nil nil)))
    (should (supervisor-entry-restart-p always-entry))
    (should-not (supervisor-entry-restart-p no-entry))
    (should (supervisor-entry-restart-p on-failure-entry))))

(ert-deftest supervisor-test-entry-restart-policy-accessor ()
  "The restart-policy accessor returns the raw policy symbol."
  (let ((entry (list "id" "cmd" 0 t 'on-failure t 'simple 'stage3 nil t 30 nil nil)))
    (should (eq 'on-failure (supervisor-entry-restart-policy entry)))))

(ert-deftest supervisor-test-get-effective-restart-policy ()
  "Effective restart returns policy symbols with override migration."
  (let ((supervisor--restart-override (make-hash-table :test 'equal)))
    ;; No override: return config value
    (should (eq 'always (supervisor--get-effective-restart "svc" 'always)))
    (should (eq 'on-failure (supervisor--get-effective-restart "svc" 'on-failure)))
    ;; Legacy boolean config: normalized
    (should (eq 'always (supervisor--get-effective-restart "svc" t)))
    (should (eq 'no (supervisor--get-effective-restart "svc" nil)))
    ;; Override with policy symbol
    (puthash "svc" 'no supervisor--restart-override)
    (should (eq 'no (supervisor--get-effective-restart "svc" 'always)))
    ;; Override with legacy enabled/disabled
    (puthash "svc" 'enabled supervisor--restart-override)
    (should (eq 'always (supervisor--get-effective-restart "svc" 'no)))
    (puthash "svc" 'disabled supervisor--restart-override)
    (should (eq 'no (supervisor--get-effective-restart "svc" 'always)))))

(ert-deftest supervisor-test-restart-policy-to-bool-nil ()
  "Nil restart policy (oneshot n/a) converts to false, not true."
  (should-not (supervisor--restart-policy-to-bool nil))
  (should-not (supervisor--restart-policy-to-bool 'no))
  (should (supervisor--restart-policy-to-bool 'always))
  (should (supervisor--restart-policy-to-bool 'on-failure))
  (should (supervisor--restart-policy-to-bool 'on-success)))

(ert-deftest supervisor-test-cycle-restart-policy ()
  "Cycle restart policy follows no -> on-success -> on-failure -> always -> no."
  (should (eq 'on-success (supervisor--cycle-restart-policy 'no)))
  (should (eq 'on-failure (supervisor--cycle-restart-policy 'on-success)))
  (should (eq 'always (supervisor--cycle-restart-policy 'on-failure)))
  (should (eq 'no (supervisor--cycle-restart-policy 'always)))
  ;; Unknown values default to no
  (should (eq 'no (supervisor--cycle-restart-policy 'bogus))))

(ert-deftest supervisor-test-dashboard-set-restart-policy-interactive ()
  "Dashboard set-restart-policy applies explicit selections end-to-end.
Exercises the interactive function with a real tabulated-list buffer,
verifying policy selection, override-clear on return to config, and
restart-timer cancellation on `no'."
  (supervisor-test-with-unit-files
      '(("sleep 999" :id "svc" :type simple :restart always))
    (let ((supervisor--restart-override (make-hash-table :test 'equal))
          (supervisor--restart-timers (make-hash-table :test 'equal))
          (supervisor--invalid (make-hash-table :test 'equal))
          (supervisor--processes (make-hash-table :test 'equal))
          (supervisor--failed (make-hash-table :test 'equal))
          (supervisor--oneshot-completed (make-hash-table :test 'equal))
          (supervisor--manually-stopped (make-hash-table :test 'equal))
          (supervisor--manually-started (make-hash-table :test 'equal))
          (supervisor--enabled-override (make-hash-table :test 'equal))
          (supervisor--logging (make-hash-table :test 'equal))
          (supervisor--mask-override (make-hash-table :test 'equal))
          (supervisor--entry-state (make-hash-table :test 'equal))
          (supervisor--start-times (make-hash-table :test 'equal))
          (supervisor--ready-times (make-hash-table :test 'equal))
          (supervisor-overrides-file nil)
          (fake-timer (run-at-time 9999 nil #'ignore)))
      (unwind-protect
          (let ((buf (get-buffer-create "*supervisor*")))
            (unwind-protect
                (with-current-buffer buf
                  (supervisor-dashboard-mode)
                  ;; Pre-seed a restart timer for cancellation test
                  (puthash "svc" fake-timer supervisor--restart-timers)
                  ;; Helper: move point to the "svc" row
                  (cl-flet ((goto-svc ()
                              (goto-char (point-min))
                              (while (and (not (eobp))
                                          (not (equal (cons :service "svc")
                                                      (tabulated-list-get-id))))
                                (forward-line 1))))
                    ;; Initial refresh to populate entries from unit file
                    (supervisor--refresh-dashboard)
                    (let ((choices '("no" "on-success" "on-failure" "always")))
                      (cl-letf (((symbol-function 'completing-read)
                                 (lambda (_prompt _collection &rest _)
                                   (prog1 (car choices)
                                     (setq choices (cdr choices))))))
                        ;; Selection 1: config=always -> no (override set, timer cancelled)
                        (goto-svc)
                        (supervisor-dashboard-set-restart-policy)
                        (should (eq 'no (gethash "svc" supervisor--restart-override)))
                        (should-not (gethash "svc" supervisor--restart-timers))
                        ;; Selection 2: no -> on-success
                        (goto-svc)
                        (supervisor-dashboard-set-restart-policy)
                        (should (eq 'on-success (gethash "svc" supervisor--restart-override)))
                        ;; Selection 3: on-success -> on-failure
                        (goto-svc)
                        (supervisor-dashboard-set-restart-policy)
                        (should (eq 'on-failure (gethash "svc" supervisor--restart-override)))
                        ;; Selection 4: on-failure -> always (matches config, override cleared)
                        (goto-svc)
                        (supervisor-dashboard-set-restart-policy)
                        (should-not (gethash "svc" supervisor--restart-override))))))
              (kill-buffer buf)))
        (when (timerp fake-timer) (cancel-timer fake-timer))))))

(ert-deftest supervisor-test-cli-restart-policy-rejects-legacy-on-off ()
  "Restart-policy rejects legacy on/off values."
  (let ((supervisor--restart-override (make-hash-table :test 'equal)))
    (let ((result (supervisor--cli-dispatch '("restart-policy" "on" "test-id"))))
      (should (= supervisor-cli-exit-invalid-args
                 (supervisor-cli-result-exitcode result))))
    (let ((result (supervisor--cli-dispatch '("restart-policy" "off" "test-id"))))
      (should (= supervisor-cli-exit-invalid-args
                 (supervisor-cli-result-exitcode result))))))

(ert-deftest supervisor-test-oneshot-json-restart-na ()
  "Oneshot entries emit restart \"n/a\" in JSON."
  (let* ((supervisor-programs '(("true" :type oneshot)))
         (supervisor--processes (make-hash-table :test 'equal))
         (supervisor--restart-override (make-hash-table :test 'equal))
         (supervisor--enabled-override (make-hash-table :test 'equal))
         (supervisor--logging (make-hash-table :test 'equal))
         (supervisor--mask-override (make-hash-table :test 'equal))
         (supervisor--failed (make-hash-table :test 'equal))
         (supervisor--oneshot-completed (make-hash-table :test 'equal))
         (supervisor--manually-stopped (make-hash-table :test 'equal))
         (supervisor--manually-started (make-hash-table :test 'equal))
         (supervisor--invalid (make-hash-table :test 'equal))
         (supervisor--start-times (make-hash-table :test 'equal))
         (supervisor--ready-times (make-hash-table :test 'equal))
         (supervisor--entry-state (make-hash-table :test 'equal))
         (supervisor-unit-directory "/nonexistent-supervisor-test-dir"))
    (let* ((result (supervisor--cli-all-entries-info))
           (entries (car result))
           (info (car entries))
           (json-obj (supervisor--cli-entry-to-json-obj info)))
      ;; restart field must be "n/a" for oneshot (not a policy symbol)
      (should (equal "n/a" (alist-get 'restart json-obj))))))

(ert-deftest supervisor-test-dashboard-restart-uses-snapshot ()
  "Dashboard restart resolution uses snapshot, not global state."
  (let* ((snapshot-restart (make-hash-table :test 'equal))
         (supervisor--restart-override (make-hash-table :test 'equal)))
    ;; Global says always, snapshot says no
    (puthash "svc" 'always supervisor--restart-override)
    (puthash "svc" 'no snapshot-restart)
    (let* ((snapshot (supervisor-snapshot--create
                      :process-alive (make-hash-table :test 'equal)
                      :process-pids (make-hash-table :test 'equal)
                      :failed (make-hash-table :test 'equal)
                      :oneshot-exit (make-hash-table :test 'equal)
                      :entry-state (make-hash-table :test 'equal)
                      :invalid (make-hash-table :test 'equal)
                      :enabled-override (make-hash-table :test 'equal)
                      :restart-override snapshot-restart
                      :logging-override (make-hash-table :test 'equal)
                      :mask-override (make-hash-table :test 'equal)
                      :manually-started (make-hash-table :test 'equal)
                      :timestamp (float-time)))
           (vec (supervisor--make-dashboard-entry
                 "svc" 'simple nil t 'always t snapshot)))
      ;; Restart column (index 5) should say "no" from snapshot, not "yes" from global
      (should (equal "no" (aref vec 5))))))

(ert-deftest supervisor-test-dashboard-oneshot-restart-renders-na ()
  "Dashboard renders oneshot restart column as n/a."
  (let* ((snapshot (supervisor-snapshot--create
                    :process-alive (make-hash-table :test 'equal)
                    :process-pids (make-hash-table :test 'equal)
                    :failed (make-hash-table :test 'equal)
                    :oneshot-exit (make-hash-table :test 'equal)
                    :entry-state (make-hash-table :test 'equal)
                    :invalid (make-hash-table :test 'equal)
                    :enabled-override (make-hash-table :test 'equal)
                    :restart-override (make-hash-table :test 'equal)
                    :logging-override (make-hash-table :test 'equal)
                    :mask-override (make-hash-table :test 'equal)
                    :manually-started (make-hash-table :test 'equal)
                    :timestamp (float-time)))
         (vec (supervisor--make-dashboard-entry
               "svc" 'oneshot nil t 'always t snapshot)))
    (should (equal "n/a" (aref vec 5)))))

(ert-deftest supervisor-test-dashboard-oneshot-done-pid-renders-dash ()
  "Dashboard hides oneshot exit-code pseudo-PIDs in the PID column."
  (let* ((oneshot-exit (make-hash-table :test 'equal))
         (snapshot nil)
         (vec nil))
    (puthash "svc" 0 oneshot-exit)
    (setq snapshot
          (supervisor-snapshot--create
           :process-alive (make-hash-table :test 'equal)
           :process-pids (make-hash-table :test 'equal)
           :failed (make-hash-table :test 'equal)
           :oneshot-exit oneshot-exit
           :entry-state (make-hash-table :test 'equal)
           :invalid (make-hash-table :test 'equal)
           :enabled-override (make-hash-table :test 'equal)
           :restart-override (make-hash-table :test 'equal)
           :logging-override (make-hash-table :test 'equal)
           :mask-override (make-hash-table :test 'equal)
           :manually-started (make-hash-table :test 'equal)
           :timestamp (float-time)))
    (setq vec (supervisor--make-dashboard-entry
               "svc" 'oneshot nil t 'always t snapshot))
    (should (equal "done" (substring-no-properties (aref vec 4))))
    (should (equal "-" (aref vec 7)))))

;;; Stage conversion tests

;;; Normalize :after tests

(ert-deftest supervisor-test-normalize-after ()
  "Normalize :after values to lists."
  (should (equal (supervisor--normalize-after nil) nil))
  (should (equal (supervisor--normalize-after "foo") '("foo")))
  (should (equal (supervisor--normalize-after '("foo" "bar")) '("foo" "bar"))))

;;; Oneshot wait/timeout tests

(ert-deftest supervisor-test-oneshot-blocking-p-default ()
  "Default oneshot blocking behavior."
  (should (eq (supervisor--oneshot-blocking-p '()) supervisor-oneshot-default-blocking)))

(ert-deftest supervisor-test-oneshot-blocking-p-explicit ()
  "Explicit :oneshot-blocking overrides default."
  (should (eq (supervisor--oneshot-blocking-p '(:oneshot-blocking t)) t))
  (should (eq (supervisor--oneshot-blocking-p '(:oneshot-blocking nil)) nil)))

(ert-deftest supervisor-test-oneshot-blocking-p-oneshot-async ()
  "The :oneshot-async flag is inverse of :oneshot-blocking."
  (should (eq (supervisor--oneshot-blocking-p '(:oneshot-async t)) nil))
  (should (eq (supervisor--oneshot-blocking-p '(:oneshot-async nil)) t)))

(ert-deftest supervisor-test-oneshot-timeout-default ()
  "Default oneshot timeout."
  (should (eq (supervisor--oneshot-timeout-value '()) supervisor-oneshot-timeout)))

(ert-deftest supervisor-test-oneshot-timeout-explicit ()
  "Explicit :oneshot-timeout."
  (should (= (supervisor--oneshot-timeout-value '(:oneshot-timeout 60)) 60))
  (should (eq (supervisor--oneshot-timeout-value '(:oneshot-timeout nil)) nil)))

;;; Entry validation tests

(ert-deftest supervisor-test-validate-string-entry ()
  "String entries are always valid."
  (should (null (supervisor--validate-entry "nm-applet")))
  (should (null (supervisor--validate-entry "/usr/bin/foo"))))

(ert-deftest supervisor-test-validate-valid-simple ()
  "Valid simple entry passes validation."
  (should (null (supervisor--validate-entry
                 '("nm-applet" :type simple :restart t)))))

(ert-deftest supervisor-test-validate-valid-oneshot ()
  "Valid oneshot entry passes validation."
  (should (null (supervisor--validate-entry
                 '("xrdb" :type oneshot :oneshot-timeout 30)))))

(ert-deftest supervisor-test-validate-unknown-keyword ()
  "Unknown keywords are rejected."
  (should (string-match "unknown keyword"
                        (supervisor--validate-entry
                         '("foo" :bogus t)))))

(ert-deftest supervisor-test-validate-rejects-legacy-oneshot-wait ()
  "Legacy :oneshot-wait keyword is rejected as unknown."
  (should (string-match "unknown keyword.*:oneshot-wait"
                        (supervisor--validate-entry
                         '("foo" :type oneshot :oneshot-wait t)))))

(ert-deftest supervisor-test-validate-rejects-legacy-async ()
  "Legacy :async keyword is rejected as unknown."
  (should (string-match "unknown keyword.*:async"
                        (supervisor--validate-entry
                         '("foo" :type oneshot :async t)))))

(ert-deftest supervisor-test-validate-invalid-type ()
  "Invalid :type values are rejected."
  (should (string-match ":type must be"
                        (supervisor--validate-entry
                         '("foo" :type daemon)))))

(ert-deftest supervisor-test-validate-invalid-stage ()
  ":stage produces deprecation error."
  (should (string-match ":stage is removed"
                        (supervisor--validate-entry
                         '("foo" :stage boot)))))

(ert-deftest supervisor-test-validate-invalid-delay ()
  "Invalid :delay values are rejected."
  (should (string-match ":delay must be"
                        (supervisor--validate-entry
                         '("foo" :delay "slow"))))
  (should (string-match ":delay must be"
                        (supervisor--validate-entry
                         '("foo" :delay -1)))))

(ert-deftest supervisor-test-validate-id-must-be-string ()
  "Non-string :id values are rejected."
  (should (string-match ":id must be a string"
                        (supervisor--validate-entry
                         '("foo" :id 42))))
  (should (string-match ":id must be a string"
                        (supervisor--validate-entry
                         '("foo" :id foo-symbol))))
  ;; String :id is valid
  (should-not (supervisor--validate-entry
               '("foo" :id "valid-string"))))

(ert-deftest supervisor-test-validate-invalid-oneshot-timeout ()
  "Invalid :oneshot-timeout values are rejected."
  (should (string-match ":oneshot-timeout must be"
                        (supervisor--validate-entry
                         '("foo" :type oneshot :oneshot-timeout "slow")))))

(ert-deftest supervisor-test-validate-mutually-exclusive-enabled ()
  ":enabled and :disabled are mutually exclusive."
  (should (string-match "mutually exclusive"
                        (supervisor--validate-entry
                         '("foo" :enabled t :disabled t)))))

(ert-deftest supervisor-test-validate-mutually-exclusive-restart ()
  ":restart and :no-restart are mutually exclusive."
  (should (string-match "mutually exclusive"
                        (supervisor--validate-entry
                         '("foo" :restart t :no-restart t)))))

(ert-deftest supervisor-test-validate-simple-rejects-oneshot-keywords ()
  "Simple type rejects oneshot-specific keywords."
  (should (string-match ":oneshot-blocking is invalid for :type simple"
                        (supervisor--validate-entry
                         '("foo" :type simple :oneshot-blocking t))))
  (should (string-match ":oneshot-async is invalid for :type simple"
                        (supervisor--validate-entry
                         '("foo" :type simple :oneshot-async t))))
  (should (string-match ":oneshot-timeout is invalid for :type simple"
                        (supervisor--validate-entry
                         '("foo" :type simple :oneshot-timeout 30)))))

(ert-deftest supervisor-test-validate-oneshot-rejects-restart-keywords ()
  "Oneshot type rejects restart-specific keywords."
  (should (string-match ":restart is invalid for :type oneshot"
                        (supervisor--validate-entry
                         '("foo" :type oneshot :restart t))))
  (should (string-match ":no-restart is invalid for :type oneshot"
                        (supervisor--validate-entry
                         '("foo" :type oneshot :no-restart t)))))

(ert-deftest supervisor-test-validate-multiple-errors ()
  "Multiple validation errors are collected."
  (let ((result (supervisor--validate-entry
                 '("foo" :enabled t :disabled t :restart t :no-restart t))))
    (should (string-match "mutually exclusive" result))
    ;; Should contain both errors separated by semicolon
    (should (> (length (split-string result ";")) 1))))

(ert-deftest supervisor-test-validate-mutually-exclusive-oneshot-blocking-async ()
  ":oneshot-blocking and :oneshot-async are mutually exclusive."
  (should (string-match "mutually exclusive"
                        (supervisor--validate-entry
                         '("foo" :type oneshot :oneshot-blocking t :oneshot-async t)))))

(ert-deftest supervisor-test-validate-type-must-be-symbol ()
  ":type must be a symbol, not a string."
  (should (string-match "must be a symbol"
                        (supervisor--validate-entry
                         '("foo" :type "oneshot")))))

(ert-deftest supervisor-test-validate-stage-must-be-symbol ()
  ":stage as string also produces deprecation error."
  (should (string-match ":stage is removed"
                        (supervisor--validate-entry
                         '("foo" :stage "stage1")))))

;;; Integration tests

(ert-deftest supervisor-test-verify-populates-invalid-hash ()
  "supervisor-verify populates supervisor--invalid hash table."
  (supervisor-test-with-unit-files
      '(("valid-entry" :id "valid-entry" :type simple)
        ("invalid-entry" :id "invalid-entry" :type "bad"))
    (let ((supervisor--invalid (make-hash-table :test 'equal)))
      (with-temp-buffer
        (let ((standard-output (current-buffer)))
          (supervisor-verify)))
      (should (null (gethash "valid-entry" supervisor--invalid)))
      (should (gethash "invalid-entry" supervisor--invalid)))))

(ert-deftest supervisor-test-all-parsed-entries-skips-invalid ()
  "supervisor--all-parsed-entries skips invalid entries."
  (supervisor-test-with-unit-files
      '(("valid" :id "valid" :type simple)
        ("invalid" :id "invalid" :type "bad")
        ("also-valid" :id "also-valid" :type oneshot))
    (let ((supervisor--invalid (make-hash-table :test 'equal)))
      (let ((entries (supervisor--all-parsed-entries)))
        ;; Should have 2 valid entries
        (should (= (length entries) 2))
        ;; Invalid should be tracked
        (should (gethash "invalid" supervisor--invalid))
        ;; Valid entries should be in result
        (should (cl-find "valid" entries :key #'car :test #'equal))
        (should (cl-find "also-valid" entries :key #'car :test #'equal))))))

(ert-deftest supervisor-test-verify-handles-malformed-entry ()
  "supervisor-verify handles malformed unit files gracefully."
  (let* ((dir (make-temp-file "units-" t))
         (supervisor-unit-authority-path (list dir))
         (supervisor-unit-directory dir)
         (supervisor--programs-cache :not-yet-loaded)
         (supervisor--unit-file-invalid (make-hash-table :test 'equal))
         (supervisor--invalid (make-hash-table :test 'equal)))
    (unwind-protect
        (progn
          ;; Write a valid unit file and a malformed (non-plist) file
          (with-temp-file (expand-file-name "valid.el" dir)
            (insert "(:id \"valid\" :command \"true\" :type simple)"))
          (with-temp-file (expand-file-name "broken.el" dir)
            (insert "42"))
          (with-temp-buffer
            (let ((standard-output (current-buffer)))
              (supervisor-verify)))
          ;; Malformed file should be tracked in invalid
          (should (gethash "broken" supervisor--invalid))
          ;; Valid entry should not be in invalid
          (should (null (gethash "valid" supervisor--invalid))))
      (delete-directory dir t))))

;;; DAG scheduler tests

(ert-deftest supervisor-test-topo-sort-stable-ordering ()
  "Unconstrained nodes maintain original list order."
  (let* ((entries '(("a" "cmd" 0 t always t simple stage3 nil t 30)
                    ("b" "cmd" 0 t always t simple stage3 nil t 30)
                    ("c" "cmd" 0 t always t simple stage3 nil t 30)))
         (sorted (supervisor--stable-topo-sort entries)))
    ;; With no dependencies, order should be preserved
    (should (equal (mapcar #'car sorted) '("a" "b" "c")))))

(ert-deftest supervisor-test-topo-sort-respects-after ()
  "Entries with :after come after their dependencies."
  (let* ((entries '(("c" "cmd" 0 t always t simple stage3 ("a") t 30)
                    ("a" "cmd" 0 t always t simple stage3 nil t 30)
                    ("b" "cmd" 0 t always t simple stage3 nil t 30)))
         (sorted (supervisor--stable-topo-sort entries))
         (order (mapcar #'car sorted)))
    ;; "a" must come before "c" (dependency constraint)
    (should (< (cl-position "a" order :test #'equal)
               (cl-position "c" order :test #'equal)))
    ;; Stable sort: after "a" emits, both "c" (idx 0) and "b" (idx 2) are ready
    ;; "c" comes first because it has lower original index
    (should (equal order '("a" "c" "b")))))

(ert-deftest supervisor-test-topo-sort-cycle-fallback ()
  "Cycle detection returns list order with :after cleared."
  (let* ((entries '(("a" "cmd" 0 t always t simple stage3 ("b") t 30)
                    ("b" "cmd" 0 t always t simple stage3 ("a") t 30)))
         (sorted (supervisor--stable-topo-sort entries)))
    ;; Should return in original order
    (should (equal (mapcar #'car sorted) '("a" "b")))
    ;; :after (index 8) should be nil for all entries
    (should (null (nth 8 (car sorted))))
    (should (null (nth 8 (cadr sorted))))))

(ert-deftest supervisor-test-topo-sort-complex-dag ()
  "Complex DAG with multiple dependencies."
  ;; d depends on b and c, b depends on a
  (let* ((entries '(("a" "cmd" 0 t always t simple stage3 nil t 30)
                    ("b" "cmd" 0 t always t simple stage3 ("a") t 30)
                    ("c" "cmd" 0 t always t simple stage3 nil t 30)
                    ("d" "cmd" 0 t always t simple stage3 ("b" "c") t 30)))
         (sorted (supervisor--stable-topo-sort entries))
         (order (mapcar #'car sorted)))
    ;; a must come before b
    (should (< (cl-position "a" order :test #'equal)
               (cl-position "b" order :test #'equal)))
    ;; b and c must come before d
    (should (< (cl-position "b" order :test #'equal)
               (cl-position "d" order :test #'equal)))
    (should (< (cl-position "c" order :test #'equal)
               (cl-position "d" order :test #'equal)))))

(ert-deftest supervisor-test-dag-init-blocking-oneshot ()
  "Blocking oneshots are tracked in supervisor--dag-blocking."
  (let ((supervisor--dag-blocking nil)
        (supervisor--dag-in-degree nil)
        (supervisor--dag-dependents nil)
        (supervisor--dag-entries nil)
        (supervisor--dag-started nil)
        (supervisor--dag-ready nil)
        (supervisor--dag-timeout-timers nil)
        (supervisor--dag-delay-timers nil)
        (supervisor--dag-id-to-index nil))
    ;; Entry: (id cmd delay enabled-p restart-policy logging-p type stage after oneshot-blocking oneshot-timeout)
    (let ((entries '(("blocking" "cmd" 0 t always t oneshot stage3 nil t 30)
                     ("non-blocking" "cmd" 0 t always t oneshot stage3 nil nil 30)
                     ("simple" "cmd" 0 t always t simple stage3 nil t 30))))
      (supervisor--dag-init entries)
      ;; Blocking oneshot should be in blocking set
      (should (gethash "blocking" supervisor--dag-blocking))
      ;; Non-blocking oneshot should NOT be in blocking set
      (should-not (gethash "non-blocking" supervisor--dag-blocking))
      ;; Simple process should NOT be in blocking set
      (should-not (gethash "simple" supervisor--dag-blocking)))))

(ert-deftest supervisor-test-dag-init-in-degree ()
  "DAG init correctly calculates in-degree from :after."
  (let ((supervisor--dag-blocking nil)
        (supervisor--dag-in-degree nil)
        (supervisor--dag-dependents nil)
        (supervisor--dag-entries nil)
        (supervisor--dag-started nil)
        (supervisor--dag-ready nil)
        (supervisor--dag-timeout-timers nil)
        (supervisor--dag-delay-timers nil)
        (supervisor--dag-id-to-index nil))
    (let ((entries '(("a" "cmd" 0 t always t simple stage3 nil t 30)
                     ("b" "cmd" 0 t always t simple stage3 ("a") t 30)
                     ("c" "cmd" 0 t always t simple stage3 ("a" "b") t 30))))
      (supervisor--dag-init entries)
      ;; a has no dependencies
      (should (= (gethash "a" supervisor--dag-in-degree) 0))
      ;; b depends on a
      (should (= (gethash "b" supervisor--dag-in-degree) 1))
      ;; c depends on a and b
      (should (= (gethash "c" supervisor--dag-in-degree) 2)))))

(ert-deftest supervisor-test-dag-init-dependents ()
  "DAG init correctly builds dependents graph."
  (let ((supervisor--dag-blocking nil)
        (supervisor--dag-in-degree nil)
        (supervisor--dag-dependents nil)
        (supervisor--dag-entries nil)
        (supervisor--dag-started nil)
        (supervisor--dag-ready nil)
        (supervisor--dag-timeout-timers nil)
        (supervisor--dag-delay-timers nil)
        (supervisor--dag-id-to-index nil))
    (let ((entries '(("a" "cmd" 0 t always t simple stage3 nil t 30)
                     ("b" "cmd" 0 t always t simple stage3 ("a") t 30)
                     ("c" "cmd" 0 t always t simple stage3 ("a") t 30))))
      (supervisor--dag-init entries)
      ;; a should have b and c as dependents
      (let ((deps (gethash "a" supervisor--dag-dependents)))
        (should (member "b" deps))
        (should (member "c" deps))))))

(ert-deftest supervisor-test-dag-disabled-entry-ready-immediately ()
  "Disabled entries are ready immediately and don't block dependents."
  (let ((supervisor--dag-blocking (make-hash-table :test 'equal))
        (supervisor--dag-in-degree (make-hash-table :test 'equal))
        (supervisor--dag-dependents (make-hash-table :test 'equal))
        (supervisor--dag-entries (make-hash-table :test 'equal))
        (supervisor--dag-started (make-hash-table :test 'equal))
        (supervisor--dag-ready (make-hash-table :test 'equal))
        (supervisor--dag-timeout-timers (make-hash-table :test 'equal))
        (supervisor--dag-delay-timers (make-hash-table :test 'equal))
        (supervisor--dag-id-to-index (make-hash-table :test 'equal))
        (supervisor--entry-state (make-hash-table :test 'equal))
        (supervisor--ready-times (make-hash-table :test 'equal)))
    ;; "a" is disabled, "b" depends on "a"
    ;;           (id   cmd   delay enabled-p restart-policy logging-p type   stage   after oneshot-blocking timeout)
    (let ((entries '(("a" "cmd" 0 nil always t simple stage3 nil t 30)
                     ("b" "cmd" 0 t   always t simple stage3 ("a") t 30))))
      (supervisor--dag-init entries)
      ;; Disabled entry should be marked ready immediately
      (should (gethash "a" supervisor--dag-ready))
      (should (gethash "a" supervisor--dag-started))
      ;; Entry state should be 'disabled
      (should (eq (gethash "a" supervisor--entry-state) 'disabled))
      ;; Dependent "b" should have in-degree 0 (not blocked by disabled "a")
      (should (= 0 (gethash "b" supervisor--dag-in-degree))))))

(ert-deftest supervisor-test-async-oneshot-not-blocking ()
  "Async oneshots (oneshot-blocking nil) do not block stage completion."
  (let ((supervisor--dag-blocking nil)
        (supervisor--dag-in-degree nil)
        (supervisor--dag-dependents nil)
        (supervisor--dag-entries nil)
        (supervisor--dag-started nil)
        (supervisor--dag-ready nil)
        (supervisor--dag-timeout-timers nil)
        (supervisor--dag-delay-timers nil)
        (supervisor--dag-id-to-index nil))
    ;; Entry with :oneshot-async t means oneshot-blocking = nil
    (let ((entries '(("async-oneshot" "cmd" 0 t always t oneshot stage3 nil nil 30))))
      (supervisor--dag-init entries)
      ;; Async oneshot should NOT be in blocking set
      (should-not (gethash "async-oneshot" supervisor--dag-blocking)))))

(ert-deftest supervisor-test-startup-complete-blocked-by-delay ()
  "Delayed entries prevent startup completion until they start."
  (let ((supervisor--dag-blocking (make-hash-table :test 'equal))
        (supervisor--dag-in-degree (make-hash-table :test 'equal))
        (supervisor--dag-dependents (make-hash-table :test 'equal))
        (supervisor--dag-entries (make-hash-table :test 'equal))
        (supervisor--dag-started (make-hash-table :test 'equal))
        (supervisor--dag-ready (make-hash-table :test 'equal))
        (supervisor--dag-timeout-timers (make-hash-table :test 'equal))
        (supervisor--dag-delay-timers (make-hash-table :test 'equal))
        (supervisor--dag-id-to-index (make-hash-table :test 'equal))
        (supervisor--dag-complete-callback nil)
        (supervisor--shutting-down nil)
        (callback-called nil))
    ;; Entry with delay
    (puthash "delayed" '("delayed" "echo hi" 5 t t t simple stage3 nil t 30) supervisor--dag-entries)
    (puthash "delayed" 0 supervisor--dag-in-degree)
    (puthash "delayed" 0 supervisor--dag-id-to-index)
    (puthash "delayed" nil supervisor--dag-dependents)
    (setq supervisor--dag-complete-callback (lambda () (setq callback-called t)))
    ;; Simulate starting the delayed entry - adds to delay-timers
    (puthash "delayed" 'mock-timer supervisor--dag-delay-timers)
    ;; Mark as "started" from scheduler's perspective
    (puthash "delayed" t supervisor--dag-started)
    ;; Try to complete stage - should NOT call callback because delay timer exists
    (supervisor--dag-check-complete)
    (should-not callback-called)))

(ert-deftest supervisor-test-startup-complete-blocked-by-blocking-oneshot ()
  "Blocking oneshots prevent startup completion until they exit."
  (let ((supervisor--dag-blocking (make-hash-table :test 'equal))
        (supervisor--dag-in-degree (make-hash-table :test 'equal))
        (supervisor--dag-dependents (make-hash-table :test 'equal))
        (supervisor--dag-entries (make-hash-table :test 'equal))
        (supervisor--dag-started (make-hash-table :test 'equal))
        (supervisor--dag-ready (make-hash-table :test 'equal))
        (supervisor--dag-timeout-timers (make-hash-table :test 'equal))
        (supervisor--dag-delay-timers (make-hash-table :test 'equal))
        (supervisor--dag-id-to-index (make-hash-table :test 'equal))
        (supervisor--dag-complete-callback nil)
        (callback-called nil))
    ;; Blocking oneshot entry
    (puthash "blocking" '("blocking" "sleep 10" 0 t always t oneshot stage3 nil t 30) supervisor--dag-entries)
    (puthash "blocking" 0 supervisor--dag-in-degree)
    (puthash "blocking" t supervisor--dag-started)
    ;; Oneshot is blocking
    (puthash "blocking" t supervisor--dag-blocking)
    (setq supervisor--dag-complete-callback (lambda () (setq callback-called t)))
    ;; Try to complete stage - should NOT call callback because blocking oneshot exists
    (supervisor--dag-check-complete)
    (should-not callback-called)))

(ert-deftest supervisor-test-mark-ready-removes-from-blocking ()
  "supervisor--dag-mark-ready removes entry from blocking set."
  (let ((supervisor--dag-blocking (make-hash-table :test 'equal))
        (supervisor--dag-in-degree (make-hash-table :test 'equal))
        (supervisor--dag-dependents (make-hash-table :test 'equal))
        (supervisor--dag-entries (make-hash-table :test 'equal))
        (supervisor--dag-started (make-hash-table :test 'equal))
        (supervisor--dag-ready (make-hash-table :test 'equal))
        (supervisor--dag-timeout-timers (make-hash-table :test 'equal))
        (supervisor--dag-delay-timers (make-hash-table :test 'equal))
        (supervisor--dag-id-to-index (make-hash-table :test 'equal))
        (supervisor--dag-complete-callback nil)
        (supervisor-verbose nil))
    ;; Set up blocking oneshot
    (puthash "oneshot" '("oneshot" "cmd" 0 t always t oneshot stage3 nil t 30) supervisor--dag-entries)
    (puthash "oneshot" 0 supervisor--dag-in-degree)
    (puthash "oneshot" t supervisor--dag-started)
    (puthash "oneshot" t supervisor--dag-blocking)
    (puthash "oneshot" nil supervisor--dag-dependents)
    ;; Mark ready
    (supervisor--dag-mark-ready "oneshot")
    ;; Should be removed from blocking
    (should-not (gethash "oneshot" supervisor--dag-blocking))
    ;; Should be in ready set
    (should (gethash "oneshot" supervisor--dag-ready))))

(ert-deftest supervisor-test-mark-ready-unlocks-dependents ()
  "supervisor--dag-mark-ready decrements in-degree for dependents."
  (let ((supervisor--dag-blocking (make-hash-table :test 'equal))
        (supervisor--dag-in-degree (make-hash-table :test 'equal))
        (supervisor--dag-dependents (make-hash-table :test 'equal))
        (supervisor--dag-entries (make-hash-table :test 'equal))
        (supervisor--dag-started (make-hash-table :test 'equal))
        (supervisor--dag-ready (make-hash-table :test 'equal))
        (supervisor--dag-timeout-timers (make-hash-table :test 'equal))
        (supervisor--dag-delay-timers (make-hash-table :test 'equal))
        (supervisor--dag-id-to-index (make-hash-table :test 'equal))
        (supervisor--dag-complete-callback nil)
        (supervisor--shutting-down nil)
        (supervisor-verbose nil)
        (started-ids nil))
    ;; Stub start function to prevent actual process spawning
    (cl-letf (((symbol-function 'supervisor--dag-start-entry-async)
               (lambda (entry) (push (car entry) started-ids))))
      ;; Set up: b depends on a
      (puthash "a" '("a" "cmd" 0 t always t simple stage3 nil t 30) supervisor--dag-entries)
      (puthash "b" '("b" "cmd" 0 t always t simple stage3 ("a") t 30) supervisor--dag-entries)
      (puthash "a" 0 supervisor--dag-in-degree)
      (puthash "b" 1 supervisor--dag-in-degree)
      (puthash "a" t supervisor--dag-started)
      (puthash "b" nil supervisor--dag-started)
      (puthash "a" '("b") supervisor--dag-dependents)
      (puthash "b" nil supervisor--dag-dependents)
      (puthash "a" 0 supervisor--dag-id-to-index)
      (puthash "b" 1 supervisor--dag-id-to-index)
      ;; Mark a as ready
      (supervisor--dag-mark-ready "a")
      ;; b's in-degree should now be 0
      (should (= 0 (gethash "b" supervisor--dag-in-degree)))
      ;; b should have been triggered to start
      (should (member "b" started-ids)))))

(ert-deftest supervisor-test-oneshot-timeout-unlocks-dependents ()
  "Oneshot timeout calls mark-ready which unlocks dependents and stage."
  (let ((supervisor--dag-blocking (make-hash-table :test 'equal))
        (supervisor--dag-in-degree (make-hash-table :test 'equal))
        (supervisor--dag-dependents (make-hash-table :test 'equal))
        (supervisor--dag-entries (make-hash-table :test 'equal))
        (supervisor--dag-started (make-hash-table :test 'equal))
        (supervisor--dag-ready (make-hash-table :test 'equal))
        (supervisor--dag-timeout-timers (make-hash-table :test 'equal))
        (supervisor--dag-delay-timers (make-hash-table :test 'equal))
        (supervisor--dag-id-to-index (make-hash-table :test 'equal))
        (supervisor--dag-complete-callback nil)
        (supervisor--shutting-down nil)
        (supervisor-verbose nil)
        (stage-complete nil)
        (started-ids nil))
    ;; Stub start function
    (cl-letf (((symbol-function 'supervisor--dag-start-entry-async)
               (lambda (entry) (push (car entry) started-ids))))
      ;; Set up: blocking oneshot "slow" with dependent "after-slow"
      (puthash "slow" '("slow" "sleep 999" 0 t always t oneshot stage3 nil t 5) supervisor--dag-entries)
      (puthash "after-slow" '("after-slow" "echo done" 0 t always t simple stage3 ("slow") t 30) supervisor--dag-entries)
      (puthash "slow" 0 supervisor--dag-in-degree)
      (puthash "after-slow" 1 supervisor--dag-in-degree)
      (puthash "slow" t supervisor--dag-started)
      (puthash "after-slow" nil supervisor--dag-started)
      (puthash "slow" t supervisor--dag-blocking)  ; blocking oneshot
      (puthash "slow" '("after-slow") supervisor--dag-dependents)
      (puthash "after-slow" nil supervisor--dag-dependents)
      (puthash "slow" 0 supervisor--dag-id-to-index)
      (puthash "after-slow" 1 supervisor--dag-id-to-index)
      ;; Set up a mock timeout timer
      (puthash "slow" 'mock-timer supervisor--dag-timeout-timers)
      ;; Stage completion callback
      (setq supervisor--dag-complete-callback
            (lambda () (setq stage-complete t)))
      ;; Simulate timeout firing: this is what the timeout timer does
      (supervisor--dag-mark-ready "slow")
      ;; Blocking oneshot should be removed from blocking set
      (should-not (gethash "slow" supervisor--dag-blocking))
      ;; Dependent should have been unlocked and triggered
      (should (= 0 (gethash "after-slow" supervisor--dag-in-degree)))
      (should (member "after-slow" started-ids))
      ;; Timeout timer should be removed
      (should-not (gethash "slow" supervisor--dag-timeout-timers)))))

;;; Global minor mode tests

(ert-deftest supervisor-test-mode-defined ()
  "Verify supervisor-mode is defined as a global minor mode."
  (should (fboundp 'supervisor-mode))
  (should (custom-variable-p 'supervisor-mode)))

;;; Verbose logging tests

(ert-deftest supervisor-test-log-warning-always-shows ()
  "Warning messages always show regardless of verbose setting."
  (let ((supervisor-verbose nil)
        (messages nil))
    (cl-letf (((symbol-function 'message)
               (lambda (fmt &rest args) (push (apply #'format fmt args) messages))))
      (supervisor--log 'warning "test warning"))
    (should (= (length messages) 1))
    (should (string-match "WARNING" (car messages)))))

(ert-deftest supervisor-test-log-info-hidden-when-not-verbose ()
  "Info messages hidden when supervisor-verbose is nil."
  (let ((supervisor-verbose nil)
        (messages nil))
    (cl-letf (((symbol-function 'message)
               (lambda (fmt &rest args) (push (apply #'format fmt args) messages))))
      (supervisor--log 'info "test info"))
    (should (= (length messages) 0))))

(ert-deftest supervisor-test-log-info-shown-when-verbose ()
  "Info messages shown when supervisor-verbose is non-nil."
  (let ((supervisor-verbose t)
        (messages nil))
    (cl-letf (((symbol-function 'message)
               (lambda (fmt &rest args) (push (apply #'format fmt args) messages))))
      (supervisor--log 'info "test info"))
    (should (= (length messages) 1))
    (should (string-match "test info" (car messages)))))

;;; P1 behavior tests

(ert-deftest supervisor-test-max-concurrent-starts-active-count-no-leak ()
  "Active count must not leak when entries are processed from queue."
  ;; The fix ensures supervisor--dag-process-pending-starts does NOT
  ;; increment the count - only supervisor--dag-do-start does.
  (let ((supervisor--dag-pending-starts nil)
        (supervisor--dag-active-starts 0)
        (supervisor--dag-entries (make-hash-table :test 'equal))
        (supervisor--dag-started (make-hash-table :test 'equal))
        (supervisor--dag-ready (make-hash-table :test 'equal))
        (supervisor--dag-blocking (make-hash-table :test 'equal))
        (supervisor--dag-in-degree (make-hash-table :test 'equal))
        (supervisor--dag-dependents (make-hash-table :test 'equal))
        (supervisor--dag-delay-timers (make-hash-table :test 'equal))
        (supervisor--dag-timeout-timers (make-hash-table :test 'equal))
        (supervisor--entry-state (make-hash-table :test 'equal))
        (supervisor--enabled-override (make-hash-table :test 'equal))
        (supervisor--ready-times (make-hash-table :test 'equal))
        (supervisor--shutting-down nil)
        (supervisor-max-concurrent-starts 2)
        (started-ids nil))
    ;; Queue entries
    (puthash "a" '("a" "true" 0 t always t simple stage3 nil t 30) supervisor--dag-entries)
    (puthash "b" '("b" "true" 0 t always t simple stage3 nil t 30) supervisor--dag-entries)
    (setq supervisor--dag-pending-starts '("a" "b"))
    ;; Before processing, count should be 0
    (should (= supervisor--dag-active-starts 0))
    ;; Stub supervisor--dag-start-entry-async to track calls without spawning
    (cl-letf (((symbol-function 'supervisor--dag-start-entry-async)
               (lambda (entry) (push (car entry) started-ids))))
      ;; Call the real function
      (supervisor--dag-process-pending-starts)
      ;; Queue should be drained
      (should (null supervisor--dag-pending-starts))
      ;; Both entries should have been passed to start-entry-async
      (should (member "a" started-ids))
      (should (member "b" started-ids))
      ;; Active count should still be 0 (no increment in process-pending-starts)
      (should (= supervisor--dag-active-starts 0)))))

(ert-deftest supervisor-test-enabled-override-affects-effective-enabled ()
  "Runtime enable override affects effective enabled state."
  (let ((supervisor--enabled-override (make-hash-table :test 'equal)))
    ;; No override: config enabled-p applies
    (should (supervisor--get-effective-enabled "a" t))
    (should-not (supervisor--get-effective-enabled "b" nil))
    ;; Override to disabled: entry is disabled regardless of config
    (puthash "a" 'disabled supervisor--enabled-override)
    (should-not (supervisor--get-effective-enabled "a" t))
    ;; Override to enabled: entry is enabled regardless of config
    (puthash "b" 'enabled supervisor--enabled-override)
    (should (supervisor--get-effective-enabled "b" nil))))

(ert-deftest supervisor-test-startup-timeout-sets-entry-state ()
  "Startup timeout marks unstarted entries with startup-timeout state."
  (let ((supervisor--dag-entries (make-hash-table :test 'equal))
        (supervisor--dag-started (make-hash-table :test 'equal))
        (supervisor--dag-blocking (make-hash-table :test 'equal))
        (supervisor--dag-in-degree (make-hash-table :test 'equal))
        (supervisor--dag-dependents (make-hash-table :test 'equal))
        (supervisor--dag-ready (make-hash-table :test 'equal))
        (supervisor--dag-delay-timers (make-hash-table :test 'equal))
        (supervisor--dag-timeout-timers (make-hash-table :test 'equal))
        (supervisor--dag-id-to-index (make-hash-table :test 'equal))
        (supervisor--dag-complete-callback nil)
        (supervisor--dag-timeout-timer nil)
        (supervisor--dag-pending-starts nil)
        (supervisor--dag-active-starts 0)
        (supervisor--entry-state (make-hash-table :test 'equal))
        (callback-called nil))
    ;; Set up entry that hasn't started
    (puthash "delayed" '("delayed" "cmd" 5 t t t simple stage3 nil t 30)
             supervisor--dag-entries)
    (setq supervisor--dag-complete-callback (lambda () (setq callback-called t)))
    ;; Force stage complete should mark unstarted as stage-timeout
    (supervisor--dag-force-complete)
    (should (eq (gethash "delayed" supervisor--entry-state) 'startup-timeout))
    (should callback-called)))

(ert-deftest supervisor-test-format-exit-status-signal ()
  "Exit status formatting distinguishes signal from exit."
  ;; Signal case
  (should (string-match "killed by signal 15"
                        (supervisor--format-exit-status 'signal 15)))
  ;; Exit with code 0
  (should (string-match "exited successfully"
                        (supervisor--format-exit-status 'exit 0)))
  ;; Exit with non-zero code
  (should (string-match "exited with code 1"
                        (supervisor--format-exit-status 'exit 1))))

(ert-deftest supervisor-test-reconcile-respects-enabled-override ()
  "Reconcile uses effective enabled state for start decisions."
  (supervisor-test-with-unit-files
      '(("true" :id "new-entry" :type simple))
    (let ((supervisor--enabled-override (make-hash-table :test 'equal))
          (supervisor--processes (make-hash-table :test 'equal))
          (supervisor--failed (make-hash-table :test 'equal))
          (supervisor--oneshot-completed (make-hash-table :test 'equal))
          (supervisor--restart-override (make-hash-table :test 'equal))
          (supervisor--logging (make-hash-table :test 'equal))
          (supervisor--invalid (make-hash-table :test 'equal))
          (started-ids nil))
      ;; Mark entry as runtime-disabled
      (puthash "new-entry" 'disabled supervisor--enabled-override)
      ;; Mock supervisor--start-process to track what gets started
      (cl-letf (((symbol-function 'supervisor--start-process)
                 (lambda (id _cmd _log _type _restart &rest _args)
                   (push id started-ids)))
                ((symbol-function 'supervisor--refresh-dashboard) #'ignore)
                ((symbol-function 'executable-find) (lambda (_) t)))
        (supervisor--reconcile)
        ;; Entry should NOT have been started due to override
        (should-not (member "new-entry" started-ids))))))

(ert-deftest supervisor-test-reconcile-stops-disabled-entries ()
  "Reconcile stops running entries that are now disabled.
Only auto-started (not manually-started) disabled units are stopped."
  (supervisor-test-with-unit-files
      '(("sleep 100" :id "running" :type simple :disabled t))
    (let ((supervisor--enabled-override (make-hash-table :test 'equal))
          (supervisor--processes (make-hash-table :test 'equal))
          (supervisor--failed (make-hash-table :test 'equal))
          (supervisor--oneshot-completed (make-hash-table :test 'equal))
          (supervisor--restart-override (make-hash-table :test 'equal))
          (supervisor--logging (make-hash-table :test 'equal))
          (supervisor--invalid (make-hash-table :test 'equal))
          (supervisor--mask-override (make-hash-table :test 'equal))
          (supervisor--manually-started (make-hash-table :test 'equal))
          (killed-ids nil))
      ;; Create a fake live process (NOT manually started)
      (let ((fake-proc (start-process "test-proc" nil "sleep" "100")))
        (puthash "running" fake-proc supervisor--processes)
        ;; Mock kill-process to track kills
        (cl-letf (((symbol-function 'kill-process)
                   (lambda (proc)
                     (push (process-name proc) killed-ids)
                     (delete-process proc)))
                  ((symbol-function 'supervisor--refresh-dashboard) #'ignore))
          (supervisor--reconcile)
          ;; Entry should have been killed due to :disabled (not manually started)
          (should (member "test-proc" killed-ids)))))))

(ert-deftest supervisor-test-computed-deps-populated ()
  "Topo-sort populates computed-deps with validated dependencies."
  (let ((supervisor--computed-deps (make-hash-table :test 'equal))
        (supervisor--cycle-fallback-ids (make-hash-table :test 'equal)))
    ;; Entry c depends on a and b, but b doesn't exist in this stage
    (let ((entries '(("a" "cmd" 0 t always t simple stage3 nil t 30)
                     ("c" "cmd" 0 t always t simple stage3 ("a" "b") t 30))))
      (supervisor--stable-topo-sort entries)
      ;; c's computed deps should only include "a" (b doesn't exist)
      (should (equal (gethash "c" supervisor--computed-deps) '("a")))
      ;; a has no deps
      (should (equal (gethash "a" supervisor--computed-deps) nil)))))

(ert-deftest supervisor-test-cycle-fallback-clears-computed-deps ()
  "Cycle fallback marks entries and clears their computed deps."
  (let ((supervisor--computed-deps (make-hash-table :test 'equal))
        (supervisor--cycle-fallback-ids (make-hash-table :test 'equal)))
    ;; Create a cycle: a -> b -> a
    (let ((entries '(("a" "cmd" 0 t always t simple stage3 ("b") t 30)
                     ("b" "cmd" 0 t always t simple stage3 ("a") t 30))))
      (supervisor--stable-topo-sort entries)
      ;; Both should be marked as cycle fallback
      (should (gethash "a" supervisor--cycle-fallback-ids))
      (should (gethash "b" supervisor--cycle-fallback-ids))
      ;; Both should have nil computed deps (edges cleared)
      (should (null (gethash "a" supervisor--computed-deps)))
      (should (null (gethash "b" supervisor--computed-deps))))))

;;; Tags parsing tests

(ert-deftest supervisor-test-parse-tags ()
  "Parse :tags keyword."
  (let ((parsed (supervisor--parse-entry '("foo" :tags (x-setup network)))))
    (should (equal (supervisor-entry-tags parsed) '(x-setup network)))))

(ert-deftest supervisor-test-parse-tags-default-nil ()
  "Tags default to nil when not specified."
  (let ((parsed (supervisor--parse-entry "foo")))
    (should-not (supervisor-entry-tags parsed))))

(ert-deftest supervisor-test-parse-tags-single ()
  "Parse single tag (not in list)."
  (let ((parsed (supervisor--parse-entry '("foo" :tags myapp))))
    ;; Single symbol should be wrapped in list
    (should (equal (supervisor-entry-tags parsed) '(myapp)))))

;;; Dry-run tests

(ert-deftest supervisor-test-dry-run-output ()
  "Dry-run produces expected output with entries."
  (supervisor-test-with-unit-files
      '(("true" :id "a" :type oneshot)
        ("true" :id "b")
        ("true" :id "c"))
    (let ((supervisor--invalid (make-hash-table :test 'equal))
          (supervisor--cycle-fallback-ids (make-hash-table :test 'equal))
          (supervisor--computed-deps (make-hash-table :test 'equal)))
      ;; supervisor-dry-run uses with-output-to-temp-buffer
      (supervisor-dry-run)
      (let ((output (with-current-buffer "*supervisor-dry-run*"
                      (buffer-string))))
        (kill-buffer "*supervisor-dry-run*")
        ;; All entries in activation order
        (should (string-match-p "Activation order" output))
        (should (string-match-p "\\ba\\b" output))
        (should (string-match-p "\\bb\\b" output))
        (should (string-match-p "\\bc\\b" output))))))

(ert-deftest supervisor-test-dry-run-shows-invalid ()
  "Dry-run shows invalid entries."
  (supervisor-test-with-unit-files
      '(("true" :id "valid" :type simple)
        ("true" :id "invalid" :type "bad"))
    (let ((supervisor-timers nil)
          (supervisor--invalid (make-hash-table :test 'equal))
          (supervisor--invalid-timers (make-hash-table :test 'equal))
          (supervisor--cycle-fallback-ids (make-hash-table :test 'equal))
          (supervisor--computed-deps (make-hash-table :test 'equal)))
      (supervisor-dry-run)
      (let ((output (with-current-buffer "*supervisor-dry-run*"
                      (buffer-string))))
        (kill-buffer "*supervisor-dry-run*")
        (should (string-match-p "Invalid Services" output))
        (should (string-match-p "invalid" output))))))

(ert-deftest supervisor-test-dry-run-validates-after ()
  "Dry-run validates :after references using same path as startup."
  (supervisor-test-with-unit-files
      '(("true" :id "a")
        ("true" :id "b" :after ("nonexistent")))
    (let ((supervisor--invalid (make-hash-table :test 'equal))
          (supervisor--cycle-fallback-ids (make-hash-table :test 'equal))
          (supervisor--computed-deps (make-hash-table :test 'equal)))
      ;; This should populate computed-deps via plan building
      (supervisor-dry-run)
      (kill-buffer "*supervisor-dry-run*")
      ;; b's computed deps should be empty since nonexistent doesn't exist
      (should (null (gethash "b" supervisor--computed-deps)))
      ;; a should have nil deps (no :after)
      (should (null (gethash "a" supervisor--computed-deps))))))

;;; Dashboard UI tests

(ert-deftest supervisor-test-separator-row-detection ()
  "Separator rows are correctly identified as symbol IDs."
  (should (supervisor--separator-row-p '--stage1--))
  (should (supervisor--separator-row-p '--stage4--))
  (should (supervisor--separator-row-p '--health--))
  (should (supervisor--separator-row-p '--timers--))
  (should (supervisor--separator-row-p '--blank-1--))
  (should-not (supervisor--separator-row-p "nm-applet"))
  (should-not (supervisor--separator-row-p nil))
  (should-not (supervisor--separator-row-p (cons :service "foo")))
  (should-not (supervisor--separator-row-p (cons :timer "bar"))))

(ert-deftest supervisor-test-health-summary-format ()
  "Health summary includes all required counts."
  (supervisor-test-with-unit-files nil
    (let ((supervisor--invalid (make-hash-table :test 'equal))
          (supervisor--processes (make-hash-table :test 'equal))
          (supervisor--failed (make-hash-table :test 'equal))
          (supervisor--oneshot-completed (make-hash-table :test 'equal)))
      (let ((summary (supervisor--health-summary)))
        ;; Should contain all five metrics
        (should (string-match-p "run" summary))
        (should (string-match-p "done" summary))
        (should (string-match-p "pend" summary))
        (should (string-match-p "fail" summary))
        (should (string-match-p "inv" summary))))))

(ert-deftest supervisor-test-help-text-key-parity ()
  "Help text includes all top-level bound keys."
  ;; Top-level keys that must be discoverable on-screen
  (should (string-match-p "\\[f\\]" supervisor--help-text))
  (should (string-match-p "\\[g\\]" supervisor--help-text))
  (should (string-match-p "\\[G\\]" supervisor--help-text))
  (should (string-match-p "\\[t\\]" supervisor--help-text))
  (should (string-match-p "\\[T\\]" supervisor--help-text))
  (should (string-match-p "\\[l\\]" supervisor--help-text))
  (should (string-match-p "\\[p\\]" supervisor--help-text))
  (should (string-match-p "\\[i\\]" supervisor--help-text))
  (should (string-match-p "\\[?\\]" supervisor--help-text))
  (should (string-match-p "\\[h\\]" supervisor--help-text))
  (should (string-match-p "\\[q\\]" supervisor--help-text)))

(ert-deftest supervisor-test-health-summary-deduplication ()
  "Health summary deduplicates entries with same ID.
Unit-file loader already deduplicates, so only one entry is loaded."
  (supervisor-test-without-builtins
    (let* ((dir (make-temp-file "units-" t))
           (supervisor-unit-authority-path (list dir))
           (supervisor-unit-directory dir)
           (supervisor--programs-cache :not-yet-loaded)
           (supervisor--unit-file-invalid (make-hash-table :test 'equal))
           (supervisor--invalid (make-hash-table :test 'equal))
           (supervisor--processes (make-hash-table :test 'equal))
           (supervisor--failed (make-hash-table :test 'equal))
           (supervisor--oneshot-completed (make-hash-table :test 'equal)))
      ;; Create two unit files with the same :id
      (with-temp-file (expand-file-name "dup1.el" dir)
        (insert "(:id \"dup\" :command \"sleep 100\")"))
      (with-temp-file (expand-file-name "dup2.el" dir)
        (insert "(:id \"dup\" :command \"sleep 100\")"))
      (unwind-protect
          (let ((summary (supervisor--health-summary)))
            ;; Should count only 1 pending, not 2
            (should (string-match-p "1 pend" summary)))
        (delete-directory dir t)))))

(ert-deftest supervisor-test-disabled-only-completes ()
  "Only disabled entries completes immediately."
  (supervisor-test-with-unit-files
      '(("sleep 100" :id "a" :disabled t))
    (let* ((supervisor--invalid (make-hash-table :test 'equal))
           (supervisor--processes (make-hash-table :test 'equal))
           (supervisor--failed (make-hash-table :test 'equal))
           (supervisor--oneshot-completed (make-hash-table :test 'equal))
           (supervisor--entry-state (make-hash-table :test 'equal))
           (supervisor--cycle-fallback-ids (make-hash-table :test 'equal))
           (supervisor--computed-deps (make-hash-table :test 'equal))
           (supervisor--shutting-down nil)
           (completed nil))
      ;; Parse entries
      (let ((entries (supervisor--all-parsed-entries)))
        ;; Start entries with callback that sets completed flag
        (supervisor--start-entries-async
         entries
         (lambda () (setq completed t)))
        ;; Should complete immediately since all entries are disabled
        (should completed)))))

(ert-deftest supervisor-test-config-watch-timer-cleanup ()
  "Config watch stop cleans up debounce timer."
  ;; Set up a fake timer on the symbol property
  (let ((fake-timer (run-at-time 100 nil #'ignore)))
    (put 'supervisor--config-watch-callback 'timer fake-timer)
    ;; Stop should cancel the timer
    (supervisor--stop-config-watch)
    ;; Timer property should be nil
    (should (null (get 'supervisor--config-watch-callback 'timer)))
    ;; Timer should be cancelled (no longer in timer-list)
    (should-not (memq fake-timer timer-list))))

(ert-deftest supervisor-test-log-dir-not-created-when-logging-disabled ()
  "Log directory is not created when logging is disabled for entry."
  (let* ((temp-dir (make-temp-file "supervisor-test" t))
         (nonexistent-subdir (expand-file-name "should-not-exist" temp-dir))
         (supervisor-log-directory nonexistent-subdir)
         (supervisor--processes (make-hash-table :test 'equal))
         (supervisor--logging (make-hash-table :test 'equal))
         (supervisor--restart-timers (make-hash-table :test 'equal))
         (supervisor--failed (make-hash-table :test 'equal))
         (supervisor--enabled-override (make-hash-table :test 'equal))
         (supervisor--restart-override (make-hash-table :test 'equal))
         (supervisor--shutting-down nil))
    (unwind-protect
        (progn
          ;; Start with logging disabled - should NOT create log directory
          (supervisor--start-process "test" "/bin/true" nil 'oneshot nil)
          ;; Log directory should not have been created
          (should-not (file-directory-p nonexistent-subdir)))
	      ;; Cleanup
	      (delete-directory temp-dir t))))

(ert-deftest supervisor-test-start-process-logging-unavailable-does-not-fail ()
  "Unwritable log directory does not block process startup."
  (let* ((supervisor--processes (make-hash-table :test 'equal))
         (supervisor--writers (make-hash-table :test 'equal))
         (supervisor--logging (make-hash-table :test 'equal))
         (supervisor--restart-timers (make-hash-table :test 'equal))
         (supervisor--failed (make-hash-table :test 'equal))
         (supervisor--enabled-override (make-hash-table :test 'equal))
         (supervisor--restart-override (make-hash-table :test 'equal))
         (supervisor--shutting-down nil))
    (cl-letf (((symbol-function 'supervisor--effective-log-directory)
               (lambda () nil))
              ((symbol-function 'supervisor--warn-log-directory)
               #'ignore))
      (let ((proc (supervisor--start-process "test" "/bin/true" t 'oneshot nil)))
        (should (processp proc))
        (while (process-live-p proc)
          (accept-process-output nil 0.01))
        (should-not (gethash "test" supervisor--writers))))))

(ert-deftest supervisor-test-shutdown-complete-flag-without-callback ()
  "Shutdown sets complete flag even when no callback is provided."
  (let ((supervisor--processes (make-hash-table :test 'equal))
        (supervisor--shutting-down nil)
        (supervisor--shutdown-complete-flag nil)
        (supervisor--shutdown-callback nil)
        (supervisor--shutdown-remaining 0)
        (supervisor--shutdown-timer nil))
    ;; Simulate a process exit during shutdown with no callback
    (setq supervisor--shutting-down t)
    (setq supervisor--shutdown-remaining 1)
    ;; Call the exit handler (simulates sentinel calling this)
    (supervisor--handle-shutdown-exit)
    ;; Flag should be set even without callback
    (should (eq supervisor--shutdown-complete-flag t))
    (should (= supervisor--shutdown-remaining 0))))

;;; Phase 1: Plan Builder Tests

(ert-deftest supervisor-test-plan-shape ()
  "Plan struct has all required fields with correct types."
  (let* ((programs '(("sleep 100" :id "a")
                     ("sleep 200" :id "b" :after "a")
                     ("invalid-entry" :unknown-keyword t)))
         (plan (supervisor--build-plan programs)))
    ;; Plan is a struct
    (should (supervisor-plan-p plan))
    ;; entries is a list of valid parsed entries
    (should (listp (supervisor-plan-entries plan)))
    (should (= 2 (length (supervisor-plan-entries plan))))
    ;; invalid is a hash table with reasons
    (should (hash-table-p (supervisor-plan-invalid plan)))
    (should (= 1 (hash-table-count (supervisor-plan-invalid plan))))
    ;; by-target is a flat list of entries (globally sorted)
    (should (listp (supervisor-plan-by-target plan)))
    (should (= 2 (length (supervisor-plan-by-target plan))))
    ;; deps is a hash table
    (should (hash-table-p (supervisor-plan-deps plan)))
    ;; dependents is a hash table
    (should (hash-table-p (supervisor-plan-dependents plan)))
    ;; cycle-fallback-ids is a hash table
    (should (hash-table-p (supervisor-plan-cycle-fallback-ids plan)))
    ;; order-index is a hash table
    (should (hash-table-p (supervisor-plan-order-index plan)))
    ;; New Phase 3 fields are nil when no activation root
    (should-not (supervisor-plan-target-members plan))
    (should-not (supervisor-plan-activation-root plan))
    (should-not (supervisor-plan-activation-closure plan))
    ;; meta is a plist with version and timestamp
    (should (listp (supervisor-plan-meta plan)))
    (should (plist-get (supervisor-plan-meta plan) :version))
    (should (plist-get (supervisor-plan-meta plan) :timestamp))))

(ert-deftest supervisor-test-plan-determinism ()
  "Identical config produces identical plan data."
  (let* ((programs '(("sleep 100" :id "a")
                     ("sleep 200" :id "b" :after "a")
                     ("sleep 300" :id "c")))
         (plan1 (supervisor--build-plan programs))
         (plan2 (supervisor--build-plan programs)))
    ;; Entries should be equal
    (should (equal (supervisor-plan-entries plan1)
                   (supervisor-plan-entries plan2)))
    ;; By-target should be equal
    (should (equal (supervisor-plan-by-target plan1)
                   (supervisor-plan-by-target plan2)))
    ;; Deps should be equal
    (should (= (hash-table-count (supervisor-plan-deps plan1))
               (hash-table-count (supervisor-plan-deps plan2))))
    (maphash (lambda (k v)
               (should (equal v (gethash k (supervisor-plan-deps plan2)))))
             (supervisor-plan-deps plan1))))

(ert-deftest supervisor-test-plan-no-global-mutation ()
  "Plan building does not mutate global state."
  (let ((programs '(("sleep 100" :id "a")
                    ("sleep 200" :id "b" :after "a"))))
    ;; Set up globals with known values
    (clrhash supervisor--invalid)
    (clrhash supervisor--cycle-fallback-ids)
    (clrhash supervisor--computed-deps)
    (puthash "sentinel" "should-remain" supervisor--invalid)
    (puthash "sentinel" t supervisor--cycle-fallback-ids)
    (puthash "sentinel" '("test") supervisor--computed-deps)
    ;; Build plan
    (supervisor--build-plan programs)
    ;; Globals should be unchanged
    (should (equal "should-remain" (gethash "sentinel" supervisor--invalid)))
    (should (eq t (gethash "sentinel" supervisor--cycle-fallback-ids)))
    (should (equal '("test") (gethash "sentinel" supervisor--computed-deps)))
    ;; Globals should NOT have plan's computed data
    (should-not (gethash "a" supervisor--computed-deps))
    (should-not (gethash "b" supervisor--computed-deps))))

(ert-deftest supervisor-test-plan-cycle-detection ()
  "Plan correctly detects cycles and falls back."
  (let* ((programs '(("sleep 100" :id "a" :after "b")
                     ("sleep 200" :id "b" :after "a")))
         (plan (supervisor--build-plan programs)))
    ;; Both entries should be marked as cycle fallback
    (should (gethash "a" (supervisor-plan-cycle-fallback-ids plan)))
    (should (gethash "b" (supervisor-plan-cycle-fallback-ids plan)))
    ;; Deps should be cleared after fallback
    (should (null (gethash "a" (supervisor-plan-deps plan))))
    (should (null (gethash "b" (supervisor-plan-deps plan))))))

(ert-deftest supervisor-test-plan-dependency-validation ()
  "Plan validates :after references correctly."
  (let* ((programs '(("sleep 100" :id "a")
                     ("sleep 200" :id "b" :after "a")
                     ("sleep 300" :id "c" :after "nonexistent")
                     ("sleep 400" :id "d" :after "a")))
         (plan (supervisor--build-plan programs)))
    ;; b's dep on a should be preserved
    (should (equal '("a") (gethash "b" (supervisor-plan-deps plan))))
    ;; c's dep on nonexistent should be removed
    (should (null (gethash "c" (supervisor-plan-deps plan))))
    ;; d's dep on a (same stage now) should be preserved
    (should (equal '("a") (gethash "d" (supervisor-plan-deps plan))))))

(ert-deftest supervisor-test-plan-duplicate-id-first-occurrence-order ()
  "Duplicate IDs use first-occurrence index for ordering.
Regression test: duplicates must not overwrite order-index of kept entry."
  (let* ((programs '(("sleep 100" :id "a")
                     ("sleep 200" :id "b")
                     ("sleep 300" :id "a")))  ; duplicate of a
         (plan (supervisor--build-plan programs)))
    ;; Only 2 entries should be in plan (a and b, duplicate skipped)
    (should (= 2 (length (supervisor-plan-entries plan))))
    ;; Order index should reflect first occurrence: a=0, b=1
    (should (= 0 (gethash "a" (supervisor-plan-order-index plan))))
    (should (= 1 (gethash "b" (supervisor-plan-order-index plan))))
    ;; Sorted order should be a, b (not b, a)
    (let* ((sorted (supervisor-plan-by-target plan))
           (ids (mapcar #'car sorted)))
      (should (equal '("a" "b") ids)))))

;;; Phase 2: Startup Uses Plan Tests

(ert-deftest supervisor-test-startup-populates-globals-from-plan ()
  "Plan->global copy mechanism populates legacy globals correctly.
Unit test for the plan data extraction used by supervisor-start.
Note: Does not call supervisor-start directly to avoid process spawning."
  (supervisor-test-with-unit-files
      '(("sleep 100" :id "a")
        ("sleep 200" :id "b" :after "a")
        ("invalid-cmd" :id "invalid" :restart t :no-restart t))
    (let ((supervisor--invalid (make-hash-table :test 'equal))
          (supervisor--cycle-fallback-ids (make-hash-table :test 'equal))
          (supervisor--computed-deps (make-hash-table :test 'equal))
          (supervisor--entry-state (make-hash-table :test 'equal))
          (supervisor--processes (make-hash-table :test 'equal))
          (supervisor--failed (make-hash-table :test 'equal))
          (supervisor--restart-override (make-hash-table :test 'equal))
          (supervisor--enabled-override (make-hash-table :test 'equal))
          (supervisor--logging (make-hash-table :test 'equal))
          (supervisor--restart-times (make-hash-table :test 'equal))
          (supervisor--restart-timers (make-hash-table :test 'equal))
          (supervisor--oneshot-completed (make-hash-table :test 'equal))
          (supervisor--start-times (make-hash-table :test 'equal))
          (supervisor--ready-times (make-hash-table :test 'equal))
          (supervisor--timers nil)
          (supervisor--current-stage nil)
          (supervisor--completed-stages nil)
          (supervisor--shutting-down t))  ; Prevent actual process starts
      ;; Build plan and populate globals (same as supervisor-start)
      (let* ((progs (supervisor--effective-programs))
             (plan (supervisor--build-plan progs)))
        (supervisor--merge-unit-file-invalid)
        (maphash (lambda (k v) (puthash k v supervisor--invalid))
                 (supervisor-plan-invalid plan))
        (maphash (lambda (k v) (puthash k v supervisor--cycle-fallback-ids))
                 (supervisor-plan-cycle-fallback-ids plan))
        (maphash (lambda (k v) (puthash k v supervisor--computed-deps))
                 (supervisor-plan-deps plan)))
      ;; Verify globals were populated from plan
      (should (gethash "invalid" supervisor--invalid))  ; Invalid entry recorded
      (should (equal '("a") (gethash "b" supervisor--computed-deps)))  ; Deps computed
      (should (= 1 (hash-table-count supervisor--invalid))))))

(ert-deftest supervisor-test-plan-build-warns-on-duplicates ()
  "Plan building emits warnings for duplicate IDs.
Regression test for warning parity with legacy startup path."
  (let* ((dir (make-temp-file "units-" t))
         (supervisor-unit-authority-path (list dir))
         (supervisor-unit-directory dir)
         (supervisor--programs-cache :not-yet-loaded)
         (supervisor--unit-file-invalid (make-hash-table :test 'equal))
         (messages nil))
    (with-temp-file (expand-file-name "dup1.el" dir)
      (insert "(:id \"dup\" :command \"sleep 100\")"))
    (with-temp-file (expand-file-name "dup2.el" dir)
      (insert "(:id \"dup\" :command \"sleep 200\")"))
    (unwind-protect
        (progn
          (cl-letf (((symbol-function 'supervisor--log)
                     (lambda (_level fmt &rest args)
                       (push (apply #'format fmt args) messages))))
            (supervisor--build-plan (supervisor--effective-programs)))
          ;; Should have warned about duplicate
          (should (cl-some (lambda (m) (string-match-p "Duplicate.*ID 'dup'" m))
                           messages)))
      (delete-directory dir t))))

(ert-deftest supervisor-test-plan-build-warns-on-invalid-after ()
  "Plan building emits warnings for invalid :after references.
Regression test for warning parity with legacy startup path."
  (supervisor-test-with-unit-files
      '(("sleep 100" :id "a")
        ("sleep 200" :id "b" :after "nonexistent"))
    (let ((messages nil))
      (cl-letf (((symbol-function 'supervisor--log)
                 (lambda (_level fmt &rest args)
                   (push (apply #'format fmt args) messages))))
        (supervisor--build-plan (supervisor--effective-programs)))
      ;; Should have warned about nonexistent dep
      (should (cl-some (lambda (m) (string-match-p "does not exist" m))
                       messages)))))

;;; Phase 3: Snapshot-Based Read Model Tests

(ert-deftest supervisor-test-snapshot-shape ()
  "Snapshot struct has all required fields."
  (let ((supervisor--processes (make-hash-table :test 'equal))
        (supervisor--failed (make-hash-table :test 'equal))
        (supervisor--oneshot-completed (make-hash-table :test 'equal))
        (supervisor--entry-state (make-hash-table :test 'equal))
        (supervisor--invalid (make-hash-table :test 'equal))
        (supervisor--enabled-override (make-hash-table :test 'equal))
        (supervisor--restart-override (make-hash-table :test 'equal))
        (supervisor--logging (make-hash-table :test 'equal)))
    (let ((snapshot (supervisor--build-snapshot)))
      (should (supervisor-snapshot-p snapshot))
      (should (hash-table-p (supervisor-snapshot-process-alive snapshot)))
      (should (hash-table-p (supervisor-snapshot-process-pids snapshot)))
      (should (hash-table-p (supervisor-snapshot-failed snapshot)))
      (should (hash-table-p (supervisor-snapshot-oneshot-exit snapshot)))
      (should (hash-table-p (supervisor-snapshot-entry-state snapshot)))
      (should (hash-table-p (supervisor-snapshot-invalid snapshot)))
      (should (hash-table-p (supervisor-snapshot-enabled-override snapshot)))
      (should (hash-table-p (supervisor-snapshot-restart-override snapshot)))
      (should (hash-table-p (supervisor-snapshot-logging-override snapshot)))
      (should (numberp (supervisor-snapshot-timestamp snapshot))))))

(ert-deftest supervisor-test-snapshot-captures-state ()
  "Snapshot captures current runtime state correctly."
  (let ((supervisor--processes (make-hash-table :test 'equal))
        (supervisor--failed (make-hash-table :test 'equal))
        (supervisor--oneshot-completed (make-hash-table :test 'equal))
        (supervisor--entry-state (make-hash-table :test 'equal))
        (supervisor--invalid (make-hash-table :test 'equal))
        (supervisor--enabled-override (make-hash-table :test 'equal))
        (supervisor--restart-override (make-hash-table :test 'equal))
        (supervisor--logging (make-hash-table :test 'equal)))
    ;; Set up some state
    (puthash "test-failed" t supervisor--failed)
    (puthash "test-oneshot" 0 supervisor--oneshot-completed)
    (puthash "test-entry" 'running supervisor--entry-state)
    (puthash "test-invalid" "bad config" supervisor--invalid)
    (puthash "test-enabled" 'disabled supervisor--enabled-override)
    ;; Build snapshot
    (let ((snapshot (supervisor--build-snapshot)))
      ;; Verify state was captured
      (should (gethash "test-failed" (supervisor-snapshot-failed snapshot)))
      (should (= 0 (gethash "test-oneshot" (supervisor-snapshot-oneshot-exit snapshot))))
      (should (eq 'running (gethash "test-entry" (supervisor-snapshot-entry-state snapshot))))
      (should (equal "bad config" (gethash "test-invalid" (supervisor-snapshot-invalid snapshot))))
      (should (eq 'disabled (gethash "test-enabled" (supervisor-snapshot-enabled-override snapshot)))))))

(ert-deftest supervisor-test-status-from-snapshot-parity ()
  "Status computation from snapshot matches direct global access."
  (let ((supervisor--processes (make-hash-table :test 'equal))
        (supervisor--failed (make-hash-table :test 'equal))
        (supervisor--oneshot-completed (make-hash-table :test 'equal))
        (supervisor--entry-state (make-hash-table :test 'equal))
        (supervisor--invalid (make-hash-table :test 'equal))
        (supervisor--enabled-override (make-hash-table :test 'equal))
        (supervisor--restart-override (make-hash-table :test 'equal))
        (supervisor--logging (make-hash-table :test 'equal)))
    ;; Set up state for a failed entry
    (puthash "test" t supervisor--failed)
    (puthash "oneshot-done" 0 supervisor--oneshot-completed)
    ;; Build snapshot
    (let ((snapshot (supervisor--build-snapshot)))
      ;; Status from globals
      (let ((status-globals (supervisor--compute-entry-status "test" 'simple)))
        ;; Status from snapshot
        (let ((status-snapshot (supervisor--compute-entry-status "test" 'simple snapshot)))
          (should (equal status-globals status-snapshot))))
      ;; Test oneshot status
      (let ((status-globals (supervisor--compute-entry-status "oneshot-done" 'oneshot)))
        (let ((status-snapshot (supervisor--compute-entry-status "oneshot-done" 'oneshot snapshot)))
          (should (equal status-globals status-snapshot)))))))

(ert-deftest supervisor-test-health-summary-from-snapshot-parity ()
  "Health summary from snapshot matches direct global access."
  (supervisor-test-with-unit-files
      '(("sleep 100" :id "a")
        ("sleep 200" :id "b"))
    (let ((supervisor--processes (make-hash-table :test 'equal))
          (supervisor--failed (make-hash-table :test 'equal))
          (supervisor--oneshot-completed (make-hash-table :test 'equal))
          (supervisor--entry-state (make-hash-table :test 'equal))
          (supervisor--invalid (make-hash-table :test 'equal))
          (supervisor--enabled-override (make-hash-table :test 'equal))
          (supervisor--restart-override (make-hash-table :test 'equal))
          (supervisor--logging (make-hash-table :test 'equal)))
      ;; Mark one as failed
      (puthash "a" t supervisor--failed)
      ;; Build snapshot
      (let ((snapshot (supervisor--build-snapshot)))
        ;; Health from globals
        (let ((health-globals (supervisor--health-summary)))
          ;; Health from snapshot
          (let ((health-snapshot (supervisor--health-summary snapshot)))
            (should (equal health-globals health-snapshot))))))))

(ert-deftest supervisor-test-reason-from-snapshot-parity ()
  "Reason computation from snapshot matches direct global access."
  (let ((supervisor--processes (make-hash-table :test 'equal))
        (supervisor--failed (make-hash-table :test 'equal))
        (supervisor--oneshot-completed (make-hash-table :test 'equal))
        (supervisor--entry-state (make-hash-table :test 'equal))
        (supervisor--invalid (make-hash-table :test 'equal))
        (supervisor--enabled-override (make-hash-table :test 'equal))
        (supervisor--restart-override (make-hash-table :test 'equal))
        (supervisor--logging (make-hash-table :test 'equal)))
    ;; Set up various states
    (puthash "disabled" 'disabled supervisor--entry-state)
    (puthash "delayed" 'delayed supervisor--entry-state)
    (puthash "waiting" 'waiting-on-deps supervisor--entry-state)
    (puthash "crashed" t supervisor--failed)
    ;; Build snapshot
    (let ((snapshot (supervisor--build-snapshot)))
      ;; Test each case
      (dolist (test-case '(("disabled" . simple)
                           ("delayed" . simple)
                           ("waiting" . simple)
                           ("crashed" . simple)))
        (let ((id (car test-case))
              (type (cdr test-case)))
          (should (equal (supervisor--compute-entry-reason id type)
                         (supervisor--compute-entry-reason id type snapshot))))))))

(ert-deftest supervisor-test-initial-dashboard-uses-shared-snapshot ()
  "Initial dashboard render uses same snapshot for entries and header.
Regression test: M-x supervisor must use shared snapshot like refresh does."
  (supervisor-test-with-unit-files
      '(("sleep 100" :id "a"))
    (let ((supervisor--processes (make-hash-table :test 'equal))
          (supervisor--failed (make-hash-table :test 'equal))
          (supervisor--oneshot-completed (make-hash-table :test 'equal))
          (supervisor--entry-state (make-hash-table :test 'equal))
          (supervisor--invalid (make-hash-table :test 'equal))
          (supervisor--enabled-override (make-hash-table :test 'equal))
          (supervisor--restart-override (make-hash-table :test 'equal))
          (supervisor--logging (make-hash-table :test 'equal))
          (supervisor--current-stage nil)
          (supervisor--completed-stages nil)
          (snapshots-built 0))
      ;; Track how many snapshots are built during initial render
      (cl-letf (((symbol-function 'supervisor--build-snapshot)
                 (lambda ()
                   (cl-incf snapshots-built)
                   (supervisor-snapshot--create
                    :process-alive (make-hash-table :test 'equal)
                    :process-pids (make-hash-table :test 'equal)
                    :failed (copy-hash-table supervisor--failed)
                    :oneshot-exit (copy-hash-table supervisor--oneshot-completed)
                    :entry-state (copy-hash-table supervisor--entry-state)
                    :invalid (copy-hash-table supervisor--invalid)
                    :enabled-override (copy-hash-table supervisor--enabled-override)
                    :restart-override (copy-hash-table supervisor--restart-override)
                    :logging-override (copy-hash-table supervisor--logging)
                    :timestamp (float-time)))))
        (unwind-protect
            (progn
              (supervisor)
              ;; Should build exactly one snapshot for initial render
              (should (= 1 snapshots-built)))
          ;; Cleanup
          (when-let* ((buf (get-buffer "*supervisor*")))
            (kill-buffer buf)))))))

(ert-deftest supervisor-test-dashboard-header-and-services-row ()
  "Dashboard shows counters in header and services columns in body row 1."
  (supervisor-test-with-unit-files
      '(("true" :id "svc" :type oneshot))
    (let ((supervisor--processes (make-hash-table :test 'equal))
          (supervisor--failed (make-hash-table :test 'equal))
          (supervisor--oneshot-completed (make-hash-table :test 'equal))
          (supervisor--entry-state (make-hash-table :test 'equal))
          (supervisor--invalid (make-hash-table :test 'equal))
          (supervisor--enabled-override (make-hash-table :test 'equal))
          (supervisor--restart-override (make-hash-table :test 'equal))
          (supervisor--logging (make-hash-table :test 'equal)))
      (unwind-protect
          (progn
            (supervisor)
            (with-current-buffer "*supervisor*"
              (let* ((raw header-line-format)
                     (header (if (stringp raw)
                                 (substring-no-properties raw)
                               (format "%s" raw))))
                (should (string-match-p "\\brun\\b" header))
                (should (string-match-p "\\bdone\\b" header))
                (should (string-match-p "\\bpend\\b" header))
                (should (string-match-p "\\bfail\\b" header))
                (should (string-match-p "\\binv\\b" header))
                (should-not (string-match-p "\\bID\\b" header)))
              (let* ((first-row (car tabulated-list-entries))
                     (first-id (car first-row))
                     (first-vec (cadr first-row)))
                (should (eq '--services-- first-id))
                (should (string-match-p "TYPE"
                                        (substring-no-properties (aref first-vec 1))))
                (should (string-match-p "TARGET"
                                        (substring-no-properties (aref first-vec 2))))
                (should (string-match-p "PID"
                                        (substring-no-properties (aref first-vec 7)))))))
        (when-let* ((buf (get-buffer "*supervisor*")))
          (kill-buffer buf))))))

;;; Phase 4: Declarative Reconciler Tests

(ert-deftest supervisor-test-compute-actions-start ()
  "Compute-actions returns start action for entries not running."
  (supervisor-test-with-unit-files
      '(("sleep 100" :id "a"))
    (let* ((plan (supervisor--build-plan (supervisor--effective-programs)))
           ;; Empty snapshot - nothing running
           (snapshot (supervisor-snapshot--create
                      :process-alive (make-hash-table :test 'equal)
                      :process-pids (make-hash-table :test 'equal)
                      :failed (make-hash-table :test 'equal)
                      :oneshot-exit (make-hash-table :test 'equal)
                      :entry-state (make-hash-table :test 'equal)
                      :invalid (make-hash-table :test 'equal)
                      :enabled-override (make-hash-table :test 'equal)
                      :restart-override (make-hash-table :test 'equal)
                      :logging-override (make-hash-table :test 'equal)
                      :timestamp (float-time)))
           (actions (supervisor--compute-actions plan snapshot)))
      (should (= 1 (length actions)))
      (should (eq 'start (plist-get (car actions) :op)))
      (should (equal "a" (plist-get (car actions) :id)))
      (should (eq 'new-entry (plist-get (car actions) :reason))))))

(ert-deftest supervisor-test-compute-actions-stop-removed ()
  "Compute-actions returns stop action for running entries not in plan."
  (supervisor-test-with-unit-files nil
    (let* ((plan (supervisor--build-plan (supervisor--effective-programs)))
           ;; Snapshot shows a running process
           (process-alive (make-hash-table :test 'equal)))
      (puthash "orphan" t process-alive)
      (let* ((snapshot (supervisor-snapshot--create
                        :process-alive process-alive
                        :process-pids (make-hash-table :test 'equal)
                        :failed (make-hash-table :test 'equal)
                        :oneshot-exit (make-hash-table :test 'equal)
                        :entry-state (make-hash-table :test 'equal)
                        :invalid (make-hash-table :test 'equal)
                        :enabled-override (make-hash-table :test 'equal)
                        :restart-override (make-hash-table :test 'equal)
                        :logging-override (make-hash-table :test 'equal)
                        :timestamp (float-time)))
             (actions (supervisor--compute-actions plan snapshot)))
        (should (= 1 (length actions)))
        (should (eq 'stop (plist-get (car actions) :op)))
        (should (equal "orphan" (plist-get (car actions) :id)))
        (should (eq 'removed (plist-get (car actions) :reason)))))))

(ert-deftest supervisor-test-compute-actions-stop-disabled ()
  "Compute-actions returns stop action for running entries now disabled."
  (supervisor-test-with-unit-files
      '(("sleep 100" :id "a" :disabled t))
    (let* ((plan (supervisor--build-plan (supervisor--effective-programs)))
           ;; Snapshot shows process is running
           (process-alive (make-hash-table :test 'equal)))
      (puthash "a" t process-alive)
      (let* ((snapshot (supervisor-snapshot--create
                        :process-alive process-alive
                        :process-pids (make-hash-table :test 'equal)
                        :failed (make-hash-table :test 'equal)
                        :oneshot-exit (make-hash-table :test 'equal)
                        :entry-state (make-hash-table :test 'equal)
                        :invalid (make-hash-table :test 'equal)
                        :enabled-override (make-hash-table :test 'equal)
                        :restart-override (make-hash-table :test 'equal)
                        :logging-override (make-hash-table :test 'equal)
                        :timestamp (float-time)))
             (actions (supervisor--compute-actions plan snapshot)))
        ;; Should have stop action for disabled entry
        (let ((stop-action (cl-find 'stop actions :key (lambda (a) (plist-get a :op)))))
          (should stop-action)
          (should (equal "a" (plist-get stop-action :id)))
          (should (eq 'disabled (plist-get stop-action :reason))))))))

(ert-deftest supervisor-test-compute-actions-noop-already-running ()
  "Compute-actions returns noop for entries already running."
  (supervisor-test-with-unit-files
      '(("sleep 100" :id "a"))
    (let* ((plan (supervisor--build-plan (supervisor--effective-programs)))
           ;; Snapshot shows process is running
           (process-alive (make-hash-table :test 'equal)))
      (puthash "a" t process-alive)
      (let* ((snapshot (supervisor-snapshot--create
                        :process-alive process-alive
                        :process-pids (make-hash-table :test 'equal)
                        :failed (make-hash-table :test 'equal)
                        :oneshot-exit (make-hash-table :test 'equal)
                        :entry-state (make-hash-table :test 'equal)
                        :invalid (make-hash-table :test 'equal)
                        :enabled-override (make-hash-table :test 'equal)
                        :restart-override (make-hash-table :test 'equal)
                        :logging-override (make-hash-table :test 'equal)
                        :timestamp (float-time)))
             (actions (supervisor--compute-actions plan snapshot)))
        (should (= 1 (length actions)))
        (should (eq 'noop (plist-get (car actions) :op)))
        (should (equal "a" (plist-get (car actions) :id)))
        (should (eq 'already-running (plist-get (car actions) :reason)))))))

(ert-deftest supervisor-test-compute-actions-skip-failed ()
  "Compute-actions returns skip for failed entries."
  (supervisor-test-with-unit-files
      '(("sleep 100" :id "a"))
    (let* ((plan (supervisor--build-plan (supervisor--effective-programs)))
           ;; Snapshot shows entry is failed
           (failed (make-hash-table :test 'equal)))
      (puthash "a" t failed)
      (let* ((snapshot (supervisor-snapshot--create
                        :process-alive (make-hash-table :test 'equal)
                        :process-pids (make-hash-table :test 'equal)
                        :failed failed
                        :oneshot-exit (make-hash-table :test 'equal)
                        :entry-state (make-hash-table :test 'equal)
                        :invalid (make-hash-table :test 'equal)
                        :enabled-override (make-hash-table :test 'equal)
                        :restart-override (make-hash-table :test 'equal)
                        :logging-override (make-hash-table :test 'equal)
                        :timestamp (float-time)))
             (actions (supervisor--compute-actions plan snapshot)))
        (should (= 1 (length actions)))
        (should (eq 'skip (plist-get (car actions) :op)))
        (should (equal "a" (plist-get (car actions) :id)))
        (should (eq 'failed (plist-get (car actions) :reason)))))))

(ert-deftest supervisor-test-compute-actions-skip-oneshot-completed ()
  "Compute-actions returns skip for completed oneshots."
  (supervisor-test-with-unit-files
      '(("echo done" :id "a" :type oneshot))
    (let* ((plan (supervisor--build-plan (supervisor--effective-programs)))
           ;; Snapshot shows oneshot completed
           (oneshot-exit (make-hash-table :test 'equal)))
      (puthash "a" 0 oneshot-exit)
      (let* ((snapshot (supervisor-snapshot--create
                        :process-alive (make-hash-table :test 'equal)
                        :process-pids (make-hash-table :test 'equal)
                        :failed (make-hash-table :test 'equal)
                        :oneshot-exit oneshot-exit
                        :entry-state (make-hash-table :test 'equal)
                        :invalid (make-hash-table :test 'equal)
                        :enabled-override (make-hash-table :test 'equal)
                        :restart-override (make-hash-table :test 'equal)
                        :logging-override (make-hash-table :test 'equal)
                        :timestamp (float-time)))
             (actions (supervisor--compute-actions plan snapshot)))
        (should (= 1 (length actions)))
        (should (eq 'skip (plist-get (car actions) :op)))
        (should (equal "a" (plist-get (car actions) :id)))
        (should (eq 'oneshot-completed (plist-get (car actions) :reason)))))))

(ert-deftest supervisor-test-compute-actions-skip-disabled ()
  "Compute-actions returns skip for disabled entries not running."
  (supervisor-test-with-unit-files
      '(("sleep 100" :id "a" :disabled t))
    (let* ((plan (supervisor--build-plan (supervisor--effective-programs)))
           ;; Empty snapshot - nothing running
           (snapshot (supervisor-snapshot--create
                      :process-alive (make-hash-table :test 'equal)
                      :process-pids (make-hash-table :test 'equal)
                      :failed (make-hash-table :test 'equal)
                      :oneshot-exit (make-hash-table :test 'equal)
                      :entry-state (make-hash-table :test 'equal)
                      :invalid (make-hash-table :test 'equal)
                      :enabled-override (make-hash-table :test 'equal)
                      :restart-override (make-hash-table :test 'equal)
                      :logging-override (make-hash-table :test 'equal)
                      :timestamp (float-time)))
           (actions (supervisor--compute-actions plan snapshot)))
      (should (= 1 (length actions)))
      (should (eq 'skip (plist-get (car actions) :op)))
      (should (equal "a" (plist-get (car actions) :id)))
      (should (eq 'disabled (plist-get (car actions) :reason))))))

(ert-deftest supervisor-test-compute-actions-is-pure ()
  "Compute-actions does not modify any global state."
  (supervisor-test-with-unit-files
      '(("sleep 100" :id "a")
        ("sleep 200" :id "b" :disabled t))
    (let* ((plan (supervisor--build-plan (supervisor--effective-programs)))
           ;; Set up some mutable globals
           (supervisor--processes (make-hash-table :test 'equal))
           (supervisor--failed (make-hash-table :test 'equal))
           (supervisor--oneshot-completed (make-hash-table :test 'equal))
           (supervisor--restart-override (make-hash-table :test 'equal)))
      (puthash "x" t supervisor--failed)
      (let* ((failed-before (copy-hash-table supervisor--failed))
             (process-alive (make-hash-table :test 'equal))
             (snapshot (supervisor-snapshot--create
                        :process-alive process-alive
                        :process-pids (make-hash-table :test 'equal)
                        :failed (copy-hash-table supervisor--failed)
                        :oneshot-exit (make-hash-table :test 'equal)
                        :entry-state (make-hash-table :test 'equal)
                        :invalid (make-hash-table :test 'equal)
                        :enabled-override (make-hash-table :test 'equal)
                        :restart-override (make-hash-table :test 'equal)
                        :logging-override (make-hash-table :test 'equal)
                        :timestamp (float-time))))
        ;; Call compute-actions multiple times
        (supervisor--compute-actions plan snapshot)
        (supervisor--compute-actions plan snapshot)
        ;; Globals should be unchanged
        (should (equal (hash-table-count supervisor--failed)
                       (hash-table-count failed-before)))
        (should (gethash "x" supervisor--failed))
        (should (= 0 (hash-table-count supervisor--processes)))
        (should (= 0 (hash-table-count supervisor--restart-override)))))))

(ert-deftest supervisor-test-compute-actions-idempotent ()
  "Idempotence: second call on converged state produces only noops/skips.
When actual state matches desired state, no start/stop actions are needed."
  (supervisor-test-with-unit-files
      '(("sleep 100" :id "a")
        ("sleep 200" :id "b")
        ("echo done" :id "c" :type oneshot)
        ("sleep 300" :id "d" :disabled t))
    (let* ((plan (supervisor--build-plan (supervisor--effective-programs)))
           ;; Simulate converged state: a and b running, c completed, d disabled
           (process-alive (make-hash-table :test 'equal))
           (oneshot-exit (make-hash-table :test 'equal)))
      (puthash "a" t process-alive)
      (puthash "b" t process-alive)
      (puthash "c" 0 oneshot-exit)
      (let* ((snapshot (supervisor-snapshot--create
                        :process-alive process-alive
                        :process-pids (make-hash-table :test 'equal)
                        :failed (make-hash-table :test 'equal)
                        :oneshot-exit oneshot-exit
                        :entry-state (make-hash-table :test 'equal)
                        :invalid (make-hash-table :test 'equal)
                        :enabled-override (make-hash-table :test 'equal)
                        :restart-override (make-hash-table :test 'equal)
                        :logging-override (make-hash-table :test 'equal)
                        :timestamp (float-time)))
             (actions (supervisor--compute-actions plan snapshot)))
        ;; Should have 4 actions, none of which are start or stop
        (should (= 4 (length actions)))
        (should-not (cl-find 'start actions :key (lambda (a) (plist-get a :op))))
        (should-not (cl-find 'stop actions :key (lambda (a) (plist-get a :op))))
        ;; All should be noop or skip
        (dolist (action actions)
          (should (memq (plist-get action :op) '(noop skip))))))))

(ert-deftest supervisor-test-compute-actions-action-matrix ()
  "Comprehensive test of action matrix with mixed scenarios.
Covers add, remove, disable (running), already-running, failed."
  (supervisor-test-with-unit-files
      '(("sleep 100" :id "a")
        ("sleep 200" :id "b")
        ("sleep 300" :id "c" :disabled t)
        ("sleep 400" :id "d")
        ("sleep 500" :id "e" :disabled t))
    ;; Plan: a (new), b (already running), c (running but now disabled),
    ;;       d (failed), e (disabled from start)
    (let* ((plan (supervisor--build-plan (supervisor--effective-programs)))
           ;; Runtime: b and c running, orphan running (removed), d failed
           (process-alive (make-hash-table :test 'equal))
           (failed (make-hash-table :test 'equal)))
      (puthash "b" t process-alive)
      (puthash "c" t process-alive)
      (puthash "orphan" t process-alive)
      (puthash "d" t failed)
      (let* ((snapshot (supervisor-snapshot--create
                        :process-alive process-alive
                        :process-pids (make-hash-table :test 'equal)
                        :failed failed
                        :oneshot-exit (make-hash-table :test 'equal)
                        :entry-state (make-hash-table :test 'equal)
                        :invalid (make-hash-table :test 'equal)
                        :enabled-override (make-hash-table :test 'equal)
                        :restart-override (make-hash-table :test 'equal)
                        :logging-override (make-hash-table :test 'equal)
                        :timestamp (float-time)))
             (actions (supervisor--compute-actions plan snapshot))
             (by-id (make-hash-table :test 'equal)))
        ;; Index actions by id for easy lookup
        (dolist (a actions)
          (puthash (plist-get a :id) a by-id))
        ;; a: should start (added)
        (should (eq 'start (plist-get (gethash "a" by-id) :op)))
        ;; b: should noop (already-running)
        (should (eq 'noop (plist-get (gethash "b" by-id) :op)))
        ;; c: should stop (disabled)
        (should (eq 'stop (plist-get (gethash "c" by-id) :op)))
        ;; orphan: should stop (removed)
        (should (eq 'stop (plist-get (gethash "orphan" by-id) :op)))
        ;; d: should skip (failed)
        (should (eq 'skip (plist-get (gethash "d" by-id) :op)))
        ;; e: should skip (disabled)
        (should (eq 'skip (plist-get (gethash "e" by-id) :op)))))))

(ert-deftest supervisor-test-apply-actions-atomic-on-invalid-plan ()
  "Apply-actions does not mutate state when plan has no matching entries.
This tests the atomic boundary: invalid/empty plans cause no side effects."
  (let* ((supervisor--processes (make-hash-table :test 'equal))
         (supervisor--restart-override (make-hash-table :test 'equal))
         (supervisor--failed (make-hash-table :test 'equal))
         ;; Empty plan (no entries)
         (plan (supervisor--build-plan nil))
         ;; Actions that reference non-existent entries
         (actions (list (list :op 'start :id "nonexistent" :reason 'added)
                        (list :op 'stop :id "also-nonexistent" :reason 'removed))))
    ;; Apply should not crash and should not modify state
    (let ((result (supervisor--apply-actions actions plan)))
      ;; No processes were started or stopped
      (should (= 0 (plist-get result :started)))
      (should (= 0 (plist-get result :stopped)))
      ;; Globals remain empty
      (should (= 0 (hash-table-count supervisor--processes)))
      (should (= 0 (hash-table-count supervisor--restart-override))))))

;;; Phase 5: Explicit FSM Adoption Tests

(ert-deftest supervisor-test-fsm-valid-states-defined ()
  "All valid states are defined in the state list."
  (should (memq 'pending supervisor--valid-states))
  (should (memq 'waiting-on-deps supervisor--valid-states))
  (should (memq 'delayed supervisor--valid-states))
  (should (memq 'disabled supervisor--valid-states))
  (should (memq 'started supervisor--valid-states))
  (should (memq 'failed-to-spawn supervisor--valid-states))
  (should (memq 'startup-timeout supervisor--valid-states)))

(ert-deftest supervisor-test-fsm-invalid-state-rejected ()
  "Transitioning to an invalid state signals an error."
  (let ((supervisor--entry-state (make-hash-table :test 'equal)))
    (should-error (supervisor--transition-state "test" 'invalid-state)
                  :type 'error)))

(ert-deftest supervisor-test-fsm-invalid-transition-rejected ()
  "Invalid state transitions signal an error."
  (let ((supervisor--entry-state (make-hash-table :test 'equal)))
    ;; Set up valid path to terminal state
    (supervisor--transition-state "test" 'pending)
    (supervisor--transition-state "test" 'started)
    ;; Transition from terminal state should error
    (should-error (supervisor--transition-state "test" 'delayed)
                  :type 'error)))

(ert-deftest supervisor-test-fsm-valid-transitions ()
  "Valid state transitions succeed."
  (let ((supervisor--entry-state (make-hash-table :test 'equal)))
    ;; nil -> pending
    (should (supervisor--transition-state "a" 'pending))
    (should (eq 'pending (gethash "a" supervisor--entry-state)))
    ;; pending -> waiting-on-deps
    (should (supervisor--transition-state "a" 'waiting-on-deps))
    (should (eq 'waiting-on-deps (gethash "a" supervisor--entry-state)))
    ;; waiting-on-deps -> delayed
    (should (supervisor--transition-state "a" 'delayed))
    (should (eq 'delayed (gethash "a" supervisor--entry-state)))
    ;; delayed -> started
    (should (supervisor--transition-state "a" 'started))
    (should (eq 'started (gethash "a" supervisor--entry-state)))))

(ert-deftest supervisor-test-fsm-self-transitions-allowed ()
  "Self-transitions are allowed for idempotent operations."
  (let ((supervisor--entry-state (make-hash-table :test 'equal)))
    (supervisor--transition-state "a" 'pending)
    ;; Self-transition should succeed
    (should (supervisor--transition-state "a" 'pending))
    (should (eq 'pending (gethash "a" supervisor--entry-state)))))

(ert-deftest supervisor-test-fsm-force-invalid-transition ()
  "Force parameter allows invalid transitions with warning.
Returns nil (not t) and emits a warning for forced invalid transitions."
  (let ((supervisor--entry-state (make-hash-table :test 'equal))
        (warnings nil))
    ;; Set up valid path to terminal state
    (supervisor--transition-state "a" 'pending)
    (supervisor--transition-state "a" 'started)
    (cl-letf (((symbol-function 'supervisor--log)
               (lambda (_level fmt &rest args)
                 (push (apply #'format fmt args) warnings))))
      ;; Force invalid transition from terminal state - should return nil
      (let ((result (supervisor--transition-state "a" 'delayed t)))
        ;; Return value should be nil for forced invalid transition
        (should (null result))
        ;; State should change despite being invalid
        (should (eq 'delayed (gethash "a" supervisor--entry-state)))
        ;; Warning should have been emitted
        (should (= 1 (length warnings)))
        (should (string-match-p "Forced invalid transition" (car warnings)))))))

(ert-deftest supervisor-test-fsm-lifecycle-simple-success ()
  "Test lifecycle path for successful simple process start."
  (let ((supervisor--entry-state (make-hash-table :test 'equal)))
    ;; Initial state
    (supervisor--transition-state "proc" 'pending)
    ;; After delay
    (supervisor--transition-state "proc" 'delayed)
    ;; After successful spawn
    (supervisor--transition-state "proc" 'started)
    (should (eq 'started (gethash "proc" supervisor--entry-state)))))

(ert-deftest supervisor-test-fsm-lifecycle-spawn-failure ()
  "Test lifecycle path for spawn failure."
  (let ((supervisor--entry-state (make-hash-table :test 'equal)))
    ;; Initial state
    (supervisor--transition-state "proc" 'pending)
    ;; Spawn fails
    (supervisor--transition-state "proc" 'failed-to-spawn)
    (should (eq 'failed-to-spawn (gethash "proc" supervisor--entry-state)))))

(ert-deftest supervisor-test-fsm-lifecycle-startup-timeout ()
  "Test lifecycle path for startup timeout."
  (let ((supervisor--entry-state (make-hash-table :test 'equal)))
    ;; Initial state with deps
    (supervisor--transition-state "proc" 'waiting-on-deps)
    ;; Stage times out before deps complete
    (supervisor--transition-state "proc" 'startup-timeout)
    (should (eq 'startup-timeout (gethash "proc" supervisor--entry-state)))))

(ert-deftest supervisor-test-fsm-lifecycle-disabled ()
  "Test lifecycle path for disabled entry."
  (let ((supervisor--entry-state (make-hash-table :test 'equal)))
    ;; Entry is disabled from the start
    (supervisor--transition-state "proc" 'disabled)
    (should (eq 'disabled (gethash "proc" supervisor--entry-state)))))

(ert-deftest supervisor-test-fsm-lifecycle-oneshot ()
  "Test lifecycle path for oneshot process."
  (let ((supervisor--entry-state (make-hash-table :test 'equal)))
    ;; Initial state
    (supervisor--transition-state "oneshot" 'pending)
    ;; Started (oneshot still uses 'started state)
    (supervisor--transition-state "oneshot" 'started)
    (should (eq 'started (gethash "oneshot" supervisor--entry-state)))))

;;; Phase 6: Structured Event Dispatcher Tests

(ert-deftest supervisor-test-event-types-defined ()
  "All event types are defined in the event type list."
  (should (memq 'startup-begin supervisor--event-types))
  (should (memq 'startup-complete supervisor--event-types))
  (should (memq 'process-started supervisor--event-types))
  (should (memq 'process-ready supervisor--event-types))
  (should (memq 'process-exit supervisor--event-types))
  (should (memq 'process-failed supervisor--event-types))
  (should (memq 'cleanup supervisor--event-types))
  ;; Timer event types
  (should (memq 'timer-trigger supervisor--event-types))
  (should (memq 'timer-overlap supervisor--event-types))
  (should (memq 'timer-success supervisor--event-types))
  (should (memq 'timer-failure supervisor--event-types)))

(ert-deftest supervisor-test-emit-event-invalid-type-rejected ()
  "Emitting an invalid event type signals an error."
  (should-error (supervisor--emit-event 'invalid-event-type nil nil nil)
                :type 'error))

(ert-deftest supervisor-test-emit-event-schema ()
  "Emitted events have the correct schema."
  (let ((events nil))
    (cl-letf (((symbol-function 'run-hook-with-args)
               (lambda (hook &rest args) (when (eq hook 'supervisor-event-hook)
                                           (push (car args) events))))
              ((symbol-function 'run-hooks) #'ignore))
      (supervisor--emit-event 'startup-begin nil nil nil)
      (let ((event (car events)))
        (should (eq 'startup-begin (plist-get event :type)))
        (should (numberp (plist-get event :ts)))
        (should (null (plist-get event :id)))
        (should (null (plist-get event :stage)))))))

(ert-deftest supervisor-test-emit-event-startup-begin ()
  "Startup-begin event is emitted with correct data."
  (let ((events nil))
    (cl-letf (((symbol-function 'run-hook-with-args)
               (lambda (hook &rest args)
                 (when (eq hook 'supervisor-event-hook)
                   (push (car args) events))))
              ((symbol-function 'run-hooks) #'ignore))
      (supervisor--emit-event 'startup-begin nil nil nil)
      (should (= 1 (length events)))
      (let ((event (car events)))
        (should (eq 'startup-begin (plist-get event :type)))
        (should (null (plist-get event :stage)))))))

(ert-deftest supervisor-test-emit-event-process-exit ()
  "Process-exit event carries status and code in data."
  (let ((events nil))
    (cl-letf (((symbol-function 'run-hook-with-args)
               (lambda (hook &rest args)
                 (when (eq hook 'supervisor-event-hook)
                   (push (car args) events))))
              ((symbol-function 'run-hooks) #'ignore))
      (supervisor--emit-event 'process-exit "myproc" nil
                              (list :status 'exited :code 0))
      (should (= 1 (length events)))
      (let ((event (car events)))
        (should (eq 'process-exit (plist-get event :type)))
        (should (equal "myproc" (plist-get event :id)))
        (should (eq 'exited (plist-get (plist-get event :data) :status)))
        (should (= 0 (plist-get (plist-get event :data) :code)))))))

(ert-deftest supervisor-test-emit-event-process-started ()
  "Process-started event includes type in data."
  (let ((events nil))
    (cl-letf (((symbol-function 'run-hook-with-args)
               (lambda (hook &rest args)
                 (when (eq hook 'supervisor-event-hook)
                   (push (car args) events))))
              ((symbol-function 'run-hooks) #'ignore))
      (supervisor--emit-event 'process-started "daemon" nil
                              (list :type 'simple))
      (should (= 1 (length events)))
      (let ((event (car events)))
        (should (eq 'process-started (plist-get event :type)))
        (should (equal "daemon" (plist-get event :id)))
        (should (eq 'simple (plist-get (plist-get event :data) :type)))))))

(ert-deftest supervisor-test-spawn-failure-no-process-ready ()
  "Spawn failure emits process-failed but NOT process-ready.
Regression test: process-ready was incorrectly emitted for failures."
  (let ((events nil)
        (supervisor--entry-state (make-hash-table :test 'equal))
        (supervisor--dag-ready (make-hash-table :test 'equal))
        (supervisor--ready-times (make-hash-table :test 'equal))
        (supervisor--dag-dependents (make-hash-table :test 'equal))
        (supervisor--dag-in-degree (make-hash-table :test 'equal))
        (supervisor--dag-blocking (make-hash-table :test 'equal))
        (supervisor--dag-timeout-timers (make-hash-table :test 'equal))
        (supervisor--dag-started (make-hash-table :test 'equal))
        (supervisor--dag-active-starts 1)
        (supervisor--dag-pending-starts nil)
        (supervisor--dag-complete-callback nil)
        (supervisor--dag-entries (make-hash-table :test 'equal)))
    ;; Set up initial state
    (supervisor--transition-state "test" 'pending)
    (puthash "test" '("test" "cmd" 0 t always t simple stage3 nil t 30 nil)
             supervisor--dag-entries)
    ;; Capture events
    (cl-letf (((symbol-function 'run-hook-with-args)
               (lambda (hook &rest args)
                 (when (eq hook 'supervisor-event-hook)
                   (push (car args) events))))
              ((symbol-function 'run-hooks) #'ignore))
      (supervisor--dag-handle-spawn-failure "test"))
    ;; Should have process-failed but NOT process-ready
    (should (cl-find 'process-failed events :key (lambda (e) (plist-get e :type))))
    (should-not (cl-find 'process-ready events :key (lambda (e) (plist-get e :type))))))

(ert-deftest supervisor-test-disabled-entry-no-process-ready ()
  "Disabled entries do NOT emit process-ready.
Regression test: process-ready was incorrectly emitted for disabled entries."
  (let ((events nil)
        (supervisor--entry-state (make-hash-table :test 'equal))
        (supervisor--dag-ready (make-hash-table :test 'equal))
        (supervisor--ready-times (make-hash-table :test 'equal))
        (supervisor--dag-dependents (make-hash-table :test 'equal))
        (supervisor--dag-in-degree (make-hash-table :test 'equal))
        (supervisor--dag-blocking (make-hash-table :test 'equal))
        (supervisor--dag-timeout-timers (make-hash-table :test 'equal))
        (supervisor--dag-started (make-hash-table :test 'equal))
        (supervisor--dag-complete-callback nil)
        (supervisor--dag-entries (make-hash-table :test 'equal))
        (supervisor--enabled-override (make-hash-table :test 'equal)))
    ;; Set up as disabled entry
    (puthash "test" '("test" "cmd" 0 nil always t simple stage3 nil t 30 nil)
             supervisor--dag-entries)
    ;; Capture events
    (cl-letf (((symbol-function 'run-hook-with-args)
               (lambda (hook &rest args)
                 (when (eq hook 'supervisor-event-hook)
                   (push (car args) events))))
              ((symbol-function 'run-hooks) #'ignore))
      (supervisor--dag-start-entry-async
       '("test" "cmd" 0 nil always t simple stage3 nil t 30 nil)))
    ;; Should NOT have process-ready
    (should-not (cl-find 'process-ready events :key (lambda (e) (plist-get e :type))))))

(ert-deftest supervisor-test-simple-spawn-emits-process-ready ()
  "Successful simple process spawn emits process-started AND process-ready."
  (let ((events nil)
        (supervisor--entry-state (make-hash-table :test 'equal))
        (supervisor--dag-ready (make-hash-table :test 'equal))
        (supervisor--ready-times (make-hash-table :test 'equal))
        (supervisor--dag-dependents (make-hash-table :test 'equal))
        (supervisor--dag-in-degree (make-hash-table :test 'equal))
        (supervisor--dag-blocking (make-hash-table :test 'equal))
        (supervisor--dag-timeout-timers (make-hash-table :test 'equal))
        (supervisor--dag-started (make-hash-table :test 'equal))
        (supervisor--dag-active-starts 1)
        (supervisor--dag-pending-starts nil)
        (supervisor--dag-complete-callback nil)
        (supervisor--dag-entries (make-hash-table :test 'equal)))
    ;; Set up initial state
    (supervisor--transition-state "test" 'pending)
    (puthash "test" '("test" "sleep" 0 t always t simple stage3 nil t 30 nil)
             supervisor--dag-entries)
    ;; Capture events
    (cl-letf (((symbol-function 'run-hook-with-args)
               (lambda (hook &rest args)
                 (when (eq hook 'supervisor-event-hook)
                   (push (car args) events))))
              ((symbol-function 'run-hooks) #'ignore))
      (supervisor--dag-handle-spawn-success "test" 'simple nil))
    ;; Should have both process-started and process-ready
    (should (cl-find 'process-started events :key (lambda (e) (plist-get e :type))))
    (should (cl-find 'process-ready events :key (lambda (e) (plist-get e :type))))))

(ert-deftest supervisor-test-no-stderr-process-created ()
  "Starting a process does not create a separate stderr process.
Regression test: stderr pipe processes used to pollute the process list."
  (supervisor-test-with-unit-files
      '(("true" :id "test-no-stderr" :type oneshot))
    (let* ((supervisor--processes (make-hash-table :test 'equal))
           (supervisor--failed (make-hash-table :test 'equal))
           (supervisor--enabled-override (make-hash-table :test 'equal))
           (supervisor--logging (make-hash-table :test 'equal))
           (supervisor--oneshot-completed (make-hash-table :test 'equal))
           (supervisor--entry-state (make-hash-table :test 'equal))
           (supervisor--restart-timestamps (make-hash-table :test 'equal))
           (supervisor-log-directory (make-temp-file "supervisor-test-" t)))
      (unwind-protect
          (progn
            (supervisor--start-process "test-no-stderr" "true" t 'oneshot nil nil)
            ;; Main process should exist
            (should (gethash "test-no-stderr" supervisor--processes))
            ;; No stderr process should exist (with or without space prefix)
            (should-not (get-process "test-no-stderr-stderr"))
            (should-not (get-process " test-no-stderr-stderr")))
        (when-let* ((proc (gethash "test-no-stderr" supervisor--processes)))
          (delete-process proc))
        (delete-directory supervisor-log-directory t)))))

(ert-deftest supervisor-test-dashboard-menu-keybinding ()
  "Dashboard ? key is bound to transient menu wrapper."
  (should (eq (lookup-key supervisor-dashboard-mode-map "?")
              'supervisor-dashboard-menu-open)))

(ert-deftest supervisor-test-dashboard-info-keybinding ()
  "Dashboard i key is bound to inspect submenu."
  (should (eq (lookup-key supervisor-dashboard-mode-map "i")
              'supervisor-dashboard-inspect)))

(ert-deftest supervisor-test-header-hints-default-hidden ()
  "Header hints are hidden by default."
  (should-not supervisor-dashboard-show-header-hints))

(ert-deftest supervisor-test-transient-menu-defined ()
  "Transient menu wrapper is defined and helper function exists."
  ;; The wrapper function should always be defined
  (should (fboundp 'supervisor-dashboard-menu-open))
  ;; The helper that defines the menu should exist
  (should (fboundp 'supervisor--define-dashboard-menu))
  ;; After calling the helper with transient loaded, the menu should exist
  (when (require 'transient nil t)
    (supervisor--define-dashboard-menu)
    (should (fboundp 'supervisor-dashboard-menu))
    (should (get 'supervisor-dashboard-menu 'transient--prefix))))

;;; Dashboard Stop/Restart Tests

(ert-deftest supervisor-test-dashboard-stop-keybinding ()
  "Dashboard l key reaches lifecycle submenu."
  (should (eq (lookup-key supervisor-dashboard-mode-map "l")
              'supervisor-dashboard-lifecycle)))

(ert-deftest supervisor-test-dashboard-restart-keybinding ()
  "Dashboard p key reaches policy submenu."
  (should (eq (lookup-key supervisor-dashboard-mode-map "p")
              'supervisor-dashboard-policy)))

(ert-deftest supervisor-test-dashboard-stop-is-defined ()
  "Dashboard stop command is defined as interactive."
  (should (fboundp 'supervisor-dashboard-stop))
  (should (commandp 'supervisor-dashboard-stop)))

(ert-deftest supervisor-test-dashboard-restart-is-defined ()
  "Dashboard restart command is defined as interactive."
  (should (fboundp 'supervisor-dashboard-restart))
  (should (commandp 'supervisor-dashboard-restart)))

(ert-deftest supervisor-test-manual-stop-not-running ()
  "Manual stop on non-running entry returns skipped."
  (let ((supervisor--processes (make-hash-table :test 'equal)))
    (let ((result (supervisor--manual-stop "nonexistent")))
      (should (eq 'skipped (plist-get result :status)))
      (should (string= "not running" (plist-get result :reason))))))

(ert-deftest supervisor-test-manual-stop-sets-manually-stopped ()
  "Manual stop sets the manually-stopped flag."
  (let* ((supervisor--processes (make-hash-table :test 'equal))
         (supervisor--manually-stopped (make-hash-table :test 'equal))
         (buf (generate-new-buffer " *test-proc*"))
         (proc (start-process "test-stop" buf "sleep" "60")))
    (unwind-protect
        (progn
          (puthash "test-svc" proc supervisor--processes)
          (let ((result (supervisor--manual-stop "test-svc")))
            (should (eq 'stopped (plist-get result :status)))
            (should (eq t (gethash "test-svc" supervisor--manually-stopped)))))
      (when (process-live-p proc) (delete-process proc))
      (kill-buffer buf))))

(ert-deftest supervisor-test-manual-kill-does-not-set-manually-stopped ()
  "Manual kill does not set manually-stopped flag."
  (let* ((supervisor--processes (make-hash-table :test 'equal))
         (supervisor--manually-stopped (make-hash-table :test 'equal))
         (buf (generate-new-buffer " *test-proc*"))
         (proc (start-process "test-kill" buf "sleep" "60")))
    (unwind-protect
        (progn
          (puthash "test-svc" proc supervisor--processes)
          (let ((result (supervisor--manual-kill "test-svc" 'SIGTERM)))
            (should (eq 'signaled (plist-get result :status)))
            (should-not (gethash "test-svc" supervisor--manually-stopped))))
      (when (process-live-p proc) (delete-process proc))
      (kill-buffer buf))))

(ert-deftest supervisor-test-dashboard-kill-leaves-manually-stopped-untouched ()
  "Dashboard kill does not set the manually-stopped flag."
  (let* ((supervisor--processes (make-hash-table :test 'equal))
         (supervisor--manually-stopped (make-hash-table :test 'equal))
         (buf (generate-new-buffer " *test-dk*"))
         (proc (start-process "test-dk" buf "sleep" "60")))
    (unwind-protect
        (progn
          (puthash "test-svc" proc supervisor--processes)
          (with-temp-buffer
            (supervisor-dashboard-mode)
            (let ((tabulated-list-entries
                   (list (list (cons :service "test-svc")
                               (vector "test-svc" "simple" "stage3"
                                       "yes" "running" "yes" "yes"
                                       "1234" "-")))))
              (tabulated-list-init-header)
              (tabulated-list-print)
              (goto-char (point-min))
              ;; Call kill with force=t to skip confirmation
              (supervisor-dashboard-kill t)
              (should-not (gethash "test-svc" supervisor--manually-stopped)))))
      (when (process-live-p proc) (delete-process proc))
      (kill-buffer buf))))

(ert-deftest supervisor-test-help-text-includes-stop-restart ()
  "Dashboard help text includes lifecycle and policy submenu hints."
  (should (string-match "\\[l\\]ifecycle" supervisor--help-text))
  (should (string-match "\\[p\\]olicy" supervisor--help-text))
  (should (string-match "\\[i\\]nspect" supervisor--help-text)))

(ert-deftest supervisor-test-timer-row-p-detects-timer ()
  "Timer row predicate detects timer rows by typed cons cell ID."
  (should (supervisor--timer-row-p (cons :timer "my-timer")))
  (should-not (supervisor--timer-row-p (cons :service "my-svc")))
  (should-not (supervisor--timer-row-p "my-timer"))
  (should-not (supervisor--timer-row-p nil))
  (should-not (supervisor--timer-row-p '--timers--)))

(ert-deftest supervisor-test-timer-row-p-rejects-service-row ()
  "Timer row predicate returns nil for service rows."
  (with-temp-buffer
    (supervisor-dashboard-mode)
    (let ((tabulated-list-entries
           (list (list "my-svc" (vector "my-svc" "simple" "stage3"
                                       "yes" "running" "yes" "yes" "1234" "-")))))
      (tabulated-list-init-header)
      (tabulated-list-print)
      (goto-char (point-min))
      (should-not (supervisor--timer-row-p "my-svc")))))

(ert-deftest supervisor-test-stop-allows-service-with-timer-id-collision ()
  "Stop on a service row works even if a timer has the same ID."
  (supervisor-test-with-unit-files
      '(("sleep 60" :id "dup" :type simple))
    (let* ((supervisor--processes (make-hash-table :test 'equal))
           (supervisor--manually-stopped (make-hash-table :test 'equal))
           (supervisor--entry-state (make-hash-table :test 'equal))
           (supervisor--invalid (make-hash-table :test 'equal))
           (supervisor--invalid-timers (make-hash-table :test 'equal)))
      ;; Timer with same ID as service
      (puthash "dup" "some schedule" supervisor--invalid-timers)
      (with-temp-buffer
        (supervisor-dashboard-mode)
        ;; Row has type "simple"  this is a service row, not a timer row
        (let ((tabulated-list-entries
               (list (list "dup" (vector "dup" "simple" "stage3"
                                        "yes" "stopped" "yes" "yes" "-" "-")))))
          (tabulated-list-init-header)
          (tabulated-list-print)
          (goto-char (point-min))
          ;; Should NOT error with "Cannot stop timer"  it's a service row
          (should-not (supervisor--timer-row-p "dup")))))))

(ert-deftest supervisor-test-stop-rejects-oneshot ()
  "Stop rejects oneshot entries."
  (supervisor-test-with-unit-files
      '(("true" :id "my-oneshot" :type oneshot))
    (let* ((supervisor--processes (make-hash-table :test 'equal))
           (supervisor--entry-state (make-hash-table :test 'equal))
           (supervisor--invalid (make-hash-table :test 'equal)))
      ;; Simulate being in dashboard with oneshot at point
      (with-temp-buffer
        (supervisor-dashboard-mode)
        (let ((tabulated-list-entries
               (list (list "my-oneshot" (vector "my-oneshot" "oneshot" "stage3"
                                               "yes" "done" "n/a" "yes" "-" "-")))))
          (tabulated-list-init-header)
          (tabulated-list-print)
          (goto-char (point-min))
          (should-error (supervisor-dashboard-stop)
                        :type 'user-error))))))

(ert-deftest supervisor-test-restart-accepts-oneshot ()
  "Restart starts oneshot entries (parity with CLI).
Stop returns skipped for completed oneshot; restart must still
proceed to call start unconditionally."
  (supervisor-test-with-unit-files
      '(("true" :id "my-oneshot" :type oneshot))
    (let* ((supervisor--processes (make-hash-table :test 'equal))
           (supervisor--entry-state (make-hash-table :test 'equal))
           (supervisor--invalid (make-hash-table :test 'equal))
           (started nil))
      (with-temp-buffer
        (supervisor-dashboard-mode)
        (let ((tabulated-list-entries
               (list (list (cons :service "my-oneshot")
                           (vector "my-oneshot" "oneshot" "stage3"
                                   "yes" "done" "n/a" "yes" "-" "-")))))
          (tabulated-list-init-header)
          (tabulated-list-print)
          (goto-char (point-min))
          (cl-letf (((symbol-function 'yes-or-no-p) (lambda (_) t))
                    ((symbol-function 'supervisor--manual-stop)
                     (lambda (_id)
                       '(:status skipped :reason "not running")))
                    ((symbol-function 'supervisor--manual-start)
                     (lambda (id) (setq started id)
                       '(:status started)))
                    ((symbol-function 'supervisor--refresh-dashboard) #'ignore))
            (supervisor-dashboard-restart)
            (should (equal "my-oneshot" started))))))))

(ert-deftest supervisor-test-stop-rejects-timer-row ()
  "Stop rejects timer rows with stable message."
  (with-temp-buffer
    (supervisor-dashboard-mode)
    (let ((tabulated-list-entries
           (list (list (cons :timer "my-timer")
                       (vector "my-timer" "timer" "-"
                               "-" "pending" "-" "-" "-" "-")))))
      (tabulated-list-init-header)
      (tabulated-list-print)
      (goto-char (point-min))
      (let ((err (should-error (supervisor-dashboard-stop)
                               :type 'user-error)))
        (should (string-match-p "timer rows" (cadr err)))))))

(ert-deftest supervisor-test-restart-rejects-timer-row ()
  "Restart rejects timer rows with stable message."
  (with-temp-buffer
    (supervisor-dashboard-mode)
    (let ((tabulated-list-entries
           (list (list (cons :timer "my-timer")
                       (vector "my-timer" "timer" "-"
                               "-" "pending" "-" "-" "-" "-")))))
      (tabulated-list-init-header)
      (tabulated-list-print)
      (goto-char (point-min))
      (let ((err (should-error (supervisor-dashboard-restart)
                               :type 'user-error)))
        (should (string-match-p "timer rows" (cadr err)))))))

(ert-deftest supervisor-test-restart-accepts-not-running ()
  "Restart starts non-running entries (parity with CLI).
Stop returns skipped for non-running entries; restart must still
proceed to call start unconditionally."
  (supervisor-test-with-unit-files
      '(("sleep 60" :id "my-svc" :type simple))
    (let* ((supervisor--processes (make-hash-table :test 'equal))
           (supervisor--entry-state (make-hash-table :test 'equal))
           (supervisor--invalid (make-hash-table :test 'equal))
           (started nil))
      (with-temp-buffer
        (supervisor-dashboard-mode)
        (let ((tabulated-list-entries
               (list (list (cons :service "my-svc")
                           (vector "my-svc" "simple" "stage3"
                                   "yes" "stopped" "yes" "yes" "-" "-")))))
          (tabulated-list-init-header)
          (tabulated-list-print)
          (goto-char (point-min))
          (cl-letf (((symbol-function 'yes-or-no-p) (lambda (_) t))
                    ((symbol-function 'supervisor--manual-stop)
                     (lambda (_id)
                       '(:status skipped :reason "not running")))
                    ((symbol-function 'supervisor--manual-start)
                     (lambda (id) (setq started id)
                       '(:status started)))
                    ((symbol-function 'supervisor--refresh-dashboard) #'ignore))
            (supervisor-dashboard-restart)
            (should (equal "my-svc" started))))))))

;;; Interactive Dashboard Timer Section Tests (PLAN-interactive Phase 5)

(ert-deftest supervisor-test-typed-row-id-service ()
  "Service row IDs are typed cons cells."
  (should (supervisor--service-row-p (cons :service "foo")))
  (should-not (supervisor--service-row-p (cons :timer "foo")))
  (should-not (supervisor--service-row-p "foo"))
  (should-not (supervisor--service-row-p nil)))

(ert-deftest supervisor-test-typed-row-id-timer ()
  "Timer row IDs are typed cons cells."
  (should (supervisor--timer-row-p (cons :timer "foo")))
  (should-not (supervisor--timer-row-p (cons :service "foo")))
  (should-not (supervisor--timer-row-p "foo"))
  (should-not (supervisor--timer-row-p nil)))

(ert-deftest supervisor-test-typed-row-id-separator ()
  "Separator row IDs are symbols."
  (should (supervisor--separator-row-p '--stage1--))
  (should (supervisor--separator-row-p '--health--))
  (should (supervisor--separator-row-p '--timers--))
  (should-not (supervisor--separator-row-p (cons :service "foo")))
  (should-not (supervisor--separator-row-p nil)))

(ert-deftest supervisor-test-row-kind-dispatch ()
  "Row kind returns correct kind for all ID types."
  (should (eq :service (supervisor--row-kind (cons :service "x"))))
  (should (eq :timer (supervisor--row-kind (cons :timer "x"))))
  (should (eq :separator (supervisor--row-kind '--stage1--)))
  (should-not (supervisor--row-kind nil)))

(ert-deftest supervisor-test-row-id-extraction ()
  "Row ID extraction returns string from typed IDs."
  (should (equal "foo" (supervisor--row-id (cons :service "foo"))))
  (should (equal "bar" (supervisor--row-id (cons :timer "bar"))))
  (should-not (supervisor--row-id '--separator--))
  (should-not (supervisor--row-id nil)))

(ert-deftest supervisor-test-collision-service-timer-same-id ()
  "Service and timer with same ID string do not collide in row dispatch."
  (let ((svc-id (cons :service "backup"))
        (tmr-id (cons :timer "backup")))
    ;; They are distinct
    (should-not (equal svc-id tmr-id))
    ;; Each detects correctly
    (should (supervisor--service-row-p svc-id))
    (should-not (supervisor--timer-row-p svc-id))
    (should (supervisor--timer-row-p tmr-id))
    (should-not (supervisor--service-row-p tmr-id))
    ;; Both extract same string
    (should (equal "backup" (supervisor--row-id svc-id)))
    (should (equal "backup" (supervisor--row-id tmr-id)))))

(ert-deftest supervisor-test-collision-dashboard-rows-coexist ()
  "Service and timer rows with same ID coexist in tabulated-list."
  (with-temp-buffer
    (supervisor-dashboard-mode)
    (let ((tabulated-list-entries
           (list (list (cons :service "backup")
                       (vector "backup" "simple" "stage1"
                               "yes" "running" "yes" "yes" "-" "-"))
                 (list (cons :timer "backup")
                       (vector "backup" "backup-svc" "yes"
                               "-" "-" "-" "-" "" "")))))
      (tabulated-list-init-header)
      (tabulated-list-print)
      (goto-char (point-min))
      ;; First row is service
      (should (supervisor--service-row-p (tabulated-list-get-id)))
      ;; Second row is timer
      (forward-line 1)
      (should (supervisor--timer-row-p (tabulated-list-get-id))))))

(ert-deftest supervisor-test-require-service-row-on-service ()
  "Require-service-row returns string ID on service row."
  (with-temp-buffer
    (supervisor-dashboard-mode)
    (let ((tabulated-list-entries
           (list (list (cons :service "svc")
                       (vector "svc" "simple" "stage1"
                               "yes" "running" "yes" "yes" "-" "-")))))
      (tabulated-list-init-header)
      (tabulated-list-print)
      (goto-char (point-min))
      (should (equal "svc" (supervisor--require-service-row))))))

(ert-deftest supervisor-test-require-service-row-rejects-timer ()
  "Require-service-row signals user-error on timer row."
  (with-temp-buffer
    (supervisor-dashboard-mode)
    (let ((tabulated-list-entries
           (list (list (cons :timer "my-timer")
                       (vector "my-timer" "target" "yes"
                               "-" "-" "-" "-" "" "")))))
      (tabulated-list-init-header)
      (tabulated-list-print)
      (goto-char (point-min))
      (should-error (supervisor--require-service-row)
                    :type 'user-error))))

(ert-deftest supervisor-test-require-service-row-rejects-separator ()
  "Require-service-row signals user-error on separator row."
  (with-temp-buffer
    (supervisor-dashboard-mode)
    (let ((tabulated-list-entries
           (list (list '--stage1--
                       (vector " stage1" "" "" "" "" "" "" "" "")))))
      (tabulated-list-init-header)
      (tabulated-list-print)
      (goto-char (point-min))
      (should-error (supervisor--require-service-row)
                    :type 'user-error))))

(ert-deftest supervisor-test-timer-section-disabled-mode ()
  "Timer section shows disabled state when timer-subsystem-mode is nil."
  (supervisor-test-with-unit-files
      '(("sleep 60" :id "svc" :type simple))
    (let ((supervisor--processes (make-hash-table :test 'equal))
          (supervisor--entry-state (make-hash-table :test 'equal))
          (supervisor--invalid (make-hash-table :test 'equal))
          (supervisor--timer-list nil)
          (supervisor--timer-state (make-hash-table :test 'equal))
          (supervisor--invalid-timers (make-hash-table :test 'equal))
          (supervisor-dashboard-show-timers t)
          (supervisor-timer-subsystem-mode nil))
      (let ((entries (supervisor--get-entries)))
        (let ((tmr-sep (cl-find '--timers-- entries :key #'car)))
          (should tmr-sep)
          (should (string-match-p "disabled"
                                  (aref (cadr tmr-sep) 0))))))))

(ert-deftest supervisor-test-timer-section-mode-on-supervisor-off ()
  "Timer section shows timers when timer-mode is on but supervisor-mode is off.
The disabled gate is `supervisor-timer-subsystem-mode', not
`supervisor-timer-subsystem-active-p' (which also requires `supervisor-mode').
When `supervisor-timer-subsystem-mode' is t but `supervisor-mode' is nil,
configured timers must be visible for analysis."
  (supervisor-test-with-unit-files
      '(("sleep 60" :id "svc" :type simple))
    (let* ((supervisor--processes (make-hash-table :test 'equal))
           (supervisor--entry-state (make-hash-table :test 'equal))
           (supervisor--invalid (make-hash-table :test 'equal))
           (supervisor--timer-state (make-hash-table :test 'equal))
           (supervisor--invalid-timers (make-hash-table :test 'equal))
           (supervisor-dashboard-show-timers t)
           (supervisor-timer-subsystem-mode t)
           (supervisor-mode nil)
           (supervisor--timer-list
            (list (supervisor-timer--create :id "t1" :target "svc"))))
      (let ((entries (supervisor--get-entries)))
        ;; Timer section present and NOT disabled
        (let ((tmr-sep (cl-find '--timers-- entries :key #'car)))
          (should tmr-sep)
          (should-not (string-match-p "disabled" (aref (cadr tmr-sep) 0)))
          ;; Column headers visible
          (should (string-match-p "TARGET" (aref (cadr tmr-sep) 1))))
        ;; Timer row visible
        (let ((tmr-row (cl-find (cons :timer "t1") entries
                                :key #'car :test #'equal)))
          (should tmr-row))))))

(ert-deftest supervisor-test-timer-section-empty-state ()
  "Timer section shows empty state when no timers configured."
  (supervisor-test-with-unit-files
      '(("sleep 60" :id "svc" :type simple))
    (let ((supervisor--processes (make-hash-table :test 'equal))
          (supervisor--entry-state (make-hash-table :test 'equal))
          (supervisor--invalid (make-hash-table :test 'equal))
          (supervisor--timer-list nil)
          (supervisor--timer-state (make-hash-table :test 'equal))
          (supervisor--invalid-timers (make-hash-table :test 'equal))
          (supervisor-dashboard-show-timers t)
          (supervisor-timer-subsystem-mode t))
      (let ((entries (supervisor--get-entries)))
        (let ((tmr-sep (cl-find '--timers-- entries :key #'car)))
          (should tmr-sep)
          (should (string-match-p "no timers configured"
                                  (aref (cadr tmr-sep) 1))))))))

(ert-deftest supervisor-test-timer-section-valid-state ()
  "Timer section shows valid timer rows when timers are configured."
  (supervisor-test-with-unit-files
      '(("sleep 60" :id "svc" :type simple))
    (let* ((supervisor--processes (make-hash-table :test 'equal))
           (supervisor--entry-state (make-hash-table :test 'equal))
           (supervisor--invalid (make-hash-table :test 'equal))
           (supervisor--timer-state (make-hash-table :test 'equal))
           (supervisor--invalid-timers (make-hash-table :test 'equal))
           (supervisor-dashboard-show-timers t)
           (supervisor-timer-subsystem-mode t)
           (supervisor--timer-list
            (list (supervisor-timer--create :id "t1" :target "svc"))))
      (let ((entries (supervisor--get-entries)))
        ;; Timers header present
        (let ((tmr-sep (cl-find '--timers-- entries :key #'car)))
          (should tmr-sep)
          (should (string-match-p "TARGET" (aref (cadr tmr-sep) 1))))
        ;; Timer row present with typed ID
        (let ((tmr-row (cl-find (cons :timer "t1") entries
                                :key #'car :test #'equal)))
          (should tmr-row))))))

(ert-deftest supervisor-test-timer-section-invalid-timers ()
  "Timer section shows invalid timer rows."
  (supervisor-test-with-unit-files
      '(("sleep 60" :id "svc" :type simple))
    (let* ((supervisor--processes (make-hash-table :test 'equal))
           (supervisor--entry-state (make-hash-table :test 'equal))
           (supervisor--invalid (make-hash-table :test 'equal))
           (supervisor--timer-state (make-hash-table :test 'equal))
           (supervisor--invalid-timers (make-hash-table :test 'equal))
           (supervisor-dashboard-show-timers t)
           (supervisor-timer-subsystem-mode t)
           (supervisor--timer-list nil))
      (puthash "bad-timer" "missing target" supervisor--invalid-timers)
      (let ((entries (supervisor--get-entries)))
        (let ((bad-row (cl-find (cons :timer "bad-timer") entries
                                :key #'car :test #'equal)))
          (should bad-row)
          ;; Check invalid status
          (should (string-match-p "invalid"
                                  (aref (cadr bad-row) 4))))))))

(ert-deftest supervisor-test-timer-section-hidden-when-show-timers-nil ()
  "Timer section not rendered when show-timers is nil."
  (supervisor-test-with-unit-files
      '(("sleep 60" :id "svc" :type simple))
    (let ((supervisor--processes (make-hash-table :test 'equal))
          (supervisor--entry-state (make-hash-table :test 'equal))
          (supervisor--invalid (make-hash-table :test 'equal))
          (supervisor--timer-list nil)
          (supervisor--timer-state (make-hash-table :test 'equal))
          (supervisor--invalid-timers (make-hash-table :test 'equal))
          (supervisor-dashboard-show-timers nil))
      (let ((entries (supervisor--get-entries)))
        (should-not (cl-find '--timers-- entries :key #'car))))))

(ert-deftest supervisor-test-timer-trigger-rejects-service-row ()
  "Timer trigger rejects service rows."
  (with-temp-buffer
    (supervisor-dashboard-mode)
    (let ((tabulated-list-entries
           (list (list (cons :service "svc")
                       (vector "svc" "simple" "stage1"
                               "yes" "running" "yes" "yes" "-" "-")))))
      (tabulated-list-init-header)
      (tabulated-list-print)
      (goto-char (point-min))
      (should-error (supervisor-dashboard-timer-trigger)
                    :type 'user-error))))

(ert-deftest supervisor-test-timer-info-rejects-service-row ()
  "Timer info rejects service rows."
  (with-temp-buffer
    (supervisor-dashboard-mode)
    (let ((tabulated-list-entries
           (list (list (cons :service "svc")
                       (vector "svc" "simple" "stage1"
                               "yes" "running" "yes" "yes" "-" "-")))))
      (tabulated-list-init-header)
      (tabulated-list-print)
      (goto-char (point-min))
      (should-error (supervisor-dashboard-timer-info)
                    :type 'user-error))))

(ert-deftest supervisor-test-timer-jump-rejects-service-row ()
  "Timer jump rejects service rows."
  (with-temp-buffer
    (supervisor-dashboard-mode)
    (let ((tabulated-list-entries
           (list (list (cons :service "svc")
                       (vector "svc" "simple" "stage1"
                               "yes" "running" "yes" "yes" "-" "-")))))
      (tabulated-list-init-header)
      (tabulated-list-print)
      (goto-char (point-min))
      (should-error (supervisor-dashboard-timer-jump)
                    :type 'user-error))))

(ert-deftest supervisor-test-timer-reset-rejects-service-row ()
  "Timer reset rejects service rows."
  (with-temp-buffer
    (supervisor-dashboard-mode)
    (let ((tabulated-list-entries
           (list (list (cons :service "svc")
                       (vector "svc" "simple" "stage1"
                               "yes" "running" "yes" "yes" "-" "-")))))
      (tabulated-list-init-header)
      (tabulated-list-print)
      (goto-char (point-min))
      (should-error (supervisor-dashboard-timer-reset)
                    :type 'user-error))))

(ert-deftest supervisor-test-timer-jump-finds-target ()
  "Timer jump moves point to target service row."
  (let ((supervisor--timer-list
         (list (supervisor-timer--create :id "t1" :target "my-svc"))))
    (with-temp-buffer
      (supervisor-dashboard-mode)
      (let ((tabulated-list-entries
             (list (list (cons :service "my-svc")
                         (vector "my-svc" "simple" "stage1"
                                 "yes" "running" "yes" "yes" "-" "-"))
                   (list (cons :timer "t1")
                         (vector "t1" "my-svc" "yes"
                                 "-" "-" "-" "-" "" "")))))
        (tabulated-list-init-header)
        (tabulated-list-print)
        ;; Go to timer row
        (goto-char (point-min))
        (forward-line 1)
        (should (supervisor--timer-row-p (tabulated-list-get-id)))
        ;; Jump
        (supervisor-dashboard-timer-jump)
        ;; Should be on service row now
        (should (supervisor--service-row-p (tabulated-list-get-id)))
        (should (equal "my-svc" (supervisor--row-id (tabulated-list-get-id))))))))

(ert-deftest supervisor-test-timer-jump-absent-target-message ()
  "Timer jump shows message when target not visible."
  (let ((supervisor--timer-list
         (list (supervisor-timer--create :id "t1" :target "missing-svc")))
        (last-msg nil))
    (with-temp-buffer
      (supervisor-dashboard-mode)
      (let ((tabulated-list-entries
             (list (list (cons :timer "t1")
                         (vector "t1" "missing-svc" "yes"
                                 "-" "-" "-" "-" "" "")))))
        (tabulated-list-init-header)
        (tabulated-list-print)
        (goto-char (point-min))
        (cl-letf (((symbol-function 'message)
                   (lambda (fmt &rest args)
                     (setq last-msg (apply #'format fmt args)))))
          (supervisor-dashboard-timer-jump)
          (should (string-match-p "not visible" last-msg)))))))

(ert-deftest supervisor-test-timer-trigger-rejects-disabled-subsystem ()
  "Timer trigger rejects when subsystem is disabled."
  (let ((supervisor--timer-list
         (list (supervisor-timer--create :id "t1" :target "svc")))
        (supervisor--invalid-timers (make-hash-table :test 'equal)))
    (with-temp-buffer
      (supervisor-dashboard-mode)
      (let ((tabulated-list-entries
             (list (list (cons :timer "t1")
                         (vector "t1" "svc" "yes" "-" "-" "-" "-" "" "")))))
        (tabulated-list-init-header)
        (tabulated-list-print)
        (goto-char (point-min))
        (cl-letf (((symbol-function 'supervisor-timer-subsystem-active-p)
                   (lambda () nil)))
          (should-error (supervisor-dashboard-timer-trigger)
                        :type 'user-error))))))

(ert-deftest supervisor-test-timer-trigger-rejects-invalid-timer ()
  "Timer trigger rejects invalid timers."
  (let ((supervisor--timer-list
         (list (supervisor-timer--create :id "t1" :target "svc")))
        (supervisor--invalid-timers (make-hash-table :test 'equal)))
    (puthash "t1" "bad config" supervisor--invalid-timers)
    (with-temp-buffer
      (supervisor-dashboard-mode)
      (let ((tabulated-list-entries
             (list (list (cons :timer "t1")
                         (vector "t1" "svc" "yes" "-" "-" "-" "-" "" "")))))
        (tabulated-list-init-header)
        (tabulated-list-print)
        (goto-char (point-min))
        (cl-letf (((symbol-function 'supervisor-timer-subsystem-active-p)
                   (lambda () t)))
          (should-error (supervisor-dashboard-timer-trigger)
                        :type 'user-error))))))

(ert-deftest supervisor-test-timer-reset-clears-state ()
  "Timer reset clears runtime state fields."
  (let* ((supervisor--timer-list
          (list (supervisor-timer--create :id "t1" :target "svc")))
         (supervisor--timer-state (make-hash-table :test 'equal))
         (supervisor--invalid-timers (make-hash-table :test 'equal))
         (update-called nil))
    ;; Seed runtime state
    (puthash "t1" (list :last-run-at 1000 :last-exit 0
                        :retry-attempt 2 :next-run-at 2000
                        :startup-triggered t)
             supervisor--timer-state)
    (with-temp-buffer
      (supervisor-dashboard-mode)
      (let ((tabulated-list-entries
             (list (list (cons :timer "t1")
                         (vector "t1" "svc" "yes" "-" "-" "0" "-" "" "")))))
        (tabulated-list-init-header)
        (tabulated-list-print)
        (goto-char (point-min))
        (cl-letf (((symbol-function 'yes-or-no-p) (lambda (_) t))
                  ((symbol-function 'supervisor-timer--update-next-run)
                   (lambda (_id) (setq update-called t)))
                  ((symbol-function 'supervisor-timer-subsystem-active-p)
                   (lambda () nil))
                  ((symbol-function 'supervisor--refresh-dashboard) #'ignore))
          (supervisor-dashboard-timer-reset)
          (let ((state (gethash "t1" supervisor--timer-state)))
            ;; All runtime fields cleared
            (should-not (plist-get state :last-run-at))
            (should-not (plist-get state :last-exit))
            (should-not (plist-get state :retry-attempt))
            (should-not (plist-get state :next-run-at))
            (should-not (plist-get state :startup-triggered))
            ;; Update-next-run was called
            (should update-called)))))))

(ert-deftest supervisor-test-service-only-reject-on-timer-enable ()
  "Enable rejects timer rows with stable message."
  (with-temp-buffer
    (supervisor-dashboard-mode)
    (let ((tabulated-list-entries
           (list (list (cons :timer "t1")
                       (vector "t1" "svc" "yes" "-" "-" "-" "-" "" "")))))
      (tabulated-list-init-header)
      (tabulated-list-print)
      (goto-char (point-min))
      (let ((err (should-error (supervisor-dashboard-enable)
                               :type 'user-error)))
        (should (string-match-p "timer rows" (cadr err)))))))

(ert-deftest supervisor-test-service-only-reject-on-timer-disable ()
  "Disable rejects timer rows with stable message."
  (with-temp-buffer
    (supervisor-dashboard-mode)
    (let ((tabulated-list-entries
           (list (list (cons :timer "t1")
                       (vector "t1" "svc" "yes" "-" "-" "-" "-" "" "")))))
      (tabulated-list-init-header)
      (tabulated-list-print)
      (goto-char (point-min))
      (let ((err (should-error (supervisor-dashboard-disable)
                               :type 'user-error)))
        (should (string-match-p "timer rows" (cadr err)))))))

(ert-deftest supervisor-test-service-only-reject-on-timer-mask ()
  "Mask rejects timer rows with stable message."
  (with-temp-buffer
    (supervisor-dashboard-mode)
    (let ((tabulated-list-entries
           (list (list (cons :timer "t1")
                       (vector "t1" "svc" "yes" "-" "-" "-" "-" "" "")))))
      (tabulated-list-init-header)
      (tabulated-list-print)
      (goto-char (point-min))
      (let ((err (should-error (supervisor-dashboard-mask)
                               :type 'user-error)))
        (should (string-match-p "timer rows" (cadr err)))))))

(ert-deftest supervisor-test-service-only-reject-on-timer-cat ()
  "Cat rejects timer rows with stable message."
  (with-temp-buffer
    (supervisor-dashboard-mode)
    (let ((tabulated-list-entries
           (list (list (cons :timer "t1")
                       (vector "t1" "svc" "yes" "-" "-" "-" "-" "" "")))))
      (tabulated-list-init-header)
      (tabulated-list-print)
      (goto-char (point-min))
      (let ((err (should-error (supervisor-dashboard-cat)
                               :type 'user-error)))
        (should (string-match-p "timer rows" (cadr err)))))))

(ert-deftest supervisor-test-service-only-reject-on-timer-kill ()
  "Kill rejects timer rows with stable message."
  (with-temp-buffer
    (supervisor-dashboard-mode)
    (let ((tabulated-list-entries
           (list (list (cons :timer "t1")
                       (vector "t1" "svc" "yes" "-" "-" "-" "-" "" "")))))
      (tabulated-list-init-header)
      (tabulated-list-print)
      (goto-char (point-min))
      (let ((err (should-error (supervisor-dashboard-kill)
                               :type 'user-error)))
        (should (string-match-p "timer rows" (cadr err)))))))

(ert-deftest supervisor-test-service-only-reject-on-timer-blame ()
  "Blame rejects timer rows with stable message."
  (with-temp-buffer
    (supervisor-dashboard-mode)
    (let ((tabulated-list-entries
           (list (list (cons :timer "t1")
                       (vector "t1" "svc" "yes" "-" "-" "-" "-" "" "")))))
      (tabulated-list-init-header)
      (tabulated-list-print)
      (goto-char (point-min))
      (let ((err (should-error (supervisor-dashboard-blame)
                               :type 'user-error)))
        (should (string-match-p "timer rows" (cadr err)))))))

(ert-deftest supervisor-test-service-only-reject-on-timer-graph ()
  "Show-graph rejects timer rows with stable message."
  (with-temp-buffer
    (supervisor-dashboard-mode)
    (let ((tabulated-list-entries
           (list (list (cons :timer "t1")
                       (vector "t1" "svc" "yes" "-" "-" "-" "-" "" "")))))
      (tabulated-list-init-header)
      (tabulated-list-print)
      (goto-char (point-min))
      (let ((err (should-error (supervisor-dashboard-show-graph)
                               :type 'user-error)))
        (should (string-match-p "timer rows" (cadr err)))))))

(ert-deftest supervisor-test-service-only-reject-on-timer-describe ()
  "Describe-entry rejects timer rows with stable message."
  (with-temp-buffer
    (supervisor-dashboard-mode)
    (let ((tabulated-list-entries
           (list (list (cons :timer "t1")
                       (vector "t1" "svc" "yes" "-" "-" "-" "-" "" "")))))
      (tabulated-list-init-header)
      (tabulated-list-print)
      (goto-char (point-min))
      (let ((err (should-error (supervisor-dashboard-describe-entry)
                               :type 'user-error)))
        (should (string-match-p "timer rows" (cadr err)))))))

(ert-deftest supervisor-test-transient-menu-has-timer-group ()
  "Transient menu definition includes Timers group with y-prefixed suffixes."
  ;; The transient menu is defined lazily; we trigger it via the definer
  (let ((supervisor--dashboard-menu-defined nil))
    (require 'transient)
    (supervisor--define-dashboard-menu)
    ;; The transient prefix should be defined now
    (should (fboundp 'supervisor-dashboard-menu))
    ;; Verify timer commands are interactive
    (should (commandp 'supervisor-dashboard-timer-trigger))
    (should (commandp 'supervisor-dashboard-timer-info))
    (should (commandp 'supervisor-dashboard-timer-jump))
    (should (commandp 'supervisor-dashboard-timer-reset))
    (should (commandp 'supervisor-dashboard-timer-refresh))
    ;; Verify transient layout has Timers group with correct key bindings.
    ;; Walk the layout tree to find :key properties, resilient to internal
    ;; transient layout format changes across Emacs versions.
    (let* ((layout (get 'supervisor-dashboard-menu 'transient--layout))
           (keys nil))
      ;; Recursively collect all :key values from the layout structure
      (cl-labels
          ((walk (node)
             (cond
              ((vectorp node)
               (dotimes (i (length node))
                 (walk (aref node i))))
              ((and (listp node) (plist-get node :key))
               (push (plist-get node :key) keys))
              ((listp node)
               (dolist (elt node)
                 (walk elt))))))
        (walk layout))
      (should (member "y t" keys))
      (should (member "y i" keys))
      (should (member "y j" keys))
      (should (member "y r" keys))
      (should (member "y g" keys)))))

(ert-deftest supervisor-test-timer-actions-dispatcher-key ()
  "Timer actions dispatcher is bound to y in dashboard keymap."
  (with-temp-buffer
    (supervisor-dashboard-mode)
    (should (eq (key-binding "y") #'supervisor-dashboard-timer-actions))))

(ert-deftest supervisor-test-service-only-reject-on-timer-reload-unit ()
  "Reload-unit rejects timer rows with stable message."
  (with-temp-buffer
    (supervisor-dashboard-mode)
    (let ((tabulated-list-entries
           (list (list (cons :timer "t1")
                       (vector "t1" "svc" "yes" "-" "-" "-" "-" "" "")))))
      (tabulated-list-init-header)
      (tabulated-list-print)
      (goto-char (point-min))
      (let ((err (should-error (supervisor-dashboard-reload-unit)
                               :type 'user-error)))
        (should (string-match-p "timer rows" (cadr err)))))))

(ert-deftest supervisor-test-service-only-reject-on-timer-reset-failed ()
  "Reset-failed rejects timer rows with stable message."
  (with-temp-buffer
    (supervisor-dashboard-mode)
    (let ((tabulated-list-entries
           (list (list (cons :timer "t1")
                       (vector "t1" "svc" "yes" "-" "-" "-" "-" "" "")))))
      (tabulated-list-init-header)
      (tabulated-list-print)
      (goto-char (point-min))
      (let ((err (should-error (supervisor-dashboard-reset-failed)
                               :type 'user-error)))
        (should (string-match-p "timer rows" (cadr err)))))))

(ert-deftest supervisor-test-service-only-reject-on-timer-unmask ()
  "Unmask rejects timer rows with stable message."
  (with-temp-buffer
    (supervisor-dashboard-mode)
    (let ((tabulated-list-entries
           (list (list (cons :timer "t1")
                       (vector "t1" "svc" "yes" "-" "-" "-" "-" "" "")))))
      (tabulated-list-init-header)
      (tabulated-list-print)
      (goto-char (point-min))
      (let ((err (should-error (supervisor-dashboard-unmask)
                               :type 'user-error)))
        (should (string-match-p "timer rows" (cadr err)))))))

(ert-deftest supervisor-test-service-only-reject-on-timer-set-restart ()
  "Set-restart-policy rejects timer rows with stable message."
  (with-temp-buffer
    (supervisor-dashboard-mode)
    (let ((tabulated-list-entries
           (list (list (cons :timer "t1")
                       (vector "t1" "svc" "yes" "-" "-" "-" "-" "" "")))))
      (tabulated-list-init-header)
      (tabulated-list-print)
      (goto-char (point-min))
      (let ((err (should-error (supervisor-dashboard-set-restart-policy)
                               :type 'user-error)))
        (should (string-match-p "timer rows" (cadr err)))))))

(ert-deftest supervisor-test-service-only-reject-on-timer-set-logging ()
  "Set-logging rejects timer rows with stable message."
  (with-temp-buffer
    (supervisor-dashboard-mode)
    (let ((tabulated-list-entries
           (list (list (cons :timer "t1")
                       (vector "t1" "svc" "yes" "-" "-" "-" "-" "" "")))))
      (tabulated-list-init-header)
      (tabulated-list-print)
      (goto-char (point-min))
      (let ((err (should-error (supervisor-dashboard-set-logging)
                               :type 'user-error)))
        (should (string-match-p "timer rows" (cadr err)))))))

(ert-deftest supervisor-test-service-only-reject-on-timer-edit ()
  "Edit rejects timer rows with stable message."
  (with-temp-buffer
    (supervisor-dashboard-mode)
    (let ((tabulated-list-entries
           (list (list (cons :timer "t1")
                       (vector "t1" "svc" "yes" "-" "-" "-" "-" "" "")))))
      (tabulated-list-init-header)
      (tabulated-list-print)
      (goto-char (point-min))
      (let ((err (should-error (supervisor-dashboard-edit)
                               :type 'user-error)))
        (should (string-match-p "timer rows" (cadr err)))))))

(ert-deftest supervisor-test-service-only-reject-on-timer-show-deps ()
  "Show-deps rejects timer rows with stable message."
  (with-temp-buffer
    (supervisor-dashboard-mode)
    (let ((tabulated-list-entries
           (list (list (cons :timer "t1")
                       (vector "t1" "svc" "yes" "-" "-" "-" "-" "" "")))))
      (tabulated-list-init-header)
      (tabulated-list-print)
      (goto-char (point-min))
      (let ((err (should-error (supervisor-dashboard-show-deps)
                               :type 'user-error)))
        (should (string-match-p "timer rows" (cadr err)))))))

(ert-deftest supervisor-test-service-only-reject-on-timer-view-log ()
  "View-log rejects timer rows with stable message."
  (with-temp-buffer
    (supervisor-dashboard-mode)
    (let ((tabulated-list-entries
           (list (list (cons :timer "t1")
                       (vector "t1" "svc" "yes" "-" "-" "-" "-" "" "")))))
      (tabulated-list-init-header)
      (tabulated-list-print)
      (goto-char (point-min))
      (let ((err (should-error (supervisor-dashboard-view-log)
                               :type 'user-error)))
        (should (string-match-p "timer rows" (cadr err)))))))

(ert-deftest supervisor-test-service-only-reject-on-timer-start ()
  "Start rejects timer rows with stable message."
  (with-temp-buffer
    (supervisor-dashboard-mode)
    (let ((tabulated-list-entries
           (list (list (cons :timer "t1")
                       (vector "t1" "svc" "yes" "-" "-" "-" "-" "" "")))))
      (tabulated-list-init-header)
      (tabulated-list-print)
      (goto-char (point-min))
      (let ((err (should-error (supervisor-dashboard-start)
                               :type 'user-error)))
        (should (string-match-p "timer rows" (cadr err)))))))

(ert-deftest supervisor-test-timer-refresh-calls-dashboard-refresh ()
  "Timer refresh command invokes dashboard refresh and messages."
  (let ((refreshed nil)
        (msg nil))
    (with-temp-buffer
      (supervisor-dashboard-mode)
      (cl-letf (((symbol-function 'supervisor--refresh-dashboard)
                 (lambda () (setq refreshed t)))
                ((symbol-function 'message)
                 (lambda (fmt &rest args)
                   (setq msg (apply #'format fmt args)))))
        (supervisor-dashboard-timer-refresh)
        (should refreshed)
        (should (string-match-p "refreshed" msg))))))

(ert-deftest supervisor-test-service-counters-in-header-line ()
  "Service counters are shown in `header-line-format'."
  (supervisor-test-with-unit-files
      '(("sleep 60" :id "svc" :type simple))
    (let ((supervisor--processes (make-hash-table :test 'equal))
          (supervisor--entry-state (make-hash-table :test 'equal))
          (supervisor--invalid (make-hash-table :test 'equal))
          (supervisor--timer-list nil)
          (supervisor--timer-state (make-hash-table :test 'equal))
          (supervisor--invalid-timers (make-hash-table :test 'equal))
          (supervisor-dashboard-show-timers nil))
      (let ((header (supervisor--dashboard-header-line)))
        (should (string-match-p "\\brun\\b" header))
        (should (string-match-p "\\bdone\\b" header))
        (should (string-match-p "\\bpend\\b" header))
        (should (string-match-p "\\bfail\\b" header))
        (should (string-match-p "\\binv\\b" header))
        ;; Header no longer carries column labels.
        (should-not (string-match-p "\\bID\\b" header))
        ;; No pipe filler separators in this compact format.
        (should-not (string-match-p "|" header))))))

(ert-deftest supervisor-test-services-header-precedes-service-and-timer-rows ()
  "Services section header appears first, then services, then timers."
  (supervisor-test-with-unit-files
      '(("sleep 60" :id "svc" :type simple))
    (let ((supervisor--processes (make-hash-table :test 'equal))
          (supervisor--entry-state (make-hash-table :test 'equal))
          (supervisor--invalid (make-hash-table :test 'equal))
          (supervisor--timer-list
           (list (supervisor-timer--create :id "t1" :target "svc")))
          (supervisor--timer-state (make-hash-table :test 'equal))
          (supervisor--invalid-timers (make-hash-table :test 'equal))
          (supervisor-dashboard-show-timers t)
          (supervisor-timer-subsystem-mode t))
      (let* ((entries (supervisor--get-entries))
             (ids (mapcar #'car entries))
             (services-pos (cl-position '--services-- ids))
             (svc-pos (cl-position-if
                       (lambda (id) (supervisor--service-row-p id)) ids))
             (timer-pos (cl-position '--timers-- ids))
             (tmr-pos (cl-position-if
                       (lambda (id) (supervisor--timer-row-p id)) ids)))
        (should svc-pos)
        (should services-pos)
        (should timer-pos)
        (should tmr-pos)
        ;; Services header is first body row.
        (should (= 0 services-pos))
        ;; Services section header precedes service rows and timers section.
        (should (< services-pos svc-pos))
        (should (< svc-pos timer-pos))
        (should (< timer-pos tmr-pos))))))

(ert-deftest supervisor-test-no-blank-summary-spacers-in-body ()
  "Dashboard body has no blank summary spacer rows."
  (supervisor-test-with-unit-files
      '(("sleep 60" :id "svc" :type simple))
    (let ((supervisor--processes (make-hash-table :test 'equal))
          (supervisor--entry-state (make-hash-table :test 'equal))
          (supervisor--invalid (make-hash-table :test 'equal))
          (supervisor--timer-list nil)
          (supervisor--timer-state (make-hash-table :test 'equal))
          (supervisor--invalid-timers (make-hash-table :test 'equal))
          (supervisor-dashboard-show-timers t)
          (supervisor-timer-subsystem-mode t))
      (let* ((entries (supervisor--get-entries))
             (ids (mapcar #'car entries)))
        (should-not
         (cl-find-if
          (lambda (id)
            (and (symbolp id)
                 (string-match-p "^--blank-" (symbol-name id))))
          ids))))))

(ert-deftest supervisor-test-header-counters-count-services-only ()
  "Header counters aggregate services only, never timer rows."
  (supervisor-test-with-unit-files
      '(("sleep 60" :id "svc" :type simple))
    (let* ((supervisor--processes (make-hash-table :test 'equal))
           (supervisor--entry-state (make-hash-table :test 'equal))
           (supervisor--invalid (make-hash-table :test 'equal))
           (supervisor--timer-list nil)
           (supervisor--timer-state (make-hash-table :test 'equal))
           (supervisor--invalid-timers (make-hash-table :test 'equal))
           (supervisor-dashboard-show-timers t)
           (supervisor-timer-subsystem-mode t)
           (header-no-timers
            (substring-no-properties (supervisor--dashboard-header-line))))
      (setq supervisor--timer-list
            (list (supervisor-timer--create :id "t1" :target "svc")))
      (let ((header-with-timers
             (substring-no-properties (supervisor--dashboard-header-line))))
        (should (equal header-no-timers header-with-timers))))))


(ert-deftest supervisor-test-timer-info-invalid-timer ()
  "Timer info shows details for invalid timers."
  (let ((supervisor--timer-list nil)
        (supervisor--invalid-timers (make-hash-table :test 'equal)))
    (puthash "bad-t" "missing target field" supervisor--invalid-timers)
    (with-temp-buffer
      (supervisor-dashboard-mode)
      (let ((tabulated-list-entries
             (list (list (cons :timer "bad-t")
                         (vector "bad-t" "-" "-" "-"
                                 (propertize "invalid" 'face 'error)
                                 "-" "missing target field" "" "")))))
        (tabulated-list-init-header)
        (tabulated-list-print)
        (goto-char (point-min))
        (supervisor-dashboard-timer-info)
        ;; Help window should be open
        (let ((info-buf (get-buffer "*supervisor-timer-info*")))
          (should info-buf)
          (with-current-buffer info-buf
            (should (string-match-p "INVALID" (buffer-string)))
            (should (string-match-p "missing target field" (buffer-string))))
          (kill-buffer info-buf))))))

(ert-deftest supervisor-test-timer-info-valid-timer ()
  "Timer info shows details for valid timers."
  (let* ((supervisor--timer-list
          (list (supervisor-timer--create
                 :id "t1" :target "svc"
                 :on-startup-sec 30
                 :persistent t)))
         (supervisor--timer-state (make-hash-table :test 'equal))
         (supervisor--invalid-timers (make-hash-table :test 'equal)))
    (puthash "t1" (list :last-run-at (float-time) :last-exit 0
                        :next-run-at (+ (float-time) 60))
             supervisor--timer-state)
    (with-temp-buffer
      (supervisor-dashboard-mode)
      (let ((tabulated-list-entries
             (list (list (cons :timer "t1")
                         (vector "t1" "svc" "yes" "-" "-" "0" "-" "" "")))))
        (tabulated-list-init-header)
        (tabulated-list-print)
        (goto-char (point-min))
        (supervisor-dashboard-timer-info)
        (let ((info-buf (get-buffer "*supervisor-timer-info*")))
          (should info-buf)
          (with-current-buffer info-buf
            (should (string-match-p "Timer: t1" (buffer-string)))
            (should (string-match-p "Target: svc" (buffer-string)))
            (should (string-match-p "Startup: 30" (buffer-string)))
            (should (string-match-p "Persistent: yes" (buffer-string))))
          (kill-buffer info-buf))))))

(ert-deftest supervisor-test-services-header-is-first-row ()
  "Services section header is the first content row."
  (supervisor-test-with-unit-files
      '(("sleep 60" :id "svc" :type simple))
    (let ((supervisor--processes (make-hash-table :test 'equal))
          (supervisor--entry-state (make-hash-table :test 'equal))
          (supervisor--invalid (make-hash-table :test 'equal))
          (supervisor--timer-list nil)
          (supervisor--timer-state (make-hash-table :test 'equal))
          (supervisor--invalid-timers (make-hash-table :test 'equal))
          (supervisor-dashboard-show-timers nil))
      (let* ((entries (supervisor--get-entries))
             (first-id (car (car entries))))
        (should (eq '--services-- first-id))))))

;;; Unit-File Tests

(ert-deftest supervisor-test-unit-file-path-resolution ()
  "Unit file path returns nil when no authority roots exist."
  (let ((supervisor-unit-authority-path nil))
    (should-not (supervisor--unit-file-path "nm-applet"))))

(ert-deftest supervisor-test-active-authority-roots-skips-missing ()
  "Active roots filters out non-existent directories."
  (let* ((dir1 (make-temp-file "tier1-" t))
         (dir2 "/nonexistent-supervisor-tier2")
         (dir3 (make-temp-file "tier3-" t))
         (supervisor-unit-authority-path (list dir1 dir2 dir3)))
    (unwind-protect
        (let ((active (supervisor--active-authority-roots)))
          (should (equal (list dir1 dir3) active)))
      (delete-directory dir1 t)
      (delete-directory dir3 t))))

(ert-deftest supervisor-test-active-authority-roots-preserves-order ()
  "Active roots preserves configured order (low to high)."
  (let* ((dir1 (make-temp-file "tier1-" t))
         (dir2 (make-temp-file "tier2-" t))
         (dir3 (make-temp-file "tier3-" t))
         (supervisor-unit-authority-path (list dir1 dir2 dir3)))
    (unwind-protect
        (let ((active (supervisor--active-authority-roots)))
          (should (equal (list dir1 dir2 dir3) active)))
      (delete-directory dir1 t)
      (delete-directory dir2 t)
      (delete-directory dir3 t))))

(ert-deftest supervisor-test-authority-root-for-id-highest-wins ()
  "Authority root returns highest-precedence root containing the ID."
  (let* ((dir1 (make-temp-file "tier1-" t))
         (dir2 (make-temp-file "tier2-" t))
         (supervisor-unit-authority-path (list dir1 dir2))
         (supervisor--authority-snapshot nil))
    (unwind-protect
        (progn
          ;; Place same ID in both tiers
          (with-temp-file (expand-file-name "svc.el" dir1)
            (insert "(:id \"svc\" :command \"echo low\")"))
          (with-temp-file (expand-file-name "svc.el" dir2)
            (insert "(:id \"svc\" :command \"echo high\")"))
          ;; Highest-precedence (dir2) should win
          (should (equal dir2 (supervisor--authority-root-for-id "svc"))))
      (delete-directory dir1 t)
      (delete-directory dir2 t))))

(ert-deftest supervisor-test-authority-root-for-id-returns-nil-when-missing ()
  "Authority root returns nil when ID does not exist in any root."
  (let* ((dir1 (make-temp-file "tier1-" t))
         (supervisor-unit-authority-path (list dir1))
         (supervisor--authority-snapshot nil))
    (unwind-protect
        (should-not (supervisor--authority-root-for-id "nonexistent"))
      (delete-directory dir1 t))))

(ert-deftest supervisor-test-unit-file-path-authority-aware ()
  "Unit file path resolves through authority snapshot.
Adding a file on disk does not change the result until the snapshot
is re-published (daemon-reload semantics)."
  (let* ((dir1 (make-temp-file "tier1-" t))
         (dir2 (make-temp-file "tier2-" t))
         (supervisor-unit-authority-path (list dir1 dir2))
         (supervisor--authority-snapshot nil))
    (unwind-protect
        (progn
          ;; svc exists only in tier 1 (lower precedence)
          (with-temp-file (expand-file-name "svc.el" dir1)
            (insert "(:id \"svc\" :command \"echo\")"))
          (should (equal (expand-file-name "svc.el" dir1)
                         (supervisor--unit-file-path "svc")))
          ;; Add to tier 2  snapshot is stale, still returns tier 1
          (with-temp-file (expand-file-name "svc.el" dir2)
            (insert "(:id \"svc\" :command \"echo\")"))
          (should (equal (expand-file-name "svc.el" dir1)
                         (supervisor--unit-file-path "svc")))
          ;; Re-publish snapshot  now tier 2 wins
          (supervisor--publish-authority-snapshot)
          (should (equal (expand-file-name "svc.el" dir2)
                         (supervisor--unit-file-path "svc"))))
      (delete-directory dir1 t)
      (delete-directory dir2 t))))

(ert-deftest supervisor-test-unit-file-path-new-unit-targets-highest ()
  "New unit file path targets highest-precedence active root."
  (let* ((dir1 (make-temp-file "tier1-" t))
         (dir2 (make-temp-file "tier2-" t))
         (supervisor-unit-authority-path (list dir1 dir2))
         (supervisor--authority-snapshot nil))
    (unwind-protect
        ;; Non-existent ID should target highest root (dir2)
        (should (equal (expand-file-name "new-svc.el" dir2)
                       (supervisor--unit-file-path "new-svc")))
      (delete-directory dir1 t)
      (delete-directory dir2 t))))

(ert-deftest supervisor-test-snapshot-resolves-mismatched-filename ()
  "Cold-start resolution finds units whose filename differs from :id.
Lazy-init publishes the snapshot automatically, so even with no
prior snapshot, lookup returns the correct root and actual file path."
  (let* ((dir (make-temp-file "tier-" t))
         (supervisor-unit-authority-path (list dir))
         (supervisor--authority-snapshot nil)
         (supervisor--programs-cache :not-yet-loaded)
         (supervisor--unit-file-invalid (make-hash-table :test 'equal)))
    (unwind-protect
        (progn
          ;; File foo.el contains :id "bar" (filename != :id)
          (with-temp-file (expand-file-name "foo.el" dir)
            (insert "(:id \"bar\" :command \"echo\")"))
          ;; Cold-start: no snapshot yet, but lazy-init resolves correctly
          (should (equal dir (supervisor--authority-root-for-id "bar")))
          (should (equal (expand-file-name "foo.el" dir)
                         (supervisor--unit-file-path "bar"))))
      (delete-directory dir t))))

;;; Authority resolver tests (Phase 2)

(ert-deftest supervisor-test-scan-authority-root-parses-files ()
  "Scanning a root returns candidate structs with metadata."
  (let ((dir (make-temp-file "tier-" t)))
    (unwind-protect
        (progn
          (with-temp-file (expand-file-name "svc.el" dir)
            (insert "(:id \"svc\" :command \"echo\")"))
          (let ((cands (supervisor--scan-authority-root dir 0)))
            (should (= 1 (length cands)))
            (let ((c (car cands)))
              (should (supervisor--authority-candidate-p c))
              (should (equal "svc" (supervisor--authority-candidate-id c)))
              (should (equal dir (supervisor--authority-candidate-root c)))
              (should (= 0 (supervisor--authority-candidate-tier c)))
              (should (supervisor--authority-candidate-valid-p c))
              (should-not (supervisor--authority-candidate-reason c)))))
      (delete-directory dir t))))

(ert-deftest supervisor-test-scan-authority-root-invalid-candidate ()
  "Scanning produces invalid candidate for malformed unit file."
  (let ((dir (make-temp-file "tier-" t)))
    (unwind-protect
        (progn
          (with-temp-file (expand-file-name "bad.el" dir)
            (insert "(:id \"bad\")"))  ; missing :command
          (let* ((cands (supervisor--scan-authority-root dir 0))
                 (c (car cands)))
            (should (= 1 (length cands)))
            (should-not (supervisor--authority-candidate-valid-p c))
            (should (supervisor--authority-candidate-reason c))))
      (delete-directory dir t))))

(ert-deftest supervisor-test-scan-authority-root-lexicographic-order ()
  "Candidates are returned in lexicographic file order."
  (let ((dir (make-temp-file "tier-" t)))
    (unwind-protect
        (progn
          (with-temp-file (expand-file-name "b-svc.el" dir)
            (insert "(:id \"b-svc\" :command \"echo b\")"))
          (with-temp-file (expand-file-name "a-svc.el" dir)
            (insert "(:id \"a-svc\" :command \"echo a\")"))
          (let ((cands (supervisor--scan-authority-root dir 0)))
            (should (= 2 (length cands)))
            (should (equal "a-svc"
                           (supervisor--authority-candidate-id (nth 0 cands))))
            (should (equal "b-svc"
                           (supervisor--authority-candidate-id (nth 1 cands))))))
      (delete-directory dir t))))

(ert-deftest supervisor-test-resolve-authority-higher-tier-wins ()
  "Higher-precedence tier wins for same ID."
  (let* ((dir1 (make-temp-file "tier1-" t))
         (dir2 (make-temp-file "tier2-" t))
         (supervisor-unit-authority-path (list dir1 dir2)))
    (unwind-protect
        (progn
          (with-temp-file (expand-file-name "svc.el" dir1)
            (insert "(:id \"svc\" :command \"echo low\")"))
          (with-temp-file (expand-file-name "svc.el" dir2)
            (insert "(:id \"svc\" :command \"echo high\")"))
          (let* ((result (supervisor--resolve-authority))
                 (winners (plist-get result :winners))
                 (shadowed (plist-get result :shadowed))
                 (winner (gethash "svc" winners)))
            ;; Higher tier wins
            (should (= 1 (supervisor--authority-candidate-tier winner)))
            (should (equal dir2 (supervisor--authority-candidate-root winner)))
            ;; Lower tier is shadowed
            (should (= 1 (length (gethash "svc" shadowed))))))
      (delete-directory dir1 t)
      (delete-directory dir2 t))))

(ert-deftest supervisor-test-resolve-authority-invalid-blocks-fallback ()
  "Invalid unit at highest tier blocks lower-tier valid unit."
  (let* ((dir1 (make-temp-file "tier1-" t))
         (dir2 (make-temp-file "tier2-" t))
         (supervisor-unit-authority-path (list dir1 dir2)))
    (unwind-protect
        (progn
          ;; Valid in lower tier
          (with-temp-file (expand-file-name "svc.el" dir1)
            (insert "(:id \"svc\" :command \"echo good\")"))
          ;; Invalid in higher tier (missing :command)
          (with-temp-file (expand-file-name "svc.el" dir2)
            (insert "(:id \"svc\")"))
          (let* ((result (supervisor--resolve-authority))
                 (winners (plist-get result :winners))
                 (invalid (plist-get result :invalid))
                 (winner (gethash "svc" winners)))
            ;; Higher tier still wins even though invalid
            (should (= 1 (supervisor--authority-candidate-tier winner)))
            (should-not (supervisor--authority-candidate-valid-p winner))
            ;; ID is in invalid hash
            (should (gethash "svc" invalid))))
      (delete-directory dir1 t)
      (delete-directory dir2 t))))

(ert-deftest supervisor-test-resolve-authority-same-tier-duplicate ()
  "Same-tier duplicate: first-seen (lexicographic) wins."
  (let* ((dir (make-temp-file "tier-" t))
         (supervisor-unit-authority-path (list dir)))
    (unwind-protect
        (progn
          ;; Two files with same :id, a-file.el sorts before z-file.el
          (with-temp-file (expand-file-name "a-file.el" dir)
            (insert "(:id \"dup\" :command \"echo first\")"))
          (with-temp-file (expand-file-name "z-file.el" dir)
            (insert "(:id \"dup\" :command \"echo second\")"))
          (let* ((result (supervisor--resolve-authority))
                 (winners (plist-get result :winners))
                 (invalid (plist-get result :invalid))
                 (winner (gethash "dup" winners)))
            ;; First-seen (a-file.el) wins
            (should (string-match "a-file\\.el"
                                  (supervisor--authority-candidate-path winner)))
            ;; Duplicate is in invalid hash
            (should (string-match "duplicate"
                                  (gethash "dup" invalid)))))
      (delete-directory dir t))))

(ert-deftest supervisor-test-resolve-authority-disjoint-ids ()
  "Units with different IDs across tiers all appear as winners."
  (let* ((dir1 (make-temp-file "tier1-" t))
         (dir2 (make-temp-file "tier2-" t))
         (supervisor-unit-authority-path (list dir1 dir2)))
    (unwind-protect
        (progn
          (with-temp-file (expand-file-name "a.el" dir1)
            (insert "(:id \"a\" :command \"echo a\")"))
          (with-temp-file (expand-file-name "b.el" dir2)
            (insert "(:id \"b\" :command \"echo b\")"))
          (let* ((result (supervisor--resolve-authority))
                 (winners (plist-get result :winners)))
            (should (gethash "a" winners))
            (should (gethash "b" winners))
            (should (= 2 (hash-table-count winners)))))
      (delete-directory dir1 t)
      (delete-directory dir2 t))))

(ert-deftest supervisor-test-resolve-authority-empty-roots ()
  "Resolver with no active roots returns empty results."
  (let ((supervisor-unit-authority-path nil))
    (let* ((result (supervisor--resolve-authority))
           (winners (plist-get result :winners)))
      (should (= 0 (hash-table-count winners))))))

(ert-deftest supervisor-test-resolve-authority-three-tiers ()
  "Three-tier resolution: highest tier always wins."
  (let* ((dir1 (make-temp-file "tier1-" t))
         (dir2 (make-temp-file "tier2-" t))
         (dir3 (make-temp-file "tier3-" t))
         (supervisor-unit-authority-path (list dir1 dir2 dir3)))
    (unwind-protect
        (progn
          (with-temp-file (expand-file-name "svc.el" dir1)
            (insert "(:id \"svc\" :command \"echo t1\")"))
          (with-temp-file (expand-file-name "svc.el" dir2)
            (insert "(:id \"svc\" :command \"echo t2\")"))
          (with-temp-file (expand-file-name "svc.el" dir3)
            (insert "(:id \"svc\" :command \"echo t3\")"))
          (let* ((result (supervisor--resolve-authority))
                 (winners (plist-get result :winners))
                 (shadowed (plist-get result :shadowed))
                 (winner (gethash "svc" winners)))
            ;; Tier 3 (index 2) wins
            (should (= 2 (supervisor--authority-candidate-tier winner)))
            ;; Two shadowed entries
            (should (= 2 (length (gethash "svc" shadowed))))))
      (delete-directory dir1 t)
      (delete-directory dir2 t)
      (delete-directory dir3 t))))

(ert-deftest supervisor-test-resolve-authority-invalid-clears-lower-invalid ()
  "Higher tier overriding clears lower-tier invalid entry for same ID."
  (let* ((dir1 (make-temp-file "tier1-" t))
         (dir2 (make-temp-file "tier2-" t))
         (supervisor-unit-authority-path (list dir1 dir2)))
    (unwind-protect
        (progn
          ;; Invalid in lower tier - same-tier dup produces invalid entry
          (with-temp-file (expand-file-name "a-svc.el" dir1)
            (insert "(:id \"svc\" :command \"echo first\")"))
          (with-temp-file (expand-file-name "z-svc.el" dir1)
            (insert "(:id \"svc\" :command \"echo dup\")"))
          ;; Valid in higher tier overrides everything
          (with-temp-file (expand-file-name "svc.el" dir2)
            (insert "(:id \"svc\" :command \"echo winner\")"))
          (let* ((result (supervisor--resolve-authority))
                 (winners (plist-get result :winners))
                 (invalid (plist-get result :invalid))
                 (winner (gethash "svc" winners)))
            ;; Higher tier wins and is valid
            (should (= 1 (supervisor--authority-candidate-tier winner)))
            (should (supervisor--authority-candidate-valid-p winner))
            ;; No invalid entry for this ID (cleared by higher tier)
            (should-not (gethash "svc" invalid))))
      (delete-directory dir1 t)
      (delete-directory dir2 t))))

(ert-deftest supervisor-test-unit-file-keywords-include-command ()
  "Unit-file valid keywords include :command."
  (should (memq :command supervisor--unit-file-keywords))
  (should (memq :id supervisor--unit-file-keywords))
  (should (memq :type supervisor--unit-file-keywords)))

(ert-deftest supervisor-test-load-unit-file-valid ()
  "Loading a valid unit file returns (LINE . PLIST)."
  (let ((path (make-temp-file "unit-test-" nil ".el")))
    (unwind-protect
        (progn
          (with-temp-file path
            (insert "(:id \"test\" :command \"echo hello\" :type simple)"))
          (let* ((result (supervisor--load-unit-file path))
                 (line (car result))
                 (plist (cdr result)))
            (should (integerp line))
            (should (equal "test" (plist-get plist :id)))
            (should (equal "echo hello" (plist-get plist :command)))
            (should (eq 'simple (plist-get plist :type)))))
      (delete-file path))))

(ert-deftest supervisor-test-load-unit-file-line-number ()
  "Line number reflects plist position after leading whitespace."
  (let ((path (make-temp-file "unit-test-" nil ".el")))
    (unwind-protect
        (progn
          (with-temp-file path
            (insert "\n\n(:id \"test\" :command \"echo\")"))
          (let* ((result (supervisor--load-unit-file path))
                 (line (car result)))
            (should (= 3 line))))
      (delete-file path))))

(ert-deftest supervisor-test-load-unit-file-missing ()
  "Loading a missing unit file signals error with path:line context."
  (let ((err (should-error
              (supervisor--load-unit-file "/tmp/nonexistent-unit-file.el")
              :type 'error)))
    (should (string-match "/tmp/nonexistent-unit-file\\.el:1:"
                          (error-message-string err)))))

(ert-deftest supervisor-test-load-unit-file-empty ()
  "Loading an empty unit file signals error with path:line context."
  (let ((path (make-temp-file "unit-test-" nil ".el")))
    (unwind-protect
        (let ((err (should-error (supervisor--load-unit-file path)
                                 :type 'error)))
          (should (string-match (regexp-quote (concat path ":1:"))
                                (error-message-string err))))
      (delete-file path))))

(ert-deftest supervisor-test-load-unit-file-not-plist ()
  "Loading a non-plist unit file signals error with path:line context."
  (let ((path (make-temp-file "unit-test-" nil ".el")))
    (unwind-protect
        (progn
          (with-temp-file path
            (insert "(defun foo () nil)"))
          (let ((err (should-error (supervisor--load-unit-file path)
                                   :type 'error)))
            (should (string-match (regexp-quote path)
                                  (error-message-string err)))
            (should (string-match ":[0-9]+:" (error-message-string err)))))
      (delete-file path))))

(ert-deftest supervisor-test-load-unit-file-trailing-content ()
  "Loading a unit file with trailing content signals error with path:line."
  (let ((path (make-temp-file "unit-test-" nil ".el")))
    (unwind-protect
        (progn
          (with-temp-file path
            (insert "(:id \"test\" :command \"echo\")\n(extra stuff)"))
          (let ((err (should-error (supervisor--load-unit-file path)
                                   :type 'error)))
            (should (string-match (regexp-quote path)
                                  (error-message-string err)))
            (should (string-match ":[0-9]+:" (error-message-string err)))))
      (delete-file path))))

(ert-deftest supervisor-test-validate-unit-file-missing-id ()
  "Unit file plist without :id is invalid with path:line context."
  (let ((reason (supervisor--validate-unit-file-plist
                 '(:command "echo") "/tmp/test.el" 1)))
    (should (stringp reason))
    (should (string-match "missing :id" reason))
    (should (string-match "/tmp/test\\.el:1:" reason))))

(ert-deftest supervisor-test-validate-unit-file-missing-command ()
  "Unit file plist without :command is invalid with path:line context."
  (let ((reason (supervisor--validate-unit-file-plist
                 '(:id "test") "/tmp/test.el" 3)))
    (should (stringp reason))
    (should (string-match "missing :command" reason))
    (should (string-match "/tmp/test\\.el:3:" reason))))

(ert-deftest supervisor-test-validate-unit-file-unknown-keyword ()
  "Unit file plist with unknown keyword is invalid with path:line context."
  (let ((reason (supervisor--validate-unit-file-plist
                 '(:id "test" :command "echo" :bogus 42) "/tmp/test.el" 1)))
    (should (stringp reason))
    (should (string-match "unknown keyword" reason))
    (should (string-match "/tmp/test\\.el:1:" reason))))

(ert-deftest supervisor-test-validate-unit-file-valid ()
  "Valid unit file plist returns nil."
  (should-not (supervisor--validate-unit-file-plist
               '(:id "test" :command "echo" :type simple)
               "/tmp/test.el" 1)))

(ert-deftest supervisor-test-unit-file-to-program-entry ()
  "Unit file plist converts to program entry format."
  (let ((entry (supervisor--unit-file-to-program-entry
                '(:id "nm" :command "nm-applet" :type simple :restart t))))
    ;; Car is the command string
    (should (equal "nm-applet" (car entry)))
    ;; Rest is a plist with :id but no :command
    (should (equal "nm" (plist-get (cdr entry) :id)))
    (should (eq 'simple (plist-get (cdr entry) :type)))
    (should (eq t (plist-get (cdr entry) :restart)))
    ;; :command should not be in the output plist
    (should-not (plist-member (cdr entry) :command))))

(ert-deftest supervisor-test-load-all-unit-files-missing-dir ()
  "Loading from nonexistent directory returns nil."
  (let ((supervisor-unit-authority-path
         '("/tmp/nonexistent-supervisor-units-dir"))
        (supervisor-unit-directory "/tmp/nonexistent-supervisor-units-dir"))
    (should-not (supervisor--load-all-unit-files))))

(ert-deftest supervisor-test-load-all-unit-files-alphabetical ()
  "Unit files are loaded in alphabetical order as plists."
  (let ((dir (make-temp-file "units-" t)))
    (unwind-protect
        (let ((supervisor-unit-authority-path (list dir))
              (supervisor-unit-directory dir))
          (with-temp-file (expand-file-name "bravo.el" dir)
            (insert "(:id \"bravo\" :command \"bravo-cmd\")"))
          (with-temp-file (expand-file-name "alpha.el" dir)
            (insert "(:id \"alpha\" :command \"alpha-cmd\")"))
          (let ((results (supervisor--load-all-unit-files)))
            (should (= 2 (length results)))
            ;; Alpha first (alphabetical); results are plists directly
            (should (equal "alpha" (plist-get (nth 0 results) :id)))
            (should (equal "bravo" (plist-get (nth 1 results) :id)))))
      (delete-directory dir t))))

(ert-deftest supervisor-test-load-all-unit-files-invalid-tracked ()
  "Invalid unit files are recorded in supervisor--unit-file-invalid."
  (let ((dir (make-temp-file "units-" t)))
    (unwind-protect
        (let ((supervisor-unit-authority-path (list dir))
              (supervisor-unit-directory dir))
          ;; Valid file
          (with-temp-file (expand-file-name "good.el" dir)
            (insert "(:id \"good\" :command \"echo ok\")"))
          ;; Invalid file (missing :command)
          (with-temp-file (expand-file-name "bad.el" dir)
            (insert "(:id \"bad\")"))
          (let ((results (supervisor--load-all-unit-files)))
            ;; Only valid entries returned
            (should (= 1 (length results)))
            (should (equal "good" (plist-get (nth 0 results) :id)))
            ;; Invalid tracked in hash with path:line context
            (should (= 1 (hash-table-count supervisor--unit-file-invalid)))
            (let ((reason (gethash "bad" supervisor--unit-file-invalid)))
              (should (stringp reason))
              (should (string-match "missing :command" reason))
              (should (string-match ":[0-9]+:" reason)))))
      (delete-directory dir t))))

(ert-deftest supervisor-test-load-all-unit-files-load-error-tracked ()
  "Unit files that fail to parse are recorded in invalid hash with path:line."
  (let ((dir (make-temp-file "units-" t)))
    (unwind-protect
        (let ((supervisor-unit-authority-path (list dir))
              (supervisor-unit-directory dir))
          (with-temp-file (expand-file-name "broken.el" dir)
            (insert "not a plist at all"))
          (let ((results (supervisor--load-all-unit-files)))
            (should (= 0 (length results)))
            (should (= 1 (hash-table-count supervisor--unit-file-invalid)))
            (let ((reason (gethash "broken" supervisor--unit-file-invalid)))
              (should (stringp reason))
              (should (string-match ":[0-9]+:" reason)))))
      (delete-directory dir t))))

(ert-deftest supervisor-test-unit-file-invalid-merged-into-plan ()
  "Invalid unit files appear in supervisor--invalid after plan build."
  (let* ((dir (make-temp-file "units-" t))
         (supervisor-unit-authority-path (list dir))
         (supervisor-unit-directory dir)
         (supervisor--programs-cache :not-yet-loaded)
         (supervisor--invalid (make-hash-table :test 'equal))
         (supervisor--cycle-fallback-ids (make-hash-table :test 'equal))
         (supervisor--computed-deps (make-hash-table :test 'equal)))
    (unwind-protect
        (progn
          (with-temp-file (expand-file-name "bad.el" dir)
            (insert "(:id \"bad-unit\")"))
          (let ((plan (supervisor--build-plan (supervisor--effective-programs))))
            (maphash (lambda (k v) (puthash k v supervisor--invalid))
                     (supervisor-plan-invalid plan))
            (supervisor--merge-unit-file-invalid)
            ;; The invalid unit file should now be visible
            (should (gethash "bad-unit" supervisor--invalid))))
      (delete-directory dir t))))

(ert-deftest supervisor-test-load-programs-empty-directory ()
  "With no unit files present, returns empty list."
  (supervisor-test-without-builtins
    (let* ((dir (make-temp-file "units-" t))
           (supervisor-unit-authority-path (list dir))
           (supervisor-unit-directory dir)
           (supervisor--programs-cache :not-yet-loaded))
      (unwind-protect
          (should (null (supervisor--effective-programs)))
        (delete-directory dir t)))))

(ert-deftest supervisor-test-load-programs-unit-file-merge ()
  "Unit file entries are loaded from disk via effective-programs."
  (supervisor-test-without-builtins
    (let* ((dir (make-temp-file "units-" t))
           (supervisor-unit-authority-path (list dir))
           (supervisor-unit-directory dir)
           (supervisor--programs-cache :not-yet-loaded))
      (unwind-protect
          (progn
            (with-temp-file (expand-file-name "svc.el" dir)
              (insert "(:id \"svc\" :command \"new-cmd\" :type simple)"))
            (let ((programs (supervisor--effective-programs)))
              ;; Should have exactly one entry (unit-file wins)
              (should (= 1 (length programs)))
              ;; The command should be the unit-file version
              (should (equal "new-cmd" (car (nth 0 programs))))))
        (delete-directory dir t)))))

(ert-deftest supervisor-test-load-programs-unit-file-adds-new ()
  "Multiple unit files are loaded and returned."
  (supervisor-test-without-builtins
    (let* ((dir (make-temp-file "units-" t))
           (supervisor-unit-authority-path (list dir))
           (supervisor-unit-directory dir)
           (supervisor--programs-cache :not-yet-loaded))
      (unwind-protect
          (progn
            (with-temp-file (expand-file-name "alpha.el" dir)
              (insert "(:id \"alpha\" :command \"alpha-cmd\" :type simple)"))
            (with-temp-file (expand-file-name "beta.el" dir)
              (insert "(:id \"beta\" :command \"beta-cmd\" :type simple)"))
            (let ((programs (supervisor--effective-programs)))
              ;; Should have both entries (alphabetical order)
              (should (= 2 (length programs)))
              (should (equal "alpha-cmd" (car (nth 0 programs))))
              (should (equal "beta-cmd" (car (nth 1 programs))))))
        (delete-directory dir t)))))

(ert-deftest supervisor-test-loader-cross-tier-precedence ()
  "Loader returns higher-tier unit when same ID exists in multiple roots."
  (supervisor-test-without-builtins
    (let* ((dir1 (make-temp-file "tier1-" t))
           (dir2 (make-temp-file "tier2-" t))
           (supervisor-unit-authority-path (list dir1 dir2))
           (supervisor-unit-directory dir2)
           (supervisor--programs-cache :not-yet-loaded))
      (unwind-protect
          (progn
            (with-temp-file (expand-file-name "svc.el" dir1)
              (insert "(:id \"svc\" :command \"low-cmd\" :type simple)"))
            (with-temp-file (expand-file-name "svc.el" dir2)
              (insert "(:id \"svc\" :command \"high-cmd\" :type simple)"))
            ;; effective-programs should return the higher-tier version
            (let ((programs (supervisor--effective-programs)))
              (should (= 1 (length programs)))
              (should (equal "high-cmd" (car (nth 0 programs))))))
        (delete-directory dir1 t)
        (delete-directory dir2 t)))))

(ert-deftest supervisor-test-loader-invalid-blocks-lower-tier ()
  "Loader blocks lower-tier valid unit when higher tier is invalid."
  (supervisor-test-without-builtins
    (let* ((dir1 (make-temp-file "tier1-" t))
           (dir2 (make-temp-file "tier2-" t))
           (supervisor-unit-authority-path (list dir1 dir2))
           (supervisor-unit-directory dir2)
           (supervisor--programs-cache :not-yet-loaded))
      (unwind-protect
          (progn
            ;; Valid in lower tier
            (with-temp-file (expand-file-name "svc.el" dir1)
              (insert "(:id \"svc\" :command \"good-cmd\")"))
            ;; Invalid in higher tier (missing :command)
            (with-temp-file (expand-file-name "svc.el" dir2)
              (insert "(:id \"svc\")"))
            (let ((programs (supervisor--effective-programs)))
              ;; No valid programs - higher tier blocks
              (should (= 0 (length programs)))
              ;; Invalid hash should record it
              (should (gethash "svc" supervisor--unit-file-invalid))))
        (delete-directory dir1 t)
        (delete-directory dir2 t)))))

(ert-deftest supervisor-test-loader-snapshot-consistency ()
  "Authority snapshot is consistent with loader output."
  (supervisor-test-without-builtins
    (let* ((dir (make-temp-file "tier-" t))
           (supervisor-unit-authority-path (list dir))
           (supervisor-unit-directory dir)
           (supervisor--programs-cache :not-yet-loaded))
      (unwind-protect
          (progn
            (with-temp-file (expand-file-name "a.el" dir)
              (insert "(:id \"a\" :command \"echo a\")"))
            (with-temp-file (expand-file-name "b.el" dir)
              (insert "(:id \"b\" :command \"echo b\")"))
            (let ((programs (supervisor--effective-programs)))
              (should (= 2 (length programs)))
              ;; Snapshot should exist and match
              (should supervisor--authority-snapshot)
            (let ((winners (plist-get supervisor--authority-snapshot :winners)))
              (should (= 2 (hash-table-count winners)))
              (should (gethash "a" winners))
              (should (gethash "b" winners)))))
        (delete-directory dir t)))))

(ert-deftest supervisor-test-dashboard-shows-invalid-authority-units ()
  "Dashboard entries include invalid units from authority resolution."
  (let* ((dir (make-temp-file "units-" t))
         (supervisor-unit-authority-path (list dir))
         (supervisor-unit-directory dir)
         (supervisor--programs-cache :not-yet-loaded)
         (supervisor--processes (make-hash-table :test 'equal))
         (supervisor--entry-state (make-hash-table :test 'equal))
         (supervisor--invalid (make-hash-table :test 'equal)))
    (unwind-protect
        (progn
          ;; Valid unit
          (with-temp-file (expand-file-name "good.el" dir)
            (insert "(:id \"good\" :command \"echo ok\")"))
          ;; Invalid unit (missing :command)
          (with-temp-file (expand-file-name "bad.el" dir)
            (insert "(:id \"bad\")"))
          (let* ((programs (supervisor--effective-programs))
                 (snapshot (supervisor--build-snapshot))
                 (entries (supervisor--get-entries snapshot programs)))
            ;; Should have entries for both good and bad (typed IDs)
            (should (cl-some (lambda (e) (equal (cons :service "good") (car e))) entries))
            (should (cl-some (lambda (e) (equal (cons :service "bad") (car e))) entries))))
      (delete-directory dir t))))

(ert-deftest supervisor-test-health-summary-counts-invalid-authority ()
  "Health summary counts invalid authority units."
  (let* ((dir (make-temp-file "units-" t))
         (supervisor-unit-authority-path (list dir))
         (supervisor-unit-directory dir)
         (supervisor--programs-cache :not-yet-loaded)
         (supervisor--processes (make-hash-table :test 'equal))
         (supervisor--entry-state (make-hash-table :test 'equal))
         (supervisor--failed (make-hash-table :test 'equal))
         (supervisor--oneshot-completed (make-hash-table :test 'equal))
         (supervisor--invalid (make-hash-table :test 'equal)))
    (unwind-protect
        (progn
          (with-temp-file (expand-file-name "bad.el" dir)
            (insert "(:id \"bad\")"))
          (let* ((programs (supervisor--effective-programs))
                 (snapshot (supervisor--build-snapshot))
                 (summary (supervisor--health-summary snapshot programs)))
            ;; Summary should show 1 invalid
            (should (string-match "1 inv" summary))))
      (delete-directory dir t))))

(ert-deftest supervisor-test-dashboard-single-snapshot-refresh ()
  "Dashboard refresh uses single authority snapshot (no re-publish)."
  (let* ((dir (make-temp-file "units-" t))
         (supervisor-unit-authority-path (list dir))
         (supervisor-unit-directory dir)
         (supervisor--programs-cache :not-yet-loaded)
         (publish-count 0))
    (unwind-protect
        (progn
          (with-temp-file (expand-file-name "svc.el" dir)
            (insert "(:id \"svc\" :command \"echo\")"))
          ;; Count publish calls during effective-programs
          (cl-letf (((symbol-function 'supervisor--resolve-authority)
                     (let ((orig (symbol-function
                                  'supervisor--resolve-authority)))
                       (lambda ()
                         (cl-incf publish-count)
                         (funcall orig)))))
            (let ((programs (supervisor--effective-programs)))
              ;; One publish for loading programs
              (should (= 1 publish-count))
              ;; Passing programs to get-entries and health-summary
              ;; should NOT trigger additional publishes
              (let ((snapshot (supervisor--build-snapshot)))
                (supervisor--get-entries snapshot programs)
                (supervisor--health-summary snapshot programs)
                (should (= 1 publish-count))))))
      (delete-directory dir t))))

(ert-deftest supervisor-test-programs-cache-isolates-disk-changes ()
  "Programs cache prevents disk changes from leaking without daemon-reload."
  (supervisor-test-without-builtins
    (let* ((dir (make-temp-file "cache-" t))
           (supervisor-unit-authority-path (list dir))
           (supervisor-unit-directory dir)
           (supervisor--programs-cache :not-yet-loaded)
           (supervisor--authority-snapshot nil)
           (supervisor--unit-file-invalid (make-hash-table :test 'equal)))
      (unwind-protect
          (progn
            ;; Create one unit and load
            (with-temp-file (expand-file-name "a.el" dir)
              (insert "(:id \"a\" :command \"echo a\")"))
            (let ((programs (supervisor--effective-programs)))
              (should (= 1 (length programs))))
            ;; Add a second unit on disk WITHOUT refreshing
            (with-temp-file (expand-file-name "b.el" dir)
              (insert "(:id \"b\" :command \"echo b\")"))
            ;; Cache should still return only 1 program
            (let ((programs (supervisor--effective-programs)))
              (should (= 1 (length programs))))
            ;; Explicit refresh (simulates daemon-reload) picks up the new unit
            (supervisor--refresh-programs)
            (let ((programs (supervisor--effective-programs)))
              (should (= 2 (length programs)))))
        (delete-directory dir t)))))

(ert-deftest supervisor-test-start-path-publishes-authority-snapshot ()
  "The `supervisor-start' path refreshes the programs cache from disk."
  (supervisor-test-without-builtins
    (let* ((dir (make-temp-file "start-" t))
           (supervisor-unit-authority-path (list dir))
           (supervisor-unit-directory dir)
           (supervisor--programs-cache :not-yet-loaded)
           (supervisor--authority-snapshot nil)
           (supervisor--unit-file-invalid (make-hash-table :test 'equal))
           (publish-count 0))
      (unwind-protect
          (progn
            (with-temp-file (expand-file-name "svc.el" dir)
              (insert "(:id \"svc\" :command \"echo ok\")"))
            ;; Count authority resolutions during refresh-programs
            (cl-letf (((symbol-function 'supervisor--resolve-authority)
                       (let ((orig (symbol-function
                                    'supervisor--resolve-authority)))
                         (lambda ()
                           (cl-incf publish-count)
                           (funcall orig)))))
              ;; Simulate what supervisor-start does: refresh then read
              (supervisor--refresh-programs)
              (should (= 1 publish-count))
              ;; Subsequent reads use cache (no extra publish)
              (let ((programs (supervisor--effective-programs)))
                (should (= 1 (length programs)))
                (should (= 1 publish-count)))))
        (delete-directory dir t)))))

(ert-deftest supervisor-test-three-tier-loader-precedence ()
  "Loader returns highest-tier unit across a three-tier authority path."
  (supervisor-test-with-authority-tiers 3
    (with-temp-file (expand-file-name "svc.el" dir1)
      (insert "(:id \"svc\" :command \"vendor-cmd\")"))
    (with-temp-file (expand-file-name "svc.el" dir2)
      (insert "(:id \"svc\" :command \"admin-cmd\")"))
    (with-temp-file (expand-file-name "svc.el" dir3)
      (insert "(:id \"svc\" :command \"user-cmd\")"))
    (let ((programs (supervisor--effective-programs)))
      (should (= 1 (length programs)))
      (should (equal "user-cmd" (car (nth 0 programs)))))))

(ert-deftest supervisor-test-authority-tiers-macro-cleanup ()
  "Authority tiers macro creates and cleans up temp directories."
  (let (saved-dirs)
    (supervisor-test-with-authority-tiers 2
      (setq saved-dirs (list dir1 dir2))
      (should (file-directory-p dir1))
      (should (file-directory-p dir2))
      (should (= 2 (length supervisor-unit-authority-path))))
    ;; Directories should be cleaned up after the macro
    (should-not (file-directory-p (nth 0 saved-dirs)))
    (should-not (file-directory-p (nth 1 saved-dirs)))))

(ert-deftest supervisor-test-mixed-tier-disjoint-and-override ()
  "Disjoint IDs coexist while shared IDs follow tier precedence."
  (supervisor-test-with-authority-tiers 2
    ;; dir1 (low): a and shared
    (with-temp-file (expand-file-name "a.el" dir1)
      (insert "(:id \"a\" :command \"low-a\")"))
    (with-temp-file (expand-file-name "shared.el" dir1)
      (insert "(:id \"shared\" :command \"low-shared\")"))
    ;; dir2 (high): b and shared
    (with-temp-file (expand-file-name "b.el" dir2)
      (insert "(:id \"b\" :command \"high-b\")"))
    (with-temp-file (expand-file-name "shared.el" dir2)
      (insert "(:id \"shared\" :command \"high-shared\")"))
    (let ((programs (supervisor--effective-programs)))
      ;; 3 programs: a (low), b (high), shared (high wins)
      (should (= 3 (length programs)))
      (let ((cmds (mapcar #'car programs)))
        (should (member "low-a" cmds))
        (should (member "high-b" cmds))
        (should (member "high-shared" cmds))
        (should-not (member "low-shared" cmds))))))

(ert-deftest supervisor-test-reordered-root-list-flips-winner ()
  "User-configured root order determines precedence, not directory names.
Reversing the authority path order flips which root wins for a
conflicting ID, proving precedence derives from list position."
  (supervisor-test-without-builtins
    (let* ((dir-a (make-temp-file "rootA-" t))
           (dir-b (make-temp-file "rootB-" t))
           (supervisor--programs-cache :not-yet-loaded)
           (supervisor--authority-snapshot nil)
           (supervisor--unit-file-invalid (make-hash-table :test 'equal)))
      (unwind-protect
          (progn
            ;; Same ID in both roots, different commands
            (with-temp-file (expand-file-name "svc.el" dir-a)
              (insert "(:id \"svc\" :command \"from-a\")"))
            (with-temp-file (expand-file-name "svc.el" dir-b)
              (insert "(:id \"svc\" :command \"from-b\")"))
            ;; Order A, B: B is last = highest precedence
            (let ((supervisor-unit-authority-path (list dir-a dir-b)))
              (supervisor--publish-authority-snapshot)
              (setq supervisor--programs-cache :not-yet-loaded)
              (let ((programs (supervisor--effective-programs)))
                (should (= 1 (length programs)))
                (should (equal "from-b" (caar programs)))))
            ;; Reverse to B, A: A is last = highest precedence
            (let ((supervisor-unit-authority-path (list dir-b dir-a)))
              (setq supervisor--authority-snapshot nil)
              (setq supervisor--programs-cache :not-yet-loaded)
              (let ((programs (supervisor--effective-programs)))
                (should (= 1 (length programs)))
                (should (equal "from-a" (caar programs))))))
        (delete-directory dir-a t)
        (delete-directory dir-b t)))))

(ert-deftest supervisor-test-cli-verify-invalid-unit-file ()
  "CLI verify reports invalid unit files in count and output."
  (let* ((dir (make-temp-file "units-" t))
         (supervisor-unit-authority-path (list dir))
         (supervisor-unit-directory dir)
         (supervisor--programs-cache :not-yet-loaded))
    (unwind-protect
        (progn
          (with-temp-file (expand-file-name "bad.el" dir)
            (insert "(:id \"bad-unit\")"))
          (let ((result (supervisor--cli-dispatch '("verify"))))
            (should (supervisor-cli-result-p result))
            (should (= supervisor-cli-exit-validation-failed
                        (supervisor-cli-result-exitcode result)))
            (should (string-match "1 invalid"
                                  (supervisor-cli-result-output result)))
            (should (string-match "bad-unit"
                                  (supervisor-cli-result-output result)))))
      (delete-directory dir t))))

(ert-deftest supervisor-test-cli-list-units-shows-invalid-unit-file ()
  "CLI list-units includes invalid unit files in output."
  (let* ((dir (make-temp-file "units-" t))
         (supervisor-unit-authority-path (list dir))
         (supervisor-unit-directory dir)
         (supervisor--programs-cache :not-yet-loaded)
         (supervisor--processes (make-hash-table :test 'equal))
         (supervisor--entry-state (make-hash-table :test 'equal)))
    (unwind-protect
        (progn
          (with-temp-file (expand-file-name "bad.el" dir)
            (insert "(:id \"bad-unit\")"))
          (let ((result (supervisor--cli-dispatch '("list-units"))))
            (should (supervisor-cli-result-p result))
            (should (string-match "bad-unit"
                                  (supervisor-cli-result-output result)))))
      (delete-directory dir t))))

(ert-deftest supervisor-test-cli-status-invalid-unit-file ()
  "CLI status ID recognizes invalid unit files, not just plan-level invalids."
  (let* ((dir (make-temp-file "units-" t))
         (supervisor-unit-authority-path (list dir))
         (supervisor-unit-directory dir)
         (supervisor--programs-cache :not-yet-loaded)
         (supervisor--processes (make-hash-table :test 'equal))
         (supervisor--entry-state (make-hash-table :test 'equal)))
    (unwind-protect
        (progn
          (with-temp-file (expand-file-name "bad.el" dir)
            (insert "(:id \"bad-unit\")"))
          (let ((result (supervisor--cli-dispatch '("status" "bad-unit"))))
            (should (supervisor-cli-result-p result))
            ;; Should find it as invalid, not "not found"
            (should (= supervisor-cli-exit-success
                        (supervisor-cli-result-exitcode result)))
            (should (string-match "invalid"
                                  (supervisor-cli-result-output result)))
            (should-not (string-match "could not be found"
                                      (supervisor-cli-result-output result)))))
      (delete-directory dir t))))

(ert-deftest supervisor-test-dry-run-shows-invalid-unit-files ()
  "Dry-run summary includes invalid unit files in count and listing."
  (let* ((dir (make-temp-file "units-" t))
         (supervisor-unit-authority-path (list dir))
         (supervisor-unit-directory dir)
         (supervisor--programs-cache :not-yet-loaded)
         (supervisor--invalid (make-hash-table :test 'equal))
         (supervisor--cycle-fallback-ids (make-hash-table :test 'equal))
         (supervisor--computed-deps (make-hash-table :test 'equal)))
    (unwind-protect
        (progn
          (with-temp-file (expand-file-name "bad.el" dir)
            (insert "(:id \"bad-unit\")"))
          (supervisor-dry-run)
          (with-current-buffer "*supervisor-dry-run*"
            (let ((content (buffer-string)))
              (should (string-match "1 invalid" content))
              (should (string-match "bad-unit" content)))))
      (delete-directory dir t))))

;;; Unit-File Scaffold and Edit/Cat Tests

(ert-deftest supervisor-test-unit-file-scaffold-contains-id ()
  "Scaffold template contains the given ID."
  (let ((scaffold (supervisor--unit-file-scaffold "my-svc")))
    (should (stringp scaffold))
    (should (string-match ":id \"my-svc\"" scaffold))
    (should (string-match ":command" scaffold))))

(ert-deftest supervisor-test-unit-file-scaffold-is-valid-plist ()
  "Scaffold template can be read as a valid plist (with command filled)."
  (let* ((scaffold (supervisor--unit-file-scaffold "test-svc"))
         ;; Replace empty command placeholder with actual value
         (filled (replace-regexp-in-string
                  ":command \"\"" ":command \"echo hello\"" scaffold)))
    (with-temp-buffer
      (insert filled)
      (goto-char (point-min))
      (let ((form (read (current-buffer))))
        (should (listp form))
        (should (keywordp (car form)))
        (should (equal "test-svc" (plist-get form :id)))
        (should (equal "echo hello" (plist-get form :command)))))))

(ert-deftest supervisor-test-seed-default-maintenance-units-creates-files ()
  "Default maintenance seeding creates logrotate and log-prune units."
  (let* ((dir (make-temp-file "units-" t))
         (supervisor-unit-authority-path (list dir))
         (supervisor-logrotate-command "/usr/bin/rotate-stub")
         (supervisor-log-prune-command "/usr/bin/prune-stub")
         (supervisor-log-directory "/tmp/sv-test-logs")
         (supervisor-logrotate-keep-days 9)
         (supervisor-log-prune-max-total-bytes 12345))
    (unwind-protect
        (progn
          (supervisor--ensure-default-maintenance-units)
          (let ((rotate-file (expand-file-name "logrotate.el" dir))
                (prune-file (expand-file-name "log-prune.el" dir)))
            (should (file-exists-p rotate-file))
            (should (file-exists-p prune-file))
            (with-temp-buffer
              (insert-file-contents rotate-file)
              (should (string-match-p ":id \"logrotate\"" (buffer-string)))
              (should (string-match-p "rotate-stub" (buffer-string)))
              (should (string-match-p "--signal-reopen" (buffer-string))))
            (with-temp-buffer
              (insert-file-contents prune-file)
              (should (string-match-p ":id \"log-prune\"" (buffer-string)))
              (should (string-match-p "prune-stub" (buffer-string)))
              (should (string-match-p ":requires (\"logrotate\")" (buffer-string))))))
      (delete-directory dir t))))

(ert-deftest supervisor-test-seed-default-maintenance-units-does-not-overwrite-existing ()
  "Maintenance seeding preserves existing units while seeding missing ones."
  (let* ((dir (make-temp-file "units-" t))
         (supervisor-unit-authority-path (list dir))
         (supervisor-logrotate-command "/usr/bin/rotate-stub")
         (supervisor-log-prune-command "/usr/bin/prune-stub")
         (supervisor-log-directory "/tmp/sv-test-logs")
         (supervisor-logrotate-keep-days 14)
         (supervisor-log-prune-max-total-bytes 999))
    (unwind-protect
        (let ((rotate-file (expand-file-name "logrotate.el" dir)))
          (write-region "(:id \"logrotate\" :command \"echo custom\")\n"
                        nil rotate-file nil 'silent)
          (supervisor--ensure-default-maintenance-units)
          (with-temp-buffer
            (insert-file-contents rotate-file)
            (should (string-match-p "echo custom" (buffer-string))))
          (should (file-exists-p (expand-file-name "log-prune.el" dir))))
      (delete-directory dir t))))

(ert-deftest supervisor-test-seed-skips-masked-units ()
  "Seeding does not create units that are masked via runtime override."
  (let* ((dir (make-temp-file "units-" t))
         (supervisor-unit-authority-path (list dir))
         (supervisor-logrotate-command "/usr/bin/rotate-stub")
         (supervisor-log-prune-command "/usr/bin/prune-stub")
         (supervisor-log-directory "/tmp/sv-test-logs")
         (supervisor-logrotate-keep-days 14)
         (supervisor-log-prune-max-total-bytes 999)
         (supervisor--mask-override (make-hash-table :test 'equal)))
    (puthash "logrotate" 'masked supervisor--mask-override)
    (unwind-protect
        (progn
          (supervisor--ensure-default-maintenance-units)
          ;; logrotate masked: should NOT be seeded
          (should-not (file-exists-p
                       (expand-file-name "logrotate.el" dir)))
          ;; log-prune not masked: should be seeded
          (should (file-exists-p
                   (expand-file-name "log-prune.el" dir))))
      (delete-directory dir t))))

(ert-deftest supervisor-test-seed-skips-disabled-units ()
  "Seeding does not create units that are disabled via runtime override."
  (let* ((dir (make-temp-file "units-" t))
         (supervisor-unit-authority-path (list dir))
         (supervisor-logrotate-command "/usr/bin/rotate-stub")
         (supervisor-log-prune-command "/usr/bin/prune-stub")
         (supervisor-log-directory "/tmp/sv-test-logs")
         (supervisor-logrotate-keep-days 14)
         (supervisor-log-prune-max-total-bytes 999)
         (supervisor--mask-override (make-hash-table :test 'equal))
         (supervisor--enabled-override (make-hash-table :test 'equal)))
    (puthash "log-prune" 'disabled supervisor--enabled-override)
    (unwind-protect
        (progn
          (supervisor--ensure-default-maintenance-units)
          ;; logrotate not disabled: should be seeded
          (should (file-exists-p
                   (expand-file-name "logrotate.el" dir)))
          ;; log-prune disabled: should NOT be seeded
          (should-not (file-exists-p
                       (expand-file-name "log-prune.el" dir))))
      (delete-directory dir t))))

(ert-deftest supervisor-test-cli-cat-existing-unit-file ()
  "CLI cat outputs raw content of existing unit file."
  (let* ((dir (make-temp-file "units-" t))
         (supervisor-unit-authority-path (list dir))
         (supervisor-unit-directory dir))
    (unwind-protect
        (progn
          (with-temp-file (expand-file-name "my-svc.el" dir)
            (insert "(:id \"my-svc\" :command \"echo ok\")"))
          (let ((result (supervisor--cli-dispatch '("cat" "my-svc"))))
            (should (supervisor-cli-result-p result))
            (should (= supervisor-cli-exit-success
                        (supervisor-cli-result-exitcode result)))
            (should (string-match ":id \"my-svc\""
                                  (supervisor-cli-result-output result)))))
      (delete-directory dir t))))

(ert-deftest supervisor-test-cli-cat-missing-unit-file ()
  "CLI cat returns error for missing unit file."
  (let ((supervisor-unit-authority-path '("/tmp/nonexistent-supervisor-units-dir"))
        (supervisor-unit-directory "/tmp/nonexistent-supervisor-units-dir"))
    (let ((result (supervisor--cli-dispatch '("cat" "nope"))))
      (should (supervisor-cli-result-p result))
      (should (= supervisor-cli-exit-failure
                  (supervisor-cli-result-exitcode result)))
      (should (string-match "not found"
                            (supervisor-cli-result-output result))))))

(ert-deftest supervisor-test-cli-cat-builtin-no-unit-file ()
  "CLI cat explains built-in entries without a backing unit file."
  (let* ((dir (make-temp-file "units-" t))
         (supervisor-unit-authority-path (list dir))
         (supervisor-unit-directory dir)
         (supervisor--authority-snapshot nil)
         (supervisor--programs-cache :not-yet-loaded)
         (supervisor--unit-file-invalid (make-hash-table :test 'equal))
         (supervisor-timer-subsystem-mode t))
    (unwind-protect
        (let ((result (supervisor--cli-dispatch '("cat" "logrotate"))))
          (should (supervisor-cli-result-p result))
          (should (= supervisor-cli-exit-failure
                     (supervisor-cli-result-exitcode result)))
          (should (string-match
                   "No unit file on disk for 'logrotate'"
                   (supervisor-cli-result-output result))))
      (delete-directory dir t))))

(ert-deftest supervisor-test-cli-cat-no-args ()
  "CLI cat requires an ID argument."
  (let ((result (supervisor--cli-dispatch '("cat"))))
    (should (supervisor-cli-result-p result))
    (should (= supervisor-cli-exit-invalid-args
                (supervisor-cli-result-exitcode result)))))

(ert-deftest supervisor-test-cli-cat-too-many-args ()
  "CLI cat takes exactly one ID."
  (let ((result (supervisor--cli-dispatch '("cat" "a" "b"))))
    (should (supervisor-cli-result-p result))
    (should (= supervisor-cli-exit-invalid-args
                (supervisor-cli-result-exitcode result)))))

(ert-deftest supervisor-test-cli-cat-json-format ()
  "CLI cat --json outputs path and content fields."
  (let* ((dir (make-temp-file "units-" t))
         (supervisor-unit-authority-path (list dir))
         (supervisor-unit-directory dir))
    (unwind-protect
        (progn
          (with-temp-file (expand-file-name "svc.el" dir)
            (insert "(:id \"svc\" :command \"echo\")"))
          (let ((result (supervisor--cli-dispatch '("cat" "svc" "--json"))))
            (should (supervisor-cli-result-p result))
            (should (= supervisor-cli-exit-success
                        (supervisor-cli-result-exitcode result)))
            (should (eq 'json (supervisor-cli-result-format result)))
            (let ((parsed (json-read-from-string
                           (supervisor-cli-result-output result))))
              (should (assoc 'path parsed))
              (should (assoc 'content parsed))
              (should (string-match ":id" (cdr (assoc 'content parsed)))))))
      (delete-directory dir t))))

(ert-deftest supervisor-test-cli-edit-creates-scaffold ()
  "CLI edit creates scaffold template for missing unit file."
  (let* ((dir (make-temp-file "units-" t))
         (supervisor-unit-authority-path (list dir))
         (supervisor-unit-directory dir))
    (unwind-protect
        ;; Use JSON mode to test scaffold creation without editor launch
        (let ((result (supervisor--cli-dispatch '("edit" "new-svc" "--json"))))
          (should (supervisor-cli-result-p result))
          (should (= supervisor-cli-exit-success
                      (supervisor-cli-result-exitcode result)))
          ;; File should have been created
          (let ((path (expand-file-name "new-svc.el" dir)))
            (should (file-exists-p path))
            ;; Content should have the ID
            (with-temp-buffer
              (insert-file-contents path)
              (should (string-match ":id \"new-svc\""
                                    (buffer-string))))))
      (delete-directory dir t))))

(ert-deftest supervisor-test-cli-edit-existing-file ()
  "CLI edit on existing file does not overwrite it."
  (let* ((dir (make-temp-file "units-" t))
         (supervisor-unit-authority-path (list dir))
         (supervisor-unit-directory dir))
    (unwind-protect
        (progn
          (with-temp-file (expand-file-name "svc.el" dir)
            (insert "(:id \"svc\" :command \"existing\")"))
          ;; Use JSON mode to test without editor launch
          (let ((result (supervisor--cli-dispatch '("edit" "svc" "--json"))))
            (should (supervisor-cli-result-p result))
            (should (= supervisor-cli-exit-success
                        (supervisor-cli-result-exitcode result)))
            ;; File content should be unchanged
            (with-temp-buffer
              (insert-file-contents (expand-file-name "svc.el" dir))
              (should (string-match "existing" (buffer-string))))))
      (delete-directory dir t))))

(ert-deftest supervisor-test-cli-edit-json-format ()
  "CLI edit --json outputs path and created flag."
  (let* ((dir (make-temp-file "units-" t))
         (supervisor-unit-authority-path (list dir))
         (supervisor-unit-directory dir))
    (unwind-protect
        (let ((result (supervisor--cli-dispatch '("edit" "new" "--json"))))
          (should (supervisor-cli-result-p result))
          (should (= supervisor-cli-exit-success
                      (supervisor-cli-result-exitcode result)))
          (should (eq 'json (supervisor-cli-result-format result)))
          (let ((parsed (json-read-from-string
                         (supervisor-cli-result-output result))))
            (should (assoc 'path parsed))
            (should (eq t (cdr (assoc 'created parsed))))
            ;; Root should be reported even for new units
            (should (stringp (cdr (assoc 'root parsed))))))
      (delete-directory dir t))))

(ert-deftest supervisor-test-cli-edit-json-includes-authority-root ()
  "CLI edit --json output includes authority root and tier."
  (let* ((dir (make-temp-file "units-" t))
         (supervisor-unit-authority-path (list dir))
         (supervisor-unit-directory dir)
         (supervisor--authority-snapshot nil)
         (supervisor--programs-cache :not-yet-loaded))
    (unwind-protect
        (progn
          (with-temp-file (expand-file-name "svc.el" dir)
            (insert "(:id \"svc\" :command \"echo\")"))
          ;; Publish snapshot so tier lookup works
          (supervisor--publish-authority-snapshot)
          (let* ((result (supervisor--cli-dispatch '("edit" "svc" "--json")))
                 (parsed (json-read-from-string
                          (supervisor-cli-result-output result))))
            (should (equal dir (cdr (assoc 'root parsed))))
            (should (equal 0 (cdr (assoc 'tier parsed))))
            (should (eq :json-false (cdr (assoc 'created parsed))))))
      (delete-directory dir t))))

(ert-deftest supervisor-test-cli-status-shows-unit-file-path ()
  "CLI status shows unit-file path in detailed output."
  (supervisor-test-with-unit-files
      '(("echo ok" :id "svc" :type simple))
    (let* ((supervisor--processes (make-hash-table :test 'equal))
           (supervisor--entry-state (make-hash-table :test 'equal))
           (result (supervisor--cli-dispatch '("status" "svc"))))
      (should (string-match "Unit file:" (supervisor-cli-result-output result))))))

(ert-deftest supervisor-test-cli-status-json-includes-unit-file ()
  "CLI status --json output includes unit_file field."
  (supervisor-test-with-unit-files
      '(("echo ok" :id "svc" :type simple))
    (let* ((supervisor--processes (make-hash-table :test 'equal))
           (supervisor--entry-state (make-hash-table :test 'equal))
           (result (supervisor--cli-dispatch '("status" "svc" "--json")))
           (parsed (json-read-from-string
                    (supervisor-cli-result-output result)))
           (entries (cdr (assoc 'entries parsed)))
           (first-entry (aref entries 0)))
      (should (assoc 'unit_file first-entry))
      (should (stringp (cdr (assoc 'unit_file first-entry)))))))

(ert-deftest supervisor-test-cli-status-builtin-omits-unit-file-line ()
  "CLI status omits unit-file line for built-ins without disk units."
  (let* ((dir (make-temp-file "units-" t))
         (logs (make-temp-file "logs-" t))
         (supervisor-unit-authority-path (list dir))
         (supervisor-unit-directory dir)
         (supervisor-log-directory logs)
         (supervisor--authority-snapshot nil)
         (supervisor--programs-cache :not-yet-loaded)
         (supervisor--unit-file-invalid (make-hash-table :test 'equal))
         (supervisor-timer-subsystem-mode t)
         (supervisor--processes (make-hash-table :test 'equal))
         (supervisor--entry-state (make-hash-table :test 'equal))
         (result (supervisor--cli-dispatch '("status" "logrotate"))))
    (unwind-protect
        (progn
          (should (= supervisor-cli-exit-success
                     (supervisor-cli-result-exitcode result)))
          (should-not (string-match "Unit file:"
                                    (supervisor-cli-result-output result))))
      (delete-directory logs t)
      (delete-directory dir t))))

(ert-deftest supervisor-test-cli-status-json-builtin-unit-file-null ()
  "CLI status --json sets unit_file to null for fileless built-ins."
  (let* ((dir (make-temp-file "units-" t))
         (logs (make-temp-file "logs-" t))
         (supervisor-unit-authority-path (list dir))
         (supervisor-unit-directory dir)
         (supervisor-log-directory logs)
         (supervisor--authority-snapshot nil)
         (supervisor--programs-cache :not-yet-loaded)
         (supervisor--unit-file-invalid (make-hash-table :test 'equal))
         (supervisor-timer-subsystem-mode t)
         (supervisor--processes (make-hash-table :test 'equal))
         (supervisor--entry-state (make-hash-table :test 'equal))
         (result (supervisor--cli-dispatch '("status" "logrotate" "--json"))))
    (unwind-protect
        (let* ((parsed (json-read-from-string
                        (supervisor-cli-result-output result)))
               (entries (cdr (assoc 'entries parsed)))
               (first-entry (and (> (length entries) 0)
                                 (aref entries 0))))
          (should (= supervisor-cli-exit-success
                     (supervisor-cli-result-exitcode result)))
          (should first-entry)
          (should (assoc 'unit_file first-entry))
          (should-not (cdr (assoc 'unit_file first-entry))))
      (delete-directory logs t)
      (delete-directory dir t))))

(ert-deftest supervisor-test-cli-edit-no-args ()
  "CLI edit requires an ID argument."
  (let ((result (supervisor--cli-dispatch '("edit"))))
    (should (supervisor-cli-result-p result))
    (should (= supervisor-cli-exit-invalid-args
                (supervisor-cli-result-exitcode result)))))

(ert-deftest supervisor-test-cli-edit-too-many-args ()
  "CLI edit takes exactly one ID."
  (let ((result (supervisor--cli-dispatch '("edit" "a" "b"))))
    (should (supervisor-cli-result-p result))
    (should (= supervisor-cli-exit-invalid-args
                (supervisor-cli-result-exitcode result)))))

(ert-deftest supervisor-test-dashboard-cat-keybinding ()
  "Dashboard keymap binds `t' to proced."
  (should (eq #'proced
              (lookup-key supervisor-dashboard-mode-map "t"))))

(ert-deftest supervisor-test-dashboard-edit-keybinding ()
  "Dashboard keymap binds `F' to tag filter."
  (should (eq #'supervisor-dashboard-cycle-tag-filter
              (lookup-key supervisor-dashboard-mode-map "F"))))

(ert-deftest supervisor-test-dashboard-cat-rejects-separator ()
  "Dashboard cat rejects separator rows."
  (with-temp-buffer
    (supervisor-dashboard-mode)
    (let ((tabulated-list-entries
           (list (list '--stage3-- (vector "" "" "" "" "" "" "" "" "")))))
      (tabulated-list-init-header)
      (tabulated-list-print)
      (goto-char (point-min))
      (should-error (supervisor-dashboard-cat)
                    :type 'user-error))))

(ert-deftest supervisor-test-dashboard-cat-rejects-timer ()
  "Dashboard cat rejects timer rows."
  (with-temp-buffer
    (supervisor-dashboard-mode)
    (let ((tabulated-list-entries
           (list (list "t1" (vector "t1" "timer" "---" "yes"
                                    "waiting" "---" "---" "-" "-")))))
      (tabulated-list-init-header)
      (tabulated-list-print)
      (goto-char (point-min))
      (should-error (supervisor-dashboard-cat)
                    :type 'user-error))))

(ert-deftest supervisor-test-dashboard-cat-builtin-no-unit-file ()
  "Dashboard cat explains fileless built-in entries."
  (let* ((dir (make-temp-file "units-" t))
         (supervisor-unit-authority-path (list dir))
         (supervisor-unit-directory dir)
         (supervisor--authority-snapshot nil)
         (supervisor--programs-cache :not-yet-loaded)
         (supervisor--unit-file-invalid (make-hash-table :test 'equal))
         (supervisor-timer-subsystem-mode t))
    (unwind-protect
        (with-temp-buffer
          (supervisor-dashboard-mode)
          (let ((tabulated-list-entries
                 (list (list (cons :service "logrotate")
                             (vector "logrotate" "oneshot" "stage4"
                                     "yes" "pending" "n/a" "yes" "-" "-")))))
            (tabulated-list-init-header)
            (tabulated-list-print)
            (goto-char (point-min))
            (let ((err (should-error (supervisor-dashboard-cat) :type 'user-error)))
              (should (string-match-p
                       "No unit file on disk for logrotate"
                       (error-message-string err))))))
      (delete-directory dir t))))

(ert-deftest supervisor-test-dashboard-edit-rejects-separator ()
  "Dashboard edit rejects separator rows."
  (with-temp-buffer
    (supervisor-dashboard-mode)
    (let ((tabulated-list-entries
           (list (list '--stage3-- (vector "" "" "" "" "" "" "" "" "")))))
      (tabulated-list-init-header)
      (tabulated-list-print)
      (goto-char (point-min))
      (should-error (supervisor-dashboard-edit)
                    :type 'user-error))))

(ert-deftest supervisor-test-cli-edit-launches-editor ()
  "CLI edit launches $VISUAL/$EDITOR via `call-process'."
  (let* ((dir (make-temp-file "units-" t))
         (supervisor-unit-authority-path (list dir))
         (supervisor-unit-directory dir)
         (launch-args nil))
    (unwind-protect
        (cl-letf (((symbol-function 'supervisor--cli-edit-launch-editor)
                   (lambda (editor path)
                     (setq launch-args (list editor path))
                     0)))
          (let* ((process-environment
                  (cons "VISUAL=my-editor" process-environment))
                 (result (supervisor--cli-dispatch '("edit" "new-svc"))))
            (should (supervisor-cli-result-p result))
            (should (= supervisor-cli-exit-success
                        (supervisor-cli-result-exitcode result)))
            ;; Editor should have been called
            (should launch-args)
            (should (equal "my-editor" (car launch-args)))))
      (delete-directory dir t))))

(ert-deftest supervisor-test-cli-edit-editor-failure ()
  "CLI edit reports failure when editor exits non-zero."
  (let* ((dir (make-temp-file "units-" t))
         (supervisor-unit-authority-path (list dir))
         (supervisor-unit-directory dir))
    (unwind-protect
        (cl-letf (((symbol-function 'supervisor--cli-edit-launch-editor)
                   (lambda (_editor _path) 1)))
          (let* ((process-environment
                  (cons "VISUAL=my-editor" process-environment))
                 (result (supervisor--cli-dispatch '("edit" "new-svc"))))
            (should (supervisor-cli-result-p result))
            (should (= supervisor-cli-exit-failure
                        (supervisor-cli-result-exitcode result)))
            (should (string-match "exited with status 1"
                                  (supervisor-cli-result-output result)))))
      (delete-directory dir t))))

(ert-deftest supervisor-test-cli-edit-no-editor-error ()
  "CLI edit returns error when no $VISUAL or $EDITOR is set."
  (let* ((dir (make-temp-file "units-" t))
         (supervisor-unit-authority-path (list dir))
         (supervisor-unit-directory dir))
    (unwind-protect
        (let* ((process-environment
                (cl-remove-if (lambda (e)
                                (or (string-prefix-p "VISUAL=" e)
                                    (string-prefix-p "EDITOR=" e)))
                              process-environment))
               (result (supervisor--cli-dispatch '("edit" "new-svc"))))
          (should (supervisor-cli-result-p result))
          (should (= supervisor-cli-exit-failure
                      (supervisor-cli-result-exitcode result)))
          (should (string-match "No \\$VISUAL or \\$EDITOR"
                                (supervisor-cli-result-output result))))
      (delete-directory dir t))))

(ert-deftest supervisor-test-dashboard-edit-enables-edit-mode ()
  "Dashboard edit activates `supervisor-edit-mode' with return-on-q."
  (let* ((dir (make-temp-file "units-" t))
         (supervisor-unit-authority-path (list dir))
         (supervisor-unit-directory dir)
         (path (expand-file-name "test-svc.el" dir)))
    (unwind-protect
        (progn
          (write-region "(:id \"test-svc\" :command \"echo\")" nil path)
          ;; Simulate dashboard with a valid entry
          (with-temp-buffer
            (supervisor-dashboard-mode)
            (let ((tabulated-list-entries
                   (list (list (cons :service "test-svc")
                               (vector "test-svc" "simple" "stage3"
                                       "yes" "running" "yes" "---"
                                       "-" "-")))))
              (tabulated-list-init-header)
              (tabulated-list-print)
              (goto-char (point-min))
              (supervisor-dashboard-edit)
              ;; Should have opened the file with edit mode
              (let ((edit-buf (get-file-buffer path)))
                (should edit-buf)
                (with-current-buffer edit-buf
                  (should supervisor-edit-mode)
                  ;; q should be bound
                  (should (eq #'supervisor-edit-quit
                              (lookup-key supervisor-edit-mode-map "q")))
                  ;; C-c C-q should be bound
                  (should (eq #'supervisor-edit-finish
                              (lookup-key supervisor-edit-mode-map
                                          (kbd "C-c C-q")))))
                (kill-buffer edit-buf)))))
      (delete-directory dir t))))

(ert-deftest supervisor-test-edit-quit-returns ()
  "Pressing `q' in edit buffer returns to dashboard."
  (let* ((dir (make-temp-file "units-" t))
         (path (expand-file-name "svc.el" dir))
         (returned nil))
    (unwind-protect
        (progn
          (write-region "(:id \"svc\" :command \"echo\")" nil path)
          (find-file path)
          (supervisor-edit-mode 1)
          (cl-letf (((symbol-function 'supervisor--return-to-dashboard)
                     (lambda () (setq returned t)))
                    ((symbol-function 'y-or-n-p) (lambda (_) nil)))
            ;; Buffer is unmodified, q should quit
            (should-not (buffer-modified-p))
            (supervisor-edit-quit)
            (should returned)))
      (ignore-errors (delete-directory dir t)))))

(ert-deftest supervisor-test-dashboard-edit-save-hook-fires ()
  "Dashboard edit save-hook wiring fires validator on save."
  (let* ((dir (make-temp-file "units-" t))
         (supervisor-unit-authority-path (list dir))
         (supervisor-unit-directory dir)
         (path (expand-file-name "hook-svc.el" dir))
         (validated nil))
    (unwind-protect
        (progn
          (write-region "(:id \"hook-svc\" :command \"echo\")" nil path)
          (with-temp-buffer
            (supervisor-dashboard-mode)
            (let ((tabulated-list-entries
                   (list (list (cons :service "hook-svc")
                               (vector "hook-svc" "simple" "stage3"
                                       "yes" "running" "yes" "---"
                                       "-" "-")))))
              (tabulated-list-init-header)
              (tabulated-list-print)
              (goto-char (point-min))
              (supervisor-dashboard-edit)
              (let ((edit-buf (get-file-buffer path)))
                (should edit-buf)
                (with-current-buffer edit-buf
                  ;; Validator should be in after-save-hook
                  (should (memq #'supervisor--validate-unit-file-buffer
                                after-save-hook))
                  ;; Mock validator to track invocation
                  (cl-letf (((symbol-function
                              'supervisor--validate-unit-file-buffer)
                             (lambda () (setq validated t))))
                    ;; Modify and save to trigger hook
                    (goto-char (point-max))
                    (insert " ")
                    (save-buffer)))
                (should validated)
                (kill-buffer edit-buf)))))
      (delete-directory dir t))))

(ert-deftest supervisor-test-validate-unit-file-buffer-hook ()
  "Validate-on-save reports validation result."
  (let* ((dir (make-temp-file "units-" t))
         (path (expand-file-name "test.el" dir)))
    (unwind-protect
        (progn
          (write-region "(:id \"test\" :command \"echo\")" nil path)
          (with-temp-buffer
            (insert-file-contents path)
            (setq buffer-file-name path)
            ;; Should not error for valid file
            (supervisor--validate-unit-file-buffer)))
      (delete-directory dir t))))

;;; Schema v1 Tests

(ert-deftest supervisor-test-service-schema-version ()
  "Service schema version constant is defined."
  (should (= supervisor-service-schema-version 1)))

(ert-deftest supervisor-test-service-struct-fields ()
  "Service struct has all expected fields."
  (let ((service (supervisor-service--create
                  :id "test"
                  :command "sleep 100"
                  :type 'simple
                  :stage 'stage2
                  :delay 5
                  :enabled t
                  :restart 'no
                  :logging t
                  :after '("dep1")
                  :requires '("req1")
                  :oneshot-blocking nil
                  :oneshot-timeout 60
                  :tags '(tag1 tag2))))
    (should (equal "test" (supervisor-service-id service)))
    (should (equal "sleep 100" (supervisor-service-command service)))
    (should (eq 'simple (supervisor-service-type service)))
    (should (eq 'stage2 (supervisor-service-stage service)))
    (should (= 5 (supervisor-service-delay service)))
    (should (supervisor-service-enabled service))
    (should (eq 'no (supervisor-service-restart service)))
    (should (supervisor-service-logging service))
    (should (equal '("dep1") (supervisor-service-after service)))
    (should (equal '("req1") (supervisor-service-requires service)))
    (should-not (supervisor-service-oneshot-blocking service))
    (should (= 60 (supervisor-service-oneshot-timeout service)))
    (should (equal '(tag1 tag2) (supervisor-service-tags service)))))

(ert-deftest supervisor-test-entry-accessors ()
  "Entry accessor functions work correctly."
  (let ((entry (supervisor--parse-entry
                '("sleep 100" :id "test" :type simple                  :delay 5 :restart nil :after ("dep1") :requires ("req1")))))
    (should (equal "test" (supervisor-entry-id entry)))
    (should (equal "sleep 100" (supervisor-entry-command entry)))
    (should (eq 'simple (supervisor-entry-type entry)))
    (should (eq 'stage3 (supervisor-entry-stage entry)))
    (should (= 5 (supervisor-entry-delay entry)))
    (should-not (supervisor-entry-restart-p entry))
    (should (equal '("dep1") (supervisor-entry-after entry)))
    (should (equal '("req1") (supervisor-entry-requires entry)))))

(ert-deftest supervisor-test-entry-to-service-conversion ()
  "Entry to service conversion preserves all fields."
  (let* ((entry (supervisor--parse-entry
                 '("sleep 100" :id "test" :type oneshot                   :after ("dep") :requires ("req") :tags (t1 t2))))
         (service (supervisor-entry-to-service entry)))
    (should (equal "test" (supervisor-service-id service)))
    (should (equal "sleep 100" (supervisor-service-command service)))
    (should (eq 'oneshot (supervisor-service-type service)))
    (should (eq 'stage3 (supervisor-service-stage service)))
    (should (equal '("dep") (supervisor-service-after service)))
    (should (equal '("req") (supervisor-service-requires service)))
    (should (equal '(t1 t2) (supervisor-service-tags service)))))

(ert-deftest supervisor-test-service-to-entry-conversion ()
  "Service to entry conversion preserves all fields."
  (let* ((service (supervisor-service--create
                   :id "test"
                   :command "sleep 100"
                   :type 'oneshot
                   :stage 'stage1
                   :delay 10
                   :enabled nil
                   :restart 'always
                   :logging nil
                   :after '("dep")
                   :requires '("req")
                   :oneshot-blocking t
                   :oneshot-timeout 120
                   :tags '(t1)))
         (entry (supervisor-service-to-entry service)))
    (should (equal "test" (supervisor-entry-id entry)))
    (should (equal "sleep 100" (supervisor-entry-command entry)))
    (should (eq 'oneshot (supervisor-entry-type entry)))
    (should (eq 'stage1 (supervisor-entry-stage entry)))
    (should (= 10 (supervisor-entry-delay entry)))
    (should-not (supervisor-entry-enabled-p entry))
    (should (supervisor-entry-restart-p entry))
    (should-not (supervisor-entry-logging-p entry))
    (should (equal '("dep") (supervisor-entry-after entry)))
    (should (equal '("req") (supervisor-entry-requires entry)))
    (should (supervisor-entry-oneshot-blocking entry))
    (should (= 120 (supervisor-entry-oneshot-timeout entry)))
    (should (equal '(t1) (supervisor-entry-tags entry)))))

;;; Dependency Semantics Tests

(ert-deftest supervisor-test-requires-keyword-valid ()
  ":requires keyword is accepted as valid."
  (should-not (supervisor--validate-entry
               '("foo" :type simple :requires "bar"))))

(ert-deftest supervisor-test-requires-parsed-correctly ()
  ":requires is parsed into entry correctly."
  (let ((entry (supervisor--parse-entry
                '("foo" :requires ("bar" "baz")))))
    (should (equal '("bar" "baz") (supervisor-entry-requires entry)))))

(ert-deftest supervisor-test-requires-missing-id-warned ()
  "Missing :requires target is warned and dropped."
  (let* ((logged nil)
         (programs '(("sleep 100" :id "a")
                     ("sleep 200" :id "b" :requires "nonexistent"))))
    (cl-letf (((symbol-function 'supervisor--log)
               (lambda (_level fmt &rest args)
                 (push (apply #'format fmt args) logged))))
      (let ((plan (supervisor--build-plan programs)))
        (should (cl-some (lambda (m) (string-match-p "does not exist" m))
                         logged))))))

(ert-deftest supervisor-test-requires-combined-with-after ()
  ":requires and :after are combined for topological sort."
  (let* ((programs '(("sleep 100" :id "a")
                     ("sleep 200" :id "b" :after "a")
                     ("sleep 300" :id "c" :requires "a")))
         (plan (supervisor--build-plan programs))
         (sorted (supervisor-plan-by-target plan))
         (ids (mapcar #'car sorted)))
    ;; a should come before both b and c
    (should (< (cl-position "a" ids :test #'equal)
               (cl-position "b" ids :test #'equal)))
    (should (< (cl-position "a" ids :test #'equal)
               (cl-position "c" ids :test #'equal)))))

(ert-deftest supervisor-test-plan-requires-deps-populated ()
  "Plan includes separate requires-deps hash."
  (let* ((programs '(("sleep 100" :id "a")
                     ("sleep 200" :id "b" :requires "a")))
         (plan (supervisor--build-plan programs)))
    (should (supervisor-plan-requires-deps plan))
    (should (equal '("a") (gethash "b" (supervisor-plan-requires-deps plan))))))

;;; Persistent Overrides Tests

(ert-deftest supervisor-test-overrides-file-path ()
  "Overrides file path respects custom setting."
  (let ((supervisor-overrides-file "/custom/path/overrides.eld"))
    (should (equal "/custom/path/overrides.eld"
                   (supervisor--overrides-file-path))))
  (let ((supervisor-overrides-file nil))
    (should-not (supervisor--overrides-file-path))))

(ert-deftest supervisor-test-overrides-to-alist ()
  "Overrides are correctly collected into an alist."
  (let ((supervisor--enabled-override (make-hash-table :test 'equal))
        (supervisor--restart-override (make-hash-table :test 'equal))
        (supervisor--logging (make-hash-table :test 'equal)))
    (puthash "a" 'enabled supervisor--enabled-override)
    (puthash "b" 'no supervisor--restart-override)
    (puthash "a" 'enabled supervisor--logging)
    (let ((alist (supervisor--overrides-to-alist)))
      (should (= 2 (length alist)))
      (let ((a-entry (cdr (assoc "a" alist)))
            (b-entry (cdr (assoc "b" alist))))
        (should (eq 'enabled (plist-get a-entry :enabled)))
        (should (eq 'enabled (plist-get a-entry :logging)))
        (should (eq 'no (plist-get b-entry :restart)))))))

(ert-deftest supervisor-test-overrides-save-load-roundtrip ()
  "Overrides survive save and load roundtrip."
  (let* ((temp-file (make-temp-file "supervisor-test-overrides-" nil ".eld"))
         (supervisor-overrides-file temp-file)
         (supervisor--enabled-override (make-hash-table :test 'equal))
         (supervisor--restart-override (make-hash-table :test 'equal))
         (supervisor--logging (make-hash-table :test 'equal))
         (supervisor--overrides-loaded nil))
    (unwind-protect
        (progn
          ;; Set some overrides
          (puthash "test-entry" 'disabled supervisor--enabled-override)
          (puthash "test-entry" 'always supervisor--restart-override)
          ;; Save
          (should (supervisor--save-overrides))
          ;; Clear memory
          (clrhash supervisor--enabled-override)
          (clrhash supervisor--restart-override)
          ;; Load
          (should (supervisor--load-overrides))
          ;; Verify
          (should (eq 'disabled (gethash "test-entry" supervisor--enabled-override)))
          (should (eq 'always (gethash "test-entry" supervisor--restart-override))))
      (delete-file temp-file))))

(ert-deftest supervisor-test-overrides-corrupt-file-handled ()
  "Corrupt overrides file is handled gracefully."
  (let* ((temp-file (make-temp-file "supervisor-test-corrupt-" nil ".eld"))
         (supervisor-overrides-file temp-file)
         (supervisor--enabled-override (make-hash-table :test 'equal))
         (supervisor--restart-override (make-hash-table :test 'equal))
         (supervisor--logging (make-hash-table :test 'equal)))
    (unwind-protect
        (progn
          ;; Write corrupt data
          (with-temp-file temp-file
            (insert "this is not valid lisp (((("))
          ;; Load should return nil but not error
          (should-not (supervisor--load-overrides))
          ;; File should still exist (not deleted)
          (should (file-exists-p temp-file)))
      (delete-file temp-file))))

(ert-deftest supervisor-test-cli-disable-loads-overrides-before-save ()
  "Disable CLI command preserves existing overrides on first save."
  (supervisor-test-with-unit-files
      '(("sleep 300" :id "svc1" :type simple)
        ("sleep 300" :id "svc2" :type simple))
    (let* ((temp-file (make-temp-file "supervisor-test-cli-load-" nil ".eld"))
           (supervisor-overrides-file temp-file)
           (supervisor--enabled-override (make-hash-table :test 'equal))
           (supervisor--restart-override (make-hash-table :test 'equal))
           (supervisor--logging (make-hash-table :test 'equal))
           (supervisor--mask-override (make-hash-table :test 'equal))
           (supervisor--overrides-loaded nil))
      (unwind-protect
          (progn
            ;; Seed file with an existing override for svc1.
            (with-temp-file temp-file
              (insert ";; Supervisor overrides file - do not edit manually\n")
              (insert ";; Schema version: 1\n")
              (pp '((version . 1)
                    (timestamp . "2026-02-15T00:00:00+0000")
                    (overrides ("svc1" :enabled disabled)))
                  (current-buffer)))
            (let ((result (supervisor--cli-dispatch '("disable" "svc2"))))
              (should (= supervisor-cli-exit-success
                         (supervisor-cli-result-exitcode result))))
            ;; Reload from disk and verify both overrides survive.
            (clrhash supervisor--enabled-override)
            (clrhash supervisor--restart-override)
            (clrhash supervisor--logging)
            (clrhash supervisor--mask-override)
            (setq supervisor--overrides-loaded nil)
            (should (supervisor--load-overrides))
            (should (eq 'disabled (gethash "svc1" supervisor--enabled-override)))
            (should (eq 'disabled (gethash "svc2" supervisor--enabled-override))))
        (delete-file temp-file)))))

(ert-deftest supervisor-test-cli-disable-does-not-overwrite-corrupt-overrides ()
  "Disable CLI command refuses to overwrite a corrupt overrides file."
  (supervisor-test-with-unit-files
      '(("sleep 300" :id "svc" :type simple))
    (let* ((temp-file (make-temp-file "supervisor-test-cli-corrupt-" nil ".eld"))
           (supervisor-overrides-file temp-file)
           (supervisor--enabled-override (make-hash-table :test 'equal))
           (supervisor--restart-override (make-hash-table :test 'equal))
           (supervisor--logging (make-hash-table :test 'equal))
           (supervisor--mask-override (make-hash-table :test 'equal))
           (supervisor--overrides-loaded nil))
      (unwind-protect
          (progn
            (with-temp-file temp-file
              (insert "this is not valid lisp (((("))
            (let ((result (supervisor--cli-dispatch '("disable" "svc"))))
              (should (= supervisor-cli-exit-failure
                         (supervisor-cli-result-exitcode result))))
            (should-not (gethash "svc" supervisor--enabled-override))
            (with-temp-buffer
              (insert-file-contents temp-file)
              (should (string-match-p "not valid lisp" (buffer-string)))))
        (delete-file temp-file)))))

;;; Migration Tests

(ert-deftest supervisor-test-migrate-string-entry ()
  "Migration handles simple string entries."
  (let ((result (supervisor--migrate-entry-to-plist "nm-applet")))
    ;; Simple string with defaults should remain a string
    (should (stringp result))
    (should (equal "nm-applet" result))))

(ert-deftest supervisor-test-migrate-plist-entry ()
  "Migration handles plist entries."
  (let ((result (supervisor--migrate-entry-to-plist
                 '("sleep 100" :type oneshot))))
    (should (listp result))
    (should (equal "sleep 100" (car result)))
    (should (eq 'oneshot (plist-get (cdr result) :type)))
    ;; No :stage in output since it defaults to stage3
    (should-not (plist-get (cdr result) :stage))))

(ert-deftest supervisor-test-migrate-all-entries-skips-invalid ()
  "Migration skips invalid entries with reason."
  (supervisor-test-with-unit-files
      '(("valid-cmd" :id "valid" :type simple)
        ("invalid-cmd" :id "invalid" :type "bad"))
    (let ((result (supervisor--migrate-all-entries)))
      (should (= 1 (length (plist-get result :migrated))))
      ;; Invalid entry is caught at unit-file validation (delegation)
      ;; and tracked in supervisor--unit-file-invalid
      (should (gethash "invalid" supervisor--unit-file-invalid)))))

(ert-deftest supervisor-test-migrate-all-entries-skips-duplicates ()
  "Migration sees only one entry when unit-file loader deduplicates."
  (supervisor-test-without-builtins
    (let* ((dir (make-temp-file "units-" t))
           (supervisor-unit-authority-path (list dir))
           (supervisor-unit-directory dir)
           (supervisor--programs-cache :not-yet-loaded)
           (supervisor--unit-file-invalid (make-hash-table :test 'equal)))
      ;; Two unit files with the same :id but different filenames
      (with-temp-file (expand-file-name "test-a.el" dir)
        (insert "(:id \"test\" :command \"a\" :type simple)"))
      (with-temp-file (expand-file-name "test-b.el" dir)
        (insert "(:id \"test\" :command \"b\" :type oneshot)"))
      (unwind-protect
          (let ((result (supervisor--migrate-all-entries)))
            ;; Unit-file loader deduplicates, so migration sees only one
            (should (= 1 (length (plist-get result :migrated))))
            ;; No skipped entries at migration level (dedup happened upstream)
            (should (= 0 (length (plist-get result :skipped)))))
        (delete-directory dir t)))))

(ert-deftest supervisor-test-migrate-entry-to-service ()
  "High-level migration function works."
  (let ((service (supervisor-migrate-entry-to-service
                  '("sleep 100" :id "test" :type oneshot))))
    (should (supervisor-service-p service))
    (should (equal "test" (supervisor-service-id service)))
    (should (eq 'oneshot (supervisor-service-type service)))))

(ert-deftest supervisor-test-migrate-entry-to-service-invalid-errors ()
  "High-level migration function signals error for invalid entry."
  (should-error
   (supervisor-migrate-entry-to-service '("foo" :type "bad"))
   :type 'error))

;;; Bug fix verification tests

(ert-deftest supervisor-test-validate-after-must-be-string-or-list ()
  "Validation rejects non-string/list :after values."
  ;; Valid cases
  (should-not (supervisor--validate-entry '("foo" :after "bar")))
  (should-not (supervisor--validate-entry '("foo" :after ("a" "b"))))
  (should-not (supervisor--validate-entry '("foo" :after nil)))
  ;; Invalid cases
  (should (string-match ":after must be"
                        (supervisor--validate-entry '("foo" :after 123))))
  (should (string-match ":after must be"
                        (supervisor--validate-entry '("foo" :after (1 2 3))))))

(ert-deftest supervisor-test-validate-requires-must-be-string-or-list ()
  "Validation rejects non-string/list :requires values."
  ;; Valid cases
  (should-not (supervisor--validate-entry '("foo" :requires "bar")))
  (should-not (supervisor--validate-entry '("foo" :requires ("a" "b"))))
  (should-not (supervisor--validate-entry '("foo" :requires nil)))
  ;; Invalid cases
  (should (string-match ":requires must be"
                        (supervisor--validate-entry '("foo" :requires 123))))
  (should (string-match ":requires must be"
                        (supervisor--validate-entry '("foo" :requires (1 2 3))))))

(ert-deftest supervisor-test-requires-valid-ordering ()
  "Entries with :requires are valid and ordered."
  (let* ((programs '(("a" :id "a")
                     ("b" :id "b" :requires "a")))
         (plan (supervisor--build-plan programs))
         (sorted (supervisor-plan-by-target plan)))
    ;; Both should be valid
    (should-not (gethash "b" (supervisor-plan-invalid plan)))
    ;; Both should appear in sorted entries
    (should (cl-find "a" sorted :key #'supervisor-entry-id :test #'equal))
    (should (cl-find "b" sorted :key #'supervisor-entry-id :test #'equal))))

(ert-deftest supervisor-test-dag-uses-requires-edges ()
  "DAG scheduler uses :requires edges for in-degree calculation."
  (let* ((entries '(("a" "sleep 1" 0 t always t simple stage3 nil t 30 nil nil)
                    ("b" "sleep 1" 0 t always t simple stage3 nil t 30 nil ("a"))))
         ;; Entry "b" has :requires "a" at index 12
         (supervisor--dag-in-degree (make-hash-table :test 'equal))
         (supervisor--dag-dependents (make-hash-table :test 'equal))
         (supervisor--dag-entries (make-hash-table :test 'equal))
         (supervisor--dag-blocking (make-hash-table :test 'equal))
         (supervisor--dag-started (make-hash-table :test 'equal))
         (supervisor--dag-ready (make-hash-table :test 'equal))
         (supervisor--dag-timeout-timers (make-hash-table :test 'equal))
         (supervisor--dag-delay-timers (make-hash-table :test 'equal))
         (supervisor--dag-id-to-index (make-hash-table :test 'equal))
         (supervisor--entry-state (make-hash-table :test 'equal)))
    (supervisor--dag-init entries)
    ;; "a" has no deps, in-degree should be 0
    (should (= 0 (gethash "a" supervisor--dag-in-degree)))
    ;; "b" has :requires "a", in-degree should be 1
    (should (= 1 (gethash "b" supervisor--dag-in-degree)))
    ;; "a" should have "b" as dependent
    (should (member "b" (gethash "a" supervisor--dag-dependents)))))

(ert-deftest supervisor-test-override-load-clears-stale-state ()
  "Loading overrides clears stale in-memory state not present in file."
  (let* ((temp-file (make-temp-file "supervisor-test-stale-" nil ".eld"))
         (supervisor-overrides-file temp-file)
         (supervisor--enabled-override (make-hash-table :test 'equal))
         (supervisor--restart-override (make-hash-table :test 'equal))
         (supervisor--logging (make-hash-table :test 'equal)))
    (unwind-protect
        (progn
          ;; First, save a file with only "file-entry"
          (puthash "file-entry" 'enabled supervisor--enabled-override)
          (supervisor--save-overrides)
          ;; Clear and add stale state that's NOT in the file
          (clrhash supervisor--enabled-override)
          (clrhash supervisor--restart-override)
          (clrhash supervisor--logging)
          (puthash "stale-entry" 'disabled supervisor--enabled-override)
          (puthash "stale-entry" 'no supervisor--restart-override)
          (puthash "stale-entry" 'disabled supervisor--logging)
          (puthash "another-stale" 'enabled supervisor--enabled-override)
          ;; Load from file - should clear stale state and restore file state
          (supervisor--load-overrides)
          ;; Stale entries should be gone (not in file)
          (should-not (gethash "stale-entry" supervisor--enabled-override))
          (should-not (gethash "another-stale" supervisor--enabled-override))
          (should-not (gethash "stale-entry" supervisor--restart-override))
          (should-not (gethash "stale-entry" supervisor--logging))
          ;; File entry should be restored
          (should (eq 'enabled (gethash "file-entry" supervisor--enabled-override))))
      (delete-file temp-file))))

(ert-deftest supervisor-test-duplicate-id-invalid-does-not-poison-valid ()
  "Valid entry is not poisoned by later invalid duplicate with same ID."
  (let* ((programs '(("cmd" :id "test" :type simple)      ; valid first
                     ("cmd" :id "test" :type "bad")))     ; invalid duplicate
         (plan (supervisor--build-plan programs)))
    ;; The valid entry should be in plan.entries
    (should (= 1 (length (supervisor-plan-entries plan))))
    (should (equal "test" (supervisor-entry-id (car (supervisor-plan-entries plan)))))
    ;; The ID should NOT be in the invalid hash (first valid wins)
    (should-not (gethash "test" (supervisor-plan-invalid plan)))))

(ert-deftest supervisor-test-duplicate-id-invalid-first-valid-later ()
  "First valid occurrence wins even when first occurrence is invalid."
  (let* ((programs '(("cmd" :id "test" :type "bad")       ; invalid first
                     ("cmd" :id "test" :type simple)))    ; valid later
         (plan (supervisor--build-plan programs)))
    ;; The valid entry should be in plan.entries
    (should (= 1 (length (supervisor-plan-entries plan))))
    (should (equal "test" (supervisor-entry-id (car (supervisor-plan-entries plan)))))
    ;; The ID should NOT be in the invalid hash (valid cleared stale invalid)
    (should-not (gethash "test" (supervisor-plan-invalid plan)))))

(ert-deftest supervisor-test-requires-included-in-plan-entries ()
  "Entries with :requires are included in plan.entries."
  (let* ((programs '(("a" :id "a")
                     ("b" :id "b" :requires "a")))
         (plan (supervisor--build-plan programs)))
    ;; Both should be valid and in plan.entries
    (should-not (gethash "b" (supervisor-plan-invalid plan)))
    (should (cl-find "b" (supervisor-plan-entries plan)
                     :key #'supervisor-entry-id :test #'equal))))

(ert-deftest supervisor-test-validate-dotted-list-after ()
  "Validation handles dotted lists in :after without error."
  ;; Dotted list should return validation error, not signal
  (let ((result (supervisor--validate-entry '("foo" :after (a . b)))))
    (should (stringp result))
    (should (string-match ":after must be" result))))

(ert-deftest supervisor-test-validate-dotted-list-requires ()
  "Validation handles dotted lists in :requires without error."
  ;; Dotted list should return validation error, not signal
  (let ((result (supervisor--validate-entry '("foo" :requires (x . y)))))
    (should (stringp result))
    (should (string-match ":requires must be" result))))

(ert-deftest supervisor-test-empty-programs-no-by-target ()
  "Empty program list produces empty by-target."
  (let* ((programs nil)
         (plan (supervisor--build-plan programs)))
    (should (null (supervisor-plan-by-target plan)))))

;;; Timer Schema tests

(ert-deftest supervisor-test-timer-struct-fields ()
  "Timer struct has expected fields."
  (let ((timer (supervisor-timer--create
                :id "test"
                :target "target"
                :enabled t
                :on-startup-sec 60
                :persistent t)))
    (should (supervisor-timer-p timer))
    (should (equal "test" (supervisor-timer-id timer)))
    (should (equal "target" (supervisor-timer-target timer)))
    (should (eq t (supervisor-timer-enabled timer)))
    (should (= 60 (supervisor-timer-on-startup-sec timer)))
    (should (eq t (supervisor-timer-persistent timer)))))

(ert-deftest supervisor-test-timer-validate-missing-id ()
  "Timer without :id is rejected."
  (let ((err (supervisor-timer--validate '(:target "foo" :on-startup-sec 60) nil)))
    (should (string-match-p ":id must be" err))))

(ert-deftest supervisor-test-timer-validate-missing-target ()
  "Timer without :target is rejected."
  (let ((err (supervisor-timer--validate '(:id "t" :on-startup-sec 60) nil)))
    (should (string-match-p ":target must be" err))))

(ert-deftest supervisor-test-timer-validate-empty-id ()
  "Timer with empty string :id is rejected."
  (let ((err (supervisor-timer--validate '(:id "" :target "foo" :on-startup-sec 60) nil)))
    (should (string-match-p ":id must be a non-empty string" err))))

(ert-deftest supervisor-test-timer-validate-empty-target ()
  "Timer with empty string :target is rejected."
  (let ((err (supervisor-timer--validate '(:id "t" :target "" :on-startup-sec 60) nil)))
    (should (string-match-p ":target must be a non-empty string" err))))

(ert-deftest supervisor-test-timer-validate-no-trigger ()
  "Timer without any trigger is rejected."
  (let ((err (supervisor-timer--validate '(:id "t" :target "foo") nil)))
    (should (string-match-p "at least one trigger" err))))

(ert-deftest supervisor-test-timer-validate-unknown-keyword ()
  "Timer with unknown keyword is rejected."
  (let ((err (supervisor-timer--validate
              '(:id "t" :target "foo" :on-startup-sec 60 :bogus t) nil)))
    (should (string-match-p "unknown keyword" err))))

(ert-deftest supervisor-test-timer-validate-startup-sec-type ()
  "Timer with non-integer :on-startup-sec is rejected."
  (let ((err (supervisor-timer--validate
              '(:id "t" :target "foo" :on-startup-sec "60") nil)))
    (should (string-match-p ":on-startup-sec must be" err))))

(ert-deftest supervisor-test-timer-validate-unit-active-sec-positive ()
  "Timer with zero :on-unit-active-sec is rejected."
  (let ((err (supervisor-timer--validate
              '(:id "t" :target "foo" :on-unit-active-sec 0) nil)))
    (should (string-match-p ":on-unit-active-sec must be a positive" err))))

(ert-deftest supervisor-test-timer-validate-startup-sec-nil ()
  "Timer with only nil :on-startup-sec has no valid trigger."
  (let ((err (supervisor-timer--validate
              '(:id "t" :target "foo" :on-startup-sec nil) nil)))
    (should (string-match-p "at least one trigger" err))))

(ert-deftest supervisor-test-timer-validate-unit-active-sec-nil ()
  "Timer with only nil :on-unit-active-sec has no valid trigger."
  (let ((err (supervisor-timer--validate
              '(:id "t" :target "foo" :on-unit-active-sec nil) nil)))
    (should (string-match-p "at least one trigger" err))))

(ert-deftest supervisor-test-timer-validate-startup-sec-nil-with-other-trigger ()
  "Timer with nil :on-startup-sec but valid :on-calendar still validates."
  (let* ((programs '(("script" :type oneshot :id "script")))
         (plan (supervisor--build-plan programs))
         (err (supervisor-timer--validate
               '(:id "t" :target "script" :on-startup-sec nil
                 :on-calendar (:hour 3))
               plan)))
    ;; Should fail on nil :on-startup-sec type check, not on missing trigger
    (should (string-match-p ":on-startup-sec must be" err))))

(ert-deftest supervisor-test-timer-validate-calendar-unknown-field ()
  "Timer with unknown calendar field is rejected."
  (let ((err (supervisor-timer--validate
              '(:id "t" :target "foo" :on-calendar (:bogus 5)) nil)))
    (should (string-match-p "unknown field" err))))

(ert-deftest supervisor-test-timer-validate-calendar-bad-value ()
  "Timer with invalid calendar value type is rejected."
  (let ((err (supervisor-timer--validate
              '(:id "t" :target "foo" :on-calendar (:hour "3")) nil)))
    (should (string-match-p "must be integer" err))))

(ert-deftest supervisor-test-timer-validate-enabled-boolean ()
  "Timer with non-boolean :enabled is rejected."
  (let ((err (supervisor-timer--validate
              '(:id "t" :target "foo" :on-startup-sec 60 :enabled "yes") nil)))
    (should (string-match-p ":enabled must be a boolean" err))))

(ert-deftest supervisor-test-timer-validate-target-not-found ()
  "Timer targeting nonexistent service is rejected."
  (let* ((programs '(("real" :type oneshot :id "real")))
         (plan (supervisor--build-plan programs))
         (err (supervisor-timer--validate
               '(:id "t" :target "missing" :on-startup-sec 60) plan)))
    (should (string-match-p "not found" err))))

(ert-deftest supervisor-test-timer-validate-target-simple-accepted ()
  "Timer targeting simple service is accepted."
  (let* ((programs '(("daemon" :type simple :id "daemon")))
         (plan (supervisor--build-plan programs))
         (err (supervisor-timer--validate
               '(:id "t" :target "daemon" :on-startup-sec 60) plan)))
    (should-not err)))

(ert-deftest supervisor-test-timer-validate-target-type-target-accepted ()
  "Timer targeting a target unit is accepted."
  (let* ((programs '(("" :type target :id "app.target")))
         (plan (supervisor--build-plan programs))
         (err (supervisor-timer--validate
               '(:id "t" :target "app.target" :on-startup-sec 60) plan)))
    (should-not err)))

(ert-deftest supervisor-test-timer-validate-target-type-target-bad-suffix ()
  "Timer targeting a target entry without .target suffix is rejected.
The suffix check at timer validation level catches any target type
entry whose ID does not end in .target (entry validation blocks
this in practice, but the timer validator defends independently)."
  ;; Construct a plan with a hand-built entry where type=target but ID
  ;; lacks the .target suffix.  This bypasses entry validation to test
  ;; the timer validator's own suffix guard.
  (let* ((fake-entry (supervisor--parse-entry
                      '(nil :id "bad.target" :type target)))
         ;; Rename the ID in the parsed tuple to remove the suffix
         (bad-entry (cons "bad-no-suffix" (cdr fake-entry)))
         (plan (supervisor-plan--create
                :entries (list bad-entry)
                :by-target nil
                :deps (make-hash-table :test 'equal)
                :requires-deps (make-hash-table :test 'equal)
                :dependents (make-hash-table :test 'equal)
                :invalid (make-hash-table :test 'equal)
                :cycle-fallback-ids (make-hash-table :test 'equal)
                :order-index (make-hash-table :test 'equal)
                :meta nil))
         (err (supervisor-timer--validate
               '(:id "t" :target "bad-no-suffix" :on-startup-sec 60) plan)))
    (should err)
    (should (string-match "does not end in .target" err))))

(ert-deftest supervisor-test-timer-validate-disallowed-target-type ()
  "Timer targeting a timer entry (not oneshot/simple/target) is rejected."
  ;; Timers can only target oneshot, simple, or target entries.
  ;; This tests the rejection of an unsupported type.
  (let* ((fake-entry (supervisor--parse-entry
                      '("sleep 1" :id "my-timer" :type timer
                        :on-calendar (:hour 3))))
         (plan (supervisor-plan--create
                :entries (list fake-entry)
                :by-target nil
                :deps (make-hash-table :test 'equal)
                :requires-deps (make-hash-table :test 'equal)
                :dependents (make-hash-table :test 'equal)
                :invalid (make-hash-table :test 'equal)
                :cycle-fallback-ids (make-hash-table :test 'equal)
                :order-index (make-hash-table :test 'equal)
                :meta nil))
         (err (supervisor-timer--validate
               '(:id "t2" :target "my-timer" :on-startup-sec 60) plan)))
    (should err)
    (should (string-match "must be oneshot, simple, or target" err))))

(ert-deftest supervisor-test-timer-validate-valid ()
  "Valid timer passes validation."
  (let* ((programs '(("script" :type oneshot :id "script")))
         (plan (supervisor--build-plan programs))
         (err (supervisor-timer--validate
               '(:id "t" :target "script" :on-startup-sec 60) plan)))
    (should-not err)))

(ert-deftest supervisor-test-timer-validate-calendar-valid ()
  "Valid calendar schedule passes validation."
  (let* ((programs '(("script" :type oneshot :id "script")))
         (plan (supervisor--build-plan programs))
         (err (supervisor-timer--validate
               '(:id "t" :target "script"
                 :on-calendar (:hour 3 :minute 0 :day-of-week *))
               plan)))
    (should-not err)))

(ert-deftest supervisor-test-timer-validate-calendar-list-valid ()
  "Valid list of calendar schedules passes validation."
  (let* ((programs '(("script" :type oneshot :id "script")))
         (plan (supervisor--build-plan programs))
         (err (supervisor-timer--validate
               '(:id "t" :target "script"
                 :on-calendar ((:hour 3 :minute 0)
                               (:hour 15 :minute 30)))
               plan)))
    (should-not err)))

(ert-deftest supervisor-test-timer-validate-calendar-list-invalid ()
  "Invalid entry in list of calendar schedules is rejected."
  (let* ((programs '(("script" :type oneshot :id "script")))
         (plan (supervisor--build-plan programs))
         (err (supervisor-timer--validate
               '(:id "t" :target "script"
                 :on-calendar ((:hour 3 :minute 0)
                               (:bogus 15)))
               plan)))
    (should (string-match-p "unknown field" err))))

(ert-deftest supervisor-test-timer-validate-calendar-empty ()
  "Empty calendar list with no other trigger has no valid trigger."
  (let* ((programs '(("script" :type oneshot :id "script")))
         (plan (supervisor--build-plan programs))
         (err (supervisor-timer--validate
               '(:id "t" :target "script" :on-calendar ())
               plan)))
    ;; Empty list is falsy so fails trigger check first
    (should (string-match-p "at least one trigger" err))))

(ert-deftest supervisor-test-timer-validate-calendar-dotted-pair ()
  "Dotted pair calendar is rejected, not crash."
  (let* ((programs '(("script" :type oneshot :id "script")))
         (plan (supervisor--build-plan programs))
         (err (supervisor-timer--validate
               '(:id "t" :target "script" :on-calendar (:hour . 3))
               plan)))
    (should (string-match-p "proper plist" err))))

(ert-deftest supervisor-test-timer-validate-calendar-empty-with-other-trigger ()
  "Empty calendar with valid :on-startup-sec fails on empty calendar."
  (let* ((programs '(("script" :type oneshot :id "script")))
         (plan (supervisor--build-plan programs))
         (err (supervisor-timer--validate
               '(:id "t" :target "script" :on-calendar () :on-startup-sec 60)
               plan)))
    (should (string-match-p "cannot be empty" err))))

(ert-deftest supervisor-test-timer-validate-calendar-list-non-plist ()
  "Non-plist entry in calendar list is rejected."
  (let* ((programs '(("script" :type oneshot :id "script")))
         (plan (supervisor--build-plan programs))
         (err (supervisor-timer--validate
               '(:id "t" :target "script"
                 :on-calendar ((:hour 3) foo))
               plan)))
    (should (string-match-p "must be a plist" err))))

(ert-deftest supervisor-test-timer-parse ()
  "Timer parsing produces correct struct."
  (let ((timer (supervisor-timer--parse
                '(:id "backup" :target "backup-script"
                  :on-calendar (:hour 3 :minute 0)
                  :enabled nil :persistent nil))))
    (should (equal "backup" (supervisor-timer-id timer)))
    (should (equal "backup-script" (supervisor-timer-target timer)))
    (should (eq nil (supervisor-timer-enabled timer)))
    (should (equal '(:hour 3 :minute 0) (supervisor-timer-on-calendar timer)))
    (should (eq nil (supervisor-timer-persistent timer)))))

(ert-deftest supervisor-test-timer-parse-defaults ()
  "Timer parsing applies correct defaults."
  (let ((timer (supervisor-timer--parse
                '(:id "t" :target "foo" :on-startup-sec 60))))
    (should (eq t (supervisor-timer-enabled timer)))
    (should (eq t (supervisor-timer-persistent timer)))))

(ert-deftest supervisor-test-timer-build-list-valid ()
  "Build timer list from valid config."
  (let* ((supervisor--builtin-timers nil)
         (supervisor-timers '((:id "t1" :target "s1" :on-startup-sec 60)
                              (:id "t2" :target "s2" :on-startup-sec 120)))
         (programs '(("s1" :type oneshot :id "s1")
                     ("s2" :type oneshot :id "s2")))
         (plan (supervisor--build-plan programs))
         (timers (supervisor-timer-build-list plan)))
    (should (= 2 (length timers)))
    (should (= 0 (hash-table-count supervisor--invalid-timers)))))

(ert-deftest supervisor-test-timer-build-list-invalid-rejected ()
  "Invalid timers are rejected and tracked."
  (let* ((supervisor--builtin-timers nil)
         (supervisor-timers '((:id "valid" :target "s1" :on-startup-sec 60)
                              (:id "invalid" :target "missing" :on-startup-sec 60)))
         (programs '(("s1" :type oneshot :id "s1")))
         (plan (supervisor--build-plan programs))
         (timers (supervisor-timer-build-list plan)))
    (should (= 1 (length timers)))
    (should (= 1 (hash-table-count supervisor--invalid-timers)))
    (should (gethash "invalid" supervisor--invalid-timers))))

(ert-deftest supervisor-test-timer-build-list-duplicate-rejected ()
  "Duplicate timer IDs are rejected."
  (let* ((supervisor--builtin-timers nil)
         (supervisor-timers '((:id "dup" :target "s1" :on-startup-sec 60)
                              (:id "dup" :target "s1" :on-startup-sec 120)))
         (programs '(("s1" :type oneshot :id "s1")))
         (plan (supervisor--build-plan programs))
         (timers (supervisor-timer-build-list plan)))
    (should (= 1 (length timers)))
    (should (= 1 (hash-table-count supervisor--invalid-timers)))))

(ert-deftest supervisor-test-timer-build-list-duplicate-invalid-first ()
  "Duplicate timer ID rejected deterministically when first is invalid.
Second valid occurrence should not activate when first invalid occurrence used the ID."
  (let* ((supervisor--builtin-timers nil)
         (supervisor-timers '((:id "dup" :target "missing" :on-startup-sec 60)  ; invalid (bad target)
                              (:id "dup" :target "s1" :on-startup-sec 120)))    ; valid but duplicate
         (programs '(("s1" :type oneshot :id "s1")))
         (plan (supervisor--build-plan programs))
         (timers (supervisor-timer-build-list plan)))
    ;; No active timers (first invalid, second duplicate)
    (should (= 0 (length timers)))
    ;; One invalid entry (hash key = "dup", first error preserved)
    (should (= 1 (hash-table-count supervisor--invalid-timers)))
    ;; First error (target not found) should be preserved, not overwritten by duplicate
    (should (string-match-p "target" (gethash "dup" supervisor--invalid-timers)))))

(ert-deftest supervisor-test-timer-validate-startup-sec-zero-rejected ()
  "Timer with zero :on-startup-sec is rejected (must be positive)."
  (let ((err (supervisor-timer--validate
              '(:id "t" :target "foo" :on-startup-sec 0) nil)))
    (should err)
    (should (string-match-p ":on-startup-sec must be a positive" err))))

(ert-deftest supervisor-test-timer-validate-calendar-field-range-minute ()
  "Calendar :minute field rejects values outside 0-59."
  (let ((err (supervisor-timer--validate
              '(:id "t" :target "foo" :on-calendar (:minute 60)) nil)))
    (should err)
    (should (string-match-p "out of range" err))))

(ert-deftest supervisor-test-timer-validate-calendar-field-range-hour ()
  "Calendar :hour field rejects values outside 0-23."
  (let ((err (supervisor-timer--validate
              '(:id "t" :target "foo" :on-calendar (:hour 24)) nil)))
    (should err)
    (should (string-match-p "out of range" err))))

(ert-deftest supervisor-test-timer-validate-calendar-field-range-day ()
  "Calendar :day-of-month field rejects values outside 1-31."
  (let ((err (supervisor-timer--validate
              '(:id "t" :target "foo" :on-calendar (:day-of-month 0)) nil)))
    (should err)
    (should (string-match-p "out of range" err))))

(ert-deftest supervisor-test-timer-validate-calendar-field-range-month ()
  "Calendar :month field rejects values outside 1-12."
  (let ((err (supervisor-timer--validate
              '(:id "t" :target "foo" :on-calendar (:month 13)) nil)))
    (should err)
    (should (string-match-p "out of range" err))))

(ert-deftest supervisor-test-timer-validate-calendar-field-range-dow ()
  "Calendar :day-of-week field rejects values outside 0-6."
  (let ((err (supervisor-timer--validate
              '(:id "t" :target "foo" :on-calendar (:day-of-week 7)) nil)))
    (should err)
    (should (string-match-p "out of range" err))))

(ert-deftest supervisor-test-timer-validate-calendar-field-range-list ()
  "Calendar field list with out-of-range value is rejected."
  (let ((err (supervisor-timer--validate
              '(:id "t" :target "foo" :on-calendar (:minute (0 30 61))) nil)))
    (should err)
    (should (string-match-p "out of range" err))))

(ert-deftest supervisor-test-timer-validate-calendar-dotted-pair-rejected ()
  "Calendar field dotted pair is rejected (not crash)."
  (let ((err (supervisor-timer--validate
              '(:id "t" :target "foo" :on-calendar (:minute (0 . 1))) nil)))
    (should err)
    (should (string-match-p "non-empty list of integers" err))))

(ert-deftest supervisor-test-timer-validate-calendar-empty-list-rejected ()
  "Calendar field empty list is rejected."
  (let ((err (supervisor-timer--validate
              '(:id "t" :target "foo" :on-calendar (:minute ())) nil)))
    (should err)
    (should (string-match-p "non-empty list of integers" err))))

;;; Timer Scheduler Core tests

(ert-deftest supervisor-test-calendar-field-matches-star ()
  "Calendar field * matches any value."
  (should (supervisor-timer--calendar-field-matches-p '* 0))
  (should (supervisor-timer--calendar-field-matches-p '* 23))
  (should (supervisor-timer--calendar-field-matches-p '* 59)))

(ert-deftest supervisor-test-calendar-field-matches-integer ()
  "Calendar field integer matches exact value."
  (should (supervisor-timer--calendar-field-matches-p 3 3))
  (should-not (supervisor-timer--calendar-field-matches-p 3 4))
  (should-not (supervisor-timer--calendar-field-matches-p 3 0)))

(ert-deftest supervisor-test-calendar-field-matches-list ()
  "Calendar field list matches any value in list."
  (should (supervisor-timer--calendar-field-matches-p '(1 3 5) 1))
  (should (supervisor-timer--calendar-field-matches-p '(1 3 5) 3))
  (should (supervisor-timer--calendar-field-matches-p '(1 3 5) 5))
  (should-not (supervisor-timer--calendar-field-matches-p '(1 3 5) 2))
  (should-not (supervisor-timer--calendar-field-matches-p '(1 3 5) 4)))

(ert-deftest supervisor-test-calendar-matches-time ()
  "Calendar spec matches decoded time correctly."
  ;; Create a decoded time for 2025-01-15 03:30:00 (Wednesday)
  (let ((decoded (decode-time (encode-time 0 30 3 15 1 2025))))
    ;; Exact match
    (should (supervisor-timer--calendar-matches-time-p
             '(:hour 3 :minute 30) decoded))
    ;; Wildcards
    (should (supervisor-timer--calendar-matches-time-p
             '(:hour 3 :minute *) decoded))
    ;; Lists
    (should (supervisor-timer--calendar-matches-time-p
             '(:hour (1 2 3) :minute 30) decoded))
    ;; Mismatch
    (should-not (supervisor-timer--calendar-matches-time-p
                 '(:hour 4 :minute 30) decoded))
    (should-not (supervisor-timer--calendar-matches-time-p
                 '(:hour 3 :minute 0) decoded))))

(ert-deftest supervisor-test-calendar-next-minute-finds-match ()
  "Calendar next minute finds matching time."
  ;; From 2025-01-15 00:00:00, find next 03:30
  (let* ((from (encode-time 0 0 0 15 1 2025))
         (next (supervisor-timer--calendar-next-minute
                from '(:hour 3 :minute 30) 2)))  ; 2 days max
    (should next)
    ;; Should be 03:30
    (let ((decoded (decode-time next)))
      (should (= 3 (decoded-time-hour decoded)))
      (should (= 30 (decoded-time-minute decoded))))))

(ert-deftest supervisor-test-calendar-next-minute-respects-limit ()
  "Calendar next minute respects iteration limit."
  ;; Looking for hour 25 (impossible) with small limit
  (let* ((from (encode-time 0 0 0 15 1 2025))
         (next (supervisor-timer--calendar-next-minute
                from '(:hour 25 :minute 0) 7)))  ; 7 days max
    (should-not next)))

(ert-deftest supervisor-test-calendar-next-minute-leap-day ()
  "Calendar next minute finds leap day across multi-year gap.
From March 2025, next Feb 29 is in 2028 (~3 years away)."
  (let* ((from (encode-time 0 0 0 1 3 2025))  ; 2025-03-01 00:00:00
         (next (supervisor-timer--calendar-next-minute
                from '(:month 2 :day-of-month 29 :hour 0 :minute 0) 10228)))  ; 28 years
    (should next)
    (let ((decoded (decode-time next)))
      (should (= 2028 (decoded-time-year decoded)))
      (should (= 2 (decoded-time-month decoded)))
      (should (= 29 (decoded-time-day decoded))))))

(ert-deftest supervisor-test-calendar-next-minute-leap-day-weekday ()
  "Calendar next minute finds leap day + weekday across long gap.
From March 2025, next Feb 29 that is Sunday (dow=0) is in 2032 (~7 years away)."
  (let* ((from (encode-time 0 0 0 1 3 2025))  ; 2025-03-01 00:00:00
         (next (supervisor-timer--calendar-next-minute
                from '(:month 2 :day-of-month 29 :day-of-week 0 :hour 0 :minute 0) 10228)))
    (should next)
    (let ((decoded (decode-time next)))
      (should (= 2032 (decoded-time-year decoded)))
      (should (= 2 (decoded-time-month decoded)))
      (should (= 29 (decoded-time-day decoded)))
      ;; Verify it's actually Sunday (day-of-week 0)
      (should (= 0 (decoded-time-weekday decoded))))))

(ert-deftest supervisor-test-calendar-next-minute-strictly-after ()
  "Calendar next minute returns time strictly after from-time.
When from-time is exactly at a matching minute boundary, should return next occurrence."
  ;; From 2025-01-15 03:30:00 exactly (matches :hour 3 :minute 30)
  (let* ((from (encode-time 0 30 3 15 1 2025))
         (next (supervisor-timer--calendar-next-minute
                from '(:hour 3 :minute 30) 2)))  ; 2 days max
    (should next)
    ;; Should be next day's 03:30, not the same time
    (should (> next (float-time from)))
    (let ((decoded (decode-time next)))
      (should (= 16 (decoded-time-day decoded)))  ; Next day
      (should (= 3 (decoded-time-hour decoded)))
      (should (= 30 (decoded-time-minute decoded))))))

(ert-deftest supervisor-test-calendar-next-minute-dst-gap ()
  "Calendar next minute skips non-existent DST gap times.
On March 9, 2025 in America/New_York, 2:00-2:59 AM doesn't exist (spring forward).
Searching for 2:30 AM should skip March 9 and return March 10 2:30 AM.
Uses `setenv' rather than `process-environment' to ensure the C-level
timezone that `encode-time' and `decode-time' use is actually changed."
  (let ((orig-tz (getenv "TZ")))
    (unwind-protect
        (progn
          (setenv "TZ" "America/New_York")
          ;; Skip test if TZ setting doesn't take effect
          ;; (CI may lack timezone data for America/New_York)
          (let* ((test-time (encode-time 0 30 2 9 3 2025))
                 (test-decoded (decode-time test-time)))
            (skip-unless (= 3 (decoded-time-hour test-decoded))))
          ;; From March 9, 2025 00:00:00 (before DST transition)
          (let* ((from (encode-time 0 0 0 9 3 2025))
                 (next (supervisor-timer--calendar-next-minute
                        from '(:hour 2 :minute 30) 7)))  ; 7 days max
            (should next)
            (let ((decoded (decode-time next)))
              ;; Should be March 10 (next day), not March 9
              (should (= 10 (decoded-time-day decoded)))
              (should (= 2 (decoded-time-hour decoded)))
              (should (= 30 (decoded-time-minute decoded))))))
      (setenv "TZ" orig-tz))))

(ert-deftest supervisor-test-timer-next-startup-time ()
  "Startup trigger computes time relative to scheduler start."
  (let* ((timer (supervisor-timer--create
                 :id "t1" :target "s1" :on-startup-sec 120))
         (supervisor--scheduler-startup-time 1000.0)
         (supervisor--timer-state (make-hash-table :test 'equal)))
    ;; No previous run - should return startup + delay
    (should (= 1120.0 (supervisor-timer--next-startup-time timer)))
    ;; After startup trigger has fired - should return nil
    (puthash "t1" '(:startup-triggered t) supervisor--timer-state)
    (should-not (supervisor-timer--next-startup-time timer))))

(ert-deftest supervisor-test-timer-next-unit-active-time ()
  "Unit-active trigger computes time relative to last success."
  (let* ((timer (supervisor-timer--create
                 :id "t1" :target "s1" :on-unit-active-sec 300))
         (supervisor--timer-state (make-hash-table :test 'equal)))
    ;; No previous success - should return nil
    (should-not (supervisor-timer--next-unit-active-time timer))
    ;; After a successful run
    (puthash "t1" '(:last-success-at 2000.0) supervisor--timer-state)
    (should (= 2300.0 (supervisor-timer--next-unit-active-time timer)))))

(ert-deftest supervisor-test-timer-compute-next-run-picks-earliest ()
  "Timer picks earliest trigger when multiple are configured."
  (let* ((timer (supervisor-timer--create
                 :id "t1" :target "s1"
                 :on-startup-sec 60
                 :on-unit-active-sec 300))
         (supervisor--scheduler-startup-time 1000.0)
         (supervisor--timer-state (make-hash-table :test 'equal)))
    ;; Only startup is available (no previous success)
    (should (= 1060.0 (supervisor-timer--compute-next-run timer 1000.0)))
    ;; After startup trigger has fired and a success recorded, unit-active becomes available
    (puthash "t1" '(:last-success-at 1050.0 :startup-triggered t) supervisor--timer-state)
    ;; Startup already fired, unit-active at 1350
    (should (= 1350.0 (supervisor-timer--compute-next-run timer 1100.0)))))

(ert-deftest supervisor-test-timer-overlap-detection ()
  "Timer detects when target is still running."
  (let* ((timer (supervisor-timer--create :id "t1" :target "s1"))
         (supervisor--processes (make-hash-table :test 'equal)))
    ;; No process - not active
    (should-not (supervisor-timer--target-active-p timer))
    ;; Dead process - not active
    (puthash "s1" (start-process "test" nil "true") supervisor--processes)
    (sleep-for 0.1) ; Let it die
    (should-not (supervisor-timer--target-active-p timer))
    ;; Cleanup
    (clrhash supervisor--processes)))

(ert-deftest supervisor-test-timer-trigger-disabled-timer ()
  "Timer trigger skips disabled timer and records miss."
  (supervisor-test-with-unit-files
      '(("true" :id "s1" :type oneshot))
    (let* ((timer (supervisor-timer--create :id "t1" :target "s1" :enabled nil))
           (supervisor--timer-state (make-hash-table :test 'equal)))
      ;; Trigger disabled timer
      (should-not (supervisor-timer--trigger timer 'scheduled))
      ;; Should record miss with reason 'disabled
      (let ((state (gethash "t1" supervisor--timer-state)))
        (should state)
        (should (plist-get state :last-missed-at))
        (should (eq 'disabled (plist-get state :last-miss-reason))))
      ;; Cleanup
      (clrhash supervisor--timer-state))))

(ert-deftest supervisor-test-timer-trigger-disabled-target ()
  "Timer trigger skips disabled target and records miss."
  (supervisor-test-with-unit-files
      '(("true" :id "s1" :type oneshot :disabled t))
    (let* ((timer (supervisor-timer--create :id "t1" :target "s1" :enabled t))
           (supervisor--timer-state (make-hash-table :test 'equal))
           (supervisor--processes (make-hash-table :test 'equal))
           (supervisor--enabled-override (make-hash-table :test 'equal))
           (supervisor--invalid (make-hash-table :test 'equal)))
      ;; Trigger timer with disabled target (via config)
      (should-not (supervisor-timer--trigger timer 'scheduled))
      ;; Should record miss with reason 'disabled-target
      (let ((state (gethash "t1" supervisor--timer-state)))
        (should state)
        (should (plist-get state :last-missed-at))
        (should (eq 'disabled-target (plist-get state :last-miss-reason))))
      ;; Cleanup
      (clrhash supervisor--timer-state)
      (clrhash supervisor--processes)
      (clrhash supervisor--enabled-override)
      (clrhash supervisor--invalid))))

(ert-deftest supervisor-test-timer-trigger-disabled-target-override ()
  "Timer trigger respects runtime disabled override."
  (supervisor-test-with-unit-files
      '(("true" :id "s1" :type oneshot))
    (let* ((timer (supervisor-timer--create :id "t1" :target "s1" :enabled t))
           (supervisor--timer-state (make-hash-table :test 'equal))
           (supervisor--processes (make-hash-table :test 'equal))
           (supervisor--enabled-override (make-hash-table :test 'equal))
           (supervisor--invalid (make-hash-table :test 'equal)))
      ;; Disable target via runtime override
      (puthash "s1" 'disabled supervisor--enabled-override)
      ;; Trigger timer
      (should-not (supervisor-timer--trigger timer 'scheduled))
      ;; Should record miss with reason 'disabled-target
      (let ((state (gethash "t1" supervisor--timer-state)))
        (should state)
        (should (eq 'disabled-target (plist-get state :last-miss-reason))))
      ;; Cleanup
      (clrhash supervisor--timer-state)
      (clrhash supervisor--processes)
      (clrhash supervisor--enabled-override)
      (clrhash supervisor--invalid))))

(ert-deftest supervisor-test-timer-trigger-target-not-found ()
  "Timer trigger handles missing target as failure."
  (supervisor-test-with-unit-files nil
    (let* ((timer (supervisor-timer--create :id "t1" :target "nonexistent" :enabled t))
           (supervisor--timer-state (make-hash-table :test 'equal)))
      ;; Trigger timer with nonexistent target
      (should-not (supervisor-timer--trigger timer 'scheduled))
      ;; Failure is recorded per plan (surfaced diagnostic)
      (let ((state (gethash "t1" supervisor--timer-state)))
        (should state)
        (should (eq 'failure (plist-get state :last-result))))
      ;; Cleanup
      (clrhash supervisor--timer-state))))

(ert-deftest supervisor-test-timer-trigger-overlap-skips ()
  "Timer trigger skips when target is still running."
  (supervisor-test-with-unit-files
      '(("sleep 10" :id "s1" :type oneshot))
    (let* ((timer (supervisor-timer--create :id "t1" :target "s1" :enabled t))
           (supervisor--timer-state (make-hash-table :test 'equal))
           (supervisor--processes (make-hash-table :test 'equal))
           (supervisor--enabled-override (make-hash-table :test 'equal))
           (supervisor--invalid (make-hash-table :test 'equal)))
      ;; Simulate running process
      (puthash "s1" (start-process "test-overlap" nil "sleep" "10")
               supervisor--processes)
      ;; Trigger timer
      (should-not (supervisor-timer--trigger timer 'scheduled))
      ;; Should record miss with reason 'overlap
      (let ((state (gethash "t1" supervisor--timer-state)))
        (should state)
        (should (eq 'overlap (plist-get state :last-miss-reason))))
      ;; Cleanup
      (let ((proc (gethash "s1" supervisor--processes)))
        (when (process-live-p proc)
          (delete-process proc)))
      (clrhash supervisor--invalid)
      (clrhash supervisor--timer-state)
      (clrhash supervisor--processes)
      (clrhash supervisor--enabled-override))))

(ert-deftest supervisor-test-timer-trigger-success-path ()
  "Timer trigger succeeds and emits timer-trigger event."
  (supervisor-test-with-unit-files
      '(("true" :id "s1" :type oneshot))
    (let* ((supervisor-timer-subsystem-mode t)
           (supervisor-mode t)
           (timer (supervisor-timer--create :id "t1" :target "s1" :enabled t))
           (supervisor--timer-state (make-hash-table :test 'equal))
           (supervisor--processes (make-hash-table :test 'equal))
           (supervisor--enabled-override (make-hash-table :test 'equal))
           (supervisor--invalid (make-hash-table :test 'equal))
           (supervisor--scheduler-startup-time (float-time))
           (events nil)
           (hook-fn (lambda (event)
                      (when (eq (plist-get event :type) 'timer-trigger)
                        (push event events)))))
      ;; Capture timer-trigger event
      (add-hook 'supervisor-event-hook hook-fn)
      (unwind-protect
          (progn
            ;; Trigger timer
            (should (supervisor-timer--trigger timer 'scheduled))
            ;; Should have recorded :last-run-at
            (let ((state (gethash "t1" supervisor--timer-state)))
              (should state)
              (should (plist-get state :last-run-at)))
            ;; Should have emitted timer-trigger event
            (should (= 1 (length events)))
            (let ((event (car events)))
              (should (eq 'timer-trigger (plist-get event :type)))
              (should (equal "t1" (plist-get event :id)))
              (should (equal "s1" (plist-get (plist-get event :data) :target)))))
        ;; Cleanup
        (remove-hook 'supervisor-event-hook hook-fn)
        (clrhash supervisor--invalid)
        (clrhash supervisor--timer-state)
        (clrhash supervisor--processes)
        (clrhash supervisor--enabled-override)))))

(ert-deftest supervisor-test-timer-startup-trigger-independent ()
  "Startup trigger is independent from calendar/unit-active triggers."
  (let* ((timer (supervisor-timer--create :id "t1" :target "s1" :enabled t
                                          :on-startup-sec 60
                                          :on-calendar '(:minute 0)))
         (supervisor--timer-state (make-hash-table :test 'equal))
         (supervisor--scheduler-startup-time 1000.0))
    ;; Simulate a calendar trigger having fired (sets :last-run-at)
    (puthash "t1" (list :last-run-at 1010.0) supervisor--timer-state)
    ;; Startup trigger should still return a time (not cancelled by calendar)
    (let ((next (supervisor-timer--next-startup-time timer)))
      (should next)
      (should (= 1060.0 next)))
    ;; Now mark startup as triggered
    (puthash "t1" (list :last-run-at 1010.0 :startup-triggered t)
             supervisor--timer-state)
    ;; Now startup trigger should return nil
    (should-not (supervisor-timer--next-startup-time timer))
    ;; Cleanup
    (clrhash supervisor--timer-state)))

(ert-deftest supervisor-test-timer-startup-consumed-on-skipped-run ()
  "Startup trigger is consumed even when run is skipped (disabled-target)."
  ;; Regression test: startup trigger must not cause 1s retry loop on skip
  (supervisor-test-with-unit-files
      '(("true" :id "s1" :type oneshot :disabled t))
    (let* ((timer (supervisor-timer--create :id "t1" :target "s1" :enabled t
                                            :on-startup-sec 10))
           (supervisor--timer-state (make-hash-table :test 'equal))
           (supervisor--processes (make-hash-table :test 'equal))
           (supervisor--enabled-override (make-hash-table :test 'equal))
           (supervisor--invalid (make-hash-table :test 'equal))
           (supervisor--scheduler-startup-time 1000.0))
      ;; Initialize next-run-at to startup trigger time
      (puthash "t1" '(:next-run-at 1010.0) supervisor--timer-state)
      ;; Simulate time is now past startup trigger
      (cl-letf (((symbol-function 'float-time) (lambda () 1015.0)))
        ;; Trigger should fail (target disabled)
        (should-not (supervisor-timer--trigger timer 'scheduled))
        ;; But startup-triggered should be set to prevent retry loop
        (let ((state (gethash "t1" supervisor--timer-state)))
          (should (plist-get state :startup-triggered)))
        ;; Next startup time should now be nil (consumed)
        (should-not (supervisor-timer--next-startup-time timer)))
      ;; Cleanup
      (clrhash supervisor--timer-state)
      (clrhash supervisor--processes)
      (clrhash supervisor--enabled-override)
      (clrhash supervisor--invalid))))

(ert-deftest supervisor-test-timer-scheduler-not-started-during-shutdown ()
  "Timer scheduler is not started when shutting down."
  (supervisor-test-with-unit-files
      '(("true" :id "s1" :type oneshot))
    (let ((supervisor--shutting-down t)
          (supervisor-timers '((:id "t1" :target "s1" :on-startup-sec 60)))
          (scheduler-started nil)
          (callback-ran nil))
      ;; Mock the scheduler start function
      (cl-letf (((symbol-function 'supervisor-timer-scheduler-start)
                 (lambda () (setq scheduler-started t))))
        ;; Simulate completion callback with no entries (immediate callback)
        (supervisor--start-entries-async
         nil
         (lambda ()
           (supervisor--dag-cleanup)
           (when (and (not supervisor--shutting-down)
                      (fboundp 'supervisor-timer-scheduler-start))
             (supervisor-timer-scheduler-start))
           (setq callback-ran t)))
        ;; Callback should have fired
        (should callback-ran)
        ;; Scheduler should NOT have been started
        (should-not scheduler-started)))))

;;; Phase 3: Retry and Catch-up Tests

(ert-deftest supervisor-test-timer-failure-retryable-positive-exit ()
  "Positive exit codes are retryable."
  (should (supervisor-timer--failure-retryable-p 1))
  (should (supervisor-timer--failure-retryable-p 127)))

(ert-deftest supervisor-test-timer-failure-not-retryable-signal ()
  "Signal deaths (stored as negative values) are not retryable.
Emacs provides signal numbers as positive values with process-status='signal.
The oneshot exit handler encodes these as negative for retry gating."
  (should-not (supervisor-timer--failure-retryable-p -9))   ; SIGKILL
  (should-not (supervisor-timer--failure-retryable-p -15))) ; SIGTERM

(ert-deftest supervisor-test-oneshot-exit-encodes-signal-as-negative ()
  "Signal deaths are stored as negative values in oneshot-completed.
This ensures retry eligibility correctly rejects signal deaths."
  (let ((supervisor--oneshot-completed (make-hash-table :test 'equal))
        (supervisor--oneshot-callbacks (make-hash-table :test 'equal))
        (supervisor--dag-blocking-oneshots nil)
        (supervisor--dag-in-degree (make-hash-table :test 'equal))
        (supervisor--dag-dependents (make-hash-table :test 'equal))
        (supervisor--dag-ready nil)
        (supervisor--event-handlers nil))
    ;; Simulate signal death: proc-status='signal, exit-code=9 (SIGKILL)
    (supervisor--handle-oneshot-exit "test-oneshot" 'signal 9)
    ;; Should be stored as -9
    (should (= -9 (gethash "test-oneshot" supervisor--oneshot-completed)))
    ;; Therefore not retryable
    (should-not (supervisor-timer--failure-retryable-p
                 (gethash "test-oneshot" supervisor--oneshot-completed)))))

(ert-deftest supervisor-test-oneshot-exit-preserves-normal-exit-code ()
  "Normal exit codes are stored as-is (positive values)."
  (let ((supervisor--oneshot-completed (make-hash-table :test 'equal))
        (supervisor--oneshot-callbacks (make-hash-table :test 'equal))
        (supervisor--dag-blocking-oneshots nil)
        (supervisor--dag-in-degree (make-hash-table :test 'equal))
        (supervisor--dag-dependents (make-hash-table :test 'equal))
        (supervisor--dag-ready nil)
        (supervisor--event-handlers nil))
    ;; Simulate normal exit: proc-status='exit, exit-code=1
    (supervisor--handle-oneshot-exit "test-oneshot" 'exit 1)
    ;; Should be stored as 1 (positive)
    (should (= 1 (gethash "test-oneshot" supervisor--oneshot-completed)))
    ;; Therefore retryable
    (should (supervisor-timer--failure-retryable-p
             (gethash "test-oneshot" supervisor--oneshot-completed)))))

(ert-deftest supervisor-test-timer-failure-not-retryable-zero ()
  "Zero exit (success) is not retryable."
  (should-not (supervisor-timer--failure-retryable-p 0)))

(ert-deftest supervisor-test-timer-failure-not-retryable-nil ()
  "Nil exit code is not retryable."
  (should-not (supervisor-timer--failure-retryable-p nil)))

(ert-deftest supervisor-test-signal-death-status-is-failed ()
  "Signal deaths (negative exit codes) are classified as failed in status.
This is a regression test: signals are non-retryable but still failed."
  (let ((supervisor--processes (make-hash-table :test 'equal))
        (supervisor--failed (make-hash-table :test 'equal))
        (supervisor--oneshot-completed (make-hash-table :test 'equal)))
    ;; Simulate SIGKILL death stored as -9
    (puthash "test-oneshot" -9 supervisor--oneshot-completed)
    (let ((result (supervisor--compute-entry-status "test-oneshot" 'oneshot)))
      (should (equal "failed" (car result)))
      (should (equal "exit:-9" (cdr result))))))

(ert-deftest supervisor-test-signal-death-dashboard-count-is-failed ()
  "Signal deaths are counted as failed in dashboard summary."
  (supervisor-test-with-unit-files
      '(("true" :id "sig-test" :type oneshot))
    (let ((supervisor--processes (make-hash-table :test 'equal))
          (supervisor--failed (make-hash-table :test 'equal))
          (supervisor--oneshot-completed (make-hash-table :test 'equal))
          (supervisor--invalid (make-hash-table :test 'equal)))
      ;; Simulate SIGTERM death stored as -15
      (puthash "sig-test" -15 supervisor--oneshot-completed)
      (let ((summary (supervisor--health-summary)))
        ;; Should show 1 fail, not 1 done
        (should (string-match-p "1 fail" summary))
        (should-not (string-match-p "1 done" summary))))))

(ert-deftest supervisor-test-timer-schedule-retry-first-attempt ()
  "First retry is scheduled with first interval."
  (let ((supervisor-timer-retry-intervals '(30 120 600))
        (supervisor--timer-state (make-hash-table :test 'equal))
        (state nil))
    (puthash "t1" state supervisor--timer-state)
    (cl-letf (((symbol-function 'float-time) (lambda () 1000.0)))
      (let ((updated (supervisor-timer--schedule-retry "t1" state)))
        (should updated)
        (should (= 1 (plist-get updated :retry-attempt)))
        (should (= 1030.0 (plist-get updated :retry-next-at)))))
    (clrhash supervisor--timer-state)))

(ert-deftest supervisor-test-timer-schedule-retry-second-attempt ()
  "Second retry uses second interval."
  (let ((supervisor-timer-retry-intervals '(30 120 600))
        (supervisor--timer-state (make-hash-table :test 'equal))
        (state '(:retry-attempt 1)))
    (puthash "t1" state supervisor--timer-state)
    (cl-letf (((symbol-function 'float-time) (lambda () 1000.0)))
      (let ((updated (supervisor-timer--schedule-retry "t1" state)))
        (should updated)
        (should (= 2 (plist-get updated :retry-attempt)))
        (should (= 1120.0 (plist-get updated :retry-next-at)))))
    (clrhash supervisor--timer-state)))

(ert-deftest supervisor-test-timer-schedule-retry-exhausted ()
  "No retry scheduled when max attempts reached."
  (let ((supervisor-timer-retry-intervals '(30 120 600))
        (supervisor--timer-state (make-hash-table :test 'equal))
        (state '(:retry-attempt 3)))
    (puthash "t1" state supervisor--timer-state)
    (should-not (supervisor-timer--schedule-retry "t1" state))
    (clrhash supervisor--timer-state)))

(ert-deftest supervisor-test-timer-schedule-retry-disabled ()
  "No retry when retry-intervals is nil."
  (let ((supervisor-timer-retry-intervals nil)
        (supervisor--timer-state (make-hash-table :test 'equal))
        (state nil))
    (puthash "t1" state supervisor--timer-state)
    (should-not (supervisor-timer--schedule-retry "t1" state))
    (clrhash supervisor--timer-state)))

(ert-deftest supervisor-test-timer-catch-up-needed ()
  "Catch-up detected for persistent timer with missed run."
  (let* ((timer (supervisor-timer--create :id "t1" :target "s1"
                                          :on-calendar '(:minute 0)
                                          :persistent t))
         (supervisor--timer-state (make-hash-table :test 'equal))
         (supervisor--scheduler-startup-time 1000.0)
         (supervisor-timer-catch-up-limit 86400))
    ;; Last run was 2 hours ago, missed the hourly schedule
    (puthash "t1" '(:last-run-at 900.0) supervisor--timer-state)
    ;; Mock calendar computation to return a time in the past
    (cl-letf (((symbol-function 'supervisor-timer--compute-next-run)
               (lambda (_timer _from) 950.0))
              ((symbol-function 'float-time) (lambda () 1000.0)))
      (should (supervisor-timer--needs-catch-up-p timer)))
    (clrhash supervisor--timer-state)))

(ert-deftest supervisor-test-timer-catch-up-not-needed-recent ()
  "No catch-up for timer with recent run."
  (let* ((timer (supervisor-timer--create :id "t1" :target "s1"
                                          :on-calendar '(:minute 0)
                                          :persistent t))
         (supervisor--timer-state (make-hash-table :test 'equal))
         (supervisor--scheduler-startup-time 1000.0)
         (supervisor-timer-catch-up-limit 86400))
    ;; Last run was just now
    (puthash "t1" '(:last-run-at 999.0) supervisor--timer-state)
    ;; Mock calendar computation to return a time in the future
    (cl-letf (((symbol-function 'supervisor-timer--compute-next-run)
               (lambda (_timer _from) 1060.0))
              ((symbol-function 'float-time) (lambda () 1000.0)))
      (should-not (supervisor-timer--needs-catch-up-p timer)))
    (clrhash supervisor--timer-state)))

(ert-deftest supervisor-test-timer-catch-up-not-needed-non-persistent ()
  "No catch-up for non-persistent timer."
  (let* ((timer (supervisor-timer--create :id "t1" :target "s1"
                                          :on-calendar '(:minute 0)
                                          :persistent nil))
         (supervisor--timer-state (make-hash-table :test 'equal))
         (supervisor--scheduler-startup-time 1000.0)
         (supervisor-timer-catch-up-limit 86400))
    (puthash "t1" '(:last-run-at 900.0) supervisor--timer-state)
    (should-not (supervisor-timer--needs-catch-up-p timer))
    (clrhash supervisor--timer-state)))

(ert-deftest supervisor-test-timer-catch-up-not-needed-too-old ()
  "No catch-up for missed run beyond catch-up limit."
  (let* ((timer (supervisor-timer--create :id "t1" :target "s1"
                                          :on-calendar '(:minute 0)
                                          :persistent t))
         (supervisor--timer-state (make-hash-table :test 'equal))
         (supervisor--scheduler-startup-time 100000.0)
         (supervisor-timer-catch-up-limit 86400))
    ;; Last run was way before catch-up window
    (puthash "t1" '(:last-run-at 1000.0) supervisor--timer-state)
    ;; Mock calendar computation to return a time before catch-up window
    (cl-letf (((symbol-function 'supervisor-timer--compute-next-run)
               (lambda (_timer _from) 2000.0))  ; Before cutoff
              ((symbol-function 'float-time) (lambda () 100000.0)))
      (should-not (supervisor-timer--needs-catch-up-p timer)))
    (clrhash supervisor--timer-state)))

(ert-deftest supervisor-test-timer-catch-up-boundary-no-false-trigger ()
  "No false catch-up when last-run-at is exactly at schedule boundary.
The fix passes (1+ last-run) to compute-next-run to avoid the case where
compute-next-run returns the same timestamp as last-run for calendar timers
at minute boundaries."
  (let* ((timer (supervisor-timer--create :id "t1" :target "s1"
                                          :on-calendar '(:minute 0)
                                          :persistent t))
         (supervisor--timer-state (make-hash-table :test 'equal))
         (supervisor--scheduler-startup-time 1000.0)
         (supervisor-timer-catch-up-limit 86400)
         (call-count 0)
         (from-times nil))
    ;; Last run was at exactly time 900.0 (a schedule boundary)
    (puthash "t1" '(:last-run-at 900.0) supervisor--timer-state)
    ;; Mock compute-next-run to return 900.0 when called with 900.0,
    ;; but return future time 1800.0 when called with 901.0
    ;; This simulates the boundary condition we fixed
    (cl-letf (((symbol-function 'supervisor-timer--compute-next-run)
               (lambda (_timer from)
                 (setq call-count (1+ call-count))
                 (push from from-times)
                 (if (= from 900.0) 900.0 1800.0)))
              ((symbol-function 'float-time) (lambda () 1000.0)))
      ;; Should NOT need catch-up because next run is in the future
      (should-not (supervisor-timer--needs-catch-up-p timer))
      ;; Verify we called with 901.0 (last-run + 1), not 900.0
      (should (= call-count 1))
      (should (= (car from-times) 901.0)))
    (clrhash supervisor--timer-state)))

(ert-deftest supervisor-test-timer-state-to-alist ()
  "Timer state to alist only includes persist keys."
  (let ((supervisor--timer-state (make-hash-table :test 'equal)))
    (puthash "t1" '(:last-run-at 1000.0
                    :last-success-at 1000.0
                    :next-run-at 2000.0
                    :retry-attempt 1
                    :startup-triggered t)
             supervisor--timer-state)
    (let ((alist (supervisor--timer-state-to-alist)))
      ;; Should include persisted keys
      (should (equal (alist-get "t1" alist nil nil #'equal)
                     '(:last-run-at 1000.0 :last-success-at 1000.0)))
      ;; Transient keys should not be included
      (should-not (plist-get (cdr (assoc "t1" alist)) :next-run-at))
      (should-not (plist-get (cdr (assoc "t1" alist)) :retry-attempt))
      (should-not (plist-get (cdr (assoc "t1" alist)) :startup-triggered)))
    (clrhash supervisor--timer-state)))

(ert-deftest supervisor-test-timer-state-save-load-roundtrip ()
  "Timer state survives save/load cycle."
  (let* ((supervisor-timer-subsystem-mode t)
         (supervisor-mode t)
         (temp-file (make-temp-file "supervisor-test-timer-state-" nil ".eld"))
         (supervisor-timer-state-file temp-file)
         (supervisor--timer-state (make-hash-table :test 'equal)))
    (unwind-protect
        (progn
          ;; Save some state
          (puthash "t1" '(:last-run-at 1000.0 :last-success-at 1000.0)
                   supervisor--timer-state)
          (puthash "t2" '(:last-failure-at 900.0 :last-exit 1)
                   supervisor--timer-state)
          (should (supervisor-timer--save-state))
          ;; Clear and reconcile
          (clrhash supervisor--timer-state)
          (should (supervisor-timer--load-state))
          ;; Verify state restored
          (let ((t1 (gethash "t1" supervisor--timer-state))
                (t2 (gethash "t2" supervisor--timer-state)))
            (should (equal (plist-get t1 :last-run-at) 1000.0))
            (should (equal (plist-get t1 :last-success-at) 1000.0))
            (should (equal (plist-get t2 :last-failure-at) 900.0))
            (should (equal (plist-get t2 :last-exit) 1))))
      (delete-file temp-file)
      (clrhash supervisor--timer-state))))

(ert-deftest supervisor-test-timer-state-corrupt-file-handled ()
  "Corrupt timer state file is handled gracefully."
  (let* ((supervisor-timer-subsystem-mode t)
         (supervisor-mode t)
         (temp-file (make-temp-file "supervisor-test-corrupt-" nil ".eld"))
         (supervisor-timer-state-file temp-file)
         (supervisor--timer-state (make-hash-table :test 'equal)))
    (unwind-protect
        (progn
          (with-temp-file temp-file
            (insert "this is not valid lisp data"))
          (should-not (supervisor-timer--load-state))
          ;; Hash should remain unchanged
          (should (= (hash-table-count supervisor--timer-state) 0)))
      (delete-file temp-file)
      (clrhash supervisor--timer-state))))

(ert-deftest supervisor-test-timer-state-persistence-disabled ()
  "Nil timer state file path disables persistence."
  (let ((supervisor-timer-subsystem-mode t)
        (supervisor-timer-state-file nil)
        (supervisor--timer-state (make-hash-table :test 'equal)))
    (puthash "t1" '(:last-run-at 1000.0) supervisor--timer-state)
    ;; Save returns nil when disabled
    (should-not (supervisor-timer--save-state))
    ;; Load returns nil when disabled
    (should-not (supervisor-timer--load-state))
    (clrhash supervisor--timer-state)))

(ert-deftest supervisor-test-timer-state-file-path ()
  "Timer state file path helper returns configured path."
  (let ((supervisor-timer-state-file "/test/path/timer-state.eld"))
    (should (equal (supervisor--timer-state-file-path) "/test/path/timer-state.eld")))
  (let ((supervisor-timer-state-file nil))
    (should-not (supervisor--timer-state-file-path))))

(ert-deftest supervisor-test-timer-state-newer-version-rejected ()
  "Newer schema version is rejected, not just warned."
  (let* ((supervisor-timer-subsystem-mode t)
         (supervisor-mode t)
         (temp-file (make-temp-file "supervisor-test-version-" nil ".eld"))
         (supervisor-timer-state-file temp-file)
         (supervisor--timer-state (make-hash-table :test 'equal)))
    (unwind-protect
        (progn
          ;; Write file with future version
          (with-temp-file temp-file
            (insert (format "((version . %d) (timestamp . \"test\") (timers . ((\"t1\" :last-run-at 1000.0))))"
                            (1+ supervisor-timer-state-schema-version))))
          ;; Load should fail
          (should-not (supervisor-timer--load-state))
          ;; Hash should remain empty (data not merged)
          (should (= (hash-table-count supervisor--timer-state) 0)))
      (delete-file temp-file)
      (clrhash supervisor--timer-state))))

(ert-deftest supervisor-test-timer-state-stale-ids-pruned ()
  "Stale timer IDs are pruned from state during scheduler startup."
  (supervisor-test-with-unit-files
      '(("true" :id "s1" :type oneshot))
    (let* ((supervisor-timer-subsystem-mode t)
           (supervisor-mode t)
           (supervisor-timers '((:id "active" :target "s1" :on-startup-sec 60)))
           (supervisor--timer-state (make-hash-table :test 'equal))
           (supervisor--timer-list nil)
           (supervisor--timer-scheduler nil)
           (supervisor--shutting-down nil)
           (supervisor--scheduler-startup-time nil)
           (supervisor-timer-state-file nil))
      ;; Pre-populate state with a stale ID
      (puthash "stale-removed" '(:last-run-at 500.0) supervisor--timer-state)
      (puthash "active" '(:last-run-at 900.0) supervisor--timer-state)
      ;; Mock to prevent actual scheduling
      (cl-letf (((symbol-function 'supervisor--timer-scheduler-tick) #'ignore)
                ((symbol-function 'supervisor-timer--process-catch-ups) #'ignore)
                ((symbol-function 'float-time) (lambda () 1000.0)))
        (supervisor-timer-scheduler-start))
      ;; Stale ID should be pruned
      (should-not (gethash "stale-removed" supervisor--timer-state))
      ;; Active ID should remain
      (should (gethash "active" supervisor--timer-state))
      (clrhash supervisor--timer-state))))

(ert-deftest supervisor-test-timer-cross-restart-catch-up ()
  "Integration test: scheduler startup with persisted state triggers catch-up."
  (supervisor-test-with-unit-files
      '(("true" :id "s1" :type oneshot))
    (let* ((supervisor-timer-subsystem-mode t)
           (supervisor-mode t)
           (temp-file (make-temp-file "supervisor-test-catchup-" nil ".eld"))
           (supervisor-timers '((:id "t1" :target "s1" :on-calendar (:minute 0)
                                 :persistent t)))
           (supervisor--timer-state (make-hash-table :test 'equal))
           (supervisor--timer-list nil)
           (supervisor--timer-scheduler nil)
           (supervisor--shutting-down nil)
           (supervisor--scheduler-startup-time nil)
           (supervisor--timer-state-loaded nil)
           (supervisor-timer-state-file temp-file)
           (supervisor-timer-catch-up-limit 86400)
           (catch-up-triggered nil))
      (unwind-protect
          (progn
            ;; Write persisted state with old last-run (simulates restart)
            (with-temp-file temp-file
              (insert (format "((version . %d) (timestamp . \"test\") (timers . ((\"t1\" :last-run-at 900.0 :last-success-at 900.0))))"
                              supervisor-timer-state-schema-version)))
            ;; Mock to track catch-up and prevent actual scheduling
            (cl-letf (((symbol-function 'supervisor--timer-scheduler-tick) #'ignore)
                      ((symbol-function 'supervisor-timer--trigger)
                       (lambda (_timer reason)
                         (when (eq reason 'catch-up)
                           (setq catch-up-triggered t))))
                      ;; Mock calendar to return a time between last-run and now
                      ((symbol-function 'supervisor-timer--compute-next-run)
                       (lambda (_timer _from) 950.0))
                      ((symbol-function 'float-time) (lambda () 1000.0)))
              (supervisor-timer-scheduler-start))
            ;; Verify state was loaded from file
            (should supervisor--timer-state-loaded)
            ;; Verify catch-up was triggered
            (should catch-up-triggered))
        (when (file-exists-p temp-file) (delete-file temp-file))
        (clrhash supervisor--timer-state)))))

(ert-deftest supervisor-test-timer-catch-up-no-double-trigger ()
  "Catch-up followed by tick does not double-trigger the same timer.
After catch-up, :next-run-at must not remain in the past."
  (let* ((supervisor-timer-subsystem-mode t)
         (supervisor-mode t)
         (timer (supervisor-timer--create :id "t1" :target "s1"
                                          :on-calendar '(:minute 0)
                                          :persistent t :enabled t))
         (supervisor--timer-list (list timer))
         (supervisor--timer-state (make-hash-table :test 'equal))
         (supervisor--timer-scheduler nil)
         (supervisor--shutting-down nil)
         (supervisor--scheduler-startup-time 1000.0)
         (supervisor-timer-catch-up-limit 86400)
         (trigger-reasons nil))
    ;; Seed state: last run was 100s ago, next-run in the past
    (puthash "t1" '(:last-run-at 900.0 :next-run-at 950.0)
             supervisor--timer-state)
    (cl-letf (((symbol-function 'supervisor-timer--trigger)
               (lambda (_timer reason)
                 (push reason trigger-reasons)))
              ((symbol-function 'supervisor-timer--compute-next-run)
               (lambda (_timer _from) 950.0))
              ((symbol-function 'float-time) (lambda () 1000.0))
              ((symbol-function 'run-at-time) (lambda (&rest _) nil)))
      ;; Process catch-ups, then tick
      (supervisor-timer--process-catch-ups)
      ;; :next-run-at must be nil (cleared because still in past)
      (should-not (plist-get (gethash "t1" supervisor--timer-state)
                             :next-run-at))
      ;; Now run tick -- should NOT trigger again
      (supervisor--timer-scheduler-tick)
      ;; Only catch-up should have fired, not scheduled
      (should (equal '(catch-up) (reverse trigger-reasons))))
    (clrhash supervisor--timer-state)))

(ert-deftest supervisor-test-timer-catch-up-simple-target ()
  "Catch-up fires for simple target type timer."
  (let* ((supervisor-timer-subsystem-mode t)
         (supervisor-mode t)
         (timer (supervisor-timer--create :id "t1" :target "s1"
                                          :on-calendar '(:minute 0)
                                          :persistent t :enabled t))
         (supervisor--timer-list (list timer))
         (supervisor--timer-state (make-hash-table :test 'equal))
         (supervisor--scheduler-startup-time 1000.0)
         (supervisor-timer-catch-up-limit 86400)
         (entry (list "s1" "echo hi" 0 t nil nil nil nil 'simple nil nil
                      nil nil nil nil nil nil nil nil nil nil nil nil
                      nil nil nil nil nil nil nil nil nil nil))
         (triggered nil))
    (puthash "t1" '(:last-run-at 900.0 :last-success-at 900.0)
             supervisor--timer-state)
    (cl-letf (((symbol-function 'supervisor-timer--compute-next-run)
               (lambda (_timer _from) 950.0))
              ((symbol-function 'float-time) (lambda () 1000.0))
              ((symbol-function 'supervisor-timer--get-entry-for-id)
               (lambda (_id) entry))
              ((symbol-function 'supervisor--get-effective-enabled)
               (lambda (_id _p) t))
              ((symbol-function 'supervisor--start-entry-async)
               (lambda (_entry _cb) (setq triggered 'simple)))
              ((symbol-function 'supervisor-timer--save-state) #'ignore)
              ((symbol-function 'supervisor--emit-event) #'ignore)
              ((symbol-function 'supervisor--log) #'ignore))
      (supervisor-timer--process-catch-ups)
      (should (eq 'simple triggered)))
    (clrhash supervisor--timer-state)))

(ert-deftest supervisor-test-timer-catch-up-target-type ()
  "Catch-up fires for target-type timer."
  (let* ((supervisor-timer-subsystem-mode t)
         (supervisor-mode t)
         (timer (supervisor-timer--create :id "t1" :target "app.target"
                                          :on-calendar '(:minute 0)
                                          :persistent t :enabled t))
         (supervisor--timer-list (list timer))
         (supervisor--timer-state (make-hash-table :test 'equal))
         (supervisor--scheduler-startup-time 1000.0)
         (supervisor-timer-catch-up-limit 86400)
         (entry (list "app.target" nil 0 t nil nil nil nil 'target nil nil
                      nil nil nil nil nil nil nil nil nil nil nil nil
                      nil nil nil nil nil nil nil nil nil nil))
         (supervisor--mask-override (make-hash-table :test 'equal))
         (triggered-reason nil))
    (puthash "t1" '(:last-run-at 900.0 :last-success-at 900.0)
             supervisor--timer-state)
    (cl-letf (((symbol-function 'supervisor-timer--compute-next-run)
               (lambda (_timer _from) 950.0))
              ((symbol-function 'float-time) (lambda () 1000.0))
              ((symbol-function 'supervisor-timer--get-entry-for-id)
               (lambda (_id) entry))
              ((symbol-function 'supervisor--get-effective-enabled)
               (lambda (_id _p) t))
              ((symbol-function 'supervisor-timer--trigger-target)
               (lambda (_timer reason)
                 (setq triggered-reason reason)))
              ((symbol-function 'supervisor-timer--save-state) #'ignore)
              ((symbol-function 'supervisor--emit-event) #'ignore)
              ((symbol-function 'supervisor--log) #'ignore))
      (supervisor-timer--process-catch-ups)
      (should (eq 'catch-up triggered-reason)))
    (clrhash supervisor--timer-state)))

(ert-deftest supervisor-test-timer-scheduler-tick-handles-retry ()
  "Scheduler tick triggers retry when due."
  (let* ((supervisor-timer-subsystem-mode t)
         (supervisor-mode t)
         (timer (supervisor-timer--create :id "t1" :target "s1" :enabled t))
         (supervisor--timer-list (list timer))
         (supervisor--timer-state (make-hash-table :test 'equal))
         (supervisor--timer-scheduler nil)
         (supervisor--shutting-down nil)
         (triggered-reason nil))
    ;; Set up state with pending retry
    (puthash "t1" '(:retry-next-at 999.0 :next-run-at 2000.0)
             supervisor--timer-state)
    ;; Mock trigger to capture reason
    (cl-letf (((symbol-function 'supervisor-timer--trigger)
               (lambda (_timer reason) (setq triggered-reason reason)))
              ((symbol-function 'float-time) (lambda () 1000.0)))
      (supervisor--timer-scheduler-tick)
      (should (eq 'retry triggered-reason)))
    (clrhash supervisor--timer-state)))

(ert-deftest supervisor-test-timer-retry-budget-reset-on-scheduled ()
  "Retry budget is reset on fresh scheduled trigger."
  (let* ((supervisor-timer-subsystem-mode t)
         (supervisor-mode t)
         (timer (supervisor-timer--create :id "t1" :target "s1" :enabled t))
         (supervisor--timer-list (list timer))
         (supervisor--timer-state (make-hash-table :test 'equal))
         (supervisor--timer-scheduler nil)
         (supervisor--shutting-down nil))
    ;; Set up state with exhausted retry budget and due scheduled run
    (puthash "t1" '(:retry-attempt 3 :retry-next-at nil :next-run-at 999.0)
             supervisor--timer-state)
    ;; Mock trigger and update functions
    (cl-letf (((symbol-function 'supervisor-timer--trigger)
               (lambda (_timer _reason) nil))
              ((symbol-function 'supervisor-timer--update-next-run)
               (lambda (_id) nil))
              ((symbol-function 'float-time) (lambda () 1000.0)))
      (supervisor--timer-scheduler-tick)
      ;; Retry budget should be reset
      (let ((state (gethash "t1" supervisor--timer-state)))
        (should (= 0 (plist-get state :retry-attempt)))
        (should-not (plist-get state :retry-next-at))))
    (clrhash supervisor--timer-state)))

(ert-deftest supervisor-test-timer-scheduler-tick-scheduled ()
  "Scheduler tick triggers scheduled run when due."
  (let* ((supervisor-timer-subsystem-mode t)
         (supervisor-mode t)
         (timer (supervisor-timer--create :id "t1" :target "s1" :enabled t))
         (supervisor--timer-list (list timer))
         (supervisor--timer-state (make-hash-table :test 'equal))
         (supervisor--timer-scheduler nil)
         (supervisor--shutting-down nil)
         (triggered-reason nil))
    ;; Set up state with scheduled run due
    (puthash "t1" '(:next-run-at 999.0) supervisor--timer-state)
    ;; Mock trigger to capture reason
    (cl-letf (((symbol-function 'supervisor-timer--trigger)
               (lambda (_timer reason) (setq triggered-reason reason)))
              ((symbol-function 'float-time) (lambda () 1000.0)))
      (supervisor--timer-scheduler-tick)
      (should (eq 'scheduled triggered-reason)))
    (clrhash supervisor--timer-state)))

(ert-deftest supervisor-test-timer-scheduler-tick-disabled-skips ()
  "Scheduler tick skips disabled timers."
  (let* ((timer (supervisor-timer--create :id "t1" :target "s1" :enabled nil))
         (supervisor--timer-list (list timer))
         (supervisor--timer-state (make-hash-table :test 'equal))
         (supervisor--timer-scheduler nil)
         (supervisor--shutting-down nil)
         (triggered nil))
    ;; Set up state with scheduled run due
    (puthash "t1" '(:next-run-at 999.0) supervisor--timer-state)
    ;; Mock trigger to detect if called
    (cl-letf (((symbol-function 'supervisor-timer--trigger)
               (lambda (_timer _reason) (setq triggered t)))
              ((symbol-function 'float-time) (lambda () 1000.0))
              ((symbol-function 'run-at-time) (lambda (&rest _) nil)))
      (supervisor--timer-scheduler-tick)
      ;; Should not trigger disabled timer
      (should-not triggered))
    (clrhash supervisor--timer-state)))

(ert-deftest supervisor-test-timer-scheduler-tick-simultaneous-order ()
  "Scheduler tick processes simultaneous due timers in list order."
  (let* ((supervisor-timer-subsystem-mode t)
         (supervisor-mode t)
         (timer1 (supervisor-timer--create :id "t1" :target "s1" :enabled t))
         (timer2 (supervisor-timer--create :id "t2" :target "s2" :enabled t))
         (timer3 (supervisor-timer--create :id "t3" :target "s3" :enabled t))
         ;; List order is t1, t2, t3
         (supervisor--timer-list (list timer1 timer2 timer3))
         (supervisor--timer-state (make-hash-table :test 'equal))
         (supervisor--timer-scheduler nil)
         (supervisor--shutting-down nil)
         (trigger-order nil))
    ;; All timers due at same time
    (puthash "t1" '(:next-run-at 999.0) supervisor--timer-state)
    (puthash "t2" '(:next-run-at 999.0) supervisor--timer-state)
    (puthash "t3" '(:next-run-at 999.0) supervisor--timer-state)
    ;; Capture trigger order
    (cl-letf (((symbol-function 'supervisor-timer--trigger)
               (lambda (timer _reason)
                 (push (supervisor-timer-id timer) trigger-order)))
              ((symbol-function 'supervisor-timer--update-next-run)
               (lambda (_id) nil))
              ((symbol-function 'float-time) (lambda () 1000.0))
              ((symbol-function 'run-at-time) (lambda (&rest _) nil)))
      (supervisor--timer-scheduler-tick)
      ;; Should process in list order: t1, t2, t3
      (should (equal '("t1" "t2" "t3") (nreverse trigger-order))))
    (clrhash supervisor--timer-state)))

(ert-deftest supervisor-test-cli-relative-time-formatter ()
  "Relative time formatter handles various time differences."
  ;; Test with mock time at 100000
  (cl-letf (((symbol-function 'float-time) (lambda () 100000.0)))
    ;; Recent past (seconds)
    (should (string-match "\\`[0-9]+s ago\\'" (supervisor--cli-format-relative-time 99990.0)))
    ;; Minutes ago
    (should (string-match "\\`[0-9]+m ago\\'" (supervisor--cli-format-relative-time 99800.0)))
    ;; Hours ago (2h = 7200s, so 100000 - 10000 = 90000)
    (should (string-match "\\`[0-9]+h ago\\'" (supervisor--cli-format-relative-time 90000.0)))
    ;; Future (in X)
    (should (string-match "\\`in [0-9]+s\\'" (supervisor--cli-format-relative-time 100010.0)))
    (should (string-match "\\`in [0-9]+m\\'" (supervisor--cli-format-relative-time 100200.0)))
    ;; Nil returns dash
    (should (equal "-" (supervisor--cli-format-relative-time nil)))))

(ert-deftest supervisor-test-cli-relative-time-boundaries ()
  "Relative time formatter handles exact boundaries correctly."
  (cl-letf (((symbol-function 'float-time) (lambda () 100000.0)))
    ;; Exactly 60 seconds (boundary between s and m)
    (should (string-match "\\`1m ago\\'" (supervisor--cli-format-relative-time 99940.0)))
    ;; 59 seconds (should be seconds)
    (should (string-match "\\`59s ago\\'" (supervisor--cli-format-relative-time 99941.0)))
    ;; Exactly 3600 seconds (boundary between m and h)
    (should (string-match "\\`1h ago\\'" (supervisor--cli-format-relative-time 96400.0)))
    ;; 3599 seconds (should be minutes)
    (should (string-match "\\`60m ago\\'" (supervisor--cli-format-relative-time 96401.0)))
    ;; Exactly 86400 seconds (boundary between h and d)
    (should (string-match "\\`1d ago\\'" (supervisor--cli-format-relative-time 13600.0)))
    ;; Day path works for large values
    (should (string-match "\\`2d ago\\'" (supervisor--cli-format-relative-time (- 100000.0 (* 2 86400)))))
    ;; Future day path
    (should (string-match "\\`in 2d\\'" (supervisor--cli-format-relative-time (+ 100000.0 (* 2 86400)))))))

(ert-deftest supervisor-test-timer-state-load-merges-correctly ()
  "Load timer state merges with existing runtime state."
  (let* ((supervisor-timer-subsystem-mode t)
         (supervisor-mode t)
         (temp-file (make-temp-file "supervisor-test-merge-" nil ".eld"))
         (supervisor-timer-state-file temp-file)
         (supervisor--timer-state (make-hash-table :test 'equal)))
    (unwind-protect
        (progn
          ;; Create state file with persisted data
          (with-temp-file temp-file
            (insert ";; Test state\n")
            (pp '((version . 1)
                  (timestamp . "2024-01-01T00:00:00")
                  (timers . (("t1" :last-run-at 500.0 :last-success-at 500.0))))
                (current-buffer)))
          ;; Pre-populate runtime state
          (puthash "t1" '(:next-run-at 2000.0 :retry-attempt 1)
                   supervisor--timer-state)
          ;; Load should merge
          (should (supervisor-timer--load-state))
          (let ((state (gethash "t1" supervisor--timer-state)))
            ;; Should have persisted keys from file
            (should (equal (plist-get state :last-run-at) 500.0))
            (should (equal (plist-get state :last-success-at) 500.0))
            ;; Should preserve runtime keys
            (should (equal (plist-get state :next-run-at) 2000.0))
            (should (equal (plist-get state :retry-attempt) 1))))
      (delete-file temp-file)
      (clrhash supervisor--timer-state))))

(ert-deftest supervisor-test-timer-state-v1-load-saves-as-v2 ()
  "Loading v1 state and saving writes v2 schema metadata."
  (let* ((supervisor-timer-subsystem-mode t)
         (supervisor-mode t)
         (temp-file (make-temp-file "supervisor-test-v1-upgrade-" nil ".eld"))
         (supervisor-timer-state-file temp-file)
         (supervisor--timer-state (make-hash-table :test 'equal))
         (supervisor--timer-state-loaded nil))
    (unwind-protect
        (progn
          ;; Write v1 state file
          (with-temp-file temp-file
            (pp '((version . 1)
                  (timestamp . "2024-01-01T00:00:00")
                  (timers . (("t1" :last-run-at 500.0
                              :last-success-at 500.0))))
                (current-buffer)))
          ;; Load v1
          (should (supervisor-timer--load-state))
          ;; Save -- should write v2
          (supervisor-timer--save-state)
          ;; Re-read file and verify version
          (let* ((data (with-temp-buffer
                         (insert-file-contents temp-file)
                         (read (current-buffer))))
                 (version (alist-get 'version data)))
            (should (= supervisor-timer-state-schema-version version))
            (should (= 2 version))))
      (delete-file temp-file)
      (clrhash supervisor--timer-state))))

(ert-deftest supervisor-test-timer-multiple-triggers-earliest-wins ()
  "Timer with multiple triggers uses earliest due time."
  (let* ((timer (supervisor-timer--create :id "t1" :target "s1"
                                          :on-startup-sec 60
                                          :on-unit-active-sec 120))
         (supervisor--timer-state (make-hash-table :test 'equal))
         (supervisor--scheduler-startup-time 1000.0))
    ;; Set last success for unit-active calculation
    (puthash "t1" '(:last-success-at 900.0) supervisor--timer-state)
    ;; Startup trigger: 1000 + 60 = 1060
    ;; Unit-active trigger: 900 + 120 = 1020 (earlier)
    (let ((next (supervisor-timer--compute-next-run timer 1001.0)))
      (should (= 1020.0 next)))
    (clrhash supervisor--timer-state)))

;;; Timer Subsystem Gating Tests

(ert-deftest supervisor-test-timer-gate-scheduler-start-noop ()
  "Scheduler start is a no-op when timer subsystem is disabled."
  (supervisor-test-with-unit-files
      '(("true" :id "s1" :type oneshot))
    (let ((supervisor-timer-subsystem-mode nil)
          (supervisor-timers '((:id "t1" :target "s1" :on-startup-sec 60)))
          (supervisor--timer-list nil)
          (supervisor--timer-scheduler nil)
          (supervisor--shutting-down nil)
          (supervisor--scheduler-startup-time nil)
          (supervisor--timer-state-loaded nil)
          (supervisor-timer-state-file nil))
      ;; Start should do nothing when gated off
      (supervisor-timer-scheduler-start)
      ;; Timer list should remain empty
      (should (null supervisor--timer-list))
      ;; Scheduler should not be running
      (should (null supervisor--timer-scheduler)))))

(ert-deftest supervisor-test-timer-gate-state-save-noop ()
  "State save is a no-op when timer subsystem is disabled."
  (let* ((supervisor-timer-subsystem-mode nil)
         (temp-file (concat (make-temp-name
                             (expand-file-name "supervisor-test-gate-"
                                               temporary-file-directory))
                            ".eld"))
         (supervisor-timer-state-file temp-file)
         (supervisor--timer-state (make-hash-table :test 'equal)))
    (unwind-protect
        (progn
          (puthash "t1" '(:last-run-at 1000.0) supervisor--timer-state)
          ;; Save should return nil when gated off
          (should-not (supervisor-timer--save-state))
          ;; File should NOT be created
          (should-not (file-exists-p temp-file)))
      (when (file-exists-p temp-file) (delete-file temp-file))
      (clrhash supervisor--timer-state))))

(ert-deftest supervisor-test-timer-gate-state-load-noop ()
  "State load is a no-op when timer subsystem is disabled."
  (let* ((supervisor-timer-subsystem-mode nil)
         (temp-file (make-temp-file "supervisor-test-gate-" nil ".eld"))
         (supervisor-timer-state-file temp-file)
         (supervisor--timer-state (make-hash-table :test 'equal)))
    (unwind-protect
        (progn
          ;; Write a valid state file
          (with-temp-file temp-file
            (insert (format "((version . %d) (timestamp . \"test\") (timers . ((\"t1\" :last-run-at 1000.0))))"
                            supervisor-timer-state-schema-version)))
          ;; Load should return nil when gated off
          (should-not (supervisor-timer--load-state))
          ;; State should NOT be populated
          (should (= 0 (hash-table-count supervisor--timer-state))))
      (delete-file temp-file)
      (clrhash supervisor--timer-state))))

(ert-deftest supervisor-test-timer-gate-scheduler-tick-noop ()
  "Scheduler tick is a no-op when timer subsystem is disabled."
  (let* ((supervisor-timer-subsystem-mode nil)
         (timer (supervisor-timer--create :id "t1" :target "s1" :enabled t
                                          :on-startup-sec 1))
         (supervisor--timer-list (list timer))
         (supervisor--timer-state (make-hash-table :test 'equal))
         (supervisor--timer-scheduler nil)
         (supervisor--shutting-down nil)
         (triggered nil))
    ;; Set up state so timer would be due
    (puthash "t1" '(:next-run-at 900.0) supervisor--timer-state)
    ;; Mock trigger to detect if called
    (cl-letf (((symbol-function 'supervisor-timer--trigger)
               (lambda (_timer _reason) (setq triggered t)))
              ((symbol-function 'float-time) (lambda () 1000.0)))
      (supervisor--timer-scheduler-tick))
    ;; Timer should NOT have been triggered
    (should-not triggered)
    (clrhash supervisor--timer-state)))

(ert-deftest supervisor-test-timer-gate-enabled-works ()
  "Timer functions work normally when subsystem is enabled."
  (let* ((supervisor-timer-subsystem-mode t)
         (supervisor-mode t)  ; Parent mode must also be enabled
         (timer (supervisor-timer--create :id "t1" :target "s1" :enabled t
                                          :on-startup-sec 1))
         (supervisor--timer-list (list timer))
         (supervisor--timer-state (make-hash-table :test 'equal))
         (supervisor--timer-scheduler nil)
         (supervisor--shutting-down nil)
         (triggered nil))
    ;; Set up state so timer would be due
    (puthash "t1" '(:next-run-at 900.0) supervisor--timer-state)
    ;; Mock trigger to detect if called
    (cl-letf (((symbol-function 'supervisor-timer--trigger)
               (lambda (_timer _reason) (setq triggered t)))
              ((symbol-function 'float-time) (lambda () 1000.0)))
      (supervisor--timer-scheduler-tick))
    ;; Timer SHOULD have been triggered when enabled
    (should triggered)
    ;; Clean up scheduler timer if created
    (when (timerp supervisor--timer-scheduler)
      (cancel-timer supervisor--timer-scheduler))
    (clrhash supervisor--timer-state)))

(ert-deftest supervisor-test-timer-gate-parent-mode-off ()
  "Timer subsystem is a no-op when parent supervisor-mode is off."
  (let* ((supervisor-timer-subsystem-mode t)  ; Timer mode enabled
         (supervisor-mode nil)                 ; But parent mode is OFF
         (timer (supervisor-timer--create :id "t1" :target "s1" :enabled t
                                          :on-startup-sec 1))
         (supervisor--timer-list (list timer))
         (supervisor--timer-state (make-hash-table :test 'equal))
         (supervisor--timer-scheduler nil)
         (supervisor--shutting-down nil)
         (triggered nil))
    ;; Set up state so timer would be due
    (puthash "t1" '(:next-run-at 900.0) supervisor--timer-state)
    ;; Mock trigger to detect if called
    (cl-letf (((symbol-function 'supervisor-timer--trigger)
               (lambda (_timer _reason) (setq triggered t)))
              ((symbol-function 'float-time) (lambda () 1000.0)))
      (supervisor--timer-scheduler-tick))
    ;; Timer should NOT be triggered when parent mode is off
    (should-not triggered)
    (clrhash supervisor--timer-state)))

;;; Timer Phase 6: Expanded Coverage

(ert-deftest supervisor-test-timer-trigger-simple-success ()
  "Timer trigger for simple service records success on spawn."
  (let* ((supervisor-timer-subsystem-mode t)
         (supervisor-mode t)
         (timer (supervisor-timer--create :id "t1" :target "svc" :enabled t))
         (supervisor--timer-state (make-hash-table :test 'equal))
         (supervisor--processes (make-hash-table :test 'equal))
         (entry (list "svc" nil 0 t nil nil nil nil 'simple nil nil
                      nil nil nil nil nil nil nil nil nil nil nil nil
                      nil nil nil nil nil nil nil nil nil nil))
         (async-callback nil))
    (puthash "t1" nil supervisor--timer-state)
    (cl-letf (((symbol-function 'supervisor-timer--get-entry-for-id)
               (lambda (_id) entry))
              ((symbol-function 'supervisor--get-effective-enabled)
               (lambda (_id _p) t))
              ((symbol-function 'supervisor--start-entry-async)
               (lambda (_entry cb) (setq async-callback cb)))
              ((symbol-function 'supervisor-timer--save-state) #'ignore)
              ((symbol-function 'supervisor--emit-event) #'ignore)
              ((symbol-function 'supervisor--timer-scheduler-tick) #'ignore)
              ((symbol-function 'supervisor-timer--update-next-run) #'ignore))
      (supervisor-timer--trigger timer 'scheduled)
      ;; Simulate successful spawn
      (funcall async-callback t)
      (let ((state (gethash "t1" supervisor--timer-state)))
        (should (eq 'success (plist-get state :last-result)))
        (should (eq 'simple (plist-get state :last-target-type)))))))

(ert-deftest supervisor-test-timer-trigger-simple-already-active ()
  "Timer trigger for already-running simple service records success no-op.
Stale retry state from a prior failure must be cleared."
  (let* ((supervisor-timer-subsystem-mode t)
         (supervisor-mode t)
         (timer (supervisor-timer--create :id "t1" :target "svc" :enabled t))
         (supervisor--timer-state (make-hash-table :test 'equal))
         (supervisor--processes (make-hash-table :test 'equal))
         (entry (list "svc" nil 0 t nil nil nil nil 'simple nil nil
                      nil nil nil nil nil nil nil nil nil nil nil nil
                      nil nil nil nil nil nil nil nil nil nil))
         (mock-proc (start-process "test" nil "sleep" "300")))
    (unwind-protect
        (progn
          ;; Seed with stale retry state from a prior failure
          (puthash "t1" '(:retry-attempt 2 :retry-next-at 55555.0)
                   supervisor--timer-state)
          (puthash "svc" mock-proc supervisor--processes)
          (cl-letf (((symbol-function 'supervisor-timer--get-entry-for-id)
                     (lambda (_id) entry))
                    ((symbol-function 'supervisor--get-effective-enabled)
                     (lambda (_id _p) t))
                    ((symbol-function 'supervisor-timer--save-state) #'ignore)
                    ((symbol-function 'supervisor--emit-event) #'ignore)
                    ((symbol-function 'supervisor--timer-scheduler-tick) #'ignore)
                    ((symbol-function 'supervisor-timer--update-next-run) #'ignore))
            (supervisor-timer--trigger timer 'scheduled)
            (let ((state (gethash "t1" supervisor--timer-state)))
              (should (eq 'success (plist-get state :last-result)))
              (should (eq 'already-active
                          (plist-get state :last-result-reason)))
              ;; Stale retry state must be cleared (success clears retry)
              (should (= 0 (plist-get state :retry-attempt)))
              (should-not (plist-get state :retry-next-at)))))
      (delete-process mock-proc))))

(ert-deftest supervisor-test-timer-trigger-simple-spawn-failure-retries ()
  "Timer trigger for simple spawn failure schedules retry."
  (let* ((supervisor-timer-subsystem-mode t)
         (supervisor-mode t)
         (timer (supervisor-timer--create :id "t1" :target "svc" :enabled t))
         (supervisor--timer-state (make-hash-table :test 'equal))
         (supervisor--processes (make-hash-table :test 'equal))
         (supervisor-timer-retry-intervals '(30 120 600))
         (entry (list "svc" nil 0 t nil nil nil nil 'simple nil nil
                      nil nil nil nil nil nil nil nil nil nil nil nil
                      nil nil nil nil nil nil nil nil nil nil))
         (async-callback nil))
    (puthash "t1" nil supervisor--timer-state)
    (cl-letf (((symbol-function 'supervisor-timer--get-entry-for-id)
               (lambda (_id) entry))
              ((symbol-function 'supervisor--get-effective-enabled)
               (lambda (_id _p) t))
              ((symbol-function 'supervisor--start-entry-async)
               (lambda (_entry cb) (setq async-callback cb)))
              ((symbol-function 'supervisor-timer--save-state) #'ignore)
              ((symbol-function 'supervisor--emit-event) #'ignore)
              ((symbol-function 'supervisor--timer-scheduler-tick) #'ignore)
              ((symbol-function 'supervisor-timer--update-next-run) #'ignore))
      (supervisor-timer--trigger timer 'scheduled)
      ;; Simulate spawn failure
      (funcall async-callback nil)
      (let ((state (gethash "t1" supervisor--timer-state)))
        (should (eq 'failure (plist-get state :last-result)))
        (should (eq 'spawn-failed (plist-get state :last-result-reason)))
        ;; Retry should be scheduled
        (should (= 1 (plist-get state :retry-attempt)))
        (should (plist-get state :retry-next-at))))))

(ert-deftest supervisor-test-timer-oneshot-complete-success ()
  "Oneshot completion callback records success with exit 0.
Exercises supervisor-timer--on-target-complete success branch end-to-end:
sets last-success-at, last-exit, last-result, clears retry state."
  (let* ((supervisor-timer-subsystem-mode t)
         (supervisor-mode t)
         (supervisor--timer-state (make-hash-table :test 'equal))
         (supervisor--oneshot-completed (make-hash-table :test 'equal))
         (supervisor--timer-list nil))
    ;; Seed with stale retry state
    (puthash "t1" '(:retry-attempt 2 :retry-next-at 33333.0)
             supervisor--timer-state)
    ;; Oneshot exited with code 0
    (puthash "svc" 0 supervisor--oneshot-completed)
    (cl-letf (((symbol-function 'supervisor-timer--save-state) #'ignore)
              ((symbol-function 'supervisor--emit-event) #'ignore)
              ((symbol-function 'supervisor-timer--update-next-run) #'ignore)
              ((symbol-function 'supervisor--timer-scheduler-tick) #'ignore))
      (supervisor-timer--on-target-complete "t1" "svc" t)
      (let ((state (gethash "t1" supervisor--timer-state)))
        (should (eq 'success (plist-get state :last-result)))
        (should-not (plist-get state :last-result-reason))
        (should (= 0 (plist-get state :last-exit)))
        (should (plist-get state :last-success-at))
        ;; Retry state cleared
        (should (= 0 (plist-get state :retry-attempt)))
        (should-not (plist-get state :retry-next-at))))))

(ert-deftest supervisor-test-timer-oneshot-complete-failure-retries ()
  "Oneshot completion callback records failure with non-zero exit and schedules retry."
  (let* ((supervisor-timer-subsystem-mode t)
         (supervisor-mode t)
         (supervisor--timer-state (make-hash-table :test 'equal))
         (supervisor--oneshot-completed (make-hash-table :test 'equal))
         (supervisor--timer-list nil)
         (supervisor-timer-retry-intervals '(30 120 600)))
    (puthash "t1" nil supervisor--timer-state)
    ;; Oneshot exited with code 1 (retryable)
    (puthash "svc" 1 supervisor--oneshot-completed)
    (cl-letf (((symbol-function 'supervisor-timer--save-state) #'ignore)
              ((symbol-function 'supervisor--emit-event) #'ignore)
              ((symbol-function 'supervisor-timer--update-next-run) #'ignore)
              ((symbol-function 'supervisor--timer-scheduler-tick) #'ignore))
      (supervisor-timer--on-target-complete "t1" "svc" nil)
      (let ((state (gethash "t1" supervisor--timer-state)))
        (should (eq 'failure (plist-get state :last-result)))
        (should (= 1 (plist-get state :last-exit)))
        (should (plist-get state :last-failure-at))
        ;; Retry scheduled
        (should (= 1 (plist-get state :retry-attempt)))
        (should (plist-get state :retry-next-at))))))

(ert-deftest supervisor-test-timer-oneshot-complete-signal-no-retry ()
  "Oneshot killed by signal records failure but does not schedule retry."
  (let* ((supervisor-timer-subsystem-mode t)
         (supervisor-mode t)
         (supervisor--timer-state (make-hash-table :test 'equal))
         (supervisor--oneshot-completed (make-hash-table :test 'equal))
         (supervisor--timer-list nil)
         (supervisor-timer-retry-intervals '(30 120 600)))
    (puthash "t1" nil supervisor--timer-state)
    ;; Signal death encoded as negative exit code
    (puthash "svc" -9 supervisor--oneshot-completed)
    (cl-letf (((symbol-function 'supervisor-timer--save-state) #'ignore)
              ((symbol-function 'supervisor--emit-event) #'ignore)
              ((symbol-function 'supervisor-timer--update-next-run) #'ignore)
              ((symbol-function 'supervisor--timer-scheduler-tick) #'ignore))
      (supervisor-timer--on-target-complete "t1" "svc" nil)
      (let ((state (gethash "t1" supervisor--timer-state)))
        (should (eq 'failure (plist-get state :last-result)))
        (should (= -9 (plist-get state :last-exit)))
        ;; Signal deaths are NOT retryable
        (should (= 0 (or (plist-get state :retry-attempt) 0)))
        (should-not (plist-get state :retry-next-at))))))

(ert-deftest supervisor-test-timer-trigger-target-reached ()
  "Timer trigger for target records success on reached convergence.
Stale retry state from a prior failure must be cleared."
  (let* ((supervisor-timer-subsystem-mode t)
         (supervisor-mode t)
         (timer (supervisor-timer--create :id "t1" :target "app.target"
                                          :enabled t))
         (supervisor--timer-state (make-hash-table :test 'equal))
         (supervisor--processes (make-hash-table :test 'equal))
         (supervisor--target-convergence (make-hash-table :test 'equal))
         (supervisor--target-converging (make-hash-table :test 'equal))
         (supervisor--current-plan t)
         (entry (list "app.target" nil 0 t nil nil nil nil 'target nil nil
                      nil nil nil nil nil nil nil nil nil nil nil nil
                      nil nil nil nil nil nil nil nil nil nil)))
    ;; Target already reached -- no-op success
    (puthash "app.target" 'reached supervisor--target-convergence)
    ;; Seed with stale retry state from a prior failure
    (puthash "t1" '(:retry-attempt 3 :retry-next-at 44444.0)
             supervisor--timer-state)
    (cl-letf (((symbol-function 'supervisor-timer--get-entry-for-id)
               (lambda (_id) entry))
              ((symbol-function 'supervisor--get-effective-enabled)
               (lambda (_id _p) t))
              ((symbol-function 'supervisor-timer--save-state) #'ignore)
              ((symbol-function 'supervisor--emit-event) #'ignore)
              ((symbol-function 'supervisor--timer-scheduler-tick) #'ignore)
              ((symbol-function 'supervisor-timer--update-next-run) #'ignore))
      (supervisor-timer--trigger timer 'scheduled)
      (let ((state (gethash "t1" supervisor--timer-state)))
        (should (eq 'success (plist-get state :last-result)))
        (should (eq 'already-reached
                    (plist-get state :last-result-reason)))
        ;; Stale retry state must be cleared (success clears retry)
        (should (= 0 (plist-get state :retry-attempt)))
        (should-not (plist-get state :retry-next-at))))))

(ert-deftest supervisor-test-timer-trigger-target-converging-skips ()
  "Timer trigger for converging target records miss and skip result."
  (let* ((supervisor-timer-subsystem-mode t)
         (supervisor-mode t)
         (timer (supervisor-timer--create :id "t1" :target "app.target"
                                          :enabled t))
         (supervisor--timer-state (make-hash-table :test 'equal))
         (supervisor--processes (make-hash-table :test 'equal))
         (supervisor--target-convergence (make-hash-table :test 'equal))
         (supervisor--target-converging (make-hash-table :test 'equal))
         (entry (list "app.target" nil 0 t nil nil nil nil 'target nil nil
                      nil nil nil nil nil nil nil nil nil nil nil nil
                      nil nil nil nil nil nil nil nil nil nil)))
    ;; Target is converging
    (puthash "app.target" t supervisor--target-converging)
    ;; Seed with stale retry state from a prior failure
    (puthash "t1" '(:retry-attempt 1 :retry-next-at 77777.0)
             supervisor--timer-state)
    (cl-letf (((symbol-function 'supervisor-timer--get-entry-for-id)
               (lambda (_id) entry))
              ((symbol-function 'supervisor--get-effective-enabled)
               (lambda (_id _p) t))
              ((symbol-function 'supervisor-timer--save-state) #'ignore)
              ((symbol-function 'supervisor--emit-event) #'ignore)
              ((symbol-function 'supervisor--timer-scheduler-tick) #'ignore))
      (let ((result (supervisor-timer--trigger timer 'scheduled)))
        (should-not result)
        (let ((state (gethash "t1" supervisor--timer-state)))
          (should (eq 'target-converging
                      (plist-get state :last-miss-reason)))
          (should (eq 'skip (plist-get state :last-result)))
          (should (eq 'target-converging
                      (plist-get state :last-result-reason)))
          ;; Stale retry state must be cleared
          (should (= 0 (plist-get state :retry-attempt)))
          (should-not (plist-get state :retry-next-at)))))))

(ert-deftest supervisor-test-timer-target-degraded-retries ()
  "Timer target convergence to degraded schedules retry."
  (let* ((supervisor-timer-subsystem-mode t)
         (supervisor-mode t)
         (supervisor--timer-state (make-hash-table :test 'equal))
         (supervisor--target-convergence (make-hash-table :test 'equal))
         (supervisor-timer-retry-intervals '(30 120 600)))
    (puthash "t1" '(:retry-attempt 0) supervisor--timer-state)
    (puthash "app.target" 'degraded supervisor--target-convergence)
    (cl-letf (((symbol-function 'supervisor-timer--save-state) #'ignore)
              ((symbol-function 'supervisor--emit-event) #'ignore)
              ((symbol-function 'supervisor--timer-scheduler-tick) #'ignore)
              ((symbol-function 'supervisor-timer--update-next-run) #'ignore))
      (supervisor-timer--on-target-converge "t1" "app.target")
      (let ((state (gethash "t1" supervisor--timer-state)))
        (should (eq 'failure (plist-get state :last-result)))
        (should (eq 'target-degraded (plist-get state :last-result-reason)))
        ;; Retry should be scheduled
        (should (= 1 (plist-get state :retry-attempt)))
        (should (plist-get state :retry-next-at))))))

(ert-deftest supervisor-test-timer-unit-active-oneshot-anchors-on-success ()
  "on-unit-active for oneshot timer anchors on last success."
  (let* ((timer (supervisor-timer--create :id "t1" :target "svc" :enabled t
                                          :on-unit-active-sec 120))
         (supervisor--timer-state (make-hash-table :test 'equal)))
    (puthash "t1" '(:last-success-at 800.0) supervisor--timer-state)
    (let ((next (supervisor-timer--next-unit-active-time timer)))
      (should (= 920.0 next)))))

(ert-deftest supervisor-test-timer-unit-active-simple-anchors-on-success ()
  "on-unit-active for simple timer anchors on last success."
  (let* ((timer (supervisor-timer--create :id "t1" :target "svc" :enabled t
                                          :on-unit-active-sec 300))
         (supervisor--timer-state (make-hash-table :test 'equal)))
    (puthash "t1" '(:last-success-at 1000.0) supervisor--timer-state)
    (let ((next (supervisor-timer--next-unit-active-time timer)))
      (should (= 1300.0 next)))))

(ert-deftest supervisor-test-timer-unit-active-target-anchors-on-success ()
  "on-unit-active for target timer anchors on last success."
  (let* ((timer (supervisor-timer--create :id "t1" :target "app.target"
                                          :enabled t :on-unit-active-sec 600))
         (supervisor--timer-state (make-hash-table :test 'equal)))
    (puthash "t1" '(:last-success-at 2000.0) supervisor--timer-state)
    (let ((next (supervisor-timer--next-unit-active-time timer)))
      (should (= 2600.0 next)))))

(ert-deftest supervisor-test-timer-overlap-no-retry ()
  "Overlap skip clears stale retry state from prior failure."
  (let* ((supervisor-timer-subsystem-mode t)
         (supervisor-mode t)
         (timer (supervisor-timer--create :id "t1" :target "svc" :enabled t))
         (supervisor--timer-state (make-hash-table :test 'equal))
         (supervisor--processes (make-hash-table :test 'equal))
         (entry (list "svc" nil 0 t nil nil nil nil 'oneshot nil nil
                      nil nil nil nil nil nil nil nil nil nil nil nil
                      nil nil nil nil nil nil nil nil nil nil))
         (mock-proc (start-process "test" nil "sleep" "300")))
    (unwind-protect
        (progn
          (puthash "svc" mock-proc supervisor--processes)
          ;; Seed with stale retry state from a prior failure
          (puthash "t1" '(:retry-attempt 1 :retry-next-at 99999.0)
                   supervisor--timer-state)
          (cl-letf (((symbol-function 'supervisor-timer--get-entry-for-id)
                     (lambda (_id) entry))
                    ((symbol-function 'supervisor--get-effective-enabled)
                     (lambda (_id _p) t))
                    ((symbol-function 'supervisor-timer--save-state) #'ignore)
                    ((symbol-function 'supervisor--emit-event) #'ignore))
            (supervisor-timer--trigger timer 'scheduled)
            (let ((state (gethash "t1" supervisor--timer-state)))
              ;; Overlap recorded as miss and skip result
              (should (eq 'overlap (plist-get state :last-miss-reason)))
              (should (eq 'skip (plist-get state :last-result)))
              (should (eq 'overlap (plist-get state :last-result-reason)))
              ;; Stale retry state must be cleared
              (should (= 0 (plist-get state :retry-attempt)))
              (should-not (plist-get state :retry-next-at)))))
      (delete-process mock-proc))))

(ert-deftest supervisor-test-timer-missing-target-records-failure ()
  "Missing target at runtime records failure with target-not-found."
  (let* ((supervisor-timer-subsystem-mode t)
         (supervisor-mode t)
         (timer (supervisor-timer--create :id "t1" :target "gone" :enabled t))
         (supervisor--timer-state (make-hash-table :test 'equal))
         (supervisor--mask-override (make-hash-table :test 'equal)))
    (puthash "t1" nil supervisor--timer-state)
    (cl-letf (((symbol-function 'supervisor-timer--get-entry-for-id)
               (lambda (_id) nil))
              ((symbol-function 'supervisor-timer--save-state) #'ignore)
              ((symbol-function 'supervisor--emit-event) #'ignore)
              ((symbol-function 'supervisor-timer--update-next-run) #'ignore))
      (supervisor-timer--trigger timer 'scheduled)
      (let ((state (gethash "t1" supervisor--timer-state)))
        (should (eq 'failure (plist-get state :last-result)))
        (should (eq 'target-not-found
                    (plist-get state :last-result-reason)))))))

(ert-deftest supervisor-test-timer-masked-target-skips ()
  "Masked target skips with masked-target miss and skip result."
  (let* ((supervisor-timer-subsystem-mode t)
         (supervisor-mode t)
         (timer (supervisor-timer--create :id "t1" :target "svc" :enabled t))
         (supervisor--timer-state (make-hash-table :test 'equal))
         (supervisor--mask-override (make-hash-table :test 'equal))
         (entry (list "svc" nil 0 t nil nil nil nil 'simple nil nil
                      nil nil nil nil nil nil nil nil nil nil nil nil
                      nil nil nil nil nil nil nil nil nil nil)))
    (puthash "svc" 'masked supervisor--mask-override)
    (puthash "t1" '(:retry-attempt 1 :retry-next-at 66666.0)
             supervisor--timer-state)
    (cl-letf (((symbol-function 'supervisor-timer--get-entry-for-id)
               (lambda (_id) entry))
              ((symbol-function 'supervisor-timer--save-state) #'ignore)
              ((symbol-function 'supervisor--emit-event) #'ignore)
              ((symbol-function 'supervisor--log) #'ignore))
      (supervisor-timer--trigger timer 'scheduled)
      (let ((state (gethash "t1" supervisor--timer-state)))
        (should (eq 'masked-target
                    (plist-get state :last-miss-reason)))
        (should (eq 'skip (plist-get state :last-result)))
        (should (eq 'masked-target
                    (plist-get state :last-result-reason)))
        (should (eq 0 (plist-get state :retry-attempt)))
        (should-not (plist-get state :retry-next-at))))))

(ert-deftest supervisor-test-timer-convergence-nil-is-failure ()
  "Nil convergence state is classified as failure, not success."
  (let* ((supervisor-timer-subsystem-mode t)
         (supervisor-mode t)
         (supervisor--timer-state (make-hash-table :test 'equal))
         (supervisor--target-convergence (make-hash-table :test 'equal)))
    (puthash "t1" nil supervisor--timer-state)
    ;; No convergence entry for app.target -- nil case
    (cl-letf (((symbol-function 'supervisor-timer--save-state) #'ignore)
              ((symbol-function 'supervisor--emit-event) #'ignore)
              ((symbol-function 'supervisor--timer-scheduler-tick) #'ignore)
              ((symbol-function 'supervisor-timer--update-next-run) #'ignore))
      (supervisor-timer--on-target-converge "t1" "app.target")
      (let ((state (gethash "t1" supervisor--timer-state)))
        (should (eq 'failure (plist-get state :last-result)))
        (should (eq 'convergence-unknown
                    (plist-get state :last-result-reason)))))))

(ert-deftest supervisor-test-timer-convergence-converging-is-failure ()
  "Converging state at callback time is classified as failure."
  (let* ((supervisor-timer-subsystem-mode t)
         (supervisor-mode t)
         (supervisor--timer-state (make-hash-table :test 'equal))
         (supervisor--target-convergence (make-hash-table :test 'equal))
         (supervisor-timer-retry-intervals '(30)))
    (puthash "t1" '(:retry-attempt 0) supervisor--timer-state)
    (puthash "app.target" 'converging supervisor--target-convergence)
    (cl-letf (((symbol-function 'supervisor-timer--save-state) #'ignore)
              ((symbol-function 'supervisor--emit-event) #'ignore)
              ((symbol-function 'supervisor--timer-scheduler-tick) #'ignore)
              ((symbol-function 'supervisor-timer--update-next-run) #'ignore))
      (supervisor-timer--on-target-converge "t1" "app.target")
      (let ((state (gethash "t1" supervisor--timer-state)))
        (should (eq 'failure (plist-get state :last-result)))
        (should (eq 'target-not-converged
                    (plist-get state :last-result-reason)))
        ;; Should schedule retry
        (should (= 1 (plist-get state :retry-attempt)))))))

(ert-deftest supervisor-test-timer-target-trigger-uses-closure ()
  "Target timer trigger only starts entries in the target's closure."
  (let* ((supervisor-timer-subsystem-mode t)
         (supervisor-mode t)
         (timer (supervisor-timer--create :id "t1" :target "app.target"
                                          :enabled t))
         (supervisor--timer-state (make-hash-table :test 'equal))
         (supervisor--processes (make-hash-table :test 'equal))
         (supervisor--target-convergence (make-hash-table :test 'equal))
         (supervisor--target-converging (make-hash-table :test 'equal))
         (supervisor--target-members (make-hash-table :test 'equal))
         (supervisor--target-member-reverse (make-hash-table :test 'equal))
         (programs '(("echo a" :id "svc-a" :wanted-by ("app.target"))
                     ("echo b" :id "svc-b" :wanted-by ("other.target"))
                     (nil :id "app.target" :type target)
                     (nil :id "other.target" :type target)))
         (plan (supervisor--build-plan programs))
         (supervisor--current-plan plan)
         (started-ids nil)
         (entry (list "app.target" nil 0 t nil nil nil nil 'target nil nil
                      nil nil nil nil nil nil nil nil nil nil nil nil
                      nil nil nil nil nil nil nil nil nil nil)))
    (puthash "t1" nil supervisor--timer-state)
    (cl-letf (((symbol-function 'supervisor-timer--get-entry-for-id)
               (lambda (_id) entry))
              ((symbol-function 'supervisor--get-effective-enabled)
               (lambda (_id _p) t))
              ((symbol-function 'supervisor-timer--save-state) #'ignore)
              ((symbol-function 'supervisor--emit-event) #'ignore)
              ((symbol-function 'supervisor--timer-scheduler-tick) #'ignore)
              ((symbol-function 'supervisor-timer--update-next-run) #'ignore)
              ((symbol-function 'supervisor--dag-start-with-deps)
               (lambda (entries callback)
                 (dolist (e entries)
                   (push (supervisor-entry-id e) started-ids))
                 (funcall callback))))
      (supervisor-timer--trigger timer 'scheduled)
      ;; svc-a and app.target should be in DAG (closure members),
      ;; but not svc-b (in other.target closure)
      (should (member "svc-a" started-ids))
      (should (member "app.target" started-ids))
      (should-not (member "svc-b" started-ids)))))

(ert-deftest supervisor-test-timer-target-trigger-convergence-success ()
  "Target timer trigger reaches success when DAG processes convergence."
  (let* ((supervisor-timer-subsystem-mode t)
         (supervisor-mode t)
         (timer (supervisor-timer--create :id "t1" :target "app.target"
                                          :enabled t))
         (supervisor--timer-state (make-hash-table :test 'equal))
         (supervisor--processes (make-hash-table :test 'equal))
         (supervisor--target-convergence (make-hash-table :test 'equal))
         (supervisor--target-converging (make-hash-table :test 'equal))
         (supervisor--target-members (make-hash-table :test 'equal))
         (supervisor--target-member-reverse (make-hash-table :test 'equal))
         (supervisor--entry-state (make-hash-table :test 'equal))
         (programs '(("echo a" :id "svc-a" :wanted-by ("app.target"))
                     (nil :id "app.target" :type target)))
         (plan (supervisor--build-plan programs))
         (supervisor--current-plan plan)
         (entry (list "app.target" nil 0 t nil nil nil nil 'target nil nil
                      nil nil nil nil nil nil nil nil nil nil nil nil
                      nil nil nil nil nil nil nil nil nil nil)))
    (puthash "t1" nil supervisor--timer-state)
    (cl-letf (((symbol-function 'supervisor-timer--get-entry-for-id)
               (lambda (_id) entry))
              ((symbol-function 'supervisor--get-effective-enabled)
               (lambda (_id _p) t))
              ((symbol-function 'supervisor-timer--save-state) #'ignore)
              ((symbol-function 'supervisor--emit-event) #'ignore)
              ((symbol-function 'supervisor--timer-scheduler-tick) #'ignore)
              ((symbol-function 'supervisor-timer--update-next-run) #'ignore)
              ((symbol-function 'supervisor--dag-start-with-deps)
               (lambda (entries callback)
                 ;; Simulate DAG processing: target entry triggers
                 ;; begin-convergence, service entries become ready
                 (dolist (e entries)
                   (let ((eid (supervisor-entry-id e)))
                     (if (eq (supervisor-entry-type e) 'target)
                         (supervisor--target-begin-convergence eid)
                       ;; Mark service as ready (simulates successful start)
                       (supervisor--dag-mark-ready eid))))
                 (funcall callback))))
      (supervisor-timer--trigger timer 'scheduled)
      ;; Target should have converged to reached
      (should (eq 'reached
                  (gethash "app.target" supervisor--target-convergence)))
      ;; Timer state should record success
      (let ((state (gethash "t1" supervisor--timer-state)))
        (should (eq 'success (plist-get state :last-result)))
        (should (eq 'target-reached
                    (plist-get state :last-result-reason)))))))

(ert-deftest supervisor-test-timer-disabled-timer-records-skip-result ()
  "Disabled timer records skip and clears stale retry state."
  (let* ((supervisor-timer-subsystem-mode t)
         (supervisor-mode t)
         (timer (supervisor-timer--create :id "t1" :target "svc"
                                          :enabled nil))
         (supervisor--timer-state (make-hash-table :test 'equal)))
    ;; Seed with stale retry state from a prior failure
    (puthash "t1" '(:retry-attempt 2 :retry-next-at 88888.0)
             supervisor--timer-state)
    (cl-letf (((symbol-function 'supervisor-timer--save-state) #'ignore)
              ((symbol-function 'supervisor--emit-event) #'ignore)
              ((symbol-function 'supervisor--log) #'ignore))
      (supervisor-timer--trigger timer 'scheduled)
      (let ((state (gethash "t1" supervisor--timer-state)))
        (should (eq 'disabled (plist-get state :last-miss-reason)))
        (should (eq 'skip (plist-get state :last-result)))
        (should (eq 'disabled (plist-get state :last-result-reason)))
        ;; Stale retry state must be cleared
        (should (= 0 (plist-get state :retry-attempt)))
        (should-not (plist-get state :retry-next-at))))))

(ert-deftest supervisor-test-cli-list-timers-json-v2-fields ()
  "CLI list-timers JSON includes v2 fields: target_type, last_result.
Target type is resolved from current config, not runtime state."
  (let* ((supervisor-timer-subsystem-mode t)
         (supervisor-mode t)
         (timer (supervisor-timer--create :id "t1" :target "svc"
                                          :enabled t :persistent t))
         (supervisor--timer-list (list timer))
         (supervisor--timer-state (make-hash-table :test 'equal))
         (supervisor--invalid-timers (make-hash-table :test 'equal))
         (mock-entry (list "svc" "echo hi" 0 t nil nil nil nil 'oneshot nil nil
                           nil nil nil nil nil nil nil nil nil nil nil nil
                           nil nil nil nil nil nil nil nil nil nil)))
    (puthash "t1" '(:last-result success
                    :last-result-reason nil)
             supervisor--timer-state)
    (cl-letf (((symbol-function 'supervisor--get-entry-for-id)
               (lambda (_id) mock-entry)))
      (let ((result (supervisor--cli-dispatch '("--json" "list-timers"))))
        (let* ((json-object-type 'alist)
               (json-array-type 'list)
               (data (json-read-from-string
                      (supervisor-cli-result-output result)))
               (timers (alist-get 'timers data))
               (entry (car timers)))
          (should (equal "success" (alist-get 'last_result entry)))
          (should (equal "oneshot" (alist-get 'target_type entry))))))))

(ert-deftest supervisor-test-cli-list-timers-human-v2-columns ()
  "CLI list-timers human output includes TYPE and RESULT columns.
TYPE is resolved from current config."
  (let* ((supervisor-timer-subsystem-mode t)
         (supervisor-mode t)
         (timer (supervisor-timer--create :id "t1" :target "svc"
                                          :enabled t))
         (supervisor--timer-list (list timer))
         (supervisor--timer-state (make-hash-table :test 'equal))
         (supervisor--invalid-timers (make-hash-table :test 'equal))
         (mock-entry (list "svc" "echo hi" 0 t nil nil nil nil 'simple nil nil
                           nil nil nil nil nil nil nil nil nil nil nil nil
                           nil nil nil nil nil nil nil nil nil nil)))
    (puthash "t1" '(:last-result failure)
             supervisor--timer-state)
    (cl-letf (((symbol-function 'supervisor--get-entry-for-id)
               (lambda (_id) mock-entry)))
      (let ((result (supervisor--cli-dispatch '("list-timers"))))
        (let ((output (supervisor-cli-result-output result)))
          ;; Header should have TYPE and RESULT columns
          (should (string-match-p "TYPE" output))
          (should (string-match-p "RESULT" output))
          ;; Data row should have the values
          (should (string-match-p "simple" output))
          (should (string-match-p "failure" output)))))))

(ert-deftest supervisor-test-dashboard-timer-entry-v2-columns ()
  "Dashboard timer entry vector includes TYPE, RESULT, and REASON columns.
TYPE is resolved from current config, not runtime state."
  (let* ((timer (supervisor-timer--create :id "t1" :target "svc" :enabled t))
         (supervisor--timer-list (list timer))
         (supervisor--timer-state (make-hash-table :test 'equal))
         (supervisor--processes (make-hash-table :test 'equal))
         (mock-entry (list "svc" "echo hi" 0 t nil nil nil nil 'oneshot nil nil
                           nil nil nil nil nil nil nil nil nil nil nil nil
                           nil nil nil nil nil nil nil nil nil nil)))
    (puthash "t1" '(:last-result success
                    :last-result-reason already-active)
             supervisor--timer-state)
    (cl-letf (((symbol-function 'supervisor--get-entry-for-id)
               (lambda (_id) mock-entry)))
      (let ((entry (supervisor--make-timer-dashboard-entry timer)))
        ;; Column 6 is REASON, column 7 is TYPE, column 8 is RESULT
        (should (string= "already-active" (aref entry 6)))
        (should (string= "oneshot" (aref entry 7)))
        (should (string-match-p "success" (aref entry 8)))))))

(ert-deftest supervisor-test-dashboard-timer-entry-empty-v2-defaults ()
  "Dashboard timer entry shows dash for missing REASON and RESULT.
TYPE is resolved from config; shows dash when target not found."
  (let* ((timer (supervisor-timer--create :id "t1" :target "svc" :enabled t))
         (supervisor--timer-list (list timer))
         (supervisor--timer-state (make-hash-table :test 'equal))
         (supervisor--processes (make-hash-table :test 'equal)))
    ;; No state set, target not found in config
    (cl-letf (((symbol-function 'supervisor--get-entry-for-id)
               (lambda (_id) nil)))
      (let ((entry (supervisor--make-timer-dashboard-entry timer)))
        (should (string= "-" (aref entry 6)))
        (should (string= "-" (aref entry 7)))
        (should (string= "-" (aref entry 8)))))))

(ert-deftest supervisor-test-dashboard-timer-entry-failure-result-reason ()
  "Dashboard timer entry shows result-reason for failure outcomes."
  (let* ((timer (supervisor-timer--create :id "t1" :target "svc" :enabled t))
         (supervisor--timer-list (list timer))
         (supervisor--timer-state (make-hash-table :test 'equal))
         (supervisor--processes (make-hash-table :test 'equal))
         (mock-entry (list "svc" "echo hi" 0 t nil nil nil nil 'oneshot nil nil
                           nil nil nil nil nil nil nil nil nil nil nil nil
                           nil nil nil nil nil nil nil nil nil nil)))
    (puthash "t1" '(:last-result failure
                    :last-result-reason spawn-failed)
             supervisor--timer-state)
    (cl-letf (((symbol-function 'supervisor--get-entry-for-id)
               (lambda (_id) mock-entry)))
      (let ((entry (supervisor--make-timer-dashboard-entry timer)))
        ;; Column 6 is REASON showing result-reason, not miss-reason
        (should (string= "spawn-failed" (aref entry 6)))
        (should (string-match-p "failure" (aref entry 8)))))))

(ert-deftest supervisor-test-dashboard-timer-entry-fresh-timer-shows-type ()
  "Fresh timer (never triggered) shows TYPE resolved from current config."
  (let* ((timer (supervisor-timer--create :id "t1" :target "svc" :enabled t))
         (supervisor--timer-list (list timer))
         (supervisor--timer-state (make-hash-table :test 'equal))
         (supervisor--processes (make-hash-table :test 'equal))
         (mock-entry (list "svc" "echo hi" 0 t nil nil nil nil 'simple nil nil
                           nil nil nil nil nil nil nil nil nil nil nil nil
                           nil nil nil nil nil nil nil nil nil nil)))
    ;; No state at all -- timer has never triggered
    (cl-letf (((symbol-function 'supervisor--get-entry-for-id)
               (lambda (_id) mock-entry)))
      (let ((entry (supervisor--make-timer-dashboard-entry timer)))
        ;; TYPE column shows resolved type even without runtime state
        (should (string= "simple" (aref entry 7)))))))

;;; CLI Control Plane tests

(ert-deftest supervisor-test-cli-result-structure ()
  "CLI result struct has required fields."
  (let ((result (supervisor--cli-make-result 0 'human "output")))
    (should (supervisor-cli-result-p result))
    (should (= 0 (supervisor-cli-result-exitcode result)))
    (should (eq 'human (supervisor-cli-result-format result)))
    (should (equal "output" (supervisor-cli-result-output result)))))

(ert-deftest supervisor-test-cli-exit-codes ()
  "CLI exit code constants are defined."
  (should (= 0 supervisor-cli-exit-success))
  (should (= 1 supervisor-cli-exit-failure))
  (should (= 2 supervisor-cli-exit-invalid-args))
  (should (= 3 supervisor-cli-exit-not-active))
  (should (= 4 supervisor-cli-exit-no-such-unit))
  (should (= 4 supervisor-cli-exit-validation-failed))
  (should (= 69 supervisor-cli-exit-server-unavailable)))

(ert-deftest supervisor-test-cli-dispatch-unknown-command ()
  "Unknown CLI command returns exit code 2."
  (let ((result (supervisor--cli-dispatch '("unknown-cmd"))))
    (should (supervisor-cli-result-p result))
    (should (= supervisor-cli-exit-invalid-args (supervisor-cli-result-exitcode result)))))

(ert-deftest supervisor-test-cli-dispatch-empty-args ()
  "Empty args returns help text."
  (let ((result (supervisor--cli-dispatch '())))
    (should (supervisor-cli-result-p result))
    (should (= supervisor-cli-exit-success (supervisor-cli-result-exitcode result)))
    (should (string-match "Usage:" (supervisor-cli-result-output result)))))

(ert-deftest supervisor-test-cli-ping ()
  "Ping command returns pong."
  (let ((result (supervisor--cli-dispatch '("ping"))))
    (should (supervisor-cli-result-p result))
    (should (= supervisor-cli-exit-success (supervisor-cli-result-exitcode result)))
    (should (string-match "pong" (supervisor-cli-result-output result)))))

(ert-deftest supervisor-test-cli-ping-json ()
  "Ping command with --json returns JSON."
  (let ((result (supervisor--cli-dispatch '("ping" "--json"))))
    (should (supervisor-cli-result-p result))
    (should (= supervisor-cli-exit-success (supervisor-cli-result-exitcode result)))
    (should (eq 'json (supervisor-cli-result-format result)))
    (should (string-match "\"status\"" (supervisor-cli-result-output result)))))

(ert-deftest supervisor-test-cli-version ()
  "Version command returns version info."
  (let ((result (supervisor--cli-dispatch '("version"))))
    (should (supervisor-cli-result-p result))
    (should (= supervisor-cli-exit-success (supervisor-cli-result-exitcode result)))
    (should (string-match "supervisorctl" (supervisor-cli-result-output result)))))

(ert-deftest supervisor-test-cli-verify-no-programs ()
  "Verify with no programs returns success."
  (supervisor-test-with-unit-files nil
    (let ((result (supervisor--cli-dispatch '("verify"))))
      (should (supervisor-cli-result-p result))
      (should (= supervisor-cli-exit-success (supervisor-cli-result-exitcode result)))
      (should (string-match "0 valid" (supervisor-cli-result-output result))))))

(ert-deftest supervisor-test-cli-verify-invalid-entry ()
  "Verify with invalid entry returns validation-failed exit code."
  (supervisor-test-with-unit-files
      '(("cmd" :id "cmd" :type "bad"))
    (let ((result (supervisor--cli-dispatch '("verify"))))
      (should (supervisor-cli-result-p result))
      (should (= supervisor-cli-exit-validation-failed (supervisor-cli-result-exitcode result)))
      (should (string-match "1 invalid" (supervisor-cli-result-output result))))))

(ert-deftest supervisor-test-cli-list-units-human-format ()
  "The `list-units' command returns human-readable table."
  (supervisor-test-with-unit-files
      '(("test-cmd" :id "test" :type simple))
    (let* ((supervisor--processes (make-hash-table :test 'equal))
           (supervisor--entry-state (make-hash-table :test 'equal))
           (result (supervisor--cli-dispatch '("list-units"))))
      (should (supervisor-cli-result-p result))
      (should (= supervisor-cli-exit-success (supervisor-cli-result-exitcode result)))
      (should (eq 'human (supervisor-cli-result-format result)))
      ;; Should contain header row
      (should (string-match "ID" (supervisor-cli-result-output result))))))

(ert-deftest supervisor-test-cli-list-units-json-format ()
  "The `list-units --json' returns JSON with entries array."
  (supervisor-test-with-unit-files
      '(("test-cmd" :id "test" :type simple))
    (let* ((supervisor--processes (make-hash-table :test 'equal))
           (supervisor--entry-state (make-hash-table :test 'equal))
           (result (supervisor--cli-dispatch '("list-units" "--json"))))
      (should (supervisor-cli-result-p result))
      (should (= supervisor-cli-exit-success (supervisor-cli-result-exitcode result)))
      (should (eq 'json (supervisor-cli-result-format result)))
      ;; Should be valid JSON with entries array
      (should (string-match "\"entries\"" (supervisor-cli-result-output result))))))

(ert-deftest supervisor-test-cli-show-requires-id ()
  "The `show' command without ID returns invalid-args exit code."
  (let ((result (supervisor--cli-dispatch '("show"))))
    (should (supervisor-cli-result-p result))
    (should (= supervisor-cli-exit-invalid-args (supervisor-cli-result-exitcode result)))))

(ert-deftest supervisor-test-cli-enable-requires-id ()
  "Enable without ID returns invalid-args exit code."
  (let ((result (supervisor--cli-dispatch '("enable"))))
    (should (supervisor-cli-result-p result))
    (should (= supervisor-cli-exit-invalid-args (supervisor-cli-result-exitcode result)))))

(ert-deftest supervisor-test-cli-enable-sets-override ()
  "Enable command sets enabled override."
  (supervisor-test-with-unit-files
      '(("sleep 300" :id "test-id" :type simple :enabled nil))
    (let ((supervisor--enabled-override (make-hash-table :test 'equal))
          (supervisor-overrides-file nil))
      (supervisor--cli-dispatch '("enable" "test-id"))
      (should (eq 'enabled (gethash "test-id" supervisor--enabled-override))))))

(ert-deftest supervisor-test-cli-disable-sets-override ()
  "Disable command sets disabled override."
  (supervisor-test-with-unit-files
      '(("sleep 300" :id "test-id" :type simple))
    (let ((supervisor--enabled-override (make-hash-table :test 'equal))
          (supervisor-overrides-file nil))
      (supervisor--cli-dispatch '("disable" "test-id"))
      (should (eq 'disabled (gethash "test-id" supervisor--enabled-override))))))

(ert-deftest supervisor-test-cli-mask-sets-override ()
  "Mask command sets masked override."
  (supervisor-test-with-unit-files
      '(("sleep 300" :id "test-id" :type simple))
    (let ((supervisor--mask-override (make-hash-table :test 'equal))
          (supervisor-overrides-file nil))
      (supervisor--cli-dispatch '("mask" "test-id"))
      (should (eq 'masked (gethash "test-id" supervisor--mask-override))))))

(ert-deftest supervisor-test-cli-unmask-clears-override ()
  "Unmask command clears masked override."
  (supervisor-test-with-unit-files
      '(("sleep 300" :id "test-id" :type simple))
    (let ((supervisor--mask-override (make-hash-table :test 'equal))
          (supervisor-overrides-file nil))
      (puthash "test-id" 'masked supervisor--mask-override)
      (supervisor--cli-dispatch '("unmask" "test-id"))
      (should-not (gethash "test-id" supervisor--mask-override)))))

(ert-deftest supervisor-test-cli-mask-requires-id ()
  "Mask command requires at least one ID."
  (let ((result (supervisor--cli-dispatch '("mask"))))
    (should (= supervisor-cli-exit-invalid-args
                (supervisor-cli-result-exitcode result)))))

(ert-deftest supervisor-test-cli-unmask-requires-id ()
  "Unmask command requires at least one ID."
  (let ((result (supervisor--cli-dispatch '("unmask"))))
    (should (= supervisor-cli-exit-invalid-args
                (supervisor-cli-result-exitcode result)))))

(ert-deftest supervisor-test-cli-mask-json-output ()
  "Mask command returns JSON with applied IDs."
  (supervisor-test-with-unit-files
      '(("sleep 300" :id "a" :type simple)
        ("sleep 300" :id "b" :type simple))
    (let ((supervisor--mask-override (make-hash-table :test 'equal))
          (supervisor-overrides-file nil))
      (let ((result (supervisor--cli-dispatch '("mask" "a" "b" "--json"))))
        (should (eq 'json (supervisor-cli-result-format result)))
        (let ((parsed (json-read-from-string
                       (supervisor-cli-result-output result))))
          (should (assoc 'applied parsed)))))))

(ert-deftest supervisor-test-cli-mask-with-separator ()
  "Mask command supports -- separator for hyphen-prefixed IDs."
  (supervisor-test-with-unit-files
      '(("sleep 300" :id "-my-id" :type simple))
    (let ((supervisor--mask-override (make-hash-table :test 'equal))
          (supervisor-overrides-file nil))
      (supervisor--cli-dispatch '("mask" "--" "-my-id"))
      (should (eq 'masked (gethash "-my-id" supervisor--mask-override))))))

(ert-deftest supervisor-test-cli-unmask-json-output ()
  "Unmask command returns JSON with applied IDs."
  (supervisor-test-with-unit-files
      '(("sleep 300" :id "a" :type simple)
        ("sleep 300" :id "b" :type simple))
    (let ((supervisor--mask-override (make-hash-table :test 'equal))
          (supervisor-overrides-file nil))
      (puthash "a" 'masked supervisor--mask-override)
      (puthash "b" 'masked supervisor--mask-override)
      (let ((result (supervisor--cli-dispatch '("unmask" "a" "b" "--json"))))
        (should (eq 'json (supervisor-cli-result-format result)))
        (let ((parsed (json-read-from-string
                       (supervisor-cli-result-output result))))
          (should (assoc 'applied parsed)))))))

(ert-deftest supervisor-test-cli-unmask-with-separator ()
  "Unmask command supports -- separator for hyphen-prefixed IDs."
  (supervisor-test-with-unit-files
      '(("sleep 300" :id "-my-id" :type simple))
    (let ((supervisor--mask-override (make-hash-table :test 'equal))
          (supervisor-overrides-file nil))
      (puthash "-my-id" 'masked supervisor--mask-override)
      (supervisor--cli-dispatch '("unmask" "--" "-my-id"))
      (should-not (gethash "-my-id" supervisor--mask-override)))))

(ert-deftest supervisor-test-mask-precedence-over-enabled ()
  "Masked entry is always disabled regardless of enabled override."
  (let ((supervisor--mask-override (make-hash-table :test 'equal))
        (supervisor--enabled-override (make-hash-table :test 'equal)))
    ;; Even with enabled override, mask takes precedence
    (puthash "test" 'masked supervisor--mask-override)
    (puthash "test" 'enabled supervisor--enabled-override)
    (should-not (supervisor--get-effective-enabled "test" t))))

(ert-deftest supervisor-test-mask-blocks-manual-start ()
  "Masked entry cannot be manually started."
  (supervisor-test-with-unit-files
      '(("echo hi" :id "svc"))
    (let ((supervisor--mask-override (make-hash-table :test 'equal))
          (supervisor--enabled-override (make-hash-table :test 'equal))
          (supervisor--invalid (make-hash-table :test 'equal))
          (supervisor--processes (make-hash-table :test 'equal)))
      (puthash "svc" 'masked supervisor--mask-override)
      (let ((result (supervisor--manual-start "svc")))
        (should (eq 'skipped (plist-get result :status)))
        (should (equal "masked" (plist-get result :reason)))))))

(ert-deftest supervisor-test-reconcile-stops-masked-running ()
  "Reconcile stops masked entries that are currently running."
  (supervisor-test-with-unit-files
      '(("echo" :id "svc"))
    (let* ((supervisor--mask-override (make-hash-table :test 'equal))
           (supervisor--enabled-override (make-hash-table :test 'equal))
           (process-alive (make-hash-table :test 'equal))
           (process-pids (make-hash-table :test 'equal))
           (failed (make-hash-table :test 'equal))
           (oneshot (make-hash-table :test 'equal))
           (entry-state (make-hash-table :test 'equal))
           (invalid (make-hash-table :test 'equal))
           (logging (make-hash-table :test 'equal))
           (restart (make-hash-table :test 'equal))
           ;; Build a plan with one entry
           (plan (supervisor--build-plan (supervisor--effective-programs))))
      ;; Simulate running process
      (puthash "svc" t process-alive)
      (puthash "svc" 123 process-pids)
      ;; Mask the entry
      (puthash "svc" 'masked supervisor--mask-override)
      (let ((snapshot (supervisor-snapshot--create
                       :process-alive process-alive
                       :process-pids process-pids
                       :failed failed
                       :oneshot-exit oneshot
                       :entry-state entry-state
                       :invalid invalid
                       :enabled-override supervisor--enabled-override
                       :restart-override restart
                       :logging-override logging
                       :mask-override supervisor--mask-override
                       :timestamp (float-time))))
        (let ((actions (supervisor--compute-actions plan snapshot)))
          ;; Should have a stop action for the masked entry
          (let ((stop-action (cl-find "svc" actions
                                      :key (lambda (a) (plist-get a :id))
                                      :test #'equal)))
            (should stop-action)
            (should (eq 'stop (plist-get stop-action :op)))
            (should (eq 'masked (plist-get stop-action :reason)))))))))

(ert-deftest supervisor-test-mask-persistence-roundtrip ()
  "Mask override survives save/load cycle."
  (let* ((dir (make-temp-file "overrides-" t))
         (supervisor-overrides-file (expand-file-name "overrides.eld" dir))
         (supervisor--mask-override (make-hash-table :test 'equal))
         (supervisor--enabled-override (make-hash-table :test 'equal))
         (supervisor--restart-override (make-hash-table :test 'equal))
         (supervisor--logging (make-hash-table :test 'equal))
         (supervisor--overrides-loaded nil))
    (unwind-protect
        (progn
          (puthash "svc" 'masked supervisor--mask-override)
          (supervisor--save-overrides)
          ;; Clear and reload
          (clrhash supervisor--mask-override)
          (should-not (gethash "svc" supervisor--mask-override))
          (supervisor--load-overrides)
          (should (eq 'masked (gethash "svc" supervisor--mask-override))))
      (delete-directory dir t))))

(ert-deftest supervisor-test-compute-entry-status-masked ()
  "Compute-entry-status returns masked even when process is running."
  (let ((supervisor--mask-override (make-hash-table :test 'equal))
        (supervisor--processes (make-hash-table :test 'equal))
        (supervisor--failed (make-hash-table :test 'equal))
        (supervisor--oneshot-completed (make-hash-table :test 'equal)))
    (puthash "svc" 'masked supervisor--mask-override)
    ;; Non-running masked entry
    (let ((result (supervisor--compute-entry-status "svc" 'simple)))
      (should (equal "masked" (car result))))
    ;; Running masked entry still shows masked
    (let ((proc (start-process "test" nil "sleep" "999")))
      (unwind-protect
          (progn
            (puthash "svc" proc supervisor--processes)
            (let ((result (supervisor--compute-entry-status "svc" 'simple)))
              (should (equal "masked" (car result)))))
        (delete-process proc)))))

(ert-deftest supervisor-test-compute-entry-reason-masked ()
  "Compute-entry-reason returns masked even when process is running."
  (let ((supervisor--mask-override (make-hash-table :test 'equal))
        (supervisor--processes (make-hash-table :test 'equal))
        (supervisor--failed (make-hash-table :test 'equal))
        (supervisor--oneshot-completed (make-hash-table :test 'equal))
        (supervisor--entry-state (make-hash-table :test 'equal)))
    (puthash "svc" 'masked supervisor--mask-override)
    ;; Non-running masked entry
    (should (equal "masked" (supervisor--compute-entry-reason "svc" 'simple)))
    ;; Running masked entry still shows masked
    (let ((proc (start-process "test" nil "sleep" "999")))
      (unwind-protect
          (progn
            (puthash "svc" proc supervisor--processes)
            (should (equal "masked"
                           (supervisor--compute-entry-reason "svc" 'simple))))
        (delete-process proc)))))

(ert-deftest supervisor-test-dashboard-mask-keybinding ()
  "Dashboard keymap binds `T' to proced auto-update."
  (should (eq #'supervisor-dashboard-toggle-proced-auto-update
              (lookup-key supervisor-dashboard-mode-map "T"))))

(ert-deftest supervisor-test-cli-restart-policy-always ()
  "Restart-policy always sets override."
  (supervisor-test-with-unit-files
      '(("sleep 300" :id "test-id" :type simple :restart nil))
    (let ((supervisor--restart-override (make-hash-table :test 'equal))
          (supervisor-overrides-file nil))
      (supervisor--cli-dispatch '("restart-policy" "always" "test-id"))
      (should (eq 'always (gethash "test-id" supervisor--restart-override))))))

(ert-deftest supervisor-test-cli-restart-policy-no ()
  "Restart-policy no sets override."
  (supervisor-test-with-unit-files
      '(("sleep 300" :id "test-id" :type simple :restart t))
    (let ((supervisor--restart-override (make-hash-table :test 'equal))
          (supervisor-overrides-file nil))
      (supervisor--cli-dispatch '("restart-policy" "no" "test-id"))
      (should (eq 'no (gethash "test-id" supervisor--restart-override))))))

(ert-deftest supervisor-test-cli-restart-policy-on-failure ()
  "Restart-policy on-failure sets override."
  (supervisor-test-with-unit-files
      '(("sleep 300" :id "test-id" :type simple :restart nil))
    (let ((supervisor--restart-override (make-hash-table :test 'equal))
          (supervisor-overrides-file nil))
      (supervisor--cli-dispatch '("restart-policy" "on-failure" "test-id"))
      (should (eq 'on-failure (gethash "test-id" supervisor--restart-override))))))

(ert-deftest supervisor-test-cli-restart-policy-on-success ()
  "Restart-policy on-success sets override."
  (supervisor-test-with-unit-files
      '(("sleep 300" :id "test-id" :type simple :restart nil))
    (let ((supervisor--restart-override (make-hash-table :test 'equal))
          (supervisor-overrides-file nil))
      (supervisor--cli-dispatch '("restart-policy" "on-success" "test-id"))
      (should (eq 'on-success (gethash "test-id" supervisor--restart-override))))))

(ert-deftest supervisor-test-cli-restart-policy-invalid ()
  "Restart-policy with invalid value returns error."
  (let ((supervisor--restart-override (make-hash-table :test 'equal))
        (result (supervisor--cli-dispatch '("restart-policy" "bogus" "test-id"))))
    (should (supervisor-cli-result-p result))
    (should (= supervisor-cli-exit-invalid-args
               (supervisor-cli-result-exitcode result)))))

(ert-deftest supervisor-test-cli-logging-on ()
  "Logging on sets override."
  (supervisor-test-with-unit-files
      '(("sleep 300" :id "test-id" :type simple :logging nil))
    (let ((supervisor--logging (make-hash-table :test 'equal))
          (supervisor-overrides-file nil))
      (supervisor--cli-dispatch '("logging" "on" "test-id"))
      (should (eq 'enabled (gethash "test-id" supervisor--logging))))))

(ert-deftest supervisor-test-cli-logging-off ()
  "Logging off sets override."
  (supervisor-test-with-unit-files
      '(("sleep 300" :id "test-id" :type simple))
    (let ((supervisor--logging (make-hash-table :test 'equal))
          (supervisor-overrides-file nil))
      (supervisor--cli-dispatch '("logging" "off" "test-id"))
      (should (eq 'disabled (gethash "test-id" supervisor--logging))))))

(ert-deftest supervisor-test-cli-stop-uses-manually-stopped ()
  "CLI stop sets manually-stopped flag, not restart-override."
  (let ((supervisor--processes (make-hash-table :test 'equal))
        (supervisor--manually-stopped (make-hash-table :test 'equal))
        (supervisor--restart-override (make-hash-table :test 'equal))
        (proc (start-process "test-proc" nil "sleep" "999")))
    (unwind-protect
        (progn
          (puthash "test-id" proc supervisor--processes)
          (supervisor--cli-dispatch '("stop" "test-id"))
          ;; Should set manually-stopped, NOT restart-override
          (should (gethash "test-id" supervisor--manually-stopped))
          (should-not (gethash "test-id" supervisor--restart-override)))
      (when (process-live-p proc)
        (delete-process proc)))))

(ert-deftest supervisor-test-cli-kill-does-not-use-manually-stopped ()
  "CLI kill does not set manually-stopped, matching signal-only semantics."
  (let ((supervisor--processes (make-hash-table :test 'equal))
        (supervisor--manually-stopped (make-hash-table :test 'equal))
        (proc (start-process "test-proc" nil "sleep" "999")))
    (unwind-protect
        (progn
          (puthash "test-id" proc supervisor--processes)
          (let ((result (supervisor--cli-dispatch '("kill" "test-id"))))
            (should (= supervisor-cli-exit-success
                       (supervisor-cli-result-exitcode result))))
          (should-not (gethash "test-id" supervisor--manually-stopped)))
      (when (process-live-p proc)
        (delete-process proc)))))

(ert-deftest supervisor-test-start-clears-manually-stopped ()
  "Starting a process clears the manually-stopped flag."
  (let ((supervisor--manually-stopped (make-hash-table :test 'equal))
        (supervisor--processes (make-hash-table :test 'equal))
        (supervisor--restart-timers (make-hash-table :test 'equal))
        (supervisor--restart-override (make-hash-table :test 'equal))
        (supervisor--enabled-override (make-hash-table :test 'equal))
        (supervisor--failed (make-hash-table :test 'equal))
        (supervisor--logging (make-hash-table :test 'equal))
        (supervisor-log-directory (make-temp-file "supervisor-test-" t))
        (supervisor--shutting-down nil))
    (puthash "test-id" t supervisor--manually-stopped)
    (should (gethash "test-id" supervisor--manually-stopped))
    (let ((proc (supervisor--start-process "test-id" "sleep 999" nil 'simple t)))
      (unwind-protect
          (progn
            ;; Flag should be cleared after start
            (should-not (gethash "test-id" supervisor--manually-stopped)))
        (when (and proc (process-live-p proc))
          (delete-process proc))))))

(ert-deftest supervisor-test-cli-logs-requires-id ()
  "Logs without ID returns invalid-args exit code."
  (let ((result (supervisor--cli-dispatch '("logs"))))
    (should (supervisor-cli-result-p result))
    (should (= supervisor-cli-exit-invalid-args (supervisor-cli-result-exitcode result)))))

(ert-deftest supervisor-test-cli-kill-requires-id ()
  "Kill without ID returns invalid-args exit code."
  (let ((result (supervisor--cli-dispatch '("kill"))))
    (should (supervisor-cli-result-p result))
    (should (= supervisor-cli-exit-invalid-args (supervisor-cli-result-exitcode result)))))

(ert-deftest supervisor-test-cli-list-dependencies-full ()
  "The `list-dependencies' command without ID returns full graph."
  (supervisor-test-with-unit-files
      '(("a" :id "a") ("b" :id "b" :after "a"))
    (let* ((result (supervisor--cli-dispatch '("list-dependencies"))))
      (should (supervisor-cli-result-p result))
      (should (= supervisor-cli-exit-success (supervisor-cli-result-exitcode result))))))

(ert-deftest supervisor-test-cli-list-dependencies-single ()
  "The `list-dependencies' command with ID returns single entry deps."
  (supervisor-test-with-unit-files
      '(("a" :id "a") ("b" :id "b" :after "a"))
    (let* ((result (supervisor--cli-dispatch '("list-dependencies" "b"))))
      (should (supervisor-cli-result-p result))
      (should (= supervisor-cli-exit-success (supervisor-cli-result-exitcode result)))
      (should (string-match "ID: b" (supervisor-cli-result-output result))))))

(ert-deftest supervisor-test-cli-blame ()
  "Blame command returns timing info."
  (let ((supervisor--start-times (make-hash-table :test 'equal))
        (supervisor--ready-times (make-hash-table :test 'equal)))
    (puthash "test" 1000.0 supervisor--start-times)
    (puthash "test" 1001.5 supervisor--ready-times)
    (let ((result (supervisor--cli-dispatch '("blame"))))
      (should (supervisor-cli-result-p result))
      (should (= supervisor-cli-exit-success (supervisor-cli-result-exitcode result)))
      (should (string-match "DURATION" (supervisor-cli-result-output result))))))

;;; CLI Arg Validation Tests

(ert-deftest supervisor-test-cli-verify-rejects-extra-args ()
  "Verify with extra args returns invalid-args exit code."
  (let ((result (supervisor--cli-dispatch '("verify" "extra"))))
    (should (supervisor-cli-result-p result))
    (should (= supervisor-cli-exit-invalid-args (supervisor-cli-result-exitcode result)))))

(ert-deftest supervisor-test-cli-validate-is-unknown-command ()
  "CLI `validate' is rejected as unknown command (renamed to `verify')."
  (let ((result (supervisor--cli-dispatch '("validate"))))
    (should (supervisor-cli-result-p result))
    (should (= supervisor-cli-exit-invalid-args (supervisor-cli-result-exitcode result)))
    (should (string-match "Unknown command" (supervisor-cli-result-output result)))))

(ert-deftest supervisor-test-cli-reset-failed-per-unit ()
  "CLI reset-failed clears failed state for a specific unit."
  (let ((supervisor--failed (make-hash-table :test 'equal))
        (supervisor--restart-times (make-hash-table :test 'equal)))
    (puthash "svc-a" t supervisor--failed)
    (puthash "svc-a" '(100 99 98) supervisor--restart-times)
    (let ((result (supervisor--cli-dispatch '("reset-failed" "svc-a"))))
      (should (supervisor-cli-result-p result))
      (should (= supervisor-cli-exit-success (supervisor-cli-result-exitcode result)))
      (should (string-match "Reset.*svc-a" (supervisor-cli-result-output result)))
      (should-not (gethash "svc-a" supervisor--failed))
      (should-not (gethash "svc-a" supervisor--restart-times)))))

(ert-deftest supervisor-test-cli-reset-failed-global ()
  "CLI reset-failed with no IDs clears all failed entries."
  (let ((supervisor--failed (make-hash-table :test 'equal))
        (supervisor--restart-times (make-hash-table :test 'equal)))
    (puthash "svc-a" t supervisor--failed)
    (puthash "svc-b" t supervisor--failed)
    (puthash "svc-a" '(100) supervisor--restart-times)
    (puthash "svc-b" '(100) supervisor--restart-times)
    (let ((result (supervisor--cli-dispatch '("reset-failed"))))
      (should (supervisor-cli-result-p result))
      (should (= supervisor-cli-exit-success (supervisor-cli-result-exitcode result)))
      (should (string-match "svc-a" (supervisor-cli-result-output result)))
      (should (string-match "svc-b" (supervisor-cli-result-output result)))
      (should (= 0 (hash-table-count supervisor--failed))))))

(ert-deftest supervisor-test-cli-reset-failed-not-failed ()
  "CLI reset-failed on a non-failed unit reports skipped."
  (let ((supervisor--failed (make-hash-table :test 'equal))
        (supervisor--restart-times (make-hash-table :test 'equal)))
    (let ((result (supervisor--cli-dispatch '("reset-failed" "svc-x"))))
      (should (supervisor-cli-result-p result))
      (should (= supervisor-cli-exit-success (supervisor-cli-result-exitcode result)))
      (should (string-match "Skipped.*svc-x" (supervisor-cli-result-output result))))))

(ert-deftest supervisor-test-cli-reset-failed-no-failed-units ()
  "CLI reset-failed with no IDs and no failed units shows message."
  (let ((supervisor--failed (make-hash-table :test 'equal)))
    (let ((result (supervisor--cli-dispatch '("reset-failed"))))
      (should (supervisor-cli-result-p result))
      (should (= supervisor-cli-exit-success (supervisor-cli-result-exitcode result)))
      (should (string-match "No failed" (supervisor-cli-result-output result))))))

(ert-deftest supervisor-test-reset-failed-core ()
  "Core reset-failed function clears failed and restart-times."
  (let ((supervisor--failed (make-hash-table :test 'equal))
        (supervisor--restart-times (make-hash-table :test 'equal)))
    (puthash "test-id" t supervisor--failed)
    (puthash "test-id" '(100 99) supervisor--restart-times)
    (let ((result (supervisor--reset-failed "test-id")))
      (should (eq 'reset (plist-get result :status)))
      (should-not (gethash "test-id" supervisor--failed))
      (should-not (gethash "test-id" supervisor--restart-times)))))

(ert-deftest supervisor-test-reset-failed-clears-failed-oneshot ()
  "Core reset-failed clears failed oneshot completion results."
  (let ((supervisor--failed (make-hash-table :test 'equal))
        (supervisor--restart-times (make-hash-table :test 'equal))
        (supervisor--oneshot-completed (make-hash-table :test 'equal)))
    (puthash "fail-id" t supervisor--failed)
    (puthash "fail-id" 1 supervisor--oneshot-completed)
    (supervisor--reset-failed "fail-id")
    (should-not (gethash "fail-id" supervisor--oneshot-completed))))

(ert-deftest supervisor-test-reset-failed-preserves-successful-oneshot ()
  "Core reset-failed does not clear successful oneshot completion."
  (let ((supervisor--failed (make-hash-table :test 'equal))
        (supervisor--restart-times (make-hash-table :test 'equal))
        (supervisor--oneshot-completed (make-hash-table :test 'equal)))
    (puthash "ok-id" t supervisor--failed)
    (puthash "ok-id" 0 supervisor--oneshot-completed)
    (supervisor--reset-failed "ok-id")
    (should (eql 0 (gethash "ok-id" supervisor--oneshot-completed)))))

(ert-deftest supervisor-test-reset-failed-clears-signal-oneshot ()
  "Core reset-failed clears oneshot that died by signal."
  (let ((supervisor--failed (make-hash-table :test 'equal))
        (supervisor--restart-times (make-hash-table :test 'equal))
        (supervisor--oneshot-completed (make-hash-table :test 'equal)))
    (puthash "sig-id" t supervisor--failed)
    (puthash "sig-id" -9 supervisor--oneshot-completed)
    (supervisor--reset-failed "sig-id")
    (should-not (gethash "sig-id" supervisor--oneshot-completed))))

(ert-deftest supervisor-test-reset-failed-not-failed ()
  "Core reset-failed on non-failed ID returns skipped."
  (let ((supervisor--failed (make-hash-table :test 'equal)))
    (let ((result (supervisor--reset-failed "test-id")))
      (should (eq 'skipped (plist-get result :status))))))

(ert-deftest supervisor-test-cli-reload-requires-at-least-one-id ()
  "CLI `reload' with no arguments returns exit 2 (invalid args)."
  (let ((result (supervisor--cli-dispatch '("reload"))))
    (should (supervisor-cli-result-p result))
    (should (= supervisor-cli-exit-invalid-args
               (supervisor-cli-result-exitcode result)))
    (should (string-match "reload requires at least one ID"
                          (supervisor-cli-result-output result)))))

(ert-deftest supervisor-test-cli-reconcile-is-unknown-command ()
  "Removed `reconcile' command is rejected as unknown."
  (let ((result (supervisor--cli-dispatch '("reconcile"))))
    (should (supervisor-cli-result-p result))
    (should (= supervisor-cli-exit-invalid-args
               (supervisor-cli-result-exitcode result)))
    (should (string-match "Unknown command: reconcile"
                          (supervisor-cli-result-output result)))))

(ert-deftest supervisor-test-cli-list-is-unknown-command ()
  "Legacy `list' command is rejected after rename to `list-units'."
  (let ((result (supervisor--cli-dispatch '("list"))))
    (should (supervisor-cli-result-p result))
    (should (= supervisor-cli-exit-invalid-args
               (supervisor-cli-result-exitcode result)))
    (should (string-match "Unknown command: list"
                          (supervisor-cli-result-output result)))))

(ert-deftest supervisor-test-cli-describe-is-unknown-command ()
  "Legacy `describe' command is rejected after rename to `show'."
  (let ((result (supervisor--cli-dispatch '("describe"))))
    (should (supervisor-cli-result-p result))
    (should (= supervisor-cli-exit-invalid-args
               (supervisor-cli-result-exitcode result)))
    (should (string-match "Unknown command: describe"
                          (supervisor-cli-result-output result)))))

(ert-deftest supervisor-test-cli-graph-is-unknown-command ()
  "Legacy `graph' command is rejected after rename to `list-dependencies'."
  (let ((result (supervisor--cli-dispatch '("graph"))))
    (should (supervisor-cli-result-p result))
    (should (= supervisor-cli-exit-invalid-args
               (supervisor-cli-result-exitcode result)))
    (should (string-match "Unknown command: graph"
                          (supervisor-cli-result-output result)))))

(ert-deftest supervisor-test-cli-timers-is-unknown-command ()
  "Legacy `timers' command is rejected after rename to `list-timers'."
  (let ((result (supervisor--cli-dispatch '("timers"))))
    (should (supervisor-cli-result-p result))
    (should (= supervisor-cli-exit-invalid-args
               (supervisor-cli-result-exitcode result)))
    (should (string-match "Unknown command: timers"
                          (supervisor-cli-result-output result)))))

(ert-deftest supervisor-test-cli-status-no-args-shows-table ()
  "The `status' with no IDs shows overview table (delegates to `list-units')."
  (supervisor-test-with-unit-files
      '(("test-cmd" :id "test" :type simple))
    (let* ((supervisor--processes (make-hash-table :test 'equal))
           (supervisor--entry-state (make-hash-table :test 'equal))
           (result (supervisor--cli-dispatch '("status"))))
      (should (supervisor-cli-result-p result))
      (should (= supervisor-cli-exit-success (supervisor-cli-result-exitcode result)))
      ;; Should contain header row (table format)
      (should (string-match "ID" (supervisor-cli-result-output result))))))

(ert-deftest supervisor-test-cli-status-with-id-shows-detail ()
  "The `status ID' shows detailed unit info."
  (supervisor-test-with-unit-files
      '(("test-cmd" :id "test" :type simple))
    (let* ((supervisor--processes (make-hash-table :test 'equal))
           (supervisor--entry-state (make-hash-table :test 'equal))
           (result (supervisor--cli-dispatch '("status" "test"))))
      (should (supervisor-cli-result-p result))
      (should (= supervisor-cli-exit-success (supervisor-cli-result-exitcode result)))
      ;; Should show detailed info (describe format)
      (should (string-match "ID: test" (supervisor-cli-result-output result)))
      (should (string-match "Type:" (supervisor-cli-result-output result)))
      (should (string-match "Status:" (supervisor-cli-result-output result))))))

(ert-deftest supervisor-test-cli-status-partial-missing ()
  "The `status ID1 ID2' prints found units and warns about missing ones."
  (supervisor-test-with-unit-files
      '(("test-cmd" :id "test" :type simple))
    (let* ((supervisor--processes (make-hash-table :test 'equal))
           (supervisor--entry-state (make-hash-table :test 'equal))
           (result (supervisor--cli-dispatch '("status" "test" "nonexistent"))))
      (should (supervisor-cli-result-p result))
      ;; Non-zero exit because of missing ID
      (should (= supervisor-cli-exit-failure (supervisor-cli-result-exitcode result)))
      ;; But should still show output for the found ID
      (should (string-match "ID: test" (supervisor-cli-result-output result)))
      ;; And warn about the missing one
      (should (string-match "nonexistent" (supervisor-cli-result-output result))))))

(ert-deftest supervisor-test-cli-status-all-missing ()
  "The `status' with only missing IDs still shows warnings."
  (supervisor-test-with-unit-files
      '(("test-cmd" :id "test" :type simple))
    (let* ((supervisor--processes (make-hash-table :test 'equal))
           (supervisor--entry-state (make-hash-table :test 'equal))
           (result (supervisor--cli-dispatch '("status" "nope"))))
      (should (supervisor-cli-result-p result))
      (should (= supervisor-cli-exit-failure (supervisor-cli-result-exitcode result)))
      (should (string-match "could not be found" (supervisor-cli-result-output result))))))

(ert-deftest supervisor-test-cli-list-units-filters-invalid ()
  "The `list-units ID' filters both valid and invalid entries."
  (supervisor-test-with-unit-files
      '(("good-cmd" :id "good" :type simple)
        ("bad-cmd" :id "bad" :type "string-type"))
    (let* ((supervisor--processes (make-hash-table :test 'equal))
           (supervisor--entry-state (make-hash-table :test 'equal))
           (result (supervisor--cli-dispatch '("list-units" "good"))))
      (should (supervisor-cli-result-p result))
      (should (= supervisor-cli-exit-success (supervisor-cli-result-exitcode result)))
      ;; Should show "good" but not "bad" (invalid entry filtered out)
      (should (string-match "good" (supervisor-cli-result-output result)))
      (should-not (string-match "bad" (supervisor-cli-result-output result))))))

(ert-deftest supervisor-test-cli-status-invalid-id-shows-invalid-detail ()
  "The `status' with an invalid unit ID shows invalid detail, not \"not found\"."
  (supervisor-test-with-unit-files
      '(("good-cmd" :id "good" :type simple)
        ("bad-cmd" :id "bad" :type "string-type"))
    (let* ((supervisor--processes (make-hash-table :test 'equal))
           (supervisor--entry-state (make-hash-table :test 'equal))
           (result (supervisor--cli-dispatch '("status" "bad"))))
      (should (supervisor-cli-result-p result))
      ;; Invalid configured unit is found, so exit success (not missing)
      (should (= supervisor-cli-exit-success (supervisor-cli-result-exitcode result)))
      (should (string-match "ID: bad" (supervisor-cli-result-output result)))
      (should (string-match "Status: invalid" (supervisor-cli-result-output result)))
      (should-not (string-match "could not be found" (supervisor-cli-result-output result))))))

(ert-deftest supervisor-test-cli-status-mixed-valid-invalid-missing ()
  "The `status' with valid, invalid, and missing IDs classifies each correctly."
  (supervisor-test-with-unit-files
      '(("good-cmd" :id "good" :type simple)
        ("bad-cmd" :id "bad" :type "string-type"))
    (let* ((supervisor--processes (make-hash-table :test 'equal))
           (supervisor--entry-state (make-hash-table :test 'equal))
           (result (supervisor--cli-dispatch '("status" "good" "bad" "ghost"))))
      (should (supervisor-cli-result-p result))
      ;; Non-zero exit because "ghost" is truly missing
      (should (= supervisor-cli-exit-failure (supervisor-cli-result-exitcode result)))
      ;; Valid unit has detail
      (should (string-match "ID: good" (supervisor-cli-result-output result)))
      ;; Invalid unit has invalid detail
      (should (string-match "ID: bad" (supervisor-cli-result-output result)))
      (should (string-match "Status: invalid" (supervisor-cli-result-output result)))
      ;; Only the truly missing ID gets "could not be found"
      (should (string-match "ghost.*could not be found" (supervisor-cli-result-output result))))))

(ert-deftest supervisor-test-cli-status-invalid-id-json ()
  "The `status --json' with invalid ID returns invalid array, not not_found."
  (supervisor-test-with-unit-files
      '(("bad-cmd" :id "bad" :type "string-type"))
    (let* ((supervisor--processes (make-hash-table :test 'equal))
           (supervisor--entry-state (make-hash-table :test 'equal))
           (result (supervisor--cli-dispatch '("status" "bad" "--json"))))
      (should (supervisor-cli-result-p result))
      (should (= supervisor-cli-exit-success (supervisor-cli-result-exitcode result)))
      (let ((parsed (json-read-from-string (supervisor-cli-result-output result))))
        ;; Invalid unit appears in "invalid" array, not "not_found"
        (should (< 0 (length (alist-get 'invalid parsed))))
        (should (equal "bad" (alist-get 'id (aref (alist-get 'invalid parsed) 0))))))))

(ert-deftest supervisor-test-cli-show-invalid-id-shows-invalid-detail ()
  "The `show' with an invalid unit ID shows invalid detail, not \"not found\"."
  (supervisor-test-with-unit-files
      '(("bad-cmd" :id "bad" :type "string-type"))
    (let* ((supervisor--processes (make-hash-table :test 'equal))
           (supervisor--entry-state (make-hash-table :test 'equal))
           (result (supervisor--cli-dispatch '("show" "bad"))))
      (should (supervisor-cli-result-p result))
      (should (= supervisor-cli-exit-success (supervisor-cli-result-exitcode result)))
      (should (string-match "ID: bad" (supervisor-cli-result-output result)))
      (should (string-match "Status: invalid" (supervisor-cli-result-output result)))
      (should-not (string-match "No entry with ID" (supervisor-cli-result-output result))))))

(ert-deftest supervisor-test-cli-show-invalid-id-json ()
  "The `show --json' with invalid ID returns invalid object, not error."
  (supervisor-test-with-unit-files
      '(("bad-cmd" :id "bad" :type "string-type"))
    (let* ((supervisor--processes (make-hash-table :test 'equal))
           (supervisor--entry-state (make-hash-table :test 'equal))
           (result (supervisor--cli-dispatch '("show" "bad" "--json"))))
      (should (supervisor-cli-result-p result))
      (should (= supervisor-cli-exit-success (supervisor-cli-result-exitcode result)))
      (let ((parsed (json-read-from-string (supervisor-cli-result-output result))))
        (should (equal "bad" (alist-get 'id parsed)))
        (should (alist-get 'reason parsed))))))

(ert-deftest supervisor-test-cli-show-truly-missing-still-errors ()
  "The `show' with a truly missing ID still returns an error."
  (supervisor-test-with-unit-files
      '(("good-cmd" :id "good" :type simple))
    (let* ((supervisor--processes (make-hash-table :test 'equal))
           (supervisor--entry-state (make-hash-table :test 'equal))
           (result (supervisor--cli-dispatch '("show" "ghost"))))
      (should (supervisor-cli-result-p result))
      (should (= supervisor-cli-exit-failure (supervisor-cli-result-exitcode result)))
      (should (string-match "No entry with ID" (supervisor-cli-result-output result))))))

(ert-deftest supervisor-test-cli-ping-rejects-extra-args ()
  "Ping with extra args returns invalid-args exit code."
  (let ((result (supervisor--cli-dispatch '("ping" "extra"))))
    (should (supervisor-cli-result-p result))
    (should (= supervisor-cli-exit-invalid-args (supervisor-cli-result-exitcode result)))))

(ert-deftest supervisor-test-cli-version-rejects-extra-args ()
  "Version with extra args returns invalid-args exit code."
  (let ((result (supervisor--cli-dispatch '("version" "extra"))))
    (should (supervisor-cli-result-p result))
    (should (= supervisor-cli-exit-invalid-args (supervisor-cli-result-exitcode result)))))

(ert-deftest supervisor-test-cli-list-timers-no-timers ()
  "The `list-timers' command with no timers configured."
  (supervisor-test-without-builtins
    (let ((supervisor-timer-subsystem-mode t)
          (supervisor-mode t)
          (supervisor-timers nil)
          (supervisor--timer-list nil)
          (supervisor--timer-state (make-hash-table :test 'equal))
          (supervisor--invalid-timers (make-hash-table :test 'equal)))
      (let ((result (supervisor--cli-dispatch '("list-timers"))))
        (should (supervisor-cli-result-p result))
        (should (= supervisor-cli-exit-success (supervisor-cli-result-exitcode result)))
        (should (string-match "No timers" (supervisor-cli-result-output result)))))))

(ert-deftest supervisor-test-cli-list-timers-builds-from-config-when-mode-off ()
  "The `list-timers' command works when `supervisor-mode' is off."
  (supervisor-test-with-unit-files
      '(("true" :id "s1" :type oneshot))
    (let ((supervisor-timer-subsystem-mode t)
          (supervisor-mode nil)
          (supervisor-timers '((:id "t1" :target "s1" :on-startup-sec 60)))
          (supervisor--timer-list nil)
          (supervisor--timer-state (make-hash-table :test 'equal))
          (supervisor--invalid-timers (make-hash-table :test 'equal)))
      (let ((result (supervisor--cli-dispatch '("list-timers"))))
        (should (supervisor-cli-result-p result))
        (should (= supervisor-cli-exit-success (supervisor-cli-result-exitcode result)))
        (should (string-match-p "t1" (supervisor-cli-result-output result)))
        (should (string-match-p "s1" (supervisor-cli-result-output result)))))))

(ert-deftest supervisor-test-cli-list-timers-disabled-message-no-experimental ()
  "The `list-timers' disabled response has no experimental wording."
  (let ((supervisor-timer-subsystem-mode nil)
        (supervisor-mode t)
        (supervisor--timer-list nil)
        (supervisor--timer-state (make-hash-table :test 'equal))
        (supervisor--invalid-timers (make-hash-table :test 'equal)))
    (let ((human (supervisor--cli-dispatch '("list-timers")))
          (json (supervisor--cli-dispatch '("--json" "list-timers"))))
      (should (supervisor-cli-result-p human))
      (should (= supervisor-cli-exit-success (supervisor-cli-result-exitcode human)))
      (should (string-match-p "Timer subsystem is disabled\\." (supervisor-cli-result-output human)))
      (should-not (string-match-p "experimental" (supervisor-cli-result-output human)))
      (let* ((json-object-type 'alist)
             (data (json-read-from-string (supervisor-cli-result-output json))))
        (should (equal "disabled" (alist-get 'status data)))
        (should (equal "Timer subsystem is disabled" (alist-get 'message data)))))))

(ert-deftest supervisor-test-cli-list-timers-shows-state ()
  "The `list-timers' command shows timer state."
  (let* ((supervisor-timer-subsystem-mode t)
         (supervisor-mode t)
         (timer (supervisor-timer--create :id "t1" :target "s1" :enabled t))
         (supervisor--timer-list (list timer))
         (supervisor--timer-state (make-hash-table :test 'equal))
         (supervisor--invalid-timers (make-hash-table :test 'equal)))
    (puthash "t1" '(:last-run-at 1000.0 :next-run-at 2000.0)
             supervisor--timer-state)
    (let ((result (supervisor--cli-dispatch '("list-timers"))))
      (should (supervisor-cli-result-p result))
      (should (= supervisor-cli-exit-success (supervisor-cli-result-exitcode result)))
      (should (string-match "t1" (supervisor-cli-result-output result)))
      (should (string-match "s1" (supervisor-cli-result-output result))))))

(ert-deftest supervisor-test-cli-list-timers-json ()
  "The `list-timers --json' outputs JSON."
  (let* ((timer (supervisor-timer--create :id "t1" :target "s1" :enabled t))
         (supervisor--timer-list (list timer))
         (supervisor--timer-state (make-hash-table :test 'equal))
         (supervisor--invalid-timers (make-hash-table :test 'equal)))
    (let ((result (supervisor--cli-dispatch '("--json" "list-timers"))))
      (should (supervisor-cli-result-p result))
      (should (= supervisor-cli-exit-success (supervisor-cli-result-exitcode result)))
      (should (eq 'json (supervisor-cli-result-format result)))
      ;; Should be valid JSON
      (let ((json-object-type 'alist))
        (should (json-read-from-string (supervisor-cli-result-output result)))))))

(ert-deftest supervisor-test-cli-list-timers-invalid-human-format ()
  "The `list-timers' command shows invalid timers with correct id and reason."
  (supervisor-test-with-unit-files nil
    (let ((supervisor-timer-subsystem-mode t)
          (supervisor-mode t)
          (supervisor-timers '((:id "bad-timer"
                               :target "missing"
                               :on-startup-sec 60)))
          (supervisor--timer-list nil)
          (supervisor--timer-state (make-hash-table :test 'equal))
          (supervisor--invalid-timers (make-hash-table :test 'equal)))
      (let ((result (supervisor--cli-dispatch '("list-timers"))))
        (should (supervisor-cli-result-p result))
        (should (= supervisor-cli-exit-success (supervisor-cli-result-exitcode result)))
        ;; Should show id and validation reason
        (should (string-match-p "bad-timer" (supervisor-cli-result-output result)))
        (should (string-match-p "target" (supervisor-cli-result-output result)))))))

(ert-deftest supervisor-test-cli-list-timers-invalid-json-format ()
  "The `list-timers --json' outputs invalid timers with correct structure."
  (supervisor-test-with-unit-files nil
    (let ((supervisor-timer-subsystem-mode t)
          (supervisor-mode t)
          (supervisor-timers '((:id "bad-timer"
                               :target "missing"
                               :on-startup-sec 60)))
          (supervisor--timer-list nil)
          (supervisor--timer-state (make-hash-table :test 'equal))
          (supervisor--invalid-timers (make-hash-table :test 'equal)))
      (let ((result (supervisor--cli-dispatch '("--json" "list-timers"))))
        (should (supervisor-cli-result-p result))
        (should (= supervisor-cli-exit-success (supervisor-cli-result-exitcode result)))
        ;; Parse JSON and check invalid array structure
        (let* ((json-object-type 'alist)
               (json-array-type 'list)
               (data (json-read-from-string (supervisor-cli-result-output result)))
               (invalid (alist-get 'invalid data))
               (entry (car invalid)))
          (should invalid)
          (should (equal "bad-timer" (alist-get 'id entry)))
          (should (string-match-p "target" (alist-get 'reason entry))))))))

(ert-deftest supervisor-test-dashboard-timer-signal-exit-is-failed ()
  "Dashboard timer entry shows signal exit code in EXIT column."
  (let* ((timer (supervisor-timer--create :id "t1" :target "s1" :enabled t))
         (supervisor--timer-list (list timer))
         (supervisor--timer-state (make-hash-table :test 'equal))
         (supervisor--processes (make-hash-table :test 'equal)))
    ;; Simulate signal death stored as negative exit code
    (puthash "t1" '(:last-exit -9 :next-run-at 2000.0) supervisor--timer-state)
    (cl-letf (((symbol-function 'supervisor--get-entry-for-id)
               (lambda (_id) nil)))
      (let ((entry (supervisor--make-timer-dashboard-entry timer)))
        ;; Exit code is at index 5
        (should (string= "-9" (aref entry 5)))))))

(ert-deftest supervisor-test-cli-list-timers-full-field-mapping ()
  "The `list-timers' output includes all required fields.
Target type is resolved from current config."
  (let* ((supervisor-timer-subsystem-mode t)
         (supervisor-mode t)
         (timer (supervisor-timer--create :id "test-timer" :target "test-target"
                                          :enabled t :persistent t))
         (supervisor--timer-list (list timer))
         (supervisor--timer-state (make-hash-table :test 'equal))
         (supervisor--invalid-timers (make-hash-table :test 'equal))
         (mock-entry (list "test-target" "echo hi" 0 t nil nil nil nil
                           'oneshot nil nil nil nil nil nil nil nil nil nil
                           nil nil nil nil nil nil nil nil nil nil nil nil
                           nil nil)))
    ;; Set up comprehensive state (note: :last-missed-at is the state key)
    (puthash "test-timer" '(:last-run-at 1000.0
                            :last-success-at 900.0
                            :last-failure-at 950.0
                            :last-exit 1
                            :next-run-at 2000.0
                            :last-missed-at 850.0
                            :last-miss-reason overlap
                            :last-result skip
                            :last-result-reason overlap)
             supervisor--timer-state)
    (cl-letf (((symbol-function 'supervisor--get-entry-for-id)
               (lambda (_id) mock-entry)))
      ;; Test human format includes all fields
      (let ((result (supervisor--cli-dispatch '("list-timers"))))
        (should (supervisor-cli-result-p result))
        (let ((output (supervisor-cli-result-output result)))
          ;; ID and target
          (should (string-match-p "test-timer" output))
          (should (string-match-p "test-target" output))
          ;; Enabled (yes/no)
          (should (string-match-p "yes" output))
          ;; Exit code
          (should (string-match-p "1" output))
          ;; Type resolved from config
          (should (string-match-p "oneshot" output))
          ;; Result and reason
          (should (string-match-p "skip" output))
          (should (string-match-p "overlap" output))))
      ;; Test JSON format includes all fields with correct values
      (let ((result (supervisor--cli-dispatch '("--json" "list-timers"))))
        (should (supervisor-cli-result-p result))
        (let* ((json-object-type 'alist)
               (json-array-type 'list)
               (data (json-read-from-string (supervisor-cli-result-output result)))
               (timers (alist-get 'timers data))
               (entry (car timers)))
          ;; Verify all required fields present and mapped correctly
          (should (equal "test-timer" (alist-get 'id entry)))
          (should (equal "test-target" (alist-get 'target entry)))
          (should (eq t (alist-get 'enabled entry)))
          (should (eq t (alist-get 'persistent entry)))
          (should (= 1000.0 (alist-get 'last_run_at entry)))
          (should (= 900.0 (alist-get 'last_success_at entry)))
          (should (= 950.0 (alist-get 'last_failure_at entry)))
          (should (= 1 (alist-get 'last_exit entry)))
          (should (= 2000.0 (alist-get 'next_run_at entry)))
          (should (= 850.0 (alist-get 'last_miss_at entry)))
          (should (equal "overlap" (alist-get 'miss_reason entry)))
          (should (equal "oneshot" (alist-get 'target_type entry))))))))

(ert-deftest supervisor-test-cli-list-timers-rejects-extra-args ()
  "The `list-timers' with extra args returns invalid-args exit code."
  (let ((supervisor--timer-list nil)
        (supervisor--timer-state (make-hash-table :test 'equal))
        (supervisor--invalid-timers (make-hash-table :test 'equal)))
    (let ((result (supervisor--cli-dispatch '("list-timers" "extra"))))
      (should (supervisor-cli-result-p result))
      (should (= supervisor-cli-exit-invalid-args (supervisor-cli-result-exitcode result))))))

(ert-deftest supervisor-test-cli-blame-rejects-extra-args ()
  "Blame with extra args returns invalid-args exit code."
  (let ((supervisor--start-times (make-hash-table :test 'equal)))
    (let ((result (supervisor--cli-dispatch '("blame" "extra"))))
      (should (supervisor-cli-result-p result))
      (should (= supervisor-cli-exit-invalid-args (supervisor-cli-result-exitcode result))))))

(ert-deftest supervisor-test-cli-show-rejects-extra-args ()
  "The `show' with extra args returns invalid-args exit code."
  (supervisor-test-with-unit-files
      '(("cmd" :id "test"))
    (let* ((result (supervisor--cli-dispatch '("show" "test" "extra"))))
      (should (supervisor-cli-result-p result))
      (should (= supervisor-cli-exit-invalid-args (supervisor-cli-result-exitcode result))))))

(ert-deftest supervisor-test-cli-status-rejects-unknown-flags ()
  "Status with unknown flag returns invalid-args exit code."
  (let ((result (supervisor--cli-dispatch '("status" "--bogus"))))
    (should (supervisor-cli-result-p result))
    (should (= supervisor-cli-exit-invalid-args (supervisor-cli-result-exitcode result)))))

(ert-deftest supervisor-test-cli-list-dependencies-rejects-extra-args ()
  "The `list-dependencies' with multiple args returns invalid-args exit code."
  (supervisor-test-with-unit-files
      '(("a" :id "a"))
    (let* ((result (supervisor--cli-dispatch '("list-dependencies" "a" "b"))))
      (should (supervisor-cli-result-p result))
      (should (= supervisor-cli-exit-invalid-args (supervisor-cli-result-exitcode result))))))

;;; CLI JSON Schema Tests

(ert-deftest supervisor-test-cli-list-units-json-empty-arrays ()
  "The `list-units --json' returns arrays, not null, for empty results."
  (supervisor-test-with-unit-files
      nil
    (let* ((result (supervisor--cli-dispatch '("list-units" "--json"))))
      (should (supervisor-cli-result-p result))
      (should (= supervisor-cli-exit-success (supervisor-cli-result-exitcode result)))
      ;; Should have [] not null
      (should (string-match "\"entries\":\\[\\]" (supervisor-cli-result-output result)))
      (should (string-match "\"invalid\":\\[\\]" (supervisor-cli-result-output result))))))

;;; CLI Wrapper Transport Tests

(ert-deftest supervisor-test-cli-wrapper-dispatch-format ()
  "Wrapper dispatch returns base64-encoded format."
  (supervisor-test-with-unit-files
      nil
    (let* ((result (supervisor--cli-dispatch-for-wrapper '("ping"))))
      ;; Format is EXITCODE:BASE64OUTPUT
      (should (stringp result))
      (should (string-match "^0:" result))
      ;; Decode the base64 part
      (let ((b64 (substring result 2)))
        (should (string-match "pong" (decode-coding-string (base64-decode-string b64) 'utf-8)))))))

(ert-deftest supervisor-test-cli-wrapper-dispatch-error ()
  "Wrapper dispatch returns non-zero exit code for errors."
  (let ((result (supervisor--cli-dispatch-for-wrapper '("unknown-cmd"))))
    ;; Should start with 2: (invalid args)
    (should (stringp result))
    (should (string-match "^2:" result))))

(ert-deftest supervisor-test-cli-wrapper-edit-transport-clean ()
  "Wrapper edit output has clean EXITCODE:BASE64 format with no extra stdout."
  (let* ((dir (make-temp-file "units-" t))
         (supervisor-unit-authority-path (list dir))
         (supervisor-unit-directory dir)
         (supervisor--authority-snapshot nil)
         (supervisor--programs-cache :not-yet-loaded)
         (supervisor--unit-file-invalid (make-hash-table :test 'equal))
         (result (supervisor--cli-dispatch-for-wrapper
                  '("edit" "new-svc" "--json"))))
    (unwind-protect
        (progn
          ;; Must be EXITCODE:BASE64 with numeric exit code
          (should (stringp result))
          (should (string-match "^\\([0-9]+\\):\\(.*\\)$" result))
          ;; Decode and verify valid JSON
          (let* ((b64 (match-string 2 result))
                 (decoded (decode-coding-string
                           (base64-decode-string b64) 'utf-8))
                 (parsed (json-read-from-string decoded)))
            (should (assoc 'path parsed))
            (should (assoc 'tier parsed))
            (should (assoc 'created parsed))))
      (delete-directory dir t))))

;;; CLI Malformed Option Tests

(ert-deftest supervisor-test-cli-status-rejects-short-unknown-flag ()
  "Status with single-letter unknown flag returns invalid-args."
  (let ((result (supervisor--cli-dispatch '("status" "-x"))))
    (should (supervisor-cli-result-p result))
    (should (= supervisor-cli-exit-invalid-args (supervisor-cli-result-exitcode result)))))

(ert-deftest supervisor-test-cli-logs-rejects-malformed-tail ()
  "Logs with --tailx (prefix match) returns invalid-args."
  (let ((result (supervisor--cli-dispatch '("logs" "test" "--tailx" "5"))))
    (should (supervisor-cli-result-p result))
    (should (= supervisor-cli-exit-invalid-args (supervisor-cli-result-exitcode result)))))

(ert-deftest supervisor-test-cli-kill-rejects-malformed-signal ()
  "Kill with --signalx (prefix match) returns invalid-args."
  (let ((result (supervisor--cli-dispatch '("kill" "test" "--signalx" "TERM"))))
    (should (supervisor-cli-result-p result))
    (should (= supervisor-cli-exit-invalid-args (supervisor-cli-result-exitcode result)))))

(ert-deftest supervisor-test-cli-logs-tail-missing-value ()
  "Logs with --tail but no value returns invalid-args."
  (let ((result (supervisor--cli-dispatch '("logs" "test" "--tail"))))
    (should (supervisor-cli-result-p result))
    (should (= supervisor-cli-exit-invalid-args (supervisor-cli-result-exitcode result)))
    (should (string-match "requires a numeric value" (supervisor-cli-result-output result)))))

(ert-deftest supervisor-test-cli-logs-tail-non-numeric ()
  "Logs with --tail abc returns invalid-args."
  (let ((result (supervisor--cli-dispatch '("logs" "test" "--tail" "abc"))))
    (should (supervisor-cli-result-p result))
    (should (= supervisor-cli-exit-invalid-args (supervisor-cli-result-exitcode result)))
    (should (string-match "must be a number" (supervisor-cli-result-output result)))))

(ert-deftest supervisor-test-cli-logs-id-matches-tail-value ()
  "Logs with ID that matches --tail value should not collide."
  ;; ("logs" "5" "--tail" "5") - ID is "5", tail value is also "5"
  ;; Should NOT reject the ID just because it matches the tail value
  (let ((result (supervisor--cli-dispatch '("logs" "5" "--tail" "5"))))
    (should (supervisor-cli-result-p result))
    ;; Should fail because log file doesn't exist, not because ID is missing
    (should (= supervisor-cli-exit-failure (supervisor-cli-result-exitcode result)))
    (should (string-match "No log file for '5'" (supervisor-cli-result-output result)))))

(ert-deftest supervisor-test-cli-logs-extra-arg-matches-tail-value ()
  "Logs with extra arg matching --tail value should be rejected."
  ;; ("logs" "foo" "--tail" "5" "5") - extra "5" should not be hidden
  (let ((result (supervisor--cli-dispatch '("logs" "foo" "--tail" "5" "5"))))
    (should (supervisor-cli-result-p result))
    (should (= supervisor-cli-exit-invalid-args (supervisor-cli-result-exitcode result)))
    (should (string-match "got extra" (supervisor-cli-result-output result)))))

(ert-deftest supervisor-test-cli-kill-id-matches-signal-value ()
  "Kill with ID that matches --signal value should not collide."
  ;; ("kill" "TERM" "--signal" "TERM") - ID is "TERM", signal value is also "TERM"
  ;; Should NOT reject the ID just because it matches the signal value
  (let* ((supervisor--processes (make-hash-table :test 'equal))
         (result (supervisor--cli-dispatch '("kill" "TERM" "--signal" "TERM"))))
    (should (supervisor-cli-result-p result))
    ;; Should fail because process not running, not because ID is missing
    (should (= supervisor-cli-exit-failure (supervisor-cli-result-exitcode result)))
    (should (string-match "not running" (supervisor-cli-result-output result)))))

(ert-deftest supervisor-test-cli-kill-extra-arg-matches-signal-value ()
  "Kill with extra arg matching --signal value should be rejected."
  ;; ("kill" "foo" "--signal" "TERM" "TERM") - extra "TERM" should not be hidden
  (let ((result (supervisor--cli-dispatch '("kill" "foo" "--signal" "TERM" "TERM"))))
    (should (supervisor-cli-result-p result))
    (should (= supervisor-cli-exit-invalid-args (supervisor-cli-result-exitcode result)))
    (should (string-match "got extra" (supervisor-cli-result-output result)))))

(ert-deftest supervisor-test-cli-logs-duplicate-tail ()
  "Logs with --tail specified twice returns invalid-args."
  (let ((result (supervisor--cli-dispatch '("logs" "foo" "--tail" "10" "--tail" "20"))))
    (should (supervisor-cli-result-p result))
    (should (= supervisor-cli-exit-invalid-args (supervisor-cli-result-exitcode result)))
    (should (string-match "multiple times" (supervisor-cli-result-output result)))))

(ert-deftest supervisor-test-cli-kill-duplicate-signal ()
  "Kill with --signal specified twice returns invalid-args."
  (let ((result (supervisor--cli-dispatch '("kill" "foo" "--signal" "TERM" "--signal" "KILL"))))
    (should (supervisor-cli-result-p result))
    (should (= supervisor-cli-exit-invalid-args (supervisor-cli-result-exitcode result)))
    (should (string-match "multiple times" (supervisor-cli-result-output result)))))

(ert-deftest supervisor-test-cli-kill-signal-missing-value ()
  "Kill with --signal but no value returns invalid-args."
  (let ((result (supervisor--cli-dispatch '("kill" "test" "--signal"))))
    (should (supervisor-cli-result-p result))
    (should (= supervisor-cli-exit-invalid-args (supervisor-cli-result-exitcode result)))
    (should (string-match "requires a signal name" (supervisor-cli-result-output result)))))

(ert-deftest supervisor-test-cli-kill-signal-invalid-name ()
  "Kill with --signal NOSIG returns invalid-args."
  (let ((result (supervisor--cli-dispatch '("kill" "test" "--signal" "NOSIG"))))
    (should (supervisor-cli-result-p result))
    (should (= supervisor-cli-exit-invalid-args (supervisor-cli-result-exitcode result)))
    (should (string-match "Invalid signal name" (supervisor-cli-result-output result)))))

(ert-deftest supervisor-test-cli-logs-option-before-id ()
  "Logs with only option (no ID) returns invalid-args (exit 2)."
  (let ((result (supervisor--cli-dispatch '("logs" "--tail" "5"))))
    (should (supervisor-cli-result-p result))
    (should (= supervisor-cli-exit-invalid-args (supervisor-cli-result-exitcode result)))
    (should (string-match "requires an ID" (supervisor-cli-result-output result)))))

(ert-deftest supervisor-test-cli-kill-option-before-id ()
  "Kill with only option (no ID) returns invalid-args (exit 2)."
  (let ((result (supervisor--cli-dispatch '("kill" "--signal" "TERM"))))
    (should (supervisor-cli-result-p result))
    (should (= supervisor-cli-exit-invalid-args (supervisor-cli-result-exitcode result)))
    (should (string-match "requires an ID" (supervisor-cli-result-output result)))))

(ert-deftest supervisor-test-cli-start-rejects-unknown-flags ()
  "Start with unknown flag returns invalid-args (exit 2)."
  (let ((result (supervisor--cli-dispatch '("start" "--bogus"))))
    (should (supervisor-cli-result-p result))
    (should (= supervisor-cli-exit-invalid-args (supervisor-cli-result-exitcode result)))))

(ert-deftest supervisor-test-cli-stop-rejects-unknown-flags ()
  "Stop with unknown flag returns invalid-args (exit 2)."
  (let ((result (supervisor--cli-dispatch '("stop" "--bogus"))))
    (should (supervisor-cli-result-p result))
    (should (= supervisor-cli-exit-invalid-args (supervisor-cli-result-exitcode result)))))

(ert-deftest supervisor-test-cli-restart-rejects-unknown-flags ()
  "Restart with unknown flag returns invalid-args (exit 2)."
  (let ((result (supervisor--cli-dispatch '("restart" "--bogus"))))
    (should (supervisor-cli-result-p result))
    (should (= supervisor-cli-exit-invalid-args (supervisor-cli-result-exitcode result)))))

(ert-deftest supervisor-test-cli-enable-rejects-unknown-flags ()
  "Enable with unknown flag returns invalid-args (exit 2)."
  (let ((result (supervisor--cli-dispatch '("enable" "--bogus"))))
    (should (supervisor-cli-result-p result))
    (should (= supervisor-cli-exit-invalid-args (supervisor-cli-result-exitcode result)))))

(ert-deftest supervisor-test-cli-disable-rejects-unknown-flags ()
  "Disable with unknown flag returns invalid-args (exit 2)."
  (let ((result (supervisor--cli-dispatch '("disable" "--bogus"))))
    (should (supervisor-cli-result-p result))
    (should (= supervisor-cli-exit-invalid-args (supervisor-cli-result-exitcode result)))))

(ert-deftest supervisor-test-cli-restart-policy-rejects-unknown-flags ()
  "Restart-policy with unknown flag returns invalid-args (exit 2)."
  (let ((result (supervisor--cli-dispatch '("restart-policy" "--bogus" "id"))))
    (should (supervisor-cli-result-p result))
    (should (= supervisor-cli-exit-invalid-args (supervisor-cli-result-exitcode result)))))

(ert-deftest supervisor-test-cli-logging-rejects-unknown-flags ()
  "Logging with unknown flag returns invalid-args (exit 2)."
  (let ((result (supervisor--cli-dispatch '("logging" "--bogus" "id"))))
    (should (supervisor-cli-result-p result))
    (should (= supervisor-cli-exit-invalid-args (supervisor-cli-result-exitcode result)))))

;;; CLI -- Separator Tests (POSIX end-of-options)

(ert-deftest supervisor-test-cli-split-at-separator ()
  "Split at -- separator correctly."
  (should (equal (supervisor--cli-split-at-separator '("a" "--" "b"))
                 '(("a") . ("b"))))
  (should (equal (supervisor--cli-split-at-separator '("a" "b"))
                 '(("a" "b") . nil)))
  (should (equal (supervisor--cli-split-at-separator '("--" "-svc"))
                 '(nil . ("-svc")))))

(ert-deftest supervisor-test-cli-strip-separator ()
  "Strip separator and concatenate."
  (should (equal (supervisor--cli-strip-separator '("a" "--" "b"))
                 '("a" "b")))
  (should (equal (supervisor--cli-strip-separator '("--" "-svc"))
                 '("-svc"))))

(ert-deftest supervisor-test-cli-parse-option ()
  "Parse option and value by position, not by value."
  ;; Option with value
  (let ((result (supervisor--cli-parse-option '("foo" "--opt" "val" "bar") "--opt")))
    (should (equal (plist-get result :value) "val"))
    (should (null (plist-get result :missing)))
    (should (equal (plist-get result :positional) '("foo" "bar"))))
  ;; Option with missing value (end of args)
  (let ((result (supervisor--cli-parse-option '("foo" "--opt") "--opt")))
    (should (null (plist-get result :value)))
    (should (plist-get result :missing))
    (should (equal (plist-get result :positional) '("foo"))))
  ;; Option with missing value (next arg is flag)
  (let ((result (supervisor--cli-parse-option '("--opt" "--other") "--opt")))
    (should (null (plist-get result :value)))
    (should (plist-get result :missing))
    (should (equal (plist-get result :positional) '("--other"))))
  ;; No option present
  (let ((result (supervisor--cli-parse-option '("foo" "bar") "--opt")))
    (should (null (plist-get result :value)))
    (should (null (plist-get result :missing)))
    (should (equal (plist-get result :positional) '("foo" "bar"))))
  ;; Value collision: positional arg equals option value
  (let ((result (supervisor--cli-parse-option '("5" "--tail" "5") "--tail")))
    (should (equal (plist-get result :value) "5"))
    (should (null (plist-get result :missing)))
    ;; Positional "5" should NOT be removed by value collision
    (should (equal (plist-get result :positional) '("5"))))
  ;; Duplicate option detection
  (let ((result (supervisor--cli-parse-option '("--opt" "val1" "--opt" "val2") "--opt")))
    (should (plist-get result :duplicate))
    ;; Value is the last one seen
    (should (equal (plist-get result :value) "val2")))
  ;; Single option is not duplicate
  (let ((result (supervisor--cli-parse-option '("--opt" "val") "--opt")))
    (should (null (plist-get result :duplicate)))))

(ert-deftest supervisor-test-cli-enable-hyphen-id-with-separator ()
  "Enable allows hyphen-prefixed ID after -- separator."
  (supervisor-test-with-unit-files
      '(("sleep 300" :id "-svc" :type simple :enabled nil))
    (let ((supervisor--enabled-override (make-hash-table :test 'equal))
          (supervisor-overrides-file nil))
      (let ((result (supervisor--cli-dispatch '("enable" "--" "-svc"))))
        (should (supervisor-cli-result-p result))
        (should (= supervisor-cli-exit-success
                    (supervisor-cli-result-exitcode result)))
        (should (eq 'enabled
                    (gethash "-svc" supervisor--enabled-override)))))))

(ert-deftest supervisor-test-cli-logs-hyphen-id-with-separator ()
  "Logs allows hyphen-prefixed ID after -- separator."
  ;; Without separator, should fail with "ID as first argument"
  (let ((result (supervisor--cli-dispatch '("logs" "-svc"))))
    (should (= supervisor-cli-exit-invalid-args (supervisor-cli-result-exitcode result))))
  ;; With separator, should proceed (will fail with "No log file" but that's exit 1, not 2)
  (let ((result (supervisor--cli-dispatch '("logs" "--" "-svc"))))
    (should (= supervisor-cli-exit-failure (supervisor-cli-result-exitcode result)))
    (should (string-match "No log file" (supervisor-cli-result-output result)))))

(ert-deftest supervisor-test-cli-logs-rejects-extra-args ()
  "Logs with extra args returns invalid-args (exit 2)."
  (let ((result (supervisor--cli-dispatch '("logs" "id1" "id2"))))
    (should (= supervisor-cli-exit-invalid-args (supervisor-cli-result-exitcode result)))
    (should (string-match "extra" (supervisor-cli-result-output result)))))

(ert-deftest supervisor-test-cli-kill-rejects-extra-args ()
  "Kill with extra args returns invalid-args (exit 2)."
  (let ((result (supervisor--cli-dispatch '("kill" "id1" "id2"))))
    (should (= supervisor-cli-exit-invalid-args (supervisor-cli-result-exitcode result)))
    (should (string-match "extra" (supervisor-cli-result-output result)))))

(ert-deftest supervisor-test-cli-logs-options-not-parsed-after-separator ()
  "Logs does not parse --tail after -- separator."
  ;; logs -- --tail should treat --tail as the ID, not an option
  (let ((result (supervisor--cli-dispatch '("logs" "--" "--tail"))))
    ;; Should fail with "No log file for --tail", not parse --tail as option
    (should (= supervisor-cli-exit-failure (supervisor-cli-result-exitcode result)))
    (should (string-match "No log file for '--tail'" (supervisor-cli-result-output result)))))

;;; CLI -- is-active Tests

(ert-deftest supervisor-test-cli-is-active-running ()
  "The `is-active' returns exit 0 for a running unit."
  (supervisor-test-with-unit-files
      '(("sleep 999" :id "svc" :type simple))
    (let* ((supervisor--processes (make-hash-table :test 'equal))
           (supervisor--entry-state (make-hash-table :test 'equal))
           (proc (start-process "test" nil "sleep" "999")))
      (unwind-protect
          (progn
            (puthash "svc" proc supervisor--processes)
            (let ((result (supervisor--cli-dispatch '("is-active" "svc"))))
              (should (= supervisor-cli-exit-success
                         (supervisor-cli-result-exitcode result)))
              (should (string-match "running" (supervisor-cli-result-output result)))))
        (delete-process proc)))))

(ert-deftest supervisor-test-cli-is-active-not-running ()
  "The `is-active' returns exit 3 (not-active) for a non-running unit."
  (supervisor-test-with-unit-files
      '(("echo hi" :id "svc" :type simple))
    (let* ((supervisor--processes (make-hash-table :test 'equal))
           (supervisor--entry-state (make-hash-table :test 'equal))
           (result (supervisor--cli-dispatch '("is-active" "svc"))))
      (should (= supervisor-cli-exit-not-active
                 (supervisor-cli-result-exitcode result))))))

(ert-deftest supervisor-test-cli-is-active-unknown-id ()
  "The `is-active' returns exit 4 (no-such-unit) for unknown ID."
  (supervisor-test-with-unit-files
      '(("echo hi" :id "svc" :type simple))
    (let* ((supervisor--processes (make-hash-table :test 'equal))
           (supervisor--entry-state (make-hash-table :test 'equal))
           (result (supervisor--cli-dispatch '("is-active" "nonexistent"))))
      (should (= supervisor-cli-exit-no-such-unit
                 (supervisor-cli-result-exitcode result)))
      (should (string-match "inactive" (supervisor-cli-result-output result))))))

(ert-deftest supervisor-test-cli-is-active-no-args ()
  "The `is-active' with no args returns exit 2."
  (let ((result (supervisor--cli-dispatch '("is-active"))))
    (should (= supervisor-cli-exit-invalid-args
               (supervisor-cli-result-exitcode result)))))

(ert-deftest supervisor-test-cli-is-active-extra-args ()
  "The `is-active' with multiple IDs returns exit 2."
  (let ((result (supervisor--cli-dispatch '("is-active" "a" "b"))))
    (should (= supervisor-cli-exit-invalid-args
               (supervisor-cli-result-exitcode result)))))

(ert-deftest supervisor-test-cli-is-active-json ()
  "The `is-active --json' returns JSON with active field."
  (supervisor-test-with-unit-files
      '(("echo hi" :id "svc" :type simple))
    (let* ((supervisor--processes (make-hash-table :test 'equal))
           (supervisor--entry-state (make-hash-table :test 'equal))
           (result (supervisor--cli-dispatch '("is-active" "svc" "--json"))))
      (should (eq 'json (supervisor-cli-result-format result)))
      (let ((parsed (json-read-from-string (supervisor-cli-result-output result))))
        (should (equal "svc" (alist-get 'id parsed)))
        (should (assoc 'active parsed))
        (should (assoc 'status parsed))))))

(ert-deftest supervisor-test-cli-is-active-json-running ()
  "The `is-active --json' returns active=true for running unit."
  (supervisor-test-with-unit-files
      '(("sleep 999" :id "svc" :type simple))
    (let* ((supervisor--processes (make-hash-table :test 'equal))
           (supervisor--entry-state (make-hash-table :test 'equal))
           (proc (start-process "test" nil "sleep" "999")))
      (unwind-protect
          (progn
            (puthash "svc" proc supervisor--processes)
            (let* ((result (supervisor--cli-dispatch '("is-active" "svc" "--json")))
                   (parsed (json-read-from-string
                            (supervisor-cli-result-output result))))
              (should (= supervisor-cli-exit-success
                         (supervisor-cli-result-exitcode result)))
              (should (eq t (alist-get 'active parsed)))))
        (delete-process proc)))))

;;; CLI -- is-enabled Tests

(ert-deftest supervisor-test-cli-is-enabled-enabled ()
  "The `is-enabled' returns exit 0 for an enabled unit."
  (supervisor-test-with-unit-files
      '(("echo hi" :id "svc" :type simple))
    (let* ((supervisor--processes (make-hash-table :test 'equal))
           (supervisor--entry-state (make-hash-table :test 'equal))
           (result (supervisor--cli-dispatch '("is-enabled" "svc"))))
      (should (= supervisor-cli-exit-success
                 (supervisor-cli-result-exitcode result)))
      (should (string-match "enabled" (supervisor-cli-result-output result))))))

(ert-deftest supervisor-test-cli-is-enabled-disabled ()
  "The `is-enabled' returns exit 1 for a disabled unit."
  (supervisor-test-with-unit-files
      '(("echo hi" :id "svc" :type simple :disabled t))
    (let* ((supervisor--processes (make-hash-table :test 'equal))
           (supervisor--entry-state (make-hash-table :test 'equal))
           (result (supervisor--cli-dispatch '("is-enabled" "svc"))))
      (should (= supervisor-cli-exit-failure
                 (supervisor-cli-result-exitcode result)))
      (should (string-match "disabled" (supervisor-cli-result-output result))))))

(ert-deftest supervisor-test-cli-is-enabled-masked ()
  "The `is-enabled' returns exit 1 and state=masked for a masked unit."
  (supervisor-test-with-unit-files
      '(("echo hi" :id "svc" :type simple))
    (let* ((supervisor--processes (make-hash-table :test 'equal))
           (supervisor--entry-state (make-hash-table :test 'equal))
           (supervisor--mask-override (make-hash-table :test 'equal)))
      (puthash "svc" 'masked supervisor--mask-override)
      (let ((result (supervisor--cli-dispatch '("is-enabled" "svc"))))
        (should (= supervisor-cli-exit-failure
                   (supervisor-cli-result-exitcode result)))
        (should (string-match "masked" (supervisor-cli-result-output result)))))))

(ert-deftest supervisor-test-cli-is-enabled-unknown-id ()
  "The `is-enabled' returns exit 4 (no-such-unit) for unknown ID."
  (supervisor-test-with-unit-files
      '(("echo hi" :id "svc" :type simple))
    (let* ((supervisor--processes (make-hash-table :test 'equal))
           (supervisor--entry-state (make-hash-table :test 'equal))
           (result (supervisor--cli-dispatch '("is-enabled" "nonexistent"))))
      (should (= supervisor-cli-exit-no-such-unit
                 (supervisor-cli-result-exitcode result)))
      (should (string-match "not-found" (supervisor-cli-result-output result))))))

(ert-deftest supervisor-test-cli-is-enabled-no-args ()
  "The `is-enabled' with no args returns exit 2."
  (let ((result (supervisor--cli-dispatch '("is-enabled"))))
    (should (= supervisor-cli-exit-invalid-args
               (supervisor-cli-result-exitcode result)))))

(ert-deftest supervisor-test-cli-is-enabled-extra-args ()
  "The `is-enabled' with multiple IDs returns exit 2."
  (let ((result (supervisor--cli-dispatch '("is-enabled" "a" "b"))))
    (should (= supervisor-cli-exit-invalid-args
               (supervisor-cli-result-exitcode result)))))

(ert-deftest supervisor-test-cli-is-enabled-json ()
  "The `is-enabled --json' returns JSON with enabled and state fields."
  (supervisor-test-with-unit-files
      '(("echo hi" :id "svc" :type simple))
    (let* ((supervisor--processes (make-hash-table :test 'equal))
           (supervisor--entry-state (make-hash-table :test 'equal))
           (result (supervisor--cli-dispatch '("is-enabled" "svc" "--json"))))
      (should (eq 'json (supervisor-cli-result-format result)))
      (let ((parsed (json-read-from-string (supervisor-cli-result-output result))))
        (should (equal "svc" (alist-get 'id parsed)))
        (should (eq t (alist-get 'enabled parsed)))
        (should (equal "enabled" (alist-get 'state parsed)))))))

(ert-deftest supervisor-test-cli-is-enabled-masked-json ()
  "The `is-enabled --json' for masked unit shows enabled=false, state=masked."
  (supervisor-test-with-unit-files
      '(("echo hi" :id "svc" :type simple))
    (let* ((supervisor--processes (make-hash-table :test 'equal))
           (supervisor--entry-state (make-hash-table :test 'equal))
           (supervisor--mask-override (make-hash-table :test 'equal)))
      (puthash "svc" 'masked supervisor--mask-override)
      (let* ((result (supervisor--cli-dispatch '("is-enabled" "svc" "--json")))
             (parsed (json-read-from-string (supervisor-cli-result-output result))))
        (should (= supervisor-cli-exit-failure
                   (supervisor-cli-result-exitcode result)))
        (should (eq :json-false (alist-get 'enabled parsed)))
        (should (equal "masked" (alist-get 'state parsed)))))))

;;; CLI -- is-failed Tests

(ert-deftest supervisor-test-cli-is-failed-dead ()
  "The `is-failed' returns exit 0 for a crash-looped (dead) unit."
  (supervisor-test-with-unit-files
      '(("echo hi" :id "svc" :type simple))
    (let* ((supervisor--processes (make-hash-table :test 'equal))
           (supervisor--entry-state (make-hash-table :test 'equal))
           (supervisor--failed (make-hash-table :test 'equal)))
      (puthash "svc" t supervisor--failed)
      (let ((result (supervisor--cli-dispatch '("is-failed" "svc"))))
        (should (= supervisor-cli-exit-success
                   (supervisor-cli-result-exitcode result)))
        (should (string-match "dead" (supervisor-cli-result-output result)))))))

(ert-deftest supervisor-test-cli-is-failed-not-failed ()
  "The `is-failed' returns exit 1 for a non-failed unit."
  (supervisor-test-with-unit-files
      '(("echo hi" :id "svc" :type simple))
    (let* ((supervisor--processes (make-hash-table :test 'equal))
           (supervisor--entry-state (make-hash-table :test 'equal))
           (result (supervisor--cli-dispatch '("is-failed" "svc"))))
      (should (= supervisor-cli-exit-failure
                 (supervisor-cli-result-exitcode result))))))

(ert-deftest supervisor-test-cli-is-failed-oneshot-failed ()
  "The `is-failed' returns exit 0 for a oneshot with non-zero exit."
  (supervisor-test-with-unit-files
      '(("false" :id "svc" :type oneshot))
    (let* ((supervisor--processes (make-hash-table :test 'equal))
           (supervisor--entry-state (make-hash-table :test 'equal))
           (supervisor--oneshot-completed (make-hash-table :test 'equal)))
      (puthash "svc" 1 supervisor--oneshot-completed)
      (let ((result (supervisor--cli-dispatch '("is-failed" "svc"))))
        (should (= supervisor-cli-exit-success
                   (supervisor-cli-result-exitcode result)))
        (should (string-match "failed" (supervisor-cli-result-output result)))))))

(ert-deftest supervisor-test-cli-is-failed-unknown-id ()
  "The `is-failed' returns exit 4 (no-such-unit) for unknown ID."
  (supervisor-test-with-unit-files
      '(("echo hi" :id "svc" :type simple))
    (let* ((supervisor--processes (make-hash-table :test 'equal))
           (supervisor--entry-state (make-hash-table :test 'equal))
           (result (supervisor--cli-dispatch '("is-failed" "nonexistent"))))
      (should (= supervisor-cli-exit-no-such-unit
                 (supervisor-cli-result-exitcode result)))
      (should (string-match "inactive" (supervisor-cli-result-output result))))))

(ert-deftest supervisor-test-cli-is-failed-no-args ()
  "The `is-failed' with no args returns exit 2."
  (let ((result (supervisor--cli-dispatch '("is-failed"))))
    (should (= supervisor-cli-exit-invalid-args
               (supervisor-cli-result-exitcode result)))))

(ert-deftest supervisor-test-cli-is-failed-extra-args ()
  "The `is-failed' with multiple IDs returns exit 2."
  (let ((result (supervisor--cli-dispatch '("is-failed" "a" "b"))))
    (should (= supervisor-cli-exit-invalid-args
               (supervisor-cli-result-exitcode result)))))

(ert-deftest supervisor-test-cli-is-failed-json ()
  "The `is-failed --json' returns JSON with failed and status fields."
  (supervisor-test-with-unit-files
      '(("echo hi" :id "svc" :type simple))
    (let* ((supervisor--processes (make-hash-table :test 'equal))
           (supervisor--entry-state (make-hash-table :test 'equal))
           (supervisor--failed (make-hash-table :test 'equal)))
      (puthash "svc" t supervisor--failed)
      (let* ((result (supervisor--cli-dispatch '("is-failed" "svc" "--json")))
             (parsed (json-read-from-string (supervisor-cli-result-output result))))
        (should (= supervisor-cli-exit-success
                   (supervisor-cli-result-exitcode result)))
        (should (eq 'json (supervisor-cli-result-format result)))
        (should (equal "svc" (alist-get 'id parsed)))
        (should (eq t (alist-get 'failed parsed)))
        (should (equal "dead" (alist-get 'status parsed)))))))

(ert-deftest supervisor-test-cli-is-failed-running-json ()
  "The `is-failed --json' returns failed=false for running unit."
  (supervisor-test-with-unit-files
      '(("sleep 999" :id "svc" :type simple))
    (let* ((supervisor--processes (make-hash-table :test 'equal))
           (supervisor--entry-state (make-hash-table :test 'equal))
           (proc (start-process "test" nil "sleep" "999")))
      (unwind-protect
          (progn
            (puthash "svc" proc supervisor--processes)
            (let* ((result (supervisor--cli-dispatch '("is-failed" "svc" "--json")))
                   (parsed (json-read-from-string
                            (supervisor-cli-result-output result))))
              (should (= supervisor-cli-exit-failure
                         (supervisor-cli-result-exitcode result)))
              (should (eq :json-false (alist-get 'failed parsed)))))
        (delete-process proc)))))

;;; CLI -- daemon-reload Tests

(ert-deftest supervisor-test-daemon-reload-picks-up-config-change ()
  "The `daemon-reload' picks up added entries from disk."
  (supervisor-test-with-unit-files nil
    (let* ((supervisor--processes (make-hash-table :test 'equal))
           (supervisor--entry-state (make-hash-table :test 'equal))
           (supervisor--current-plan nil)
           (supervisor--invalid (make-hash-table :test 'equal)))
      ;; Write one unit file and reload
      (with-temp-file (expand-file-name "a.el" supervisor-unit-directory)
        (insert "(:id \"a\" :command \"echo a\" :type simple)"))
      (supervisor-daemon-reload)
      (should supervisor--current-plan)
      (should (= 1 (length (supervisor-plan-entries supervisor--current-plan))))
      ;; Add a second unit file and reload again
      (with-temp-file (expand-file-name "b.el" supervisor-unit-directory)
        (insert "(:id \"b\" :command \"echo b\" :type simple)"))
      (supervisor-daemon-reload)
      (should (= 2 (length (supervisor-plan-entries supervisor--current-plan)))))))

(ert-deftest supervisor-test-daemon-reload-runtime-untouched ()
  "The `daemon-reload' does not start or stop processes."
  (supervisor-test-with-unit-files
      '(("sleep 999" :id "svc" :type simple))
    (let ((supervisor--processes (make-hash-table :test 'equal))
          (supervisor--entry-state (make-hash-table :test 'equal))
          (supervisor--current-plan nil)
          (supervisor--invalid (make-hash-table :test 'equal))
          (proc (start-process "test" nil "sleep" "999")))
      (unwind-protect
          (progn
            (puthash "svc" proc supervisor--processes)
            ;; Remove the unit file from disk and reload
            (delete-file (expand-file-name "svc.el" supervisor-unit-directory))
            (supervisor-daemon-reload)
            ;; Process should still be running (runtime untouched)
            (should (process-live-p proc))
            (should (gethash "svc" supervisor--processes)))
        (delete-process proc)))))

(ert-deftest supervisor-test-daemon-reload-surfaces-invalid ()
  "The `daemon-reload' surfaces invalid entries in plan."
  (supervisor-test-with-unit-files
      '(("true" :id "ok" :type simple)
        ("true" :id "nope" :type "not-a-symbol"))
    (let ((supervisor--processes (make-hash-table :test 'equal))
          (supervisor--entry-state (make-hash-table :test 'equal))
          (supervisor--current-plan nil)
          (supervisor--invalid (make-hash-table :test 'equal)))
      (let ((result (supervisor-daemon-reload)))
        (should (= 1 (plist-get result :entries)))
        (should (= 1 (plist-get result :invalid)))
        (should (gethash "nope" supervisor--invalid))))))

(ert-deftest supervisor-test-daemon-reload-returns-counts ()
  "The `daemon-reload' returns entry and invalid counts."
  (supervisor-test-with-unit-files
      '(("echo a" :id "a" :type simple))
    (let ((supervisor--processes (make-hash-table :test 'equal))
          (supervisor--entry-state (make-hash-table :test 'equal))
          (supervisor--current-plan nil)
          (supervisor--invalid (make-hash-table :test 'equal)))
      (let ((result (supervisor-daemon-reload)))
        (should (= 1 (plist-get result :entries)))
        (should (= 0 (plist-get result :invalid)))))))

(ert-deftest supervisor-test-cli-daemon-reload ()
  "CLI `daemon-reload' returns success."
  (supervisor-test-with-unit-files
      '(("echo a" :id "a" :type simple))
    (let ((supervisor--processes (make-hash-table :test 'equal))
          (supervisor--entry-state (make-hash-table :test 'equal))
          (supervisor--current-plan nil)
          (supervisor--invalid (make-hash-table :test 'equal)))
      (let ((result (supervisor--cli-dispatch '("daemon-reload"))))
        (should (= supervisor-cli-exit-success
                   (supervisor-cli-result-exitcode result)))
        (should (string-match "1 entries" (supervisor-cli-result-output result)))))))

(ert-deftest supervisor-test-cli-daemon-reload-json ()
  "CLI `daemon-reload --json' returns JSON with reloaded and counts."
  (supervisor-test-with-unit-files
      '(("echo a" :id "a" :type simple))
    (let ((supervisor--processes (make-hash-table :test 'equal))
          (supervisor--entry-state (make-hash-table :test 'equal))
          (supervisor--current-plan nil)
          (supervisor--invalid (make-hash-table :test 'equal)))
      (let* ((result (supervisor--cli-dispatch '("daemon-reload" "--json")))
             (parsed (json-read-from-string (supervisor-cli-result-output result))))
        (should (= supervisor-cli-exit-success
                   (supervisor-cli-result-exitcode result)))
        (should (eq 'json (supervisor-cli-result-format result)))
        (should (eq t (alist-get 'reloaded parsed)))
        (should (= 1 (alist-get 'entries parsed)))
        (should (= 0 (alist-get 'invalid parsed)))))))

(ert-deftest supervisor-test-cli-daemon-reload-rejects-args ()
  "CLI `daemon-reload' with extra args returns exit 2."
  (let ((result (supervisor--cli-dispatch '("daemon-reload" "extra"))))
    (should (= supervisor-cli-exit-invalid-args
               (supervisor-cli-result-exitcode result)))))

(ert-deftest supervisor-test-start-clears-current-plan ()
  "The `supervisor-start' clears `supervisor--current-plan'."
  (let ((supervisor--current-plan 'dummy))
    ;; supervisor-start resets this to nil early in its flow
    ;; We can't call full start in tests, but verify the variable exists
    (should (boundp 'supervisor--current-plan))))

(ert-deftest supervisor-test-daemon-reload-counts-unit-file-invalid ()
  "The `daemon-reload' invalid count includes malformed unit files."
  (supervisor-test-with-unit-files nil
    (let* ((supervisor--processes (make-hash-table :test 'equal))
           (supervisor--entry-state (make-hash-table :test 'equal))
           (supervisor--current-plan nil)
           (supervisor--invalid (make-hash-table :test 'equal))
           (supervisor--cycle-fallback-ids (make-hash-table :test 'equal))
           (supervisor--computed-deps (make-hash-table :test 'equal)))
      ;; Create a malformed unit file (missing :command)
      (with-temp-file (expand-file-name "bad.el" supervisor-unit-directory)
        (insert "(:id \"bad-unit\")"))
      (let ((result (supervisor-daemon-reload)))
        ;; Invalid count should include the unit-file invalid
        (should (= 1 (plist-get result :invalid)))
        (should (gethash "bad-unit" supervisor--invalid))))))

;;; Phase 8: reload command tests

(ert-deftest supervisor-test-reload-unit-running-simple-restarts ()
  "Reloading a running simple unit stops and restarts it.
Reload bypasses `supervisor--manual-start' and calls
`supervisor--start-process' directly to avoid disabled-policy refusal."
  (supervisor-test-with-unit-files
      '(("sleep 999" :id "svc1"))
    (let* ((supervisor--processes (make-hash-table :test 'equal))
           (supervisor--failed (make-hash-table :test 'equal))
           (supervisor--restart-times (make-hash-table :test 'equal))
           (supervisor--oneshot-completed (make-hash-table :test 'equal))
           (supervisor--manually-stopped (make-hash-table :test 'equal))
           (supervisor--entry-state (make-hash-table :test 'equal))
           (supervisor--mask-override (make-hash-table :test 'equal))
           (supervisor--enabled-override (make-hash-table :test 'equal))
           (supervisor--invalid (make-hash-table :test 'equal))
           (supervisor--cycle-fallback-ids (make-hash-table :test 'equal))
           (supervisor--computed-deps (make-hash-table :test 'equal))
           (supervisor--logging (make-hash-table :test 'equal))
           (stop-called nil)
           (start-called nil))
      ;; Simulate a running process
      (puthash "svc1" (start-process "test" nil "sleep" "999")
               supervisor--processes)
      (unwind-protect
          (cl-letf (((symbol-function 'supervisor--manual-stop)
                     (lambda (id)
                       (setq stop-called id)
                       (let ((p (gethash id supervisor--processes)))
                         (when (and p (process-live-p p))
                           (delete-process p)))
                       (list :status 'stopped :reason nil)))
                    ((symbol-function 'supervisor--start-process)
                     (lambda (id _cmd _logging _type _restart &rest _args)
                       (setq start-called id)
                       t)))
            (let ((result (supervisor--reload-unit "svc1")))
              (should (equal "svc1" (plist-get result :id)))
              (should (equal "reloaded" (plist-get result :action)))
              (should (equal "svc1" stop-called))
              (should (equal "svc1" start-called))))
        ;; Cleanup
        (let ((p (gethash "svc1" supervisor--processes)))
          (when (and p (process-live-p p))
            (delete-process p)))))))

(ert-deftest supervisor-test-reload-unit-stopped-updates ()
  "Reloading a stopped unit returns `updated' and clears stale state."
  (supervisor-test-with-unit-files
      '(("echo hi" :id "svc1"))
    (let* ((supervisor--processes (make-hash-table :test 'equal))
           (supervisor--failed (make-hash-table :test 'equal))
           (supervisor--restart-times (make-hash-table :test 'equal))
           (supervisor--oneshot-completed (make-hash-table :test 'equal))
           (supervisor--manually-stopped (make-hash-table :test 'equal))
           (supervisor--entry-state (make-hash-table :test 'equal))
           (supervisor--mask-override (make-hash-table :test 'equal))
           (supervisor--enabled-override (make-hash-table :test 'equal))
           (supervisor--invalid (make-hash-table :test 'equal))
           (supervisor--cycle-fallback-ids (make-hash-table :test 'equal))
           (supervisor--computed-deps (make-hash-table :test 'equal))
           (supervisor--logging (make-hash-table :test 'equal)))
      ;; Set some stale state
      (puthash "svc1" t supervisor--failed)
      (puthash "svc1" '(12345) supervisor--restart-times)
      (puthash "svc1" 0 supervisor--oneshot-completed)
      (let ((result (supervisor--reload-unit "svc1")))
        (should (equal "svc1" (plist-get result :id)))
        (should (equal "updated" (plist-get result :action)))
        ;; Stale state should be cleared
        (should-not (gethash "svc1" supervisor--failed))
        (should-not (gethash "svc1" supervisor--restart-times))
        (should-not (gethash "svc1" supervisor--oneshot-completed))))))

(ert-deftest supervisor-test-reload-unit-masked-skips ()
  "Reloading a masked unit returns `skipped (masked)'."
  (supervisor-test-with-unit-files
      '(("echo hi" :id "svc1"))
    (let* ((supervisor--processes (make-hash-table :test 'equal))
           (supervisor--mask-override (make-hash-table :test 'equal))
           (supervisor--invalid (make-hash-table :test 'equal)))
      (puthash "svc1" 'masked supervisor--mask-override)
      (let ((result (supervisor--reload-unit "svc1")))
        (should (equal "svc1" (plist-get result :id)))
        (should (equal "skipped (masked)" (plist-get result :action)))))))

(ert-deftest supervisor-test-reload-unit-unknown-errors ()
  "Reloading an unknown unit returns an error."
  (supervisor-test-with-unit-files nil
    (let* ((supervisor--processes (make-hash-table :test 'equal))
           (supervisor--mask-override (make-hash-table :test 'equal))
           (supervisor--invalid (make-hash-table :test 'equal))
           (supervisor--cycle-fallback-ids (make-hash-table :test 'equal))
           (supervisor--computed-deps (make-hash-table :test 'equal)))
      (let ((result (supervisor--reload-unit "nonexistent")))
        (should (equal "nonexistent" (plist-get result :id)))
        (should (equal "error: not found" (plist-get result :action)))))))

(ert-deftest supervisor-test-cli-reload-requires-ids ()
  "CLI `reload' with no IDs returns exit 2."
  (let ((result (supervisor--cli-dispatch '("reload"))))
    (should (= supervisor-cli-exit-invalid-args
               (supervisor-cli-result-exitcode result)))))

(ert-deftest supervisor-test-cli-reload-unknown-flag ()
  "CLI `reload' with unknown flag returns exit 2."
  (let ((result (supervisor--cli-dispatch '("reload" "--bogus" "svc1"))))
    (should (= supervisor-cli-exit-invalid-args
               (supervisor-cli-result-exitcode result)))))

(ert-deftest supervisor-test-cli-reload-stopped-human ()
  "CLI `reload' on stopped unit shows `updated' in human output."
  (supervisor-test-with-unit-files
      '(("echo hi" :id "svc1"))
    (let* ((supervisor--processes (make-hash-table :test 'equal))
           (supervisor--failed (make-hash-table :test 'equal))
           (supervisor--restart-times (make-hash-table :test 'equal))
           (supervisor--oneshot-completed (make-hash-table :test 'equal))
           (supervisor--manually-stopped (make-hash-table :test 'equal))
           (supervisor--entry-state (make-hash-table :test 'equal))
           (supervisor--mask-override (make-hash-table :test 'equal))
           (supervisor--enabled-override (make-hash-table :test 'equal))
           (supervisor--invalid (make-hash-table :test 'equal))
           (supervisor--cycle-fallback-ids (make-hash-table :test 'equal))
           (supervisor--computed-deps (make-hash-table :test 'equal))
           (supervisor--logging (make-hash-table :test 'equal)))
      (let ((result (supervisor--cli-dispatch '("reload" "--" "svc1"))))
        (should (= supervisor-cli-exit-success
                   (supervisor-cli-result-exitcode result)))
        (should (string-match-p "svc1: updated"
                                (supervisor-cli-result-output result)))))))

(ert-deftest supervisor-test-cli-reload-masked-human ()
  "CLI `reload' on masked unit shows `skipped (masked)' in human output."
  (supervisor-test-with-unit-files
      '(("echo hi" :id "svc1"))
    (let* ((supervisor--processes (make-hash-table :test 'equal))
           (supervisor--mask-override (make-hash-table :test 'equal))
           (supervisor--invalid (make-hash-table :test 'equal)))
      (puthash "svc1" 'masked supervisor--mask-override)
      (let ((result (supervisor--cli-dispatch '("reload" "svc1"))))
        (should (= supervisor-cli-exit-success
                   (supervisor-cli-result-exitcode result)))
        (should (string-match-p "skipped (masked)"
                                (supervisor-cli-result-output result)))))))

(ert-deftest supervisor-test-cli-reload-unknown-id-human ()
  "CLI `reload' on unknown ID returns exit 1 with error."
  (supervisor-test-with-unit-files nil
    (let* ((supervisor--processes (make-hash-table :test 'equal))
           (supervisor--mask-override (make-hash-table :test 'equal))
           (supervisor--invalid (make-hash-table :test 'equal))
           (supervisor--cycle-fallback-ids (make-hash-table :test 'equal))
           (supervisor--computed-deps (make-hash-table :test 'equal)))
      (let ((result (supervisor--cli-dispatch '("reload" "ghost"))))
        (should (= supervisor-cli-exit-failure
                   (supervisor-cli-result-exitcode result)))
        (should (string-match-p "error: not found"
                                (supervisor-cli-result-output result)))))))

(ert-deftest supervisor-test-cli-reload-json ()
  "CLI `reload' with --json returns proper JSON structure."
  (supervisor-test-with-unit-files
      '(("echo hi" :id "svc1") ("echo bye" :id "svc2"))
    (let* ((supervisor--processes (make-hash-table :test 'equal))
           (supervisor--failed (make-hash-table :test 'equal))
           (supervisor--restart-times (make-hash-table :test 'equal))
           (supervisor--oneshot-completed (make-hash-table :test 'equal))
           (supervisor--manually-stopped (make-hash-table :test 'equal))
           (supervisor--entry-state (make-hash-table :test 'equal))
           (supervisor--mask-override (make-hash-table :test 'equal))
           (supervisor--enabled-override (make-hash-table :test 'equal))
           (supervisor--invalid (make-hash-table :test 'equal))
           (supervisor--cycle-fallback-ids (make-hash-table :test 'equal))
           (supervisor--computed-deps (make-hash-table :test 'equal))
           (supervisor--logging (make-hash-table :test 'equal)))
      (puthash "svc2" 'masked supervisor--mask-override)
      (let* ((result (supervisor--cli-dispatch '("reload" "svc1" "svc2" "--json")))
             (json-data (json-read-from-string
                         (supervisor-cli-result-output result)))
             (results (cdr (assoc 'results json-data))))
        (should (= supervisor-cli-exit-success
                   (supervisor-cli-result-exitcode result)))
        (should (= 2 (length results)))
        (should (equal "updated" (cdr (assoc 'action (aref results 0)))))
        (should (equal "skipped (masked)" (cdr (assoc 'action (aref results 1)))))))))

(ert-deftest supervisor-test-cli-reload-mixed-error-json ()
  "CLI `reload' with mix of valid and unknown IDs returns exit 1 JSON."
  (supervisor-test-with-unit-files
      '(("echo hi" :id "svc1"))
    (let* ((supervisor--processes (make-hash-table :test 'equal))
           (supervisor--failed (make-hash-table :test 'equal))
           (supervisor--restart-times (make-hash-table :test 'equal))
           (supervisor--oneshot-completed (make-hash-table :test 'equal))
           (supervisor--manually-stopped (make-hash-table :test 'equal))
           (supervisor--entry-state (make-hash-table :test 'equal))
           (supervisor--mask-override (make-hash-table :test 'equal))
           (supervisor--enabled-override (make-hash-table :test 'equal))
           (supervisor--invalid (make-hash-table :test 'equal))
           (supervisor--cycle-fallback-ids (make-hash-table :test 'equal))
           (supervisor--computed-deps (make-hash-table :test 'equal))
           (supervisor--logging (make-hash-table :test 'equal)))
      (let* ((result (supervisor--cli-dispatch '("reload" "svc1" "ghost" "--json")))
             (json-data (json-read-from-string
                         (supervisor-cli-result-output result)))
             (results (cdr (assoc 'results json-data))))
        (should (= supervisor-cli-exit-failure
                   (supervisor-cli-result-exitcode result)))
        (should (= 2 (length results)))
        (should (equal "updated" (cdr (assoc 'action (aref results 0)))))
        (should (string-match-p "error:" (cdr (assoc 'action (aref results 1)))))))))

(ert-deftest supervisor-test-cli-reload-help-listed ()
  "CLI help text includes the `reload' command."
  (let ((result (supervisor--cli-dispatch nil)))
    (should (string-match-p "reload \\[--\\] ID"
                            (supervisor-cli-result-output result)))))

(ert-deftest supervisor-test-reload-unit-file-only ()
  "Reload finds unit-file-only entries via effective programs."
  (supervisor-test-with-unit-files
      '(("echo hello" :id "uf-svc"))
    (let* ((supervisor--processes (make-hash-table :test 'equal))
           (supervisor--failed (make-hash-table :test 'equal))
           (supervisor--restart-times (make-hash-table :test 'equal))
           (supervisor--oneshot-completed (make-hash-table :test 'equal))
           (supervisor--manually-stopped (make-hash-table :test 'equal))
           (supervisor--entry-state (make-hash-table :test 'equal))
           (supervisor--mask-override (make-hash-table :test 'equal))
           (supervisor--enabled-override (make-hash-table :test 'equal))
           (supervisor--invalid (make-hash-table :test 'equal))
           (supervisor--cycle-fallback-ids (make-hash-table :test 'equal))
           (supervisor--computed-deps (make-hash-table :test 'equal))
           (supervisor--logging (make-hash-table :test 'equal)))
      (let ((result (supervisor--reload-unit "uf-svc")))
        (should (equal "uf-svc" (plist-get result :id)))
        (should (equal "updated" (plist-get result :action)))))))

(ert-deftest supervisor-test-reload-clears-stale-invalid ()
  "Reload succeeds on a previously-invalid entry after config fix.
When an entry was recorded in `supervisor--invalid' but has since
been fixed, reload should find and parse it fresh, clearing the
stale invalid state."
  (supervisor-test-with-unit-files
      '(("echo fixed" :id "svc1"))
    (let* ((supervisor--processes (make-hash-table :test 'equal))
           (supervisor--failed (make-hash-table :test 'equal))
           (supervisor--restart-times (make-hash-table :test 'equal))
           (supervisor--oneshot-completed (make-hash-table :test 'equal))
           (supervisor--manually-stopped (make-hash-table :test 'equal))
           (supervisor--entry-state (make-hash-table :test 'equal))
           (supervisor--mask-override (make-hash-table :test 'equal))
           (supervisor--enabled-override (make-hash-table :test 'equal))
           (supervisor--invalid (make-hash-table :test 'equal))
           (supervisor--cycle-fallback-ids (make-hash-table :test 'equal))
           (supervisor--computed-deps (make-hash-table :test 'equal))
           (supervisor--logging (make-hash-table :test 'equal)))
      ;; Simulate stale invalid entry (was broken, now fixed in config)
      (puthash "svc1" "previously broken" supervisor--invalid)
      (let ((result (supervisor--reload-unit "svc1")))
        (should (equal "svc1" (plist-get result :id)))
        (should (equal "updated" (plist-get result :action)))
        ;; Invalid cache should be cleared for this entry
        (should-not (gethash "svc1" supervisor--invalid))))))

(ert-deftest supervisor-test-reload-find-entry-uses-effective-programs ()
  "The `supervisor--reload-find-entry' reads from effective programs."
  (supervisor-test-with-unit-files
      '(("echo hi" :id "from-config"))
    (let* ((supervisor--invalid (make-hash-table :test 'equal)))
      ;; Should find unit-file entry
      (should (supervisor--reload-find-entry "from-config"))
      ;; Should not find nonexistent entry
      (should-not (supervisor--reload-find-entry "nonexistent"))
      ;; Should find entry even if it's in the invalid cache
      (puthash "from-config" "some reason" supervisor--invalid)
      (should (supervisor--reload-find-entry "from-config")))))

(ert-deftest supervisor-test-reload-running-disabled-unit-succeeds ()
  "Reloading a running disabled unit keeps it running.
Reload bypasses enabled/disabled policy since the unit is already
running and reload's contract is config hot-swap."
  (supervisor-test-with-unit-files
      '(("sleep 999" :id "svc1" :disabled t))
    (let* ((supervisor--processes (make-hash-table :test 'equal))
           (supervisor--failed (make-hash-table :test 'equal))
           (supervisor--restart-times (make-hash-table :test 'equal))
           (supervisor--oneshot-completed (make-hash-table :test 'equal))
           (supervisor--manually-stopped (make-hash-table :test 'equal))
           (supervisor--entry-state (make-hash-table :test 'equal))
           (supervisor--mask-override (make-hash-table :test 'equal))
           (supervisor--enabled-override (make-hash-table :test 'equal))
           (supervisor--invalid (make-hash-table :test 'equal))
           (supervisor--cycle-fallback-ids (make-hash-table :test 'equal))
           (supervisor--computed-deps (make-hash-table :test 'equal))
           (supervisor--logging (make-hash-table :test 'equal))
           (start-process-called nil))
      ;; Simulate a running process (was started before being disabled)
      (puthash "svc1" (start-process "test" nil "sleep" "999")
               supervisor--processes)
      (unwind-protect
          (cl-letf (((symbol-function 'supervisor--manual-stop)
                     (lambda (id)
                       (let ((p (gethash id supervisor--processes)))
                         (when (and p (process-live-p p))
                           (delete-process p)))
                       (list :status 'stopped :reason nil)))
                    ((symbol-function 'supervisor--start-process)
                     (lambda (id _cmd _logging _type _restart &rest _args)
                       (setq start-process-called id)
                       t)))
            (let ((result (supervisor--reload-unit "svc1")))
              ;; Must succeed, not fail with "disabled"
              (should (equal "reloaded" (plist-get result :action)))
              (should (equal "svc1" start-process-called))))
        ;; Cleanup
        (let ((p (gethash "svc1" supervisor--processes)))
          (when (and p (process-live-p p))
            (delete-process p)))))))

(ert-deftest supervisor-test-reload-running-oneshot-updates-only ()
  "Reloading a running oneshot does not interrupt it.
Per Phase 8 spec, only running simple units are restarted.
Running oneshots get definition update only."
  (supervisor-test-with-unit-files
      '(("sleep 999" :id "osh1" :type oneshot))
    (let* ((supervisor--processes (make-hash-table :test 'equal))
           (supervisor--failed (make-hash-table :test 'equal))
           (supervisor--restart-times (make-hash-table :test 'equal))
           (supervisor--oneshot-completed (make-hash-table :test 'equal))
           (supervisor--manually-stopped (make-hash-table :test 'equal))
           (supervisor--entry-state (make-hash-table :test 'equal))
           (supervisor--mask-override (make-hash-table :test 'equal))
           (supervisor--enabled-override (make-hash-table :test 'equal))
           (supervisor--invalid (make-hash-table :test 'equal))
           (supervisor--cycle-fallback-ids (make-hash-table :test 'equal))
           (supervisor--computed-deps (make-hash-table :test 'equal))
           (supervisor--logging (make-hash-table :test 'equal))
           (stop-called nil))
      ;; Simulate a running oneshot process
      (puthash "osh1" (start-process "test" nil "sleep" "999")
               supervisor--processes)
      (unwind-protect
          (cl-letf (((symbol-function 'supervisor--manual-stop)
                     (lambda (id)
                       (setq stop-called id)
                       (list :status 'stopped :reason nil))))
            (let ((result (supervisor--reload-unit "osh1")))
              ;; Should return "updated", not "reloaded"
              (should (equal "updated" (plist-get result :action)))
              ;; Should NOT have called stop
              (should-not stop-called)))
        ;; Cleanup
        (let ((p (gethash "osh1" supervisor--processes)))
          (when (and p (process-live-p p))
            (delete-process p)))))))

(ert-deftest supervisor-test-reload-parse-error-returns-invalid-config ()
  "Reload on unparseable entry returns `error: invalid config'.
This distinguishes config errors from truly missing entries."
  (supervisor-test-with-unit-files nil
    (let* ((supervisor--processes (make-hash-table :test 'equal))
           (supervisor--mask-override (make-hash-table :test 'equal))
           (supervisor--invalid (make-hash-table :test 'equal)))
      (cl-letf (((symbol-function 'supervisor--effective-programs)
                 (lambda ()
                   ;; Return a malformed entry: not a string or (string . plist)
                   '(42))))
        ;; The malformed entry's ID will be "malformed#0"
        (let ((result (supervisor--reload-unit "malformed#0")))
          (should (equal "malformed#0" (plist-get result :id)))
          (should (equal "error: invalid config" (plist-get result :action))))))))

;;; Phase 9: enable/disable model alignment tests

(ert-deftest supervisor-test-start-disabled-unit-works ()
  "Manual start on a disabled unit succeeds (systemctl model).
`start' on a disabled unit runs it this session only without
changing the enabled override."
  (supervisor-test-with-unit-files
      '(("echo hello" :id "svc1" :disabled t))
    (let* ((supervisor--processes (make-hash-table :test 'equal))
           (supervisor--failed (make-hash-table :test 'equal))
           (supervisor--restart-times (make-hash-table :test 'equal))
           (supervisor--oneshot-completed (make-hash-table :test 'equal))
           (supervisor--manually-stopped (make-hash-table :test 'equal))
           (supervisor--manually-started (make-hash-table :test 'equal))
           (supervisor--entry-state (make-hash-table :test 'equal))
           (supervisor--mask-override (make-hash-table :test 'equal))
           (supervisor--enabled-override (make-hash-table :test 'equal))
           (supervisor--invalid (make-hash-table :test 'equal))
           (supervisor--cycle-fallback-ids (make-hash-table :test 'equal))
           (supervisor--computed-deps (make-hash-table :test 'equal))
           (supervisor--logging (make-hash-table :test 'equal))
           (started nil))
      (cl-letf (((symbol-function 'supervisor--start-process)
                 (lambda (id _cmd _logging _type _restart &rest _args)
                   (setq started id)
                   t)))
        (let ((result (supervisor--manual-start "svc1")))
          ;; Should succeed, not be skipped
          (should (eq 'started (plist-get result :status)))
          (should (equal "svc1" started))
          ;; Should NOT change enabled override
          (should-not (gethash "svc1" supervisor--enabled-override))
          ;; Should mark as manually started for reconcile
          (should (gethash "svc1" supervisor--manually-started)))))))

(ert-deftest supervisor-test-start-disabled-unit-override-unchanged ()
  "Starting a disabled unit does not flip the enabled override.
Even with an explicit :disabled override set, manual start does not
change the override  it just runs the unit this session."
  (supervisor-test-with-unit-files
      '(("echo hello" :id "svc1"))
    (let* ((supervisor--processes (make-hash-table :test 'equal))
           (supervisor--failed (make-hash-table :test 'equal))
           (supervisor--restart-times (make-hash-table :test 'equal))
           (supervisor--oneshot-completed (make-hash-table :test 'equal))
           (supervisor--manually-stopped (make-hash-table :test 'equal))
           (supervisor--manually-started (make-hash-table :test 'equal))
           (supervisor--entry-state (make-hash-table :test 'equal))
           (supervisor--mask-override (make-hash-table :test 'equal))
           (supervisor--enabled-override (make-hash-table :test 'equal))
           (supervisor--invalid (make-hash-table :test 'equal))
           (supervisor--cycle-fallback-ids (make-hash-table :test 'equal))
           (supervisor--computed-deps (make-hash-table :test 'equal))
           (supervisor--logging (make-hash-table :test 'equal)))
      ;; Disable via override
      (puthash "svc1" 'disabled supervisor--enabled-override)
      (cl-letf (((symbol-function 'supervisor--start-process)
                 (lambda (_id _cmd _logging _type _restart &rest _args) t)))
        (let ((result (supervisor--manual-start "svc1")))
          (should (eq 'started (plist-get result :status)))
          ;; Override should still be 'disabled (unchanged)
          (should (eq 'disabled (gethash "svc1" supervisor--enabled-override))))))))

(ert-deftest supervisor-test-reconcile-keeps-manually-started-disabled ()
  "Reconcile does not stop disabled units that were manually started.
Per the systemctl model, `start' on a disabled unit is session-only
and reconcile should not undo it."
  (supervisor-test-with-unit-files
      '(("sleep 100" :id "svc1" :disabled t))
    (let* ((plan (supervisor--build-plan (supervisor--effective-programs)))
           (process-alive (make-hash-table :test 'equal))
           (manually-started (make-hash-table :test 'equal)))
      (puthash "svc1" t process-alive)
      (puthash "svc1" t manually-started)
      (let* ((snapshot (supervisor-snapshot--create
                        :process-alive process-alive
                        :process-pids (make-hash-table :test 'equal)
                        :failed (make-hash-table :test 'equal)
                        :oneshot-exit (make-hash-table :test 'equal)
                        :entry-state (make-hash-table :test 'equal)
                        :invalid (make-hash-table :test 'equal)
                        :enabled-override (make-hash-table :test 'equal)
                        :restart-override (make-hash-table :test 'equal)
                        :logging-override (make-hash-table :test 'equal)
                        :manually-started manually-started
                        :timestamp (float-time)))
             (actions (supervisor--compute-actions plan snapshot)))
        ;; Should be noop (manually-started), NOT stop (disabled)
        (let ((action (cl-find "svc1" actions
                               :key (lambda (a) (plist-get a :id))
                               :test #'equal)))
          (should action)
          (should (eq 'noop (plist-get action :op)))
          (should (eq 'manually-started (plist-get action :reason))))))))

(ert-deftest supervisor-test-reconcile-stops-non-manual-disabled ()
  "Reconcile stops disabled units that were NOT manually started."
  (supervisor-test-with-unit-files
      '(("sleep 100" :id "svc1" :disabled t))
    (let* ((plan (supervisor--build-plan (supervisor--effective-programs)))
           (process-alive (make-hash-table :test 'equal)))
      (puthash "svc1" t process-alive)
      (let* ((snapshot (supervisor-snapshot--create
                        :process-alive process-alive
                        :process-pids (make-hash-table :test 'equal)
                        :failed (make-hash-table :test 'equal)
                        :oneshot-exit (make-hash-table :test 'equal)
                        :entry-state (make-hash-table :test 'equal)
                        :invalid (make-hash-table :test 'equal)
                        :enabled-override (make-hash-table :test 'equal)
                        :restart-override (make-hash-table :test 'equal)
                        :logging-override (make-hash-table :test 'equal)
                        :manually-started (make-hash-table :test 'equal)
                        :timestamp (float-time)))
             (actions (supervisor--compute-actions plan snapshot)))
        ;; Should stop (disabled, not manually started)
        (let ((action (cl-find "svc1" actions
                               :key (lambda (a) (plist-get a :id))
                               :test #'equal)))
          (should action)
          (should (eq 'stop (plist-get action :op)))
          (should (eq 'disabled (plist-get action :reason))))))))

(ert-deftest supervisor-test-reconcile-stops-masked-even-if-manually-started ()
  "Reconcile stops masked units even if manually started.
Mask overrides everything including manual-start tracking."
  (supervisor-test-with-unit-files
      '(("sleep 100" :id "svc1"))
    (let* ((plan (supervisor--build-plan (supervisor--effective-programs)))
           (process-alive (make-hash-table :test 'equal))
           (manually-started (make-hash-table :test 'equal))
           (mask-override (make-hash-table :test 'equal)))
      (puthash "svc1" t process-alive)
      (puthash "svc1" t manually-started)
      (puthash "svc1" 'masked mask-override)
      (let* ((snapshot (supervisor-snapshot--create
                        :process-alive process-alive
                        :process-pids (make-hash-table :test 'equal)
                        :failed (make-hash-table :test 'equal)
                        :oneshot-exit (make-hash-table :test 'equal)
                        :entry-state (make-hash-table :test 'equal)
                        :invalid (make-hash-table :test 'equal)
                        :enabled-override (make-hash-table :test 'equal)
                        :restart-override (make-hash-table :test 'equal)
                        :logging-override (make-hash-table :test 'equal)
                        :mask-override mask-override
                        :manually-started manually-started
                        :timestamp (float-time)))
             (actions (supervisor--compute-actions plan snapshot)))
        (let ((action (cl-find "svc1" actions
                               :key (lambda (a) (plist-get a :id))
                               :test #'equal)))
          (should action)
          (should (eq 'stop (plist-get action :op)))
          (should (eq 'masked (plist-get action :reason))))))))

(ert-deftest supervisor-test-manual-stop-clears-manually-started ()
  "Manually stopping a unit clears the manually-started flag.
After manual stop, reconcile is free to treat it normally."
  (let* ((supervisor--processes (make-hash-table :test 'equal))
         (supervisor--manually-stopped (make-hash-table :test 'equal))
         (supervisor--manually-started (make-hash-table :test 'equal)))
    ;; Simulate a manually-started running process
    (puthash "svc1" (start-process "test" nil "sleep" "999")
             supervisor--processes)
    (puthash "svc1" t supervisor--manually-started)
    (unwind-protect
        (progn
          (supervisor--manual-stop "svc1")
          ;; manually-started should be cleared
          (should-not (gethash "svc1" supervisor--manually-started))
          ;; manually-stopped should be set
          (should (gethash "svc1" supervisor--manually-stopped)))
      (let ((p (gethash "svc1" supervisor--processes)))
        (when (and p (process-live-p p))
          (delete-process p))))))

(ert-deftest supervisor-test-cli-start-disabled-unit ()
  "CLI `start' on a disabled unit succeeds."
  (supervisor-test-with-unit-files
      '(("echo hi" :id "svc1" :disabled t))
    (let* ((supervisor--processes (make-hash-table :test 'equal))
           (supervisor--failed (make-hash-table :test 'equal))
           (supervisor--restart-times (make-hash-table :test 'equal))
           (supervisor--oneshot-completed (make-hash-table :test 'equal))
           (supervisor--manually-stopped (make-hash-table :test 'equal))
           (supervisor--manually-started (make-hash-table :test 'equal))
           (supervisor--entry-state (make-hash-table :test 'equal))
           (supervisor--mask-override (make-hash-table :test 'equal))
           (supervisor--enabled-override (make-hash-table :test 'equal))
           (supervisor--invalid (make-hash-table :test 'equal))
           (supervisor--cycle-fallback-ids (make-hash-table :test 'equal))
           (supervisor--computed-deps (make-hash-table :test 'equal))
           (supervisor--logging (make-hash-table :test 'equal)))
      (cl-letf (((symbol-function 'supervisor--start-process)
                 (lambda (_id _cmd _logging _type _restart &rest _args) t)))
        (let ((result (supervisor--cli-dispatch '("start" "--" "svc1"))))
          (should (= supervisor-cli-exit-success
                     (supervisor-cli-result-exitcode result)))
          (should (string-match-p "Started: svc1"
                                  (supervisor-cli-result-output result))))))))

(ert-deftest supervisor-test-mask-still-blocks-manual-start ()
  "Masked units are still blocked from manual start.
Only mask blocks; disabled does not."
  (supervisor-test-with-unit-files
      '(("echo hi" :id "svc1"))
    (let* ((supervisor--processes (make-hash-table :test 'equal))
           (supervisor--failed (make-hash-table :test 'equal))
           (supervisor--restart-times (make-hash-table :test 'equal))
           (supervisor--oneshot-completed (make-hash-table :test 'equal))
           (supervisor--manually-stopped (make-hash-table :test 'equal))
           (supervisor--manually-started (make-hash-table :test 'equal))
           (supervisor--entry-state (make-hash-table :test 'equal))
           (supervisor--mask-override (make-hash-table :test 'equal))
           (supervisor--enabled-override (make-hash-table :test 'equal))
           (supervisor--invalid (make-hash-table :test 'equal))
           (supervisor--cycle-fallback-ids (make-hash-table :test 'equal))
           (supervisor--computed-deps (make-hash-table :test 'equal))
           (supervisor--logging (make-hash-table :test 'equal)))
      (puthash "svc1" 'masked supervisor--mask-override)
      (let ((result (supervisor--manual-start "svc1")))
        (should (eq 'skipped (plist-get result :status)))
        (should (equal "masked" (plist-get result :reason)))))))

(ert-deftest supervisor-test-cli-enable-persists ()
  "CLI `enable' command persists the override to disk."
  (supervisor-test-with-unit-files
      '(("sleep 300" :id "svc1" :type simple :enabled nil))
    (let* ((temp-file (make-temp-file "supervisor-test-enable-" nil ".eld"))
           (supervisor-overrides-file temp-file)
           (supervisor--enabled-override (make-hash-table :test 'equal))
           (supervisor--restart-override (make-hash-table :test 'equal))
           (supervisor--logging (make-hash-table :test 'equal))
           (supervisor--mask-override (make-hash-table :test 'equal))
           (supervisor--overrides-loaded nil))
      (unwind-protect
          (progn
            (supervisor--cli-dispatch '("enable" "svc1"))
            ;; In-memory override set
            (should (eq 'enabled (gethash "svc1" supervisor--enabled-override)))
            ;; Clear memory and reload from file
            (clrhash supervisor--enabled-override)
            (should (supervisor--load-overrides))
            ;; Should survive roundtrip
            (should (eq 'enabled
                        (gethash "svc1" supervisor--enabled-override))))
        (delete-file temp-file)))))

(ert-deftest supervisor-test-cli-disable-persists ()
  "CLI `disable' command persists the override to disk."
  (supervisor-test-with-unit-files
      '(("sleep 300" :id "svc1" :type simple))
    (let* ((temp-file (make-temp-file "supervisor-test-disable-" nil ".eld"))
           (supervisor-overrides-file temp-file)
           (supervisor--enabled-override (make-hash-table :test 'equal))
           (supervisor--restart-override (make-hash-table :test 'equal))
           (supervisor--logging (make-hash-table :test 'equal))
           (supervisor--mask-override (make-hash-table :test 'equal))
           (supervisor--overrides-loaded nil))
      (unwind-protect
          (progn
            (supervisor--cli-dispatch '("disable" "svc1"))
            ;; In-memory override set
            (should (eq 'disabled
                        (gethash "svc1" supervisor--enabled-override)))
            ;; Clear memory and reload from file
            (clrhash supervisor--enabled-override)
            (should (supervisor--load-overrides))
            ;; Should survive roundtrip
            (should (eq 'disabled
                        (gethash "svc1" supervisor--enabled-override))))
        (delete-file temp-file)))))

(ert-deftest supervisor-test-manual-start-failure-no-stale-flag ()
  "Failed manual start does not leave stale manually-started flag.
Only successful starts should set the flag, otherwise reconcile
could incorrectly preserve a non-running disabled unit."
  (supervisor-test-with-unit-files
      '(("echo hi" :id "svc1"))
    (let* ((supervisor--processes (make-hash-table :test 'equal))
           (supervisor--failed (make-hash-table :test 'equal))
           (supervisor--restart-times (make-hash-table :test 'equal))
           (supervisor--oneshot-completed (make-hash-table :test 'equal))
           (supervisor--manually-stopped (make-hash-table :test 'equal))
           (supervisor--manually-started (make-hash-table :test 'equal))
           (supervisor--entry-state (make-hash-table :test 'equal))
           (supervisor--mask-override (make-hash-table :test 'equal))
           (supervisor--enabled-override (make-hash-table :test 'equal))
           (supervisor--invalid (make-hash-table :test 'equal))
           (supervisor--cycle-fallback-ids (make-hash-table :test 'equal))
           (supervisor--computed-deps (make-hash-table :test 'equal))
           (supervisor--logging (make-hash-table :test 'equal)))
      (cl-letf (((symbol-function 'supervisor--start-process)
                 (lambda (_id _cmd _logging _type _restart &rest _args)
                   nil)))  ; Simulate spawn failure
        (let ((result (supervisor--manual-start "svc1")))
          (should (eq 'error (plist-get result :status)))
          ;; Flag must NOT be set on failure
          (should-not (gethash "svc1" supervisor--manually-started)))))))

;;;; Phase P1: New keyword parsing, validation, and normalization

(ert-deftest supervisor-test-parse-entry-new-fields-defaults ()
  "Parsed entry has nil defaults for P2 and PT3 fields."
  (let ((entry (supervisor--parse-entry "echo hello")))
    (should (= (length entry) 39))
    (should-not (supervisor-entry-working-directory entry))
    (should-not (supervisor-entry-environment entry))
    (should-not (supervisor-entry-environment-file entry))
    (should-not (supervisor-entry-exec-stop entry))
    (should-not (supervisor-entry-exec-reload entry))
    (should-not (supervisor-entry-restart-sec entry))
    (should-not (supervisor-entry-description entry))
    (should-not (supervisor-entry-documentation entry))
    (should-not (supervisor-entry-before entry))
    (should-not (supervisor-entry-wants entry))
    (should-not (supervisor-entry-kill-signal entry))
    (should-not (supervisor-entry-kill-mode entry))
    (should-not (supervisor-entry-remain-after-exit entry))
    (should-not (supervisor-entry-success-exit-status entry))
    (should-not (supervisor-entry-wanted-by entry))
    (should-not (supervisor-entry-required-by entry))))

(ert-deftest supervisor-test-parse-entry-working-directory ()
  "Parsed entry extracts :working-directory."
  (let ((entry (supervisor--parse-entry
                '("echo hi" :id "svc" :working-directory "/tmp"))))
    (should (equal (supervisor-entry-working-directory entry) "/tmp"))))

(ert-deftest supervisor-test-parse-entry-environment ()
  "Parsed entry extracts :environment alist."
  (let ((entry (supervisor--parse-entry
                '("echo hi" :id "svc"
                  :environment (("FOO" . "bar") ("BAZ" . "qux"))))))
    (should (equal (supervisor-entry-environment entry)
                   '(("FOO" . "bar") ("BAZ" . "qux"))))))

(ert-deftest supervisor-test-parse-entry-environment-file-string ()
  "Parsed entry normalizes :environment-file string to list."
  (let ((entry (supervisor--parse-entry
                '("echo hi" :id "svc" :environment-file "/etc/env"))))
    (should (equal (supervisor-entry-environment-file entry)
                   '("/etc/env")))))

(ert-deftest supervisor-test-parse-entry-environment-file-list ()
  "Parsed entry preserves :environment-file list."
  (let ((entry (supervisor--parse-entry
                '("echo hi" :id "svc"
                  :environment-file ("/etc/env" "-/etc/env.local")))))
    (should (equal (supervisor-entry-environment-file entry)
                   '("/etc/env" "-/etc/env.local")))))

(ert-deftest supervisor-test-parse-entry-exec-stop-string ()
  "Parsed entry normalizes :exec-stop string to list."
  (let ((entry (supervisor--parse-entry
                '("my-daemon" :id "svc" :exec-stop "kill-cmd"))))
    (should (equal (supervisor-entry-exec-stop entry) '("kill-cmd")))))

(ert-deftest supervisor-test-parse-entry-exec-stop-list ()
  "Parsed entry preserves :exec-stop list."
  (let ((entry (supervisor--parse-entry
                '("my-daemon" :id "svc"
                  :exec-stop ("stop-phase1" "stop-phase2")))))
    (should (equal (supervisor-entry-exec-stop entry)
                   '("stop-phase1" "stop-phase2")))))

(ert-deftest supervisor-test-parse-entry-exec-reload-string ()
  "Parsed entry normalizes :exec-reload string to list."
  (let ((entry (supervisor--parse-entry
                '("my-daemon" :id "svc" :exec-reload "reload-cmd"))))
    (should (equal (supervisor-entry-exec-reload entry)
                   '("reload-cmd")))))

(ert-deftest supervisor-test-parse-entry-restart-sec ()
  "Parsed entry extracts :restart-sec."
  (let ((entry (supervisor--parse-entry
                '("my-daemon" :id "svc" :restart-sec 5))))
    (should (equal (supervisor-entry-restart-sec entry) 5))))

(ert-deftest supervisor-test-parse-entry-restart-sec-zero ()
  "Parsed entry accepts :restart-sec 0."
  (let ((entry (supervisor--parse-entry
                '("my-daemon" :id "svc" :restart-sec 0))))
    (should (equal (supervisor-entry-restart-sec entry) 0))))

(ert-deftest supervisor-test-validate-duplicate-key-entry ()
  "Duplicate plist keys are rejected in entry validation."
  (let ((reason (supervisor--validate-entry
                 '("cmd" :id "svc" :delay 1 :delay 2))))
    (should reason)
    (should (string-match-p "duplicate key :delay" reason))))

(ert-deftest supervisor-test-validate-duplicate-key-unit-file ()
  "Duplicate plist keys are rejected in unit-file validation."
  (let ((reason (supervisor--validate-unit-file-plist
                 '(:id "svc" :command "cmd" :delay 1 :delay 2)
                 "/test.el" 1)))
    (should reason)
    (should (string-match-p "duplicate key :delay" reason))))

(ert-deftest supervisor-test-plist-duplicate-keys-none ()
  "No duplicates returns nil."
  (should-not (supervisor--plist-duplicate-keys
               '(:id "svc" :command "cmd" :delay 1))))

(ert-deftest supervisor-test-plist-duplicate-keys-found ()
  "Duplicate keys are detected."
  (should (equal (supervisor--plist-duplicate-keys
                  '(:id "svc" :delay 1 :id "other" :delay 2))
                 '(:id :delay))))

(ert-deftest supervisor-test-validate-duplicate-key-description ()
  "Duplicate :description key is rejected."
  (let ((reason (supervisor--validate-entry
                 '("cmd" :id "svc" :description "a" :description "b"))))
    (should reason)
    (should (string-match-p "duplicate key :description" reason))))

(ert-deftest supervisor-test-validate-duplicate-key-documentation ()
  "Duplicate :documentation key is rejected."
  (let ((reason (supervisor--validate-entry
                 '("cmd" :id "svc" :documentation "a" :documentation "b"))))
    (should reason)
    (should (string-match-p "duplicate key :documentation" reason))))

(ert-deftest supervisor-test-validate-duplicate-key-before ()
  "Duplicate :before key is rejected."
  (let ((reason (supervisor--validate-entry
                 '("cmd" :id "svc" :before "a" :before "b"))))
    (should reason)
    (should (string-match-p "duplicate key :before" reason))))

(ert-deftest supervisor-test-validate-duplicate-key-wants ()
  "Duplicate :wants key is rejected."
  (let ((reason (supervisor--validate-entry
                 '("cmd" :id "svc" :wants "a" :wants "b"))))
    (should reason)
    (should (string-match-p "duplicate key :wants" reason))))

(ert-deftest supervisor-test-validate-duplicate-key-kill-signal ()
  "Duplicate :kill-signal key is rejected."
  (let ((reason (supervisor--validate-entry
                 '("cmd" :id "svc" :kill-signal SIGTERM :kill-signal SIGHUP))))
    (should reason)
    (should (string-match-p "duplicate key :kill-signal" reason))))

(ert-deftest supervisor-test-validate-duplicate-key-kill-mode ()
  "Duplicate :kill-mode key is rejected."
  (let ((reason (supervisor--validate-entry
                 '("cmd" :id "svc" :kill-mode process :kill-mode mixed))))
    (should reason)
    (should (string-match-p "duplicate key :kill-mode" reason))))

(ert-deftest supervisor-test-validate-duplicate-key-remain-after-exit ()
  "Duplicate :remain-after-exit key is rejected."
  (let ((reason (supervisor--validate-entry
                 '("cmd" :id "svc" :type oneshot
                   :remain-after-exit t :remain-after-exit nil))))
    (should reason)
    (should (string-match-p "duplicate key :remain-after-exit" reason))))

(ert-deftest supervisor-test-validate-duplicate-key-success-exit-status ()
  "Duplicate :success-exit-status key is rejected."
  (let ((reason (supervisor--validate-entry
                 '("cmd" :id "svc" :success-exit-status 42
                   :success-exit-status 43))))
    (should reason)
    (should (string-match-p "duplicate key :success-exit-status" reason))))

(ert-deftest supervisor-test-validate-duplicate-key-working-directory ()
  "Duplicate :working-directory key is rejected."
  (let ((reason (supervisor--validate-entry
                 '("cmd" :id "svc" :working-directory "/a"
                   :working-directory "/b"))))
    (should reason)
    (should (string-match-p "duplicate key :working-directory" reason))))

(ert-deftest supervisor-test-validate-duplicate-key-environment ()
  "Duplicate :environment key is rejected."
  (let ((reason (supervisor--validate-entry
                 '("cmd" :id "svc"
                   :environment (("A" . "1"))
                   :environment (("B" . "2"))))))
    (should reason)
    (should (string-match-p "duplicate key :environment" reason))))

(ert-deftest supervisor-test-validate-duplicate-key-environment-file ()
  "Duplicate :environment-file key is rejected."
  (let ((reason (supervisor--validate-entry
                 '("cmd" :id "svc"
                   :environment-file "/a.env"
                   :environment-file "/b.env"))))
    (should reason)
    (should (string-match-p "duplicate key :environment-file" reason))))

(ert-deftest supervisor-test-validate-duplicate-key-exec-stop ()
  "Duplicate :exec-stop key is rejected."
  (let ((reason (supervisor--validate-entry
                 '("cmd" :id "svc"
                   :exec-stop "stop1"
                   :exec-stop "stop2"))))
    (should reason)
    (should (string-match-p "duplicate key :exec-stop" reason))))

(ert-deftest supervisor-test-validate-duplicate-key-exec-reload ()
  "Duplicate :exec-reload key is rejected."
  (let ((reason (supervisor--validate-entry
                 '("cmd" :id "svc"
                   :exec-reload "reload1"
                   :exec-reload "reload2"))))
    (should reason)
    (should (string-match-p "duplicate key :exec-reload" reason))))

(ert-deftest supervisor-test-validate-duplicate-key-restart-sec ()
  "Duplicate :restart-sec key is rejected."
  (let ((reason (supervisor--validate-entry
                 '("cmd" :id "svc"
                   :restart-sec 3
                   :restart-sec 5))))
    (should reason)
    (should (string-match-p "duplicate key :restart-sec" reason))))

(ert-deftest supervisor-test-validate-working-directory-invalid ()
  "Non-string :working-directory is rejected."
  (let ((reason (supervisor--validate-entry
                 '("cmd" :id "svc" :working-directory 123))))
    (should reason)
    (should (string-match-p ":working-directory must be a string" reason))))

(ert-deftest supervisor-test-validate-environment-invalid ()
  "Non-alist :environment is rejected."
  (let ((reason (supervisor--validate-entry
                 '("cmd" :id "svc" :environment "FOO=bar"))))
    (should reason)
    (should (string-match-p ":environment must be an alist" reason))))

(ert-deftest supervisor-test-validate-environment-bad-pair ()
  "Environment alist with non-string values is rejected."
  (let ((reason (supervisor--validate-entry
                 '("cmd" :id "svc"
                   :environment (("FOO" . 123))))))
    (should reason)
    (should (string-match-p ":environment must be an alist" reason))))

(ert-deftest supervisor-test-validate-environment-file-invalid ()
  "Non-string :environment-file is rejected."
  (let ((reason (supervisor--validate-entry
                 '("cmd" :id "svc" :environment-file 123))))
    (should reason)
    (should (string-match-p ":environment-file must be" reason))))

(ert-deftest supervisor-test-validate-exec-stop-invalid ()
  "Non-string :exec-stop is rejected."
  (let ((reason (supervisor--validate-entry
                 '("cmd" :id "svc" :exec-stop 123))))
    (should reason)
    (should (string-match-p ":exec-stop must be" reason))))

(ert-deftest supervisor-test-validate-exec-reload-invalid ()
  "Non-string :exec-reload is rejected."
  (let ((reason (supervisor--validate-entry
                 '("cmd" :id "svc" :exec-reload 123))))
    (should reason)
    (should (string-match-p ":exec-reload must be" reason))))

(ert-deftest supervisor-test-validate-restart-sec-invalid ()
  "Non-numeric :restart-sec is rejected."
  (let ((reason (supervisor--validate-entry
                 '("cmd" :id "svc" :restart-sec "fast"))))
    (should reason)
    (should (string-match-p ":restart-sec must be" reason))))

(ert-deftest supervisor-test-validate-restart-sec-negative ()
  "Negative :restart-sec is rejected."
  (let ((reason (supervisor--validate-entry
                 '("cmd" :id "svc" :restart-sec -1))))
    (should reason)
    (should (string-match-p ":restart-sec must be" reason))))

(ert-deftest supervisor-test-validate-exec-stop-oneshot-rejected ()
  "The :exec-stop keyword is rejected for oneshot type."
  (let ((reason (supervisor--validate-entry
                 '("cmd" :id "svc" :type oneshot
                   :exec-stop "stop-cmd"))))
    (should reason)
    (should (string-match-p ":exec-stop is invalid for :type oneshot" reason))))

(ert-deftest supervisor-test-validate-exec-reload-oneshot-rejected ()
  "The :exec-reload keyword is rejected for oneshot type."
  (let ((reason (supervisor--validate-entry
                 '("cmd" :id "svc" :type oneshot
                   :exec-reload "reload-cmd"))))
    (should reason)
    (should (string-match-p ":exec-reload is invalid for :type oneshot" reason))))

(ert-deftest supervisor-test-validate-restart-sec-oneshot-rejected ()
  "The :restart-sec keyword is rejected for oneshot type."
  (let ((reason (supervisor--validate-entry
                 '("cmd" :id "svc" :type oneshot
                   :restart-sec 5))))
    (should reason)
    (should (string-match-p ":restart-sec is invalid for :type oneshot" reason))))

(ert-deftest supervisor-test-validate-new-keywords-accepted ()
  "All six new keywords are accepted for simple type."
  (should-not (supervisor--validate-entry
               '("cmd" :id "svc"
                 :working-directory "/tmp"
                 :environment (("FOO" . "bar"))
                 :environment-file "/etc/env"
                 :exec-stop "stop"
                 :exec-reload "reload"
                 :restart-sec 5))))

(ert-deftest supervisor-test-validate-env-dir-accepted-oneshot ()
  "Working-directory, environment, environment-file accepted for oneshot."
  (should-not (supervisor--validate-entry
               '("cmd" :id "svc" :type oneshot
                 :working-directory "/tmp"
                 :environment (("FOO" . "bar"))
                 :environment-file "/etc/env"))))

(ert-deftest supervisor-test-entry-to-service-new-fields ()
  "Entry-to-service conversion carries all six new fields."
  (let* ((entry (supervisor--parse-entry
                 '("my-daemon" :id "svc"
                   :working-directory "/opt"
                   :environment (("K" . "V"))
                   :environment-file ("/etc/env")
                   :exec-stop ("stop1" "stop2")
                   :exec-reload "reload1"
                   :restart-sec 3)))
         (svc (supervisor-entry-to-service entry)))
    (should (equal (supervisor-service-working-directory svc) "/opt"))
    (should (equal (supervisor-service-environment svc) '(("K" . "V"))))
    (should (equal (supervisor-service-environment-file svc) '("/etc/env")))
    (should (equal (supervisor-service-exec-stop svc) '("stop1" "stop2")))
    (should (equal (supervisor-service-exec-reload svc) '("reload1")))
    (should (equal (supervisor-service-restart-sec svc) 3))))

(ert-deftest supervisor-test-service-to-entry-new-fields ()
  "Service-to-entry conversion preserves all P2 and PT3 fields."
  (let* ((svc (supervisor-service--create
               :id "svc" :command "cmd"
               :working-directory "/opt"
               :environment '(("K" . "V"))
               :environment-file '("/etc/env")
               :exec-stop '("stop1")
               :exec-reload '("reload1")
               :restart-sec 3
               :description "test"
               :kill-signal 'SIGTERM
               :kill-mode 'mixed))
         (entry (supervisor-service-to-entry svc)))
    (should (= (length entry) 39))
    (should (equal (supervisor-entry-working-directory entry) "/opt"))
    (should (equal (supervisor-entry-environment entry) '(("K" . "V"))))
    (should (equal (supervisor-entry-environment-file entry) '("/etc/env")))
    (should (equal (supervisor-entry-exec-stop entry) '("stop1")))
    (should (equal (supervisor-entry-exec-reload entry) '("reload1")))
    (should (equal (supervisor-entry-restart-sec entry) 3))
    (should (equal (supervisor-entry-description entry) "test"))
    (should (eq (supervisor-entry-kill-signal entry) 'SIGTERM))
    (should (eq (supervisor-entry-kill-mode entry) 'mixed))))

(ert-deftest supervisor-test-normalize-string-or-list ()
  "String-or-list normalization works correctly."
  (should-not (supervisor--normalize-string-or-list nil))
  (should (equal (supervisor--normalize-string-or-list "foo") '("foo")))
  (should (equal (supervisor--normalize-string-or-list '("a" "b")) '("a" "b")))
  (should-not (supervisor--normalize-string-or-list 123)))

(ert-deftest supervisor-test-build-plan-preserves-new-fields ()
  "Build-plan :requires normalization preserves fields 13-26."
  (let* ((supervisor--authority-snapshot nil)
         (programs '(("svc-a" :id "svc-a"
                      :working-directory "/opt"
                      :environment (("K" . "V"))
                      :exec-stop "stop-cmd"
                      :description "Service A")
                     ("svc-b" :id "svc-b"
                      :requires "svc-a"
                      :restart-sec 5
                      :exec-reload "reload-cmd"
                      :kill-signal SIGTERM)))
         (plan (supervisor--build-plan programs))
         (entries (supervisor-plan-entries plan)))
    ;; Both entries must be full parsed tuples.
    (dolist (entry entries)
      (should (= (length entry) 39)))
    ;; svc-a new fields preserved
    (let ((a (cl-find "svc-a" entries :key #'car :test #'equal)))
      (should (equal (supervisor-entry-working-directory a) "/opt"))
      (should (equal (supervisor-entry-environment a) '(("K" . "V"))))
      (should (equal (supervisor-entry-exec-stop a) '("stop-cmd")))
      (should (equal (supervisor-entry-description a) "Service A")))
    ;; svc-b new fields preserved (has :requires which triggers rewrite)
    (let ((b (cl-find "svc-b" entries :key #'car :test #'equal)))
      (should (equal (supervisor-entry-restart-sec b) 5))
      (should (equal (supervisor-entry-exec-reload b) '("reload-cmd")))
      (should (eq (supervisor-entry-kill-signal b) 'SIGTERM)))))

(ert-deftest supervisor-test-stable-topo-cycle-preserves-new-fields ()
  "Cycle fallback in stable-topo-sort preserves fields 13-26."
  (let ((supervisor--computed-deps (make-hash-table :test 'equal))
        (supervisor--cycle-fallback-ids (make-hash-table :test 'equal)))
    ;; 27-element entries with cycle: a -> b -> a
    (let* ((entries (list (list "a" "cmd" 0 t 'always t 'simple 'stage3 '("b")
                                t 30 nil nil "/opt" '(("K" . "V")) nil
                                '("stop") nil 3
                                "desc-a" nil nil nil nil nil nil nil)
                          (list "b" "cmd" 0 t 'always t 'simple 'stage3 '("a")
                                t 30 nil nil nil nil '("/env") nil
                                '("reload") nil
                                nil nil nil nil 'SIGTERM nil nil nil)))
           (sorted (supervisor--stable-topo-sort entries)))
      ;; All entries must remain 27 fields
      (dolist (entry sorted)
        (should (= (length entry) 27)))
      ;; :after (8) and :requires (12) cleared
      (dolist (entry sorted)
        (should (null (nth 8 entry)))
        (should (null (nth 12 entry))))
      ;; P2 fields preserved
      (let ((a (cl-find "a" sorted :key #'car :test #'equal)))
        (should (equal (supervisor-entry-working-directory a) "/opt"))
        (should (equal (supervisor-entry-environment a) '(("K" . "V"))))
        (should (equal (supervisor-entry-exec-stop a) '("stop")))
        (should (equal (supervisor-entry-restart-sec a) 3))
        (should (equal (supervisor-entry-description a) "desc-a")))
      (let ((b (cl-find "b" sorted :key #'car :test #'equal)))
        (should (equal (supervisor-entry-environment-file b) '("/env")))
        (should (equal (supervisor-entry-exec-reload b) '("reload")))
        (should (eq (supervisor-entry-kill-signal b) 'SIGTERM))))))

(ert-deftest supervisor-test-build-plan-topo-cycle-preserves-new-fields ()
  "Cycle fallback in build-plan-topo-sort preserves fields 13-26."
  ;; 27-element entries with cycle: a -> b -> a
  (let* ((deps (make-hash-table :test 'equal))
         (order-index (make-hash-table :test 'equal))
         (cycle-fallback-ids (make-hash-table :test 'equal))
         (entries (list (list "a" "cmd" 0 t 'always t 'simple 'stage3 '("b")
                              t 30 nil nil "/tmp" nil nil '("s1") '("r1") 2
                              "desc" nil nil nil nil 'mixed nil nil)
                        (list "b" "cmd" 0 t 'always t 'simple 'stage3 '("a")
                              t 30 nil nil nil '(("X" . "Y")) '("/e") nil nil 0
                              nil '("man:b(1)") nil nil 'SIGHUP nil nil nil))))
    (puthash "a" '("b") deps)
    (puthash "b" '("a") deps)
    (puthash "a" 0 order-index)
    (puthash "b" 1 order-index)
    (let ((sorted (supervisor--build-plan-topo-sort
                   entries deps order-index cycle-fallback-ids)))
      ;; All entries must remain 27 fields
      (dolist (entry sorted)
        (should (= (length entry) 27)))
      ;; P2 fields preserved
      (let ((a (cl-find "a" sorted :key #'car :test #'equal)))
        (should (equal (supervisor-entry-working-directory a) "/tmp"))
        (should (equal (supervisor-entry-exec-stop a) '("s1")))
        (should (equal (supervisor-entry-exec-reload a) '("r1")))
        (should (equal (supervisor-entry-restart-sec a) 2))
        (should (equal (supervisor-entry-description a) "desc"))
        (should (eq (supervisor-entry-kill-mode a) 'mixed)))
      (let ((b (cl-find "b" sorted :key #'car :test #'equal)))
        (should (equal (supervisor-entry-environment b) '(("X" . "Y"))))
        (should (equal (supervisor-entry-environment-file b) '("/e")))
        (should (equal (supervisor-entry-restart-sec b) 0))
        (should (equal (supervisor-entry-documentation b) '("man:b(1)")))
        (should (eq (supervisor-entry-kill-signal b) 'SIGHUP))))))

;;;; Phase P2: Runtime foundation tests (cwd/env/restart-sec)

(ert-deftest supervisor-test-parse-env-file ()
  "Parse a well-formed environment file."
  (let ((tmpfile (make-temp-file "env-test")))
    (unwind-protect
        (progn
          (with-temp-file tmpfile
            (insert "# comment\n")
            (insert "; another comment\n")
            (insert "\n")
            (insert "FOO=bar\n")
            (insert "BAZ=qux value\n")
            (insert "export EXPORTED=yes\n")
            (insert "bad line no equals\n")
            (insert "EMPTY=\n"))
          (let ((result (supervisor--parse-env-file tmpfile)))
            (should (equal result '(("FOO" . "bar")
                                    ("BAZ" . "qux value")
                                    ("EXPORTED" . "yes")
                                    ("EMPTY" . ""))))))
      (delete-file tmpfile))))

(ert-deftest supervisor-test-parse-env-file-key-validation ()
  "Env file rejects keys that don't match [A-Za-z_][A-Za-z0-9_]*."
  (let ((tmpfile (make-temp-file "env-test")))
    (unwind-protect
        (progn
          (with-temp-file tmpfile
            (insert "VALID_KEY=ok\n")
            (insert "123BAD=no\n")
            (insert "_ok=yes\n"))
          (let ((result (supervisor--parse-env-file tmpfile)))
            (should (= (length result) 2))
            (should (equal (car result) '("VALID_KEY" . "ok")))
            (should (equal (cadr result) '("_ok" . "yes")))))
      (delete-file tmpfile))))

(ert-deftest supervisor-test-parse-env-file-invalid-lines-logged ()
  "Invalid env-file lines are logged as warnings."
  (let ((tmpfile (make-temp-file "env-test"))
        (logged-warnings nil))
    (unwind-protect
        (progn
          (with-temp-file tmpfile
            (insert "GOOD=ok\n")
            (insert "bad line no equals\n")
            (insert "123BAD=no\n"))
          (cl-letf (((symbol-function 'supervisor--log)
                     (lambda (level fmt &rest args)
                       (when (eq level 'warning)
                         (push (apply #'format fmt args) logged-warnings)))))
            (let ((result (supervisor--parse-env-file tmpfile)))
              (should (= (length result) 1))
              (should (equal (car result) '("GOOD" . "ok")))
              ;; Two invalid lines should produce two warnings
              (should (= (length logged-warnings) 2))
              (should (cl-some (lambda (w) (string-match-p "bad line no equals" w))
                               logged-warnings))
              (should (cl-some (lambda (w) (string-match-p "123BAD=no" w))
                               logged-warnings)))))
      (delete-file tmpfile))))

(ert-deftest supervisor-test-resolve-env-file-path ()
  "Resolve env-file path with and without optional - prefix."
  (let ((result (supervisor--resolve-env-file-path "/etc/env" "/units/")))
    (should-not (car result))
    (should (equal (cdr result) "/etc/env")))
  (let ((result (supervisor--resolve-env-file-path "-/etc/env.local" "/units/")))
    (should (car result))
    (should (equal (cdr result) "/etc/env.local")))
  ;; Relative path resolved against unit dir
  (let ((result (supervisor--resolve-env-file-path "local.env" "/opt/units/")))
    (should-not (car result))
    (should (equal (cdr result) "/opt/units/local.env")))
  ;; Optional relative
  (let ((result (supervisor--resolve-env-file-path "-local.env" "/opt/units/")))
    (should (car result))
    (should (equal (cdr result) "/opt/units/local.env"))))

(ert-deftest supervisor-test-build-process-environment ()
  "Build effective process-environment from env-files and alist."
  (let* ((tmpfile (make-temp-file "env-test"))
         (process-environment '("INHERITED=yes" "OVERRIDE=old")))
    (unwind-protect
        (progn
          (with-temp-file tmpfile
            (insert "FILE_VAR=from-file\n")
            (insert "OVERRIDE=from-file\n"))
          (let ((result (supervisor--build-process-environment
                         (list tmpfile)
                         '(("ALIST_VAR" . "from-alist")
                           ("OVERRIDE" . "from-alist"))
                         "/tmp/")))
            ;; Alist wins over file (applied later)
            (should (member "OVERRIDE=from-alist" result))
            (should (member "FILE_VAR=from-file" result))
            (should (member "ALIST_VAR=from-alist" result))
            (should (member "INHERITED=yes" result))))
      (delete-file tmpfile))))

(ert-deftest supervisor-test-build-process-environment-optional-missing ()
  "Optional missing env-file (leading -) is silently skipped."
  (let ((process-environment '("KEEP=yes")))
    (let ((result (supervisor--build-process-environment
                   '("-/nonexistent/file.env")
                   nil "/tmp/")))
      ;; Should not error, inherited env preserved
      (should (member "KEEP=yes" result)))))

(ert-deftest supervisor-test-build-process-environment-required-missing ()
  "Required missing env-file (no leading -) signals an error."
  (let ((process-environment '("KEEP=yes")))
    (should-error (supervisor--build-process-environment
                   '("/nonexistent/required.env")
                   nil "/tmp/"))))

(ert-deftest supervisor-test-environment-alist-later-wins ()
  "In :environment alist, later assignment for the same key wins."
  (let ((process-environment '()))
    (let ((result (supervisor--build-process-environment
                   nil
                   '(("KEY" . "first") ("OTHER" . "x") ("KEY" . "second"))
                   "/tmp/")))
      ;; "KEY=second" must appear later in the list than "KEY=first"
      ;; so getenv-style lookup (which scans from head) finds "second"
      (should (member "KEY=second" result))
      ;; "first" is still present but shadowed
      (should (member "KEY=first" result))
      (should (< (cl-position "KEY=second" result :test #'equal)
                 (cl-position "KEY=first" result :test #'equal))))))

(ert-deftest supervisor-test-environment-file-ordering ()
  "Multiple env-files are applied in list order; later file overrides earlier."
  (let ((file1 (make-temp-file "env1-"))
        (file2 (make-temp-file "env2-")))
    (unwind-protect
        (progn
          (with-temp-file file1
            (insert "SHARED=from-file1\n")
            (insert "ONLY1=yes\n"))
          (with-temp-file file2
            (insert "SHARED=from-file2\n")
            (insert "ONLY2=yes\n"))
          (let* ((process-environment '())
                 (result (supervisor--build-process-environment
                          (list file1 file2) nil "/tmp/")))
            ;; file2 applied after file1, so SHARED=from-file2 is later (wins)
            (should (member "SHARED=from-file2" result))
            (should (member "SHARED=from-file1" result))
            (should (< (cl-position "SHARED=from-file2" result :test #'equal)
                       (cl-position "SHARED=from-file1" result :test #'equal)))
            ;; Both unique keys present
            (should (member "ONLY1=yes" result))
            (should (member "ONLY2=yes" result))))
      (delete-file file1)
      (delete-file file2))))

(ert-deftest supervisor-test-resolve-working-directory-absolute ()
  "Resolve absolute working directory."
  (should (equal (supervisor--resolve-working-directory "/tmp" "/opt/") "/tmp")))

(ert-deftest supervisor-test-resolve-working-directory-home ()
  "Resolve ~ in working directory."
  (let ((result (supervisor--resolve-working-directory "~" "/opt/")))
    (should (equal result (expand-file-name "~")))))

(ert-deftest supervisor-test-resolve-working-directory-relative ()
  "Resolve relative working directory against unit-file directory."
  (let ((tmp-dir (make-temp-file "wdir-" t)))
    (unwind-protect
        (let ((sub (expand-file-name "subdir" tmp-dir)))
          (make-directory sub)
          (should (equal (supervisor--resolve-working-directory
                          "subdir" (file-name-as-directory tmp-dir))
                         sub)))
      (delete-directory tmp-dir t))))

(ert-deftest supervisor-test-resolve-working-directory-nonexistent ()
  "Non-existent working directory signals error."
  (should-error (supervisor--resolve-working-directory
                 "/nonexistent/dir/xyz" "/tmp/")))

(ert-deftest supervisor-test-restart-sec-overrides-global ()
  "Per-unit :restart-sec overrides `supervisor-restart-delay' in schedule-restart."
  (let* ((supervisor-restart-delay 10)
         (supervisor--restart-timers (make-hash-table :test 'equal))
         (scheduled-delay nil))
    (cl-letf (((symbol-function 'run-at-time)
               (lambda (delay _repeat &rest _args)
                 (setq scheduled-delay delay)
                 'mock-timer))
              ((symbol-function 'supervisor--log) #'ignore)
              ((symbol-function 'supervisor--format-exit-status)
               (lambda (&rest _) "exited")))
      ;; With restart-sec = 3, should use 3 not 10
      (supervisor--schedule-restart "svc" "cmd" t 'simple 'always
                                    'exit 1 nil nil nil 3)
      (should (= scheduled-delay 3)))))

(ert-deftest supervisor-test-restart-sec-nil-uses-global ()
  "Nil :restart-sec falls back to global `supervisor-restart-delay'."
  (let* ((supervisor-restart-delay 7)
         (supervisor--restart-timers (make-hash-table :test 'equal))
         (scheduled-delay nil))
    (cl-letf (((symbol-function 'run-at-time)
               (lambda (delay _repeat &rest _args)
                 (setq scheduled-delay delay)
                 'mock-timer))
              ((symbol-function 'supervisor--log) #'ignore)
              ((symbol-function 'supervisor--format-exit-status)
               (lambda (&rest _) "exited")))
      ;; With restart-sec = nil, should use global 7
      (supervisor--schedule-restart "svc" "cmd" t 'simple 'always
                                    'exit 1 nil nil nil nil)
      (should (= scheduled-delay 7)))))

(ert-deftest supervisor-test-restart-sec-zero-immediate ()
  "Restart-sec 0 means immediate retry."
  (let* ((supervisor-restart-delay 10)
         (supervisor--restart-timers (make-hash-table :test 'equal))
         (scheduled-delay nil))
    (cl-letf (((symbol-function 'run-at-time)
               (lambda (delay _repeat &rest _args)
                 (setq scheduled-delay delay)
                 'mock-timer))
              ((symbol-function 'supervisor--log) #'ignore)
              ((symbol-function 'supervisor--format-exit-status)
               (lambda (&rest _) "exited")))
      (supervisor--schedule-restart "svc" "cmd" t 'simple 'always
                                    'exit 1 nil nil nil 0)
      (should (= scheduled-delay 0)))))

(ert-deftest supervisor-test-unit-file-directory-for-id ()
  "Return directory of authoritative unit file."
  (let ((supervisor--authority-snapshot nil)
        (tmp-dir (make-temp-file "units-" t)))
    (unwind-protect
        (let ((supervisor-unit-authority-path (list tmp-dir)))
          (with-temp-file (expand-file-name "svc.el" tmp-dir)
            (insert "(:id \"svc\" :command \"echo hi\")"))
          ;; Force snapshot refresh
          (setq supervisor--authority-snapshot nil)
          (let ((dir (supervisor--unit-file-directory-for-id "svc")))
            (should (equal (file-name-as-directory dir)
                           (file-name-as-directory tmp-dir)))))
      (delete-directory tmp-dir t))))

;;;; Phase P3: Stop and Reload Command Execution

(ert-deftest supervisor-test-run-command-with-timeout-success ()
  "Command that exits 0 returns 0."
  (should (= 0 (supervisor--run-command-with-timeout
                "true" 5 nil nil nil))))

(ert-deftest supervisor-test-run-command-with-timeout-failure ()
  "Command that exits non-zero returns its exit code."
  (should (= 1 (supervisor--run-command-with-timeout
                "false" 5 nil nil nil))))

(ert-deftest supervisor-test-run-command-with-timeout-timeout ()
  "Command that exceeds timeout returns 124."
  (should (= 124 (supervisor--run-command-with-timeout
                  "sleep 60" 0.2 nil nil nil))))

(ert-deftest supervisor-test-run-command-with-timeout-inherits-dir ()
  "Command runs in the specified working directory."
  (let ((tmp-dir (make-temp-file "sv-test-" t)))
    (unwind-protect
        (should (= 0 (supervisor--run-command-with-timeout
                      "test -d ." 5 tmp-dir nil nil)))
      (delete-directory tmp-dir t))))

(ert-deftest supervisor-test-run-command-with-timeout-inherits-env ()
  "Command inherits the specified environment."
  (let ((env (cons "SV_TEST_VAR=hello42" process-environment)))
    (should (= 0 (supervisor--run-command-with-timeout
                  "test \"$SV_TEST_VAR\" = hello42" 5 nil env nil)))))

(ert-deftest supervisor-test-run-command-with-timeout-logs-output ()
  "Command output is written to log file when provided."
  (let ((log-file (make-temp-file "sv-test-log-")))
    (unwind-protect
        (progn
          (supervisor--run-command-with-timeout
           "echo test-output-marker" 5 nil nil log-file)
          (let ((content (with-temp-buffer
                           (insert-file-contents log-file)
                           (buffer-string))))
            (should (string-match-p "test-output-marker" content))))
      (delete-file log-file))))

(ert-deftest supervisor-test-exec-command-chain-all-succeed ()
  "All commands succeed returns t."
  (should (eq t (supervisor--exec-command-chain
                 '("true" "true" "true") "test-id"
                 nil nil nil 5))))

(ert-deftest supervisor-test-exec-command-chain-partial-failure ()
  "One failure returns nil but all commands still run."
  (let ((log-file (make-temp-file "sv-test-log-")))
    (unwind-protect
        (progn
          (should (eq nil (supervisor--exec-command-chain
                           '("echo before" "false" "echo after") "test-id"
                           nil nil log-file 5)))
          ;; Verify "after" command ran despite "false" failure
          (let ((content (with-temp-buffer
                           (insert-file-contents log-file)
                           (buffer-string))))
            (should (string-match-p "before" content))
            (should (string-match-p "after" content))))
      (delete-file log-file))))

(ert-deftest supervisor-test-exec-command-chain-timeout ()
  "Timeout in one command returns nil but continues to next."
  (let ((log-file (make-temp-file "sv-test-log-")))
    (unwind-protect
        (progn
          (should (eq nil (supervisor--exec-command-chain
                           '("sleep 60" "echo ran-after-timeout") "test-id"
                           nil nil log-file 0.2)))
          (let ((content (with-temp-buffer
                           (insert-file-contents log-file)
                           (buffer-string))))
            (should (string-match-p "ran-after-timeout" content))))
      (delete-file log-file))))

(ert-deftest supervisor-test-exec-command-chain-empty ()
  "Empty command list returns t."
  (should (eq t (supervisor--exec-command-chain
                 nil "test-id" nil nil nil 5))))

(ert-deftest supervisor-test-manual-stop-with-exec-stop ()
  "Exec-stop commands run before kill-signal with escalation timer."
  (let ((supervisor--processes (make-hash-table :test 'equal))
        (supervisor--manually-stopped (make-hash-table :test 'equal))
        (supervisor--manually-started (make-hash-table :test 'equal))
        (chain-called nil)
        (signal-sent nil)
        (timer-set nil)
        (proc (start-process "test-stop" nil "sleep" "300")))
    (unwind-protect
        (progn
          (puthash "test-stop" proc supervisor--processes)
          (cl-letf (((symbol-function 'supervisor--get-entry-for-id)
                     (lambda (_id)
                       (list "test-stop" "sleep 300" 0 t 'no t 'simple
                             'stage1 nil nil 30 nil nil
                             nil nil nil
                             '("my-stop-cmd") nil nil)))
                    ((symbol-function 'supervisor--exec-command-chain)
                     (lambda (cmds _id _dir _env _log _timeout)
                       (setq chain-called cmds)
                       ;; Process should still be alive at this point
                       (should (process-live-p proc))
                       t))
                    ((symbol-function 'supervisor--unit-file-directory-for-id)
                     (lambda (_id) nil))
                    ((symbol-function 'signal-process)
                     (lambda (_p sig) (setq signal-sent sig)))
                    ((symbol-function 'run-at-time)
                     (lambda (&rest _args) (setq timer-set t))))
            (let ((result (supervisor--manual-stop "test-stop")))
              (should (eq (plist-get result :status) 'stopped))
              (should (equal chain-called '("my-stop-cmd")))
              ;; Kill-signal sent after exec-stop
              (should (eq 'SIGTERM signal-sent))
              ;; Escalation timer set up
              (should timer-set))))
      (when (process-live-p proc)
        (delete-process proc)))))

(ert-deftest supervisor-test-manual-stop-without-exec-stop ()
  "Without exec-stop, process is terminated directly."
  (let ((supervisor--processes (make-hash-table :test 'equal))
        (supervisor--manually-stopped (make-hash-table :test 'equal))
        (supervisor--manually-started (make-hash-table :test 'equal))
        (chain-called nil)
        (proc (start-process "test-stop2" nil "sleep" "300")))
    (unwind-protect
        (progn
          (puthash "test-stop2" proc supervisor--processes)
          (cl-letf (((symbol-function 'supervisor--get-entry-for-id)
                     (lambda (_id)
                       ;; Entry with no exec-stop (nil at index 16)
                       (list "test-stop2" "sleep 300" 0 t 'no t 'simple
                             'stage1 nil nil 30 nil nil
                             nil nil nil
                             nil nil nil)))
                    ((symbol-function 'supervisor--exec-command-chain)
                     (lambda (cmds _id _dir _env _log _timeout)
                       (setq chain-called cmds)
                       t))
                    ((symbol-function 'supervisor--unit-file-directory-for-id)
                     (lambda (_id) nil)))
            (let ((result (supervisor--manual-stop "test-stop2")))
              (should (eq (plist-get result :status) 'stopped))
              ;; Chain should NOT have been called
              (should (null chain-called)))))
      (when (process-live-p proc)
        (delete-process proc)))))

(ert-deftest supervisor-test-manual-stop-exec-stop-failure-still-terminates ()
  "Even if exec-stop fails, kill-signal is still sent."
  (let ((supervisor--processes (make-hash-table :test 'equal))
        (supervisor--manually-stopped (make-hash-table :test 'equal))
        (supervisor--manually-started (make-hash-table :test 'equal))
        (signal-sent nil)
        (proc (start-process "test-stop3" nil "sleep" "300")))
    (unwind-protect
        (progn
          (puthash "test-stop3" proc supervisor--processes)
          (cl-letf (((symbol-function 'supervisor--get-entry-for-id)
                     (lambda (_id)
                       (list "test-stop3" "sleep 300" 0 t 'no t 'simple
                             'stage1 nil nil 30 nil nil
                             nil nil nil
                             '("false") nil nil)))
                    ((symbol-function 'supervisor--exec-command-chain)
                     (lambda (_cmds _id _dir _env _log _timeout)
                       nil))  ; Simulate failure
                    ((symbol-function 'supervisor--unit-file-directory-for-id)
                     (lambda (_id) nil))
                    ((symbol-function 'signal-process)
                     (lambda (_p sig) (setq signal-sent sig)))
                    ((symbol-function 'run-at-time)
                     (lambda (&rest _args))))
            (let ((result (supervisor--manual-stop "test-stop3")))
              (should (eq (plist-get result :status) 'stopped))
              ;; Kill-signal sent regardless of exec-stop failure
              (should (eq 'SIGTERM signal-sent)))))
      (when (process-live-p proc)
        (delete-process proc)))))

(ert-deftest supervisor-test-reload-unit-with-exec-reload ()
  "Reload with exec-reload runs commands without stop/start."
  (let ((supervisor--processes (make-hash-table :test 'equal))
        (supervisor--manually-stopped (make-hash-table :test 'equal))
        (supervisor--manually-started (make-hash-table :test 'equal))
        (supervisor--mask-override (make-hash-table :test 'equal))
        (supervisor--invalid (make-hash-table :test 'equal))
        (supervisor--failed (make-hash-table :test 'equal))
        (supervisor--restart-times (make-hash-table :test 'equal))
        (chain-called nil)
        (stop-called nil)
        (proc (start-process "test-reload" nil "sleep" "300")))
    (unwind-protect
        (progn
          (puthash "test-reload" proc supervisor--processes)
          (cl-letf (((symbol-function 'supervisor--reload-find-entry)
                     (lambda (_id)
                       (list "test-reload" "sleep 300" 0 t 'no t 'simple
                             'stage1 nil nil 30 nil nil
                             nil nil nil
                             nil '("my-reload-cmd") nil)))
                    ((symbol-function 'supervisor--exec-command-chain)
                     (lambda (cmds _id _dir _env _log _timeout)
                       (setq chain-called cmds)
                       t))
                    ((symbol-function 'supervisor--manual-stop)
                     (lambda (_id)
                       (setq stop-called t)
                       (list :status 'stopped :reason nil)))
                    ((symbol-function 'supervisor--unit-file-directory-for-id)
                     (lambda (_id) nil)))
            (let ((result (supervisor--reload-unit "test-reload")))
              (should (equal (plist-get result :action) "reloaded"))
              (should (equal chain-called '("my-reload-cmd")))
              ;; Stop should NOT have been called
              (should (null stop-called))
              ;; Process should still be running
              (should (process-live-p proc)))))
      (when (process-live-p proc)
        (delete-process proc)))))

(ert-deftest supervisor-test-reload-unit-without-exec-reload ()
  "Reload without exec-reload does stop + start."
  (let ((supervisor--processes (make-hash-table :test 'equal))
        (supervisor--manually-stopped (make-hash-table :test 'equal))
        (supervisor--manually-started (make-hash-table :test 'equal))
        (supervisor--mask-override (make-hash-table :test 'equal))
        (supervisor--invalid (make-hash-table :test 'equal))
        (supervisor--failed (make-hash-table :test 'equal))
        (supervisor--restart-times (make-hash-table :test 'equal))
        (stop-called nil)
        (start-called nil)
        (proc (start-process "test-reload2" nil "sleep" "300")))
    (unwind-protect
        (progn
          (puthash "test-reload2" proc supervisor--processes)
          (cl-letf (((symbol-function 'supervisor--reload-find-entry)
                     (lambda (_id)
                       ;; No exec-reload (nil at index 17)
                       (list "test-reload2" "sleep 300" 0 t 'no t 'simple
                             'stage1 nil nil 30 nil nil
                             nil nil nil
                             nil nil nil)))
                    ((symbol-function 'supervisor--manual-stop)
                     (lambda (_id)
                       (setq stop-called t)
                       (list :status 'stopped :reason nil)))
                    ((symbol-function 'supervisor--start-process)
                     (lambda (&rest _args)
                       (setq start-called t)
                       proc))
                    ((symbol-function 'supervisor--unit-file-directory-for-id)
                     (lambda (_id) nil)))
            (let ((result (supervisor--reload-unit "test-reload2")))
              (should (equal (plist-get result :action) "reloaded"))
              (should stop-called)
              (should start-called))))
      (when (process-live-p proc)
        (delete-process proc)))))

(ert-deftest supervisor-test-reload-unit-exec-reload-failure ()
  "Reload command failure reports error, keeps process running."
  (let ((supervisor--processes (make-hash-table :test 'equal))
        (supervisor--manually-stopped (make-hash-table :test 'equal))
        (supervisor--manually-started (make-hash-table :test 'equal))
        (supervisor--mask-override (make-hash-table :test 'equal))
        (supervisor--invalid (make-hash-table :test 'equal))
        (supervisor--failed (make-hash-table :test 'equal))
        (supervisor--restart-times (make-hash-table :test 'equal))
        (proc (start-process "test-reload3" nil "sleep" "300")))
    (unwind-protect
        (progn
          (puthash "test-reload3" proc supervisor--processes)
          (cl-letf (((symbol-function 'supervisor--reload-find-entry)
                     (lambda (_id)
                       (list "test-reload3" "sleep 300" 0 t 'no t 'simple
                             'stage1 nil nil 30 nil nil
                             nil nil nil
                             nil '("false") nil)))
                    ((symbol-function 'supervisor--exec-command-chain)
                     (lambda (_cmds _id _dir _env _log _timeout)
                       nil))  ; Simulate failure
                    ((symbol-function 'supervisor--unit-file-directory-for-id)
                     (lambda (_id) nil)))
            (let ((result (supervisor--reload-unit "test-reload3")))
              (should (string-match-p "reload command failed"
                                      (plist-get result :action)))
              ;; Process should still be running
              (should (process-live-p proc)))))
      (when (process-live-p proc)
        (delete-process proc)))))

(ert-deftest supervisor-test-manual-stop-entry-not-found ()
  "Exec-stop is skipped when entry lookup returns nil."
  (let ((supervisor--processes (make-hash-table :test 'equal))
        (supervisor--manually-stopped (make-hash-table :test 'equal))
        (supervisor--manually-started (make-hash-table :test 'equal))
        (chain-called nil)
        (proc (start-process "test-stop-nf" nil "sleep" "300")))
    (unwind-protect
        (progn
          (puthash "test-stop-nf" proc supervisor--processes)
          (cl-letf (((symbol-function 'supervisor--get-entry-for-id)
                     (lambda (_id) nil))
                    ((symbol-function 'supervisor--exec-command-chain)
                     (lambda (cmds _id _dir _env _log _timeout)
                       (setq chain-called cmds)
                       t)))
            (let ((result (supervisor--manual-stop "test-stop-nf")))
              (should (eq (plist-get result :status) 'stopped))
              (should (null chain-called)))))
      (when (process-live-p proc)
        (delete-process proc)))))

(ert-deftest supervisor-test-reload-stopped-unit-with-exec-reload ()
  "Stopped simple unit with exec-reload does not run reload chain."
  (let ((supervisor--processes (make-hash-table :test 'equal))
        (supervisor--manually-stopped (make-hash-table :test 'equal))
        (supervisor--manually-started (make-hash-table :test 'equal))
        (supervisor--mask-override (make-hash-table :test 'equal))
        (supervisor--invalid (make-hash-table :test 'equal))
        (supervisor--failed (make-hash-table :test 'equal))
        (supervisor--restart-times (make-hash-table :test 'equal))
        (supervisor--oneshot-completed (make-hash-table :test 'equal))
        (chain-called nil))
    ;; No process in supervisor--processes  unit is stopped
    (cl-letf (((symbol-function 'supervisor--reload-find-entry)
               (lambda (_id)
                 (list "stopped-svc" "echo hi" 0 t 'no t 'simple
                       'stage1 nil nil 30 nil nil
                       nil nil nil
                       nil '("reload-cmd") nil)))
              ((symbol-function 'supervisor--exec-command-chain)
               (lambda (cmds _id _dir _env _log _timeout)
                 (setq chain-called cmds)
                 t))
              ((symbol-function 'supervisor--unit-file-directory-for-id)
               (lambda (_id) nil)))
      (let ((result (supervisor--reload-unit "stopped-svc")))
        ;; Should update definition, not run reload chain
        (should (equal (plist-get result :action) "updated"))
        (should (null chain-called))))))

(ert-deftest supervisor-test-exec-stop-skips-on-cwd-resolution-error ()
  "Exec-stop is skipped when working directory resolution fails."
  (let ((supervisor--processes (make-hash-table :test 'equal))
        (supervisor--manually-stopped (make-hash-table :test 'equal))
        (supervisor--manually-started (make-hash-table :test 'equal))
        (chain-called nil)
        (proc (start-process "test-cwd-err" nil "sleep" "300")))
    (unwind-protect
        (progn
          (puthash "test-cwd-err" proc supervisor--processes)
          (cl-letf (((symbol-function 'supervisor--get-entry-for-id)
                     (lambda (_id)
                       (list "test-cwd-err" "sleep 300" 0 t 'no t 'simple
                             'stage1 nil nil 30 nil nil
                             "/nonexistent/dir" nil nil
                             '("stop-cmd") nil nil)))
                    ((symbol-function 'supervisor--exec-command-chain)
                     (lambda (cmds _id _dir _env _log _timeout)
                       (setq chain-called cmds)
                       t))
                    ((symbol-function 'supervisor--unit-file-directory-for-id)
                     (lambda (_id) nil)))
            (let ((result (supervisor--manual-stop "test-cwd-err")))
              (should (eq (plist-get result :status) 'stopped))
              ;; Chain should NOT have been called due to cwd error
              (should (null chain-called)))))
      (when (process-live-p proc)
        (delete-process proc)))))

(ert-deftest supervisor-test-exec-stop-skips-on-env-resolution-error ()
  "Exec-stop is skipped when environment resolution fails."
  (let ((supervisor--processes (make-hash-table :test 'equal))
        (supervisor--manually-stopped (make-hash-table :test 'equal))
        (supervisor--manually-started (make-hash-table :test 'equal))
        (chain-called nil)
        (proc (start-process "test-env-err" nil "sleep" "300")))
    (unwind-protect
        (progn
          (puthash "test-env-err" proc supervisor--processes)
          (cl-letf (((symbol-function 'supervisor--get-entry-for-id)
                     (lambda (_id)
                       (list "test-env-err" "sleep 300" 0 t 'no t 'simple
                             'stage1 nil nil 30 nil nil
                             nil nil '("/nonexistent/env-file")
                             '("stop-cmd") nil nil)))
                    ((symbol-function 'supervisor--exec-command-chain)
                     (lambda (cmds _id _dir _env _log _timeout)
                       (setq chain-called cmds)
                       t))
                    ((symbol-function 'supervisor--unit-file-directory-for-id)
                     (lambda (_id) nil)))
            (let ((result (supervisor--manual-stop "test-env-err")))
              (should (eq (plist-get result :status) 'stopped))
              ;; Chain should NOT have been called due to env error
              (should (null chain-called)))))
      (when (process-live-p proc)
        (delete-process proc)))))

(ert-deftest supervisor-test-reload-unit-exec-reload-context-error ()
  "Reload reports error when context resolution fails."
  (let ((supervisor--processes (make-hash-table :test 'equal))
        (supervisor--manually-stopped (make-hash-table :test 'equal))
        (supervisor--manually-started (make-hash-table :test 'equal))
        (supervisor--mask-override (make-hash-table :test 'equal))
        (supervisor--invalid (make-hash-table :test 'equal))
        (supervisor--failed (make-hash-table :test 'equal))
        (supervisor--restart-times (make-hash-table :test 'equal))
        (proc (start-process "test-reload-ctx" nil "sleep" "300")))
    (unwind-protect
        (progn
          (puthash "test-reload-ctx" proc supervisor--processes)
          (cl-letf (((symbol-function 'supervisor--reload-find-entry)
                     (lambda (_id)
                       (list "test-reload-ctx" "sleep 300" 0 t 'no t 'simple
                             'stage1 nil nil 30 nil nil
                             "/nonexistent/dir" nil nil
                             nil '("reload-cmd") nil)))
                    ((symbol-function 'supervisor--unit-file-directory-for-id)
                     (lambda (_id) nil)))
            (let ((result (supervisor--reload-unit "test-reload-ctx")))
              (should (string-match-p "cannot resolve"
                                      (plist-get result :action)))
              ;; Process should still be running
              (should (process-live-p proc)))))
      (when (process-live-p proc)
        (delete-process proc)))))

(ert-deftest supervisor-test-stop-all-runs-exec-stop ()
  "The stop-all flow runs exec-stop for applicable units."
  (let ((supervisor--processes (make-hash-table :test 'equal))
        (supervisor--manually-stopped (make-hash-table :test 'equal))
        (supervisor--manually-started (make-hash-table :test 'equal))
        (supervisor--timers nil)
        (supervisor--restart-timers (make-hash-table :test 'equal))
        (supervisor--shutting-down nil)
        (supervisor--shutdown-complete-flag nil)
        (supervisor--shutdown-remaining 0)
        (supervisor--shutdown-timer nil)
        (supervisor--shutdown-callback nil)
        (exec-stop-ids nil)
        (proc (start-process "test-stop-all" nil "sleep" "300")))
    (unwind-protect
        (progn
          (puthash "test-stop-all" proc supervisor--processes)
          (cl-letf (((symbol-function 'supervisor--run-exec-stop-for-id)
                     (lambda (id)
                       (push id exec-stop-ids)))
                    ((symbol-function 'supervisor--dag-cleanup)
                     #'ignore)
                    ((symbol-function 'supervisor--emit-event)
                     #'ignore))
            (supervisor-stop)
            ;; exec-stop should have been called for the unit
            (should (member "test-stop-all" exec-stop-ids))))
      (when (process-live-p proc)
        (delete-process proc)))))

;;;; Phase N1: PT3 Parser/Schema/Validation Tests

;; Signal normalization

(ert-deftest supervisor-test-normalize-signal-name-sigterm ()
  "Normalize SIGTERM symbol."
  (should (eq (supervisor--normalize-signal-name 'SIGTERM) 'SIGTERM)))

(ert-deftest supervisor-test-normalize-signal-name-term ()
  "Normalize short form TERM to SIGTERM."
  (should (eq (supervisor--normalize-signal-name 'TERM) 'SIGTERM)))

(ert-deftest supervisor-test-normalize-signal-name-string ()
  "Normalize string form."
  (should (eq (supervisor--normalize-signal-name "sigterm") 'SIGTERM)))

(ert-deftest supervisor-test-normalize-signal-name-string-short ()
  "Normalize short string form."
  (should (eq (supervisor--normalize-signal-name "hup") 'SIGHUP)))

(ert-deftest supervisor-test-normalize-signal-name-unknown ()
  "Return nil for unknown signal."
  (should-not (supervisor--normalize-signal-name 'SIGFAKE)))

(ert-deftest supervisor-test-normalize-signal-name-sigusr1 ()
  "Normalize SIGUSR1."
  (should (eq (supervisor--normalize-signal-name 'USR1) 'SIGUSR1)))

;; Kill-mode normalization

(ert-deftest supervisor-test-normalize-kill-mode-process ()
  "Normalize process symbol."
  (should (eq (supervisor--normalize-kill-mode 'process) 'process)))

(ert-deftest supervisor-test-normalize-kill-mode-mixed ()
  "Normalize mixed symbol."
  (should (eq (supervisor--normalize-kill-mode 'mixed) 'mixed)))

(ert-deftest supervisor-test-normalize-kill-mode-string ()
  "Normalize string form."
  (should (eq (supervisor--normalize-kill-mode "process") 'process)))

(ert-deftest supervisor-test-normalize-kill-mode-invalid ()
  "Return nil for invalid kill mode."
  (should-not (supervisor--normalize-kill-mode 'group)))

;; Success-exit-status normalization

(ert-deftest supervisor-test-normalize-success-exit-status-nil ()
  "Return nil for nil input."
  (should-not (supervisor--normalize-success-exit-status nil)))

(ert-deftest supervisor-test-normalize-success-exit-status-int ()
  "Normalize single integer."
  (let ((result (supervisor--normalize-success-exit-status 42)))
    (should (equal (plist-get result :codes) '(42)))
    (should (equal (plist-get result :signals) nil))))

(ert-deftest supervisor-test-normalize-success-exit-status-signal ()
  "Normalize single signal."
  (let ((result (supervisor--normalize-success-exit-status 'TERM)))
    (should (equal (plist-get result :codes) nil))
    (should (equal (plist-get result :signals) '(SIGTERM)))))

(ert-deftest supervisor-test-normalize-success-exit-status-list ()
  "Normalize mixed list of ints and signals."
  (let ((result (supervisor--normalize-success-exit-status '(0 42 SIGHUP "term"))))
    (should (equal (plist-get result :codes) '(0 42)))
    (should (equal (plist-get result :signals) '(SIGHUP SIGTERM)))))

(ert-deftest supervisor-test-normalize-success-exit-status-dedup ()
  "Deduplicate codes and signals."
  (let ((result (supervisor--normalize-success-exit-status '(1 1 TERM SIGTERM))))
    (should (equal (plist-get result :codes) '(1)))
    (should (equal (plist-get result :signals) '(SIGTERM)))))

;; Deduplicate-stable

(ert-deftest supervisor-test-deduplicate-stable ()
  "Deduplicate preserving first occurrence."
  (should (equal (supervisor--deduplicate-stable '("a" "b" "a" "c" "b"))
                 '("a" "b" "c"))))

(ert-deftest supervisor-test-deduplicate-stable-empty ()
  "Empty list returns empty."
  (should (equal (supervisor--deduplicate-stable nil) nil)))

;; Parse-entry with PT3 fields

(ert-deftest supervisor-test-parse-entry-description ()
  "Parse entry with :description."
  (let ((entry (supervisor--parse-entry '("cmd" :description "my service"))))
    (should (equal (supervisor-entry-description entry) "my service"))))

(ert-deftest supervisor-test-parse-entry-documentation-string ()
  "Parse entry with :documentation as string, normalized to list."
  (let ((entry (supervisor--parse-entry '("cmd" :documentation "man:foo(1)"))))
    (should (equal (supervisor-entry-documentation entry) '("man:foo(1)")))))

(ert-deftest supervisor-test-parse-entry-documentation-list ()
  "Parse entry with :documentation as list."
  (let ((entry (supervisor--parse-entry
                '("cmd" :documentation ("man:foo(1)" "https://example.com")))))
    (should (equal (supervisor-entry-documentation entry)
                   '("man:foo(1)" "https://example.com")))))

(ert-deftest supervisor-test-parse-entry-documentation-dedup ()
  "Parse entry with :documentation deduplicates."
  (let ((entry (supervisor--parse-entry
                '("cmd" :documentation ("man:foo(1)" "man:foo(1)")))))
    (should (equal (supervisor-entry-documentation entry)
                   '("man:foo(1)")))))

(ert-deftest supervisor-test-parse-entry-before ()
  "Parse entry with :before."
  (let ((entry (supervisor--parse-entry '("cmd" :before "other"))))
    (should (equal (supervisor-entry-before entry) '("other")))))

(ert-deftest supervisor-test-parse-entry-before-list ()
  "Parse entry with :before as list."
  (let ((entry (supervisor--parse-entry '("cmd" :before ("a" "b")))))
    (should (equal (supervisor-entry-before entry) '("a" "b")))))

(ert-deftest supervisor-test-parse-entry-before-dedup ()
  "Parse entry with :before deduplicates."
  (let ((entry (supervisor--parse-entry '("cmd" :before ("a" "a" "b")))))
    (should (equal (supervisor-entry-before entry) '("a" "b")))))

(ert-deftest supervisor-test-parse-entry-wants ()
  "Parse entry with :wants."
  (let ((entry (supervisor--parse-entry '("cmd" :wants "dep"))))
    (should (equal (supervisor-entry-wants entry) '("dep")))))

(ert-deftest supervisor-test-parse-entry-wants-list ()
  "Parse entry with :wants as list."
  (let ((entry (supervisor--parse-entry '("cmd" :wants ("a" "b")))))
    (should (equal (supervisor-entry-wants entry) '("a" "b")))))

(ert-deftest supervisor-test-parse-entry-kill-signal ()
  "Parse entry with :kill-signal."
  (let ((entry (supervisor--parse-entry '("cmd" :kill-signal SIGTERM))))
    (should (eq (supervisor-entry-kill-signal entry) 'SIGTERM))))

(ert-deftest supervisor-test-parse-entry-kill-signal-short ()
  "Parse entry with :kill-signal short form."
  (let ((entry (supervisor--parse-entry '("cmd" :kill-signal HUP))))
    (should (eq (supervisor-entry-kill-signal entry) 'SIGHUP))))

(ert-deftest supervisor-test-parse-entry-kill-mode ()
  "Parse entry with :kill-mode."
  (let ((entry (supervisor--parse-entry '("cmd" :kill-mode mixed))))
    (should (eq (supervisor-entry-kill-mode entry) 'mixed))))

(ert-deftest supervisor-test-parse-entry-remain-after-exit ()
  "Parse entry with :remain-after-exit."
  (let ((entry (supervisor--parse-entry
                '("cmd" :type oneshot :remain-after-exit t))))
    (should (eq (supervisor-entry-remain-after-exit entry) t))))

(ert-deftest supervisor-test-parse-entry-success-exit-status ()
  "Parse entry with :success-exit-status."
  (let ((entry (supervisor--parse-entry
                '("cmd" :success-exit-status (42 SIGHUP)))))
    (should (equal (plist-get (supervisor-entry-success-exit-status entry) :codes)
                   '(42)))
    (should (equal (plist-get (supervisor-entry-success-exit-status entry) :signals)
                   '(SIGHUP)))))

(ert-deftest supervisor-test-parse-entry-pt3-defaults ()
  "All PT3 fields default to nil for string entry."
  (let ((entry (supervisor--parse-entry "sleep 300")))
    (should-not (supervisor-entry-description entry))
    (should-not (supervisor-entry-documentation entry))
    (should-not (supervisor-entry-before entry))
    (should-not (supervisor-entry-wants entry))
    (should-not (supervisor-entry-kill-signal entry))
    (should-not (supervisor-entry-kill-mode entry))
    (should-not (supervisor-entry-remain-after-exit entry))
    (should-not (supervisor-entry-success-exit-status entry))))

(ert-deftest supervisor-test-parse-entry-33-elements ()
  "Parse entry returns 39 elements."
  (let ((entry (supervisor--parse-entry "sleep 300")))
    (should (= (length entry) 39))))

;; Validation tests for PT3 keys

(ert-deftest supervisor-test-validate-description-valid ()
  "Valid :description passes validation."
  (should-not (supervisor--validate-entry '("cmd" :description "my service"))))

(ert-deftest supervisor-test-validate-description-nil ()
  "Nil :description passes validation."
  (should-not (supervisor--validate-entry '("cmd" :description nil))))

(ert-deftest supervisor-test-validate-description-invalid ()
  "Non-string :description fails validation."
  (should (string-match-p ":description must be"
                          (supervisor--validate-entry '("cmd" :description 42)))))

(ert-deftest supervisor-test-validate-documentation-valid-string ()
  "String :documentation passes validation."
  (should-not (supervisor--validate-entry '("cmd" :documentation "man:foo(1)"))))

(ert-deftest supervisor-test-validate-documentation-valid-list ()
  "List :documentation passes validation."
  (should-not (supervisor--validate-entry
               '("cmd" :documentation ("man:foo(1)" "https://example.com")))))

(ert-deftest supervisor-test-validate-documentation-invalid ()
  "Invalid :documentation fails validation."
  (should (string-match-p ":documentation must be"
                          (supervisor--validate-entry '("cmd" :documentation 42)))))

(ert-deftest supervisor-test-validate-before-valid ()
  "Valid :before passes."
  (should-not (supervisor--validate-entry '("cmd" :before "other"))))

(ert-deftest supervisor-test-validate-before-valid-list ()
  "List :before passes."
  (should-not (supervisor--validate-entry '("cmd" :before ("a" "b")))))

(ert-deftest supervisor-test-validate-before-invalid ()
  "Invalid :before fails."
  (should (string-match-p ":before must be"
                          (supervisor--validate-entry '("cmd" :before 42)))))

(ert-deftest supervisor-test-validate-wants-valid ()
  "Valid :wants passes."
  (should-not (supervisor--validate-entry '("cmd" :wants "dep"))))

(ert-deftest supervisor-test-validate-wants-invalid ()
  "Invalid :wants fails."
  (should (string-match-p ":wants must be"
                          (supervisor--validate-entry '("cmd" :wants 42)))))

(ert-deftest supervisor-test-validate-kill-signal-valid ()
  "Valid :kill-signal passes."
  (should-not (supervisor--validate-entry '("cmd" :kill-signal SIGTERM))))

(ert-deftest supervisor-test-validate-kill-signal-short ()
  "Short form :kill-signal passes."
  (should-not (supervisor--validate-entry '("cmd" :kill-signal HUP))))

(ert-deftest supervisor-test-validate-kill-signal-invalid ()
  "Invalid :kill-signal fails."
  (should (string-match-p ":kill-signal must be"
                          (supervisor--validate-entry '("cmd" :kill-signal SIGFAKE)))))

(ert-deftest supervisor-test-validate-kill-mode-valid ()
  "Valid :kill-mode passes."
  (should-not (supervisor--validate-entry '("cmd" :kill-mode process))))

(ert-deftest supervisor-test-validate-kill-mode-mixed ()
  "Mixed :kill-mode passes."
  (should-not (supervisor--validate-entry '("cmd" :kill-mode mixed))))

(ert-deftest supervisor-test-validate-kill-mode-invalid ()
  "Invalid :kill-mode fails."
  (should (string-match-p ":kill-mode must be"
                          (supervisor--validate-entry '("cmd" :kill-mode group)))))

(ert-deftest supervisor-test-validate-remain-after-exit-valid ()
  "Valid :remain-after-exit passes."
  (should-not (supervisor--validate-entry
               '("cmd" :type oneshot :remain-after-exit t))))

(ert-deftest supervisor-test-validate-remain-after-exit-nil ()
  "Nil :remain-after-exit passes."
  (should-not (supervisor--validate-entry
               '("cmd" :type oneshot :remain-after-exit nil))))

(ert-deftest supervisor-test-validate-remain-after-exit-invalid ()
  "Non-boolean :remain-after-exit fails."
  (should (string-match-p ":remain-after-exit must be"
                          (supervisor--validate-entry
                           '("cmd" :type oneshot :remain-after-exit 1)))))

(ert-deftest supervisor-test-validate-remain-after-exit-simple-invalid ()
  "Remain-after-exit on simple type fails."
  (should (string-match-p ":remain-after-exit is invalid for :type simple"
                          (supervisor--validate-entry
                           '("cmd" :type simple :remain-after-exit t)))))

(ert-deftest supervisor-test-validate-success-exit-status-valid-int ()
  "Valid int :success-exit-status passes."
  (should-not (supervisor--validate-entry '("cmd" :success-exit-status 42))))

(ert-deftest supervisor-test-validate-success-exit-status-valid-signal ()
  "Valid signal :success-exit-status passes."
  (should-not (supervisor--validate-entry '("cmd" :success-exit-status SIGHUP))))

(ert-deftest supervisor-test-validate-success-exit-status-valid-list ()
  "Valid list :success-exit-status passes."
  (should-not (supervisor--validate-entry
               '("cmd" :success-exit-status (42 SIGHUP)))))

(ert-deftest supervisor-test-validate-success-exit-status-invalid ()
  "Non-int/signal :success-exit-status item fails."
  (should (string-match-p ":success-exit-status item must be"
                          (supervisor--validate-entry
                           '("cmd" :success-exit-status (42 3.14))))))

(ert-deftest supervisor-test-validate-success-exit-status-unknown-signal ()
  "Unknown signal name in :success-exit-status fails."
  (should (string-match-p "unknown signal SIGFAKE"
                          (supervisor--validate-entry
                           '("cmd" :success-exit-status SIGFAKE)))))

(ert-deftest supervisor-test-validate-success-exit-status-oneshot-invalid ()
  "Success-exit-status on oneshot type fails."
  (should (string-match-p ":success-exit-status is invalid for :type oneshot"
                          (supervisor--validate-entry
                           '("cmd" :type oneshot :success-exit-status 42)))))

;; Entry-to-service and service-to-entry roundtrip with PT3 fields

(ert-deftest supervisor-test-entry-service-roundtrip-pt3 ()
  "Round-trip entry->service->entry preserves PT3 fields."
  (let* ((entry (supervisor--parse-entry
                 '("cmd" :description "test svc"
                   :documentation ("man:foo(1)")
                   :before ("b")
                   :wants ("w")
                   :kill-signal SIGTERM
                   :kill-mode mixed
                   :success-exit-status (42 SIGHUP))))
         (service (supervisor-entry-to-service entry))
         (roundtripped (supervisor-service-to-entry service)))
    (should (equal (supervisor-entry-description roundtripped) "test svc"))
    (should (equal (supervisor-entry-documentation roundtripped) '("man:foo(1)")))
    (should (equal (supervisor-entry-before roundtripped) '("b")))
    (should (equal (supervisor-entry-wants roundtripped) '("w")))
    (should (eq (supervisor-entry-kill-signal roundtripped) 'SIGTERM))
    (should (eq (supervisor-entry-kill-mode roundtripped) 'mixed))
    (should (equal (plist-get (supervisor-entry-success-exit-status roundtripped) :codes)
                   '(42)))
    (should (equal (plist-get (supervisor-entry-success-exit-status roundtripped) :signals)
                   '(SIGHUP)))))

(ert-deftest supervisor-test-entry-service-roundtrip-pt3-remain ()
  "Round-trip preserves remain-after-exit for oneshot."
  (let* ((entry (supervisor--parse-entry
                 '("cmd" :type oneshot :remain-after-exit t)))
         (service (supervisor-entry-to-service entry))
         (roundtripped (supervisor-service-to-entry service)))
    (should (eq (supervisor-entry-remain-after-exit roundtripped) t))))

;; Unit-file keyword whitelist includes PT3 keys

(ert-deftest supervisor-test-unit-file-keywords-pt3 ()
  "Unit-file keywords include all PT3 keys."
  (dolist (kw '(:description :documentation :before :wants
                :kill-signal :kill-mode :remain-after-exit :success-exit-status))
    (should (memq kw supervisor--unit-file-keywords))))

;; Core keyword whitelist includes PT3 keys

(ert-deftest supervisor-test-valid-keywords-pt3 ()
  "Valid keywords include all PT3 keys."
  (dolist (kw '(:description :documentation :before :wants
                :kill-signal :kill-mode :remain-after-exit :success-exit-status))
    (should (memq kw supervisor--valid-keywords))))

;; Unit-file and core keyword whitelists include :user/:group

(ert-deftest supervisor-test-unit-file-keywords-user-group ()
  "Unit-file keywords include :user and :group."
  (should (memq :user supervisor--unit-file-keywords))
  (should (memq :group supervisor--unit-file-keywords)))

(ert-deftest supervisor-test-valid-keywords-user-group ()
  "Core valid keywords include :user and :group."
  (should (memq :user supervisor--valid-keywords))
  (should (memq :group supervisor--valid-keywords)))

(ert-deftest supervisor-test-unit-file-user-group-accepted ()
  "Unit file with :user/:group passes validation."
  (supervisor-test-with-unit-files
      '(("echo hi" :id "svc" :user "alice" :group "staff"))
    (let* ((entries (supervisor--all-parsed-entries)))
      (should (= 1 (length entries)))
      (let ((entry (car entries)))
        (should (equal (supervisor-entry-user entry) "alice"))
        (should (equal (supervisor-entry-group entry) "staff"))))))

;; Unit-file and core keyword whitelists include sandbox keys

(ert-deftest supervisor-test-unit-file-keywords-sandbox ()
  "Unit-file keywords include all sandbox keys."
  (dolist (kw '(:sandbox-profile :sandbox-network :sandbox-ro-bind
                :sandbox-rw-bind :sandbox-tmpfs :sandbox-raw-args))
    (should (memq kw supervisor--unit-file-keywords))))

(ert-deftest supervisor-test-unit-file-sandbox-profile-accepted ()
  "Unit file with :sandbox-profile passes validation and roundtrips."
  (cl-letf (((symbol-function 'executable-find)
             (lambda (name) (when (equal name "bwrap") "/usr/bin/bwrap"))))
    (supervisor-test-with-unit-files
        '(("echo hi" :id "svc" :sandbox-profile strict))
      (let* ((entries (supervisor--all-parsed-entries)))
        (should (= 1 (length entries)))
        (should (eq (supervisor-entry-sandbox-profile (car entries))
                    'strict))))))

(ert-deftest supervisor-test-unit-file-sandbox-ro-bind-accepted ()
  "Unit file with :sandbox-ro-bind passes validation and roundtrips."
  (cl-letf (((symbol-function 'executable-find)
             (lambda (name) (when (equal name "bwrap") "/usr/bin/bwrap"))))
    (supervisor-test-with-unit-files
        '(("echo hi" :id "svc" :sandbox-ro-bind ("/tmp")))
      (let* ((entries (supervisor--all-parsed-entries)))
        (should (= 1 (length entries)))
        (should (equal (supervisor-entry-sandbox-ro-bind (car entries))
                       '("/tmp")))))))

;; Type-gating

(ert-deftest supervisor-test-remain-after-exit-oneshot-only ()
  "Remain-after-exit is in oneshot-only keywords."
  (should (memq :remain-after-exit supervisor--oneshot-only-keywords)))

(ert-deftest supervisor-test-success-exit-status-simple-only ()
  "Success-exit-status is in simple-only keywords."
  (should (memq :success-exit-status supervisor--simple-only-keywords)))

;; Scaffold includes PT3 keys

(ert-deftest supervisor-test-scaffold-pt3-keys ()
  "Scaffold template mentions PT3 keywords."
  (let ((scaffold (supervisor--unit-file-scaffold "test-id")))
    (dolist (kw '(":description" ":documentation" ":before" ":wants"
                  ":kill-signal" ":kill-mode" ":remain-after-exit"
                  ":success-exit-status"))
      (should (string-match-p kw scaffold)))))

;;;; Phase N2: Metadata Surface Tests

(ert-deftest supervisor-test-cli-entry-info-description ()
  "Entry info includes :description."
  (let ((entry (supervisor--parse-entry
                '("cmd" :id "svc" :description "My service"))))
    (let ((info (supervisor--cli-entry-info entry)))
      (should (equal (alist-get 'description info) "My service")))))

(ert-deftest supervisor-test-cli-entry-info-documentation ()
  "Entry info includes :documentation."
  (let ((entry (supervisor--parse-entry
                '("cmd" :id "svc" :documentation ("man:foo(1)")))))
    (let ((info (supervisor--cli-entry-info entry)))
      (should (equal (alist-get 'documentation info) '("man:foo(1)"))))))

(ert-deftest supervisor-test-cli-entry-info-description-nil ()
  "Entry info description is nil when not set."
  (let ((entry (supervisor--parse-entry '("cmd" :id "svc"))))
    (let ((info (supervisor--cli-entry-info entry)))
      (should-not (alist-get 'description info)))))

(ert-deftest supervisor-test-cli-describe-human-description ()
  "Human describe includes description line."
  (let* ((entry (supervisor--parse-entry
                 '("cmd" :id "svc" :description "My service")))
         (info (supervisor--cli-entry-info entry))
         (output (supervisor--cli-describe-human info)))
    (should (string-match-p "Description: My service" output))))

(ert-deftest supervisor-test-cli-describe-human-documentation ()
  "Human describe includes documentation line."
  (let* ((entry (supervisor--parse-entry
                 '("cmd" :id "svc" :documentation ("man:foo(1)" "https://x.com"))))
         (info (supervisor--cli-entry-info entry))
         (output (supervisor--cli-describe-human info)))
    (should (string-match-p "Documentation: man:foo(1), https://x.com" output))))

(ert-deftest supervisor-test-cli-describe-human-no-desc ()
  "Human describe omits description line when nil."
  (let* ((entry (supervisor--parse-entry '("cmd" :id "svc")))
         (info (supervisor--cli-entry-info entry))
         (output (supervisor--cli-describe-human info)))
    (should-not (string-match-p "Description:" output))))

(ert-deftest supervisor-test-cli-json-description ()
  "JSON output includes description."
  (let* ((entry (supervisor--parse-entry
                 '("cmd" :id "svc" :description "My service")))
         (info (supervisor--cli-entry-info entry))
         (json (supervisor--cli-entry-to-json-obj info)))
    (should (equal (alist-get 'description json) "My service"))))

(ert-deftest supervisor-test-cli-json-documentation ()
  "JSON output includes documentation array."
  (let* ((entry (supervisor--parse-entry
                 '("cmd" :id "svc" :documentation ("man:foo(1)"))))
         (info (supervisor--cli-entry-info entry))
         (json (supervisor--cli-entry-to-json-obj info)))
    (should (equal (alist-get 'documentation json) '("man:foo(1)")))))

(ert-deftest supervisor-test-cli-json-documentation-empty ()
  "JSON output uses empty array when no documentation."
  (let* ((entry (supervisor--parse-entry '("cmd" :id "svc")))
         (info (supervisor--cli-entry-info entry))
         (json (supervisor--cli-entry-to-json-obj info)))
    (should (equal (alist-get 'documentation json) []))))

;; CLI dispatcher integration tests for metadata

(ert-deftest supervisor-test-cli-show-includes-description ()
  "The `show ID' output includes Description when set."
  (supervisor-test-with-unit-files
      '(("cmd" :id "svc" :description "My test service"))
    (let* ((supervisor--processes (make-hash-table :test 'equal))
           (supervisor--entry-state (make-hash-table :test 'equal))
           (result (supervisor--cli-dispatch '("show" "svc"))))
      (should (= supervisor-cli-exit-success (supervisor-cli-result-exitcode result)))
      (should (string-match-p "Description: My test service"
                              (supervisor-cli-result-output result))))))

(ert-deftest supervisor-test-cli-show-includes-documentation ()
  "The `show ID' output includes Documentation when set."
  (supervisor-test-with-unit-files
      '(("cmd" :id "svc" :documentation ("man:svc(1)" "https://example.com")))
    (let* ((supervisor--processes (make-hash-table :test 'equal))
           (supervisor--entry-state (make-hash-table :test 'equal))
           (result (supervisor--cli-dispatch '("show" "svc"))))
      (should (= supervisor-cli-exit-success (supervisor-cli-result-exitcode result)))
      (should (string-match-p "Documentation: man:svc(1), https://example.com"
                              (supervisor-cli-result-output result))))))

(ert-deftest supervisor-test-cli-show-omits-description-when-nil ()
  "The `show ID' output omits Description line when not set."
  (supervisor-test-with-unit-files
      '(("cmd" :id "svc"))
    (let* ((supervisor--processes (make-hash-table :test 'equal))
           (supervisor--entry-state (make-hash-table :test 'equal))
           (result (supervisor--cli-dispatch '("show" "svc"))))
      (should (= supervisor-cli-exit-success (supervisor-cli-result-exitcode result)))
      (should-not (string-match-p "Description:"
                                  (supervisor-cli-result-output result))))))

(ert-deftest supervisor-test-cli-show-json-includes-metadata ()
  "The `show --json ID' includes description and documentation."
  (supervisor-test-with-unit-files
      '(("cmd" :id "svc" :description "Test"
         :documentation ("man:svc(1)")))
    (let* ((supervisor--processes (make-hash-table :test 'equal))
           (supervisor--entry-state (make-hash-table :test 'equal))
           (result (supervisor--cli-dispatch '("show" "svc" "--json"))))
      (should (= supervisor-cli-exit-success (supervisor-cli-result-exitcode result)))
      (let ((parsed (json-read-from-string (supervisor-cli-result-output result))))
        (should (equal "Test" (alist-get 'description parsed)))
        (should (equal ["man:svc(1)"] (alist-get 'documentation parsed)))))))

(ert-deftest supervisor-test-cli-status-id-includes-description ()
  "The `status ID' detail view includes Description."
  (supervisor-test-with-unit-files
      '(("cmd" :id "svc" :description "Status desc test"
         :documentation ("man:svc(1)" "https://example.com")))
    (let* ((supervisor--processes (make-hash-table :test 'equal))
           (supervisor--entry-state (make-hash-table :test 'equal))
           (result (supervisor--cli-dispatch '("status" "svc"))))
      (should (= supervisor-cli-exit-success (supervisor-cli-result-exitcode result)))
      (should (string-match-p "Description: Status desc test"
                              (supervisor-cli-result-output result)))
      (should (string-match-p "Documentation: man:svc(1), https://example.com"
                              (supervisor-cli-result-output result))))))

(ert-deftest supervisor-test-cli-status-id-json-includes-metadata ()
  "The `status ID --json' includes description and documentation."
  (supervisor-test-with-unit-files
      '(("cmd" :id "svc" :description "JSON meta"
         :documentation ("man:svc(1)")))
    (let* ((supervisor--processes (make-hash-table :test 'equal))
           (supervisor--entry-state (make-hash-table :test 'equal))
           (result (supervisor--cli-dispatch '("status" "svc" "--json"))))
      (should (= supervisor-cli-exit-success (supervisor-cli-result-exitcode result)))
      (let* ((parsed (json-read-from-string (supervisor-cli-result-output result)))
             (entry (aref (alist-get 'entries parsed) 0)))
        (should (equal "JSON meta" (alist-get 'description entry)))
        (should (equal ["man:svc(1)"] (alist-get 'documentation entry)))))))

;; Dashboard describe-entry integration test

(ert-deftest supervisor-test-dashboard-describe-shows-metadata ()
  "Dashboard describe-entry includes description and docs in detail view."
  (let* ((entry (supervisor--parse-entry
                 '("cmd" :id "svc" :description "Dashboard desc"
                   :documentation ("man:svc(1)"))))
         (supervisor--processes (make-hash-table :test 'equal))
         (supervisor--failed (make-hash-table :test 'equal))
         (supervisor--restart-override (make-hash-table :test 'equal))
         (supervisor--enabled-override (make-hash-table :test 'equal))
         (supervisor--mask-override (make-hash-table :test 'equal))
         (supervisor--entry-state (make-hash-table :test 'equal))
         (supervisor--invalid (make-hash-table :test 'equal))
         (supervisor--manually-stopped (make-hash-table :test 'equal))
         (supervisor--manually-started (make-hash-table :test 'equal))
         (supervisor--oneshot-completed (make-hash-table :test 'equal))
         (supervisor--remain-active (make-hash-table :test 'equal))
         (supervisor--last-exit-info (make-hash-table :test 'equal))
         (supervisor--start-times (make-hash-table :test 'equal))
         (supervisor--ready-times (make-hash-table :test 'equal))
         (supervisor--restart-times (make-hash-table :test 'equal))
         (supervisor--restart-timers (make-hash-table :test 'equal))
         (supervisor--logging (make-hash-table :test 'equal))
         (supervisor--logging-override (make-hash-table :test 'equal))
         (output nil))
    ;; describe-entry-detail uses with-help-window; read the buffer
    (cl-letf (((symbol-function 'supervisor--unit-file-path)
               (lambda (_id) nil))
              ((symbol-function 'supervisor--telemetry-log-tail)
               (lambda (_id &optional _lines) nil)))
      (supervisor--describe-entry-detail "svc" entry)
      (let ((info-buf (get-buffer "*supervisor-info*")))
        (unwind-protect
            (progn
              (should info-buf)
              (setq output (with-current-buffer info-buf
                             (buffer-string)))
              (should (string-match-p "Dashboard desc" output))
              (should (string-match-p "man:svc(1)" output)))
          (when info-buf (kill-buffer info-buf)))))))

;;;; Phase N3: Ordering and Soft Dependencies Tests

;; :before inversion parity with :after

(ert-deftest supervisor-test-before-inversion-basic ()
  "A :before B produces same ordering as B :after A."
  (let* ((supervisor--authority-snapshot nil)
         ;; A should start before B
         (programs-before '(("cmd-a" :id "a" :before ("b"))
                            ("cmd-b" :id "b")))
         (programs-after '(("cmd-a" :id "a")
                           ("cmd-b" :id "b" :after ("a"))))
         (plan-before (supervisor--build-plan programs-before))
         (plan-after (supervisor--build-plan programs-after))
         (ids-before (mapcar #'supervisor-entry-id
                             (supervisor-plan-entries plan-before)))
         (ids-after (mapcar #'supervisor-entry-id
                            (supervisor-plan-entries plan-after))))
    (should (equal ids-before ids-after))))

(ert-deftest supervisor-test-before-inversion-multiple ()
  "A :before (B C) creates edges for both."
  (let* ((supervisor--authority-snapshot nil)
         (programs '(("cmd-a" :id "a" :before ("b" "c"))
                     ("cmd-b" :id "b")
                     ("cmd-c" :id "c")))
         (plan (supervisor--build-plan programs))
         (sorted (supervisor-plan-by-target plan))
         (ids (mapcar #'supervisor-entry-id sorted)))
    ;; a must come before b and c
    (should (< (cl-position "a" ids :test #'equal)
               (cl-position "b" ids :test #'equal)))
    (should (< (cl-position "a" ids :test #'equal)
               (cl-position "c" ids :test #'equal)))))

(ert-deftest supervisor-test-before-ordering ()
  "The :before directive creates ordering edge."
  (let* ((supervisor--authority-snapshot nil)
         (programs '(("cmd-a" :id "a" :before ("b"))
                     ("cmd-b" :id "b")))
         (plan (supervisor--build-plan programs))
         (sorted (supervisor-plan-by-target plan))
         (ids (mapcar #'supervisor-entry-id sorted)))
    ;; a :before b  a comes before b
    (should (< (cl-position "a" ids :test #'equal)
               (cl-position "b" ids :test #'equal)))))

(ert-deftest supervisor-test-before-missing-target-ignored ()
  "Missing :before target is warned and ignored."
  (let* ((supervisor--authority-snapshot nil)
         (logged nil)
         (programs '(("cmd-a" :id "a" :before ("nonexistent")))))
    (cl-letf (((symbol-function 'supervisor--log)
               (lambda (_level fmt &rest args)
                 (push (apply #'format fmt args) logged))))
      (supervisor--build-plan programs)
      ;; Should have logged a warning about nonexistent
      (should (cl-some (lambda (msg)
                         (string-match-p ":before.*does not exist" msg))
                       logged)))))

(ert-deftest supervisor-test-before-combined-with-after ()
  "Both :before and :after edges combine correctly."
  (let* ((supervisor--authority-snapshot nil)
         ;; a :before c, b :after a  order: a, b, c
         (programs '(("cmd-a" :id "a" :before ("c"))
                     ("cmd-b" :id "b" :after ("a"))
                     ("cmd-c" :id "c")))
         (plan (supervisor--build-plan programs))
         (sorted (supervisor-plan-by-target plan))
         (ids (mapcar #'supervisor-entry-id sorted)))
    (should (< (cl-position "a" ids :test #'equal)
               (cl-position "b" ids :test #'equal)))
    (should (< (cl-position "a" ids :test #'equal)
               (cl-position "c" ids :test #'equal)))))

;; :before and :after cycle behavior

(ert-deftest supervisor-test-before-after-cycle-fallback ()
  "Cycle involving :before falls back correctly."
  (let* ((supervisor--authority-snapshot nil)
         ;; a :before b, b :before a  cycle
         (programs '(("cmd-a" :id "a" :before ("b"))
                     ("cmd-b" :id "b" :before ("a"))))
         (plan (supervisor--build-plan programs)))
    ;; Both should be in cycle-fallback
    (should (gethash "a" (supervisor-plan-cycle-fallback-ids plan)))
    (should (gethash "b" (supervisor-plan-cycle-fallback-ids plan)))))

;; :wants soft dependency tests

(ert-deftest supervisor-test-wants-ordering ()
  "Wants creates ordering preference when target exists."
  (let* ((supervisor--authority-snapshot nil)
         (programs '(("cmd-a" :id "a")
                     ("cmd-b" :id "b" :wants ("a"))))
         (plan (supervisor--build-plan programs))
         (sorted (supervisor-plan-by-target plan))
         (ids (mapcar #'supervisor-entry-id sorted)))
    ;; a should come before b
    (should (< (cl-position "a" ids :test #'equal)
               (cl-position "b" ids :test #'equal)))))

(ert-deftest supervisor-test-wants-missing-silently-dropped ()
  "Missing :wants target is silently dropped (no warning)."
  (let* ((supervisor--authority-snapshot nil)
         (logged nil)
         (programs '(("cmd-a" :id "a" :wants ("nonexistent")))))
    (cl-letf (((symbol-function 'supervisor--log)
               (lambda (_level fmt &rest args)
                 (push (apply #'format fmt args) logged))))
      (let ((plan (supervisor--build-plan programs)))
        ;; Entry should still be valid
        (should (= 1 (length (supervisor-plan-entries plan))))
        ;; No warning about the missing wanted unit
        (should-not (cl-some (lambda (msg)
                               (string-match-p "nonexistent" msg))
                             logged))))))

(ert-deftest supervisor-test-wants-ordering-position ()
  "The :wants directive creates ordering edge."
  (let* ((supervisor--authority-snapshot nil)
         (programs '(("cmd-a" :id "a")
                     ("cmd-b" :id "b" :wants ("a"))))
         (plan (supervisor--build-plan programs))
         (sorted (supervisor-plan-by-target plan))
         (ids (mapcar #'supervisor-entry-id sorted)))
    ;; a should come before b
    (should (< (cl-position "a" ids :test #'equal)
               (cl-position "b" ids :test #'equal)))))

(ert-deftest supervisor-test-wants-disabled-not-blocking ()
  "Disabled :wants target does not block the wanting unit."
  (let* ((supervisor--authority-snapshot nil)
         (programs '(("cmd-a" :id "a" :disabled t)
                     ("cmd-b" :id "b" :wants ("a"))))
         (plan (supervisor--build-plan programs))
         (sorted (supervisor-plan-by-target plan)))
    ;; Both entries should be in the plan
    (should (= 2 (length sorted)))))

(ert-deftest supervisor-test-wants-participates-in-cycle-detection ()
  "Wants edges participate in cycle detection."
  (let* ((supervisor--authority-snapshot nil)
         ;; a :wants b, b :wants a  cycle
         (programs '(("cmd-a" :id "a" :wants ("b"))
                     ("cmd-b" :id "b" :wants ("a"))))
         (plan (supervisor--build-plan programs)))
    ;; Both should be in cycle-fallback
    (should (gethash "a" (supervisor-plan-cycle-fallback-ids plan)))
    (should (gethash "b" (supervisor-plan-cycle-fallback-ids plan)))))

(ert-deftest supervisor-test-wants-combined-with-after ()
  "Wants and after edges combine for ordering."
  (let* ((supervisor--authority-snapshot nil)
         ;; c wants a, c :after b  order: a before c, b before c
         (programs '(("cmd-a" :id "a")
                     ("cmd-b" :id "b")
                     ("cmd-c" :id "c" :wants ("a") :after ("b"))))
         (plan (supervisor--build-plan programs))
         (sorted (supervisor-plan-by-target plan))
         (ids (mapcar #'supervisor-entry-id sorted)))
    (should (< (cl-position "a" ids :test #'equal)
               (cl-position "c" ids :test #'equal)))
    (should (< (cl-position "b" ids :test #'equal)
               (cl-position "c" ids :test #'equal)))))

;; DAG init with :wants

(ert-deftest supervisor-test-dag-init-includes-wants ()
  "DAG init includes valid wants in dependency graph."
  (let* ((entries (list (supervisor--parse-entry '("cmd-a" :id "a"))
                        (supervisor--parse-entry '("cmd-b" :id "b" :wants ("a")))))
         (supervisor--entry-state (make-hash-table :test 'equal)))
    (supervisor--dag-init entries)
    ;; b should depend on a (in-degree 1)
    (should (= 1 (gethash "b" supervisor--dag-in-degree)))
    ;; a should have b as dependent
    (should (member "b" (gethash "a" supervisor--dag-dependents)))))

(ert-deftest supervisor-test-dag-init-missing-wants-ignored ()
  "DAG init ignores wants for entries not in the stage."
  (let* ((entries (list (supervisor--parse-entry
                         '("cmd-b" :id "b" :wants ("nonexistent")))))
         (supervisor--entry-state (make-hash-table :test 'equal)))
    (supervisor--dag-init entries)
    ;; b should have in-degree 0 (missing wants ignored)
    (should (= 0 (gethash "b" supervisor--dag-in-degree)))))

(ert-deftest supervisor-test-dag-init-masked-wants-ignored ()
  "DAG init ignores wants for masked entries."
  (let* ((entries (list (supervisor--parse-entry '("cmd-a" :id "a"))
                        (supervisor--parse-entry '("cmd-b" :id "b" :wants ("a")))))
         (supervisor--entry-state (make-hash-table :test 'equal))
         (supervisor--mask-override (make-hash-table :test 'equal)))
    ;; Mask entry a
    (puthash "a" 'masked supervisor--mask-override)
    (supervisor--dag-init entries)
    ;; b should have in-degree 0 (masked wants ignored)
    (should (= 0 (gethash "b" supervisor--dag-in-degree)))))

(ert-deftest supervisor-test-wants-cycle-fallback-clears-wants ()
  "Cycle fallback clears :wants edges so runtime DAG has zero in-degree."
  (let* ((supervisor--authority-snapshot nil)
         (programs '(("cmd-a" :id "a" :wants ("b"))
                     ("cmd-b" :id "b" :wants ("a"))))
         (plan (supervisor--build-plan programs))
         (sorted (supervisor-plan-by-target plan)))
    ;; Cycle fallback should have cleared :wants
    (dolist (entry sorted)
      (should (null (supervisor-entry-wants entry))))
    ;; DAG init should produce zero in-degree for both
    (let ((supervisor--entry-state (make-hash-table :test 'equal))
          (supervisor--mask-override (make-hash-table :test 'equal)))
      (supervisor--dag-init sorted)
      (should (= 0 (gethash "a" supervisor--dag-in-degree)))
      (should (= 0 (gethash "b" supervisor--dag-in-degree))))))

(ert-deftest supervisor-test-stable-topo-cycle-clears-wants ()
  "Stable topo sort cycle fallback clears :wants."
  (let ((supervisor--computed-deps (make-hash-table :test 'equal))
        (supervisor--cycle-fallback-ids (make-hash-table :test 'equal)))
    ;; 27-element entries with :wants cycle
    (let* ((entries (list (list "a" "cmd" 0 t 'always t 'simple 'stage3 nil
                                t 30 nil nil nil nil nil nil nil nil
                                nil nil nil '("b") nil nil nil nil)
                          (list "b" "cmd" 0 t 'always t 'simple 'stage3 nil
                                t 30 nil nil nil nil nil nil nil nil
                                nil nil nil '("a") nil nil nil nil)))
           (sorted (supervisor--stable-topo-sort entries)))
      ;; :wants should be cleared
      (dolist (entry sorted)
        (should (null (supervisor-entry-wants entry)))))))

(ert-deftest supervisor-test-wants-failed-spawn-not-blocking ()
  "A wanted unit that fails to start does not block the wanting unit.
Spawn failure calls `supervisor--dag-mark-ready', which decrements
in-degree of dependents including :wants edges."
  (let* ((entries (list (supervisor--parse-entry '("cmd-a" :id "a"))
                        (supervisor--parse-entry '("cmd-b" :id "b" :wants ("a")))))
         (supervisor--entry-state (make-hash-table :test 'equal))
         (supervisor--mask-override (make-hash-table :test 'equal))
         (supervisor--dag-active-starts 0)
         (supervisor--dag-pending-starts nil)
         (supervisor--dag-stage-callback nil))
    (supervisor--dag-init entries)
    ;; b depends on a (in-degree 1)
    (should (= 1 (gethash "b" supervisor--dag-in-degree)))
    ;; Simulate a failing to start
    (supervisor--dag-handle-spawn-failure "a")
    ;; b should now be unblocked (in-degree 0)
    (should (= 0 (gethash "b" supervisor--dag-in-degree)))))

;;;; Phase N4: Kill Controls

(ert-deftest supervisor-test-kill-signal-for-id-default ()
  "Return SIGTERM when unit has no :kill-signal configured."
  (let* ((supervisor--programs-cache
          (list (list "sleep 300" :id "svc1")))
         (supervisor--invalid (make-hash-table :test 'equal)))
    (should (eq 'SIGTERM (supervisor--kill-signal-for-id "svc1")))))

(ert-deftest supervisor-test-kill-signal-for-id-configured ()
  "Return configured :kill-signal for unit."
  (let* ((supervisor--programs-cache
          (list (list "sleep 300" :id "svc1" :kill-signal "SIGINT")))
         (supervisor--invalid (make-hash-table :test 'equal)))
    (should (eq 'SIGINT (supervisor--kill-signal-for-id "svc1")))))

(ert-deftest supervisor-test-kill-signal-for-id-unknown ()
  "Return SIGTERM for unknown unit ID."
  (let* ((supervisor--programs-cache nil)
         (supervisor--invalid (make-hash-table :test 'equal)))
    (should (eq 'SIGTERM (supervisor--kill-signal-for-id "nonexistent")))))

(ert-deftest supervisor-test-kill-mode-for-id-default ()
  "Return `process' when unit has no :kill-mode configured."
  (let* ((supervisor--programs-cache
          (list (list "sleep 300" :id "svc1")))
         (supervisor--invalid (make-hash-table :test 'equal)))
    (should (eq 'process (supervisor--kill-mode-for-id "svc1")))))

(ert-deftest supervisor-test-kill-mode-for-id-mixed ()
  "Return `mixed' when unit has :kill-mode mixed."
  (let* ((supervisor--programs-cache
          (list (list "sleep 300" :id "svc1" :kill-mode 'mixed)))
         (supervisor--invalid (make-hash-table :test 'equal)))
    (should (eq 'mixed (supervisor--kill-mode-for-id "svc1")))))

(ert-deftest supervisor-test-kill-mode-for-id-unknown ()
  "Return `process' for unknown unit ID."
  (let* ((supervisor--programs-cache nil)
         (supervisor--invalid (make-hash-table :test 'equal)))
    (should (eq 'process (supervisor--kill-mode-for-id "nonexistent")))))

(ert-deftest supervisor-test-process-descendants-returns-children ()
  "Descendant discovery finds child PIDs via process-attributes."
  (cl-letf (((symbol-function 'list-system-processes)
             (lambda () '(1 10 20 30 40)))
            ((symbol-function 'process-attributes)
             (lambda (pid)
               (pcase pid
                 (10 '((ppid . 1)))
                 (20 '((ppid . 10)))
                 (30 '((ppid . 10)))
                 (40 '((ppid . 99)))
                 (_ nil)))))
    (let ((desc (supervisor--process-descendants 10)))
      (should (member 20 desc))
      (should (member 30 desc))
      (should-not (member 40 desc))
      (should-not (member 1 desc)))))

(ert-deftest supervisor-test-process-descendants-transitive ()
  "Descendant discovery finds grandchildren transitively."
  (cl-letf (((symbol-function 'list-system-processes)
             (lambda () '(1 10 20 30)))
            ((symbol-function 'process-attributes)
             (lambda (pid)
               (pcase pid
                 (10 '((ppid . 1)))
                 (20 '((ppid . 10)))
                 (30 '((ppid . 20)))
                 (_ nil)))))
    (let ((desc (supervisor--process-descendants 10)))
      (should (member 20 desc))
      (should (member 30 desc)))))

(ert-deftest supervisor-test-process-descendants-fallback-on-error ()
  "Descendant discovery returns nil and logs warning on error."
  (let ((warnings nil))
    (cl-letf (((symbol-function 'list-system-processes)
               (lambda () (error "Not supported")))
              ((symbol-function 'supervisor--log)
               (lambda (level fmt &rest args)
                 (when (eq level 'warning)
                   (push (apply #'format fmt args) warnings)))))
      (should-not (supervisor--process-descendants 1234))
      (should (= 1 (length warnings)))
      (should (string-match-p "descendant discovery failed" (car warnings))))))

(ert-deftest supervisor-test-kill-with-descendants-main-only ()
  "Kill with descendants sends SIGKILL to main process only.
No warning is emitted when there are simply no child processes."
  (let* ((killed-signals nil)
         (warnings nil)
         (proc (start-process "test-kill" nil "sleep" "300")))
    (unwind-protect
        (cl-letf (((symbol-function 'supervisor--process-descendants)
                   (lambda (_pid) nil))
                  ((symbol-function 'signal-process)
                   (lambda (p sig)
                     (push (list p sig) killed-signals)))
                  ((symbol-function 'supervisor--log)
                   (lambda (level _fmt &rest _args)
                     (when (eq level 'warning)
                       (push t warnings)))))
          (supervisor--kill-with-descendants proc)
          (should (= 1 (length killed-signals)))
          (should (eq 'SIGKILL (cadr (car killed-signals))))
          ;; No warning for normal "no children" case
          (should (= 0 (length warnings))))
      (when (process-live-p proc)
        (delete-process proc)))))

(ert-deftest supervisor-test-kill-with-descendants-mixed ()
  "Kill with descendants sends SIGKILL to main and descendant PIDs."
  (let* ((killed nil)
         (proc (start-process "test-kill-mixed" nil "sleep" "300")))
    (unwind-protect
        (cl-letf (((symbol-function 'supervisor--process-descendants)
                   (lambda (_pid) '(9991 9992)))
                  ((symbol-function 'signal-process)
                   (lambda (p sig)
                     (push (list p sig) killed)))
                  ((symbol-function 'supervisor--log)
                   (lambda (&rest _args))))
          (supervisor--kill-with-descendants proc)
          ;; Main process + 2 descendants = 3 SIGKILL signals
          (should (= 3 (length killed)))
          (should (cl-every (lambda (entry) (eq 'SIGKILL (cadr entry)))
                            killed)))
      (when (process-live-p proc)
        (delete-process proc)))))

(ert-deftest supervisor-test-manual-stop-uses-kill-signal ()
  "Manual stop sends configured :kill-signal instead of default."
  (let* ((supervisor--processes (make-hash-table :test 'equal))
         (supervisor--manually-stopped (make-hash-table :test 'equal))
         (supervisor--manually-started (make-hash-table :test 'equal))
         (signaled-with nil)
         (proc (start-process "test-stop-sig" nil "sleep" "300")))
    (unwind-protect
        (progn
          (puthash "svc1" proc supervisor--processes)
          (cl-letf (((symbol-function 'supervisor--run-exec-stop-for-id)
                     (lambda (_id)))
                    ((symbol-function 'supervisor--kill-signal-for-id)
                     (lambda (_id) 'SIGUSR1))
                    ((symbol-function 'supervisor--kill-mode-for-id)
                     (lambda (_id) 'process))
                    ((symbol-function 'signal-process)
                     (lambda (_p sig)
                       (push sig signaled-with)))
                    ((symbol-function 'run-at-time)
                     (lambda (&rest _args))))
            (let ((result (supervisor--manual-stop "svc1")))
              (should (eq 'stopped (plist-get result :status)))
              ;; Should have sent SIGUSR1, not SIGTERM
              (should (memq 'SIGUSR1 signaled-with))
              (should-not (memq 'SIGTERM signaled-with)))))
      (when (process-live-p proc)
        (delete-process proc)))))

(ert-deftest supervisor-test-manual-stop-escalation-timer ()
  "Manual stop sets up SIGKILL escalation timer."
  (let* ((supervisor--processes (make-hash-table :test 'equal))
         (supervisor--manually-stopped (make-hash-table :test 'equal))
         (supervisor--manually-started (make-hash-table :test 'equal))
         (timer-set nil)
         (proc (start-process "test-esc" nil "sleep" "300")))
    (unwind-protect
        (progn
          (puthash "svc1" proc supervisor--processes)
          (cl-letf (((symbol-function 'supervisor--run-exec-stop-for-id)
                     (lambda (_id)))
                    ((symbol-function 'supervisor--kill-signal-for-id)
                     (lambda (_id) 'SIGTERM))
                    ((symbol-function 'supervisor--kill-mode-for-id)
                     (lambda (_id) 'process))
                    ((symbol-function 'signal-process)
                     (lambda (_p _sig)))
                    ((symbol-function 'run-at-time)
                     (lambda (timeout _repeat fn)
                       (setq timer-set
                             (list :timeout timeout :fn fn)))))
            (supervisor--manual-stop "svc1")
            ;; Escalation timer should be set
            (should timer-set)
            (should (= supervisor-shutdown-timeout
                       (plist-get timer-set :timeout)))))
      (when (process-live-p proc)
        (delete-process proc)))))

(ert-deftest supervisor-test-manual-stop-mixed-escalation ()
  "Manual stop with :kill-mode mixed uses kill-with-descendants on escalation."
  (let* ((supervisor--processes (make-hash-table :test 'equal))
         (supervisor--manually-stopped (make-hash-table :test 'equal))
         (supervisor--manually-started (make-hash-table :test 'equal))
         (escalation-fn nil)
         (kill-descendants-called nil)
         (proc (start-process "test-mixed" nil "sleep" "300")))
    (unwind-protect
        (progn
          (puthash "svc1" proc supervisor--processes)
          (cl-letf (((symbol-function 'supervisor--run-exec-stop-for-id)
                     (lambda (_id)))
                    ((symbol-function 'supervisor--kill-signal-for-id)
                     (lambda (_id) 'SIGTERM))
                    ((symbol-function 'supervisor--kill-mode-for-id)
                     (lambda (_id) 'mixed))
                    ((symbol-function 'signal-process)
                     (lambda (_p _sig)))
                    ((symbol-function 'run-at-time)
                     (lambda (_timeout _repeat fn)
                       (setq escalation-fn fn))))
            (supervisor--manual-stop "svc1")
            ;; Fire the escalation timer while process is still live
            (cl-letf (((symbol-function 'supervisor--kill-with-descendants)
                       (lambda (_proc)
                         (setq kill-descendants-called t))))
              (funcall escalation-fn)
              (should kill-descendants-called))))
      (when (process-live-p proc)
        (delete-process proc)))))

(ert-deftest supervisor-test-manual-kill-defaults-to-unit-signal ()
  "Manual kill without explicit signal uses unit's :kill-signal."
  (let* ((supervisor--processes (make-hash-table :test 'equal))
         (signaled-with nil)
         (proc (start-process "test-kill-def" nil "sleep" "300")))
    (unwind-protect
        (progn
          (puthash "svc1" proc supervisor--processes)
          (cl-letf (((symbol-function 'supervisor--kill-signal-for-id)
                     (lambda (_id) 'SIGINT))
                    ((symbol-function 'signal-process)
                     (lambda (_p sig)
                       (setq signaled-with sig))))
            (supervisor--manual-kill "svc1")
            (should (eq 'SIGINT signaled-with))))
      (when (process-live-p proc)
        (delete-process proc)))))

(ert-deftest supervisor-test-manual-kill-explicit-signal-overrides ()
  "Manual kill with explicit signal overrides unit's :kill-signal."
  (let* ((supervisor--processes (make-hash-table :test 'equal))
         (signaled-with nil)
         (proc (start-process "test-kill-exp" nil "sleep" "300")))
    (unwind-protect
        (progn
          (puthash "svc1" proc supervisor--processes)
          (cl-letf (((symbol-function 'supervisor--kill-signal-for-id)
                     (lambda (_id) 'SIGINT))
                    ((symbol-function 'signal-process)
                     (lambda (_p sig)
                       (setq signaled-with sig))))
            (supervisor--manual-kill "svc1" 'SIGUSR2)
            (should (eq 'SIGUSR2 signaled-with))))
      (when (process-live-p proc)
        (delete-process proc)))))

(ert-deftest supervisor-test-shutdown-uses-per-unit-kill-signal ()
  "Shutdown sends per-unit :kill-signal instead of blanket SIGTERM."
  (let* ((supervisor--processes (make-hash-table :test 'equal))
         (supervisor--timers nil)
         (supervisor--restart-timers (make-hash-table :test 'equal))
         (supervisor--shutting-down nil)
         (supervisor--shutdown-complete-flag nil)
         (supervisor--shutdown-remaining 0)
         (supervisor--shutdown-callback nil)
         (supervisor--shutdown-timer nil)
         (signals-sent nil)
         (proc1 (start-process "svc1" nil "sleep" "300"))
         (proc2 (start-process "svc2" nil "sleep" "300")))
    (unwind-protect
        (progn
          (puthash "svc1" proc1 supervisor--processes)
          (puthash "svc2" proc2 supervisor--processes)
          (cl-letf (((symbol-function 'supervisor--run-exec-stop-for-id)
                     (lambda (_id)))
                    ((symbol-function 'supervisor--dag-cleanup)
                     (lambda ()))
                    ((symbol-function 'supervisor--emit-event)
                     (lambda (&rest _args)))
                    ((symbol-function 'supervisor--kill-signal-for-id)
                     (lambda (id)
                       (if (string= id "svc1") 'SIGUSR1 'SIGINT)))
                    ((symbol-function 'signal-process)
                     (lambda (p sig)
                       (push (list (process-name p) sig) signals-sent)))
                    ((symbol-function 'run-at-time)
                     (lambda (&rest _args))))
            (supervisor-stop)
            ;; Each unit should get its own kill-signal
            (should (cl-find-if (lambda (e)
                                  (and (string= "svc1" (car e))
                                       (eq 'SIGUSR1 (cadr e))))
                                signals-sent))
            (should (cl-find-if (lambda (e)
                                  (and (string= "svc2" (car e))
                                       (eq 'SIGINT (cadr e))))
                                signals-sent))))
      (when (process-live-p proc1) (delete-process proc1))
      (when (process-live-p proc2) (delete-process proc2)))))

(ert-deftest supervisor-test-shutdown-escalation-respects-kill-mode ()
  "Shutdown SIGKILL escalation uses kill-with-descendants for mixed mode."
  (let* ((supervisor--processes (make-hash-table :test 'equal))
         (supervisor--timers nil)
         (supervisor--restart-timers (make-hash-table :test 'equal))
         (supervisor--shutting-down nil)
         (supervisor--shutdown-complete-flag nil)
         (supervisor--shutdown-remaining 0)
         (supervisor--shutdown-callback nil)
         (supervisor--shutdown-timer nil)
         (escalation-fn nil)
         (kill-desc-called nil)
         (plain-kill-called nil)
         (proc1 (start-process "mixed-svc" nil "sleep" "300"))
         (proc2 (start-process "normal-svc" nil "sleep" "300")))
    (unwind-protect
        (progn
          (puthash "mixed-svc" proc1 supervisor--processes)
          (puthash "normal-svc" proc2 supervisor--processes)
          (cl-letf (((symbol-function 'supervisor--run-exec-stop-for-id)
                     (lambda (_id)))
                    ((symbol-function 'supervisor--dag-cleanup)
                     (lambda ()))
                    ((symbol-function 'supervisor--emit-event)
                     (lambda (&rest _args)))
                    ((symbol-function 'supervisor--kill-signal-for-id)
                     (lambda (_id) 'SIGTERM))
                    ((symbol-function 'supervisor--kill-mode-for-id)
                     (lambda (id)
                       (if (string= id "mixed-svc") 'mixed 'process)))
                    ((symbol-function 'signal-process)
                     (lambda (_p _sig)))
                    ((symbol-function 'run-at-time)
                     (lambda (_timeout _repeat fn)
                       (setq escalation-fn fn))))
            (supervisor-stop)
            ;; Fire the escalation timer
            (cl-letf (((symbol-function 'supervisor--kill-with-descendants)
                       (lambda (_proc)
                         (setq kill-desc-called t)))
                      ((symbol-function 'signal-process)
                       (lambda (_p sig)
                         (when (eq sig 'SIGKILL)
                           (setq plain-kill-called t)))))
              (funcall escalation-fn)
              ;; mixed-svc should use kill-with-descendants
              (should kill-desc-called)
              ;; normal-svc should use plain SIGKILL
              (should plain-kill-called))))
      (when (process-live-p proc1) (delete-process proc1))
      (when (process-live-p proc2) (delete-process proc2)))))

(ert-deftest supervisor-test-kill-signal-real-process ()
  "Kill-signal SIGTERM terminates a real process."
  (let* ((proc (start-process "test-real-kill" nil "sleep" "300")))
    (unwind-protect
        (progn
          (should (process-live-p proc))
          (signal-process proc 'SIGTERM)
          ;; Wait briefly for process to die
          (let ((deadline (+ (float-time) 1.0)))
            (while (and (< (float-time) deadline)
                        (process-live-p proc))
              (sleep-for 0.05)))
          (should-not (process-live-p proc)))
      (when (process-live-p proc)
        (delete-process proc)))))

(ert-deftest supervisor-test-manual-stop-not-running-skipped ()
  "Manual stop on non-running process returns skipped."
  (let* ((supervisor--processes (make-hash-table :test 'equal))
         (supervisor--manually-stopped (make-hash-table :test 'equal))
         (supervisor--manually-started (make-hash-table :test 'equal)))
    (let ((result (supervisor--manual-stop "nonexistent")))
      (should (eq 'skipped (plist-get result :status))))))

;;;; Phase N5: Oneshot Active-Latch (remain-after-exit)

(ert-deftest supervisor-test-remain-after-exit-success-active ()
  "Oneshot with :remain-after-exit t shows `active' status on success."
  (let ((supervisor--oneshot-completed (make-hash-table :test 'equal))
        (supervisor--remain-active (make-hash-table :test 'equal))
        (supervisor--processes (make-hash-table :test 'equal))
        (supervisor--failed (make-hash-table :test 'equal))
        (supervisor--mask-override (make-hash-table :test 'equal)))
    ;; Simulate successful oneshot exit with remain-after-exit latch
    (puthash "svc1" 0 supervisor--oneshot-completed)
    (puthash "svc1" t supervisor--remain-active)
    (let ((result (supervisor--compute-entry-status "svc1" 'oneshot)))
      (should (string= "active" (car result)))
      (should (string= "exit:0" (cdr result))))))

(ert-deftest supervisor-test-remain-after-exit-failure-not-active ()
  "Oneshot with :remain-after-exit t shows `failed' on non-zero exit."
  (let ((supervisor--oneshot-completed (make-hash-table :test 'equal))
        (supervisor--remain-active (make-hash-table :test 'equal))
        (supervisor--processes (make-hash-table :test 'equal))
        (supervisor--failed (make-hash-table :test 'equal))
        (supervisor--mask-override (make-hash-table :test 'equal)))
    ;; Failure: remain-active should NOT be set
    (puthash "svc1" 1 supervisor--oneshot-completed)
    (let ((result (supervisor--compute-entry-status "svc1" 'oneshot)))
      (should (string= "failed" (car result))))))

(ert-deftest supervisor-test-remain-after-exit-regular-oneshot-done ()
  "Regular oneshot without remain-after-exit still shows `done'."
  (let ((supervisor--oneshot-completed (make-hash-table :test 'equal))
        (supervisor--remain-active (make-hash-table :test 'equal))
        (supervisor--processes (make-hash-table :test 'equal))
        (supervisor--failed (make-hash-table :test 'equal))
        (supervisor--mask-override (make-hash-table :test 'equal)))
    (puthash "svc1" 0 supervisor--oneshot-completed)
    ;; No remain-active entry
    (let ((result (supervisor--compute-entry-status "svc1" 'oneshot)))
      (should (string= "done" (car result))))))

(ert-deftest supervisor-test-remain-after-exit-handle-oneshot-exit ()
  "Handle-oneshot-exit sets remain-active on successful exit."
  (let ((supervisor--oneshot-completed (make-hash-table :test 'equal))
        (supervisor--remain-active (make-hash-table :test 'equal))
        (supervisor--oneshot-callbacks (make-hash-table :test 'equal))
        (supervisor--programs-cache
         (list (list "true" :id "svc1" :type 'oneshot
                     :remain-after-exit t)))
        (supervisor--invalid (make-hash-table :test 'equal)))
    (cl-letf (((symbol-function 'supervisor--dag-mark-ready)
               (lambda (_id)))
              ((symbol-function 'supervisor--emit-event)
               (lambda (&rest _args)))
              ((symbol-function 'supervisor--log)
               (lambda (&rest _args))))
      (supervisor--handle-oneshot-exit "svc1" 'exit 0)
      (should (gethash "svc1" supervisor--remain-active))
      (should (= 0 (gethash "svc1" supervisor--oneshot-completed))))))

(ert-deftest supervisor-test-remain-after-exit-handle-failure ()
  "Handle-oneshot-exit does NOT set remain-active on failure."
  (let ((supervisor--oneshot-completed (make-hash-table :test 'equal))
        (supervisor--remain-active (make-hash-table :test 'equal))
        (supervisor--oneshot-callbacks (make-hash-table :test 'equal))
        (supervisor--programs-cache
         (list (list "false" :id "svc1" :type 'oneshot
                     :remain-after-exit t)))
        (supervisor--invalid (make-hash-table :test 'equal)))
    (cl-letf (((symbol-function 'supervisor--dag-mark-ready)
               (lambda (_id)))
              ((symbol-function 'supervisor--emit-event)
               (lambda (&rest _args)))
              ((symbol-function 'supervisor--log)
               (lambda (&rest _args))))
      (supervisor--handle-oneshot-exit "svc1" 'exit 1)
      (should-not (gethash "svc1" supervisor--remain-active))
      (should (= 1 (gethash "svc1" supervisor--oneshot-completed))))))

(ert-deftest supervisor-test-remain-after-exit-handle-signal ()
  "Handle-oneshot-exit does NOT set remain-active on signal death."
  (let ((supervisor--oneshot-completed (make-hash-table :test 'equal))
        (supervisor--remain-active (make-hash-table :test 'equal))
        (supervisor--oneshot-callbacks (make-hash-table :test 'equal))
        (supervisor--programs-cache
         (list (list "true" :id "svc1" :type 'oneshot
                     :remain-after-exit t)))
        (supervisor--invalid (make-hash-table :test 'equal)))
    (cl-letf (((symbol-function 'supervisor--dag-mark-ready)
               (lambda (_id)))
              ((symbol-function 'supervisor--emit-event)
               (lambda (&rest _args)))
              ((symbol-function 'supervisor--log)
               (lambda (&rest _args))))
      (supervisor--handle-oneshot-exit "svc1" 'signal 9)
      (should-not (gethash "svc1" supervisor--remain-active)))))

(ert-deftest supervisor-test-remain-after-exit-start-noop ()
  "Start on active remain-after-exit unit is a no-op."
  (let ((supervisor--processes (make-hash-table :test 'equal))
        (supervisor--remain-active (make-hash-table :test 'equal))
        (supervisor--invalid (make-hash-table :test 'equal))
        (supervisor--failed (make-hash-table :test 'equal))
        (supervisor--manually-stopped (make-hash-table :test 'equal))
        (supervisor--manually-started (make-hash-table :test 'equal))
        (supervisor--restart-times (make-hash-table :test 'equal))
        (supervisor--oneshot-completed (make-hash-table :test 'equal)))
    (puthash "svc1" t supervisor--remain-active)
    (let ((result (supervisor--manual-start "svc1")))
      (should (eq 'skipped (plist-get result :status)))
      (should (string= "already active" (plist-get result :reason)))
      ;; Latch should still be set
      (should (gethash "svc1" supervisor--remain-active)))))

(ert-deftest supervisor-test-remain-after-exit-stop-clears-latch ()
  "Stop on active remain-after-exit unit clears the latch."
  (let ((supervisor--processes (make-hash-table :test 'equal))
        (supervisor--remain-active (make-hash-table :test 'equal))
        (supervisor--manually-stopped (make-hash-table :test 'equal))
        (supervisor--manually-started (make-hash-table :test 'equal)))
    (puthash "svc1" t supervisor--remain-active)
    (let ((result (supervisor--manual-stop "svc1")))
      (should (eq 'stopped (plist-get result :status)))
      ;; Latch should be cleared
      (should-not (gethash "svc1" supervisor--remain-active))
      ;; Manually-stopped should be set
      (should (gethash "svc1" supervisor--manually-stopped)))))

(ert-deftest supervisor-test-remain-after-exit-restart-reruns ()
  "Restart on active remain-after-exit unit clears latch and re-runs."
  (let ((supervisor--processes (make-hash-table :test 'equal))
        (supervisor--remain-active (make-hash-table :test 'equal))
        (supervisor--manually-stopped (make-hash-table :test 'equal))
        (supervisor--manually-started (make-hash-table :test 'equal))
        (supervisor--oneshot-completed (make-hash-table :test 'equal))
        (supervisor--invalid (make-hash-table :test 'equal))
        (supervisor--failed (make-hash-table :test 'equal))
        (supervisor--restart-times (make-hash-table :test 'equal))
        (supervisor--mask-override (make-hash-table :test 'equal))
        (supervisor--programs-cache
         (list (list "true" :id "svc1" :type 'oneshot
                     :remain-after-exit t)))
        (started nil))
    (puthash "svc1" t supervisor--remain-active)
    (puthash "svc1" 0 supervisor--oneshot-completed)
    ;; Stop clears the latch
    (supervisor--manual-stop "svc1")
    (should-not (gethash "svc1" supervisor--remain-active))
    ;; Start re-runs (mock the actual process creation)
    (cl-letf (((symbol-function 'supervisor--start-process)
               (lambda (&rest _args)
                 (setq started t)
                 (start-process "mock" nil "true")))
              ((symbol-function 'supervisor--unit-file-directory-for-id)
               (lambda (_id) nil)))
      (let ((result (supervisor--manual-start "svc1")))
        (should (eq 'started (plist-get result :status)))
        (should started)
        ;; Oneshot-completed should have been cleared
        (should-not (gethash "svc1" supervisor--oneshot-completed))
        ;; Remain-active should have been cleared
        (should-not (gethash "svc1" supervisor--remain-active))))))

(ert-deftest supervisor-test-remain-after-exit-snapshot ()
  "Snapshot includes remain-active state."
  (let ((supervisor--processes (make-hash-table :test 'equal))
        (supervisor--failed (make-hash-table :test 'equal))
        (supervisor--oneshot-completed (make-hash-table :test 'equal))
        (supervisor--entry-state (make-hash-table :test 'equal))
        (supervisor--invalid (make-hash-table :test 'equal))
        (supervisor--enabled-override (make-hash-table :test 'equal))
        (supervisor--restart-override (make-hash-table :test 'equal))
        (supervisor--logging (make-hash-table :test 'equal))
        (supervisor--mask-override (make-hash-table :test 'equal))
        (supervisor--manually-started (make-hash-table :test 'equal))
        (supervisor--remain-active (make-hash-table :test 'equal)))
    (puthash "svc1" t supervisor--remain-active)
    (let ((snapshot (supervisor--build-snapshot)))
      (should (gethash "svc1" (supervisor-snapshot-remain-active snapshot))))))

(ert-deftest supervisor-test-remain-after-exit-status-via-snapshot ()
  "Status computed via snapshot respects remain-active."
  (let ((supervisor--processes (make-hash-table :test 'equal))
        (supervisor--failed (make-hash-table :test 'equal))
        (supervisor--oneshot-completed (make-hash-table :test 'equal))
        (supervisor--entry-state (make-hash-table :test 'equal))
        (supervisor--invalid (make-hash-table :test 'equal))
        (supervisor--enabled-override (make-hash-table :test 'equal))
        (supervisor--restart-override (make-hash-table :test 'equal))
        (supervisor--logging (make-hash-table :test 'equal))
        (supervisor--mask-override (make-hash-table :test 'equal))
        (supervisor--manually-started (make-hash-table :test 'equal))
        (supervisor--remain-active (make-hash-table :test 'equal)))
    (puthash "svc1" 0 supervisor--oneshot-completed)
    (puthash "svc1" t supervisor--remain-active)
    (let* ((snapshot (supervisor--build-snapshot))
           (result (supervisor--compute-entry-status "svc1" 'oneshot snapshot)))
      (should (string= "active" (car result))))))

(ert-deftest supervisor-test-remain-after-exit-stop-status-becomes-stopped ()
  "After stopping an active remain-after-exit unit, status is stopped."
  (supervisor-test-with-unit-files
      '(("true" :id "svc1" :type oneshot :remain-after-exit t))
    (let ((supervisor--processes (make-hash-table :test 'equal))
          (supervisor--remain-active (make-hash-table :test 'equal))
          (supervisor--oneshot-completed (make-hash-table :test 'equal))
          (supervisor--manually-stopped (make-hash-table :test 'equal))
          (supervisor--manually-started (make-hash-table :test 'equal))
          (supervisor--failed (make-hash-table :test 'equal))
          (supervisor--entry-state (make-hash-table :test 'equal))
          (supervisor--invalid (make-hash-table :test 'equal))
          (supervisor--enabled-override (make-hash-table :test 'equal))
          (supervisor--restart-override (make-hash-table :test 'equal))
          (supervisor--mask-override (make-hash-table :test 'equal))
          (supervisor--logging (make-hash-table :test 'equal)))
      ;; Simulate active latch state (successful oneshot exit)
      (puthash "svc1" 0 supervisor--oneshot-completed)
      (puthash "svc1" t supervisor--remain-active)
      ;; Verify status is active before stop
      (let ((status (car (supervisor--compute-entry-status "svc1" 'oneshot))))
        (should (string= "active" status)))
      ;; Stop the unit
      (supervisor--manual-stop "svc1")
      ;; Verify status is stopped after stop
      (let ((status (car (supervisor--compute-entry-status "svc1" 'oneshot))))
        (should (string= "stopped" status))))))

(ert-deftest supervisor-test-cli-is-active-remain-after-exit ()
  "The `is-active' returns exit 0 for an active remain-after-exit unit."
  (supervisor-test-with-unit-files
      '(("true" :id "svc" :type oneshot :remain-after-exit t))
    (let* ((supervisor--processes (make-hash-table :test 'equal))
           (supervisor--entry-state (make-hash-table :test 'equal))
           (supervisor--remain-active (make-hash-table :test 'equal))
           (supervisor--oneshot-completed (make-hash-table :test 'equal))
           (supervisor--failed (make-hash-table :test 'equal))
           (supervisor--invalid (make-hash-table :test 'equal))
           (supervisor--enabled-override (make-hash-table :test 'equal))
           (supervisor--restart-override (make-hash-table :test 'equal))
           (supervisor--mask-override (make-hash-table :test 'equal))
           (supervisor--logging (make-hash-table :test 'equal))
           (supervisor--manually-started (make-hash-table :test 'equal)))
      ;; Simulate active latch state
      (puthash "svc" 0 supervisor--oneshot-completed)
      (puthash "svc" t supervisor--remain-active)
      (let ((result (supervisor--cli-dispatch '("is-active" "svc"))))
        (should (= supervisor-cli-exit-success
                   (supervisor-cli-result-exitcode result)))
        (should (string-match "active" (supervisor-cli-result-output result)))))))

(ert-deftest supervisor-test-dashboard-stop-active-remain-after-exit ()
  "Dashboard stop succeeds on active remain-after-exit oneshot."
  (supervisor-test-with-unit-files
      '(("true" :id "svc1" :type oneshot :remain-after-exit t))
    (let ((supervisor--processes (make-hash-table :test 'equal))
          (supervisor--remain-active (make-hash-table :test 'equal))
          (supervisor--oneshot-completed (make-hash-table :test 'equal))
          (supervisor--manually-stopped (make-hash-table :test 'equal))
          (supervisor--manually-started (make-hash-table :test 'equal))
          (supervisor--failed (make-hash-table :test 'equal))
          (supervisor--entry-state (make-hash-table :test 'equal))
          (supervisor--invalid (make-hash-table :test 'equal))
          (supervisor--enabled-override (make-hash-table :test 'equal))
          (supervisor--restart-override (make-hash-table :test 'equal))
          (supervisor--mask-override (make-hash-table :test 'equal))
          (supervisor--logging (make-hash-table :test 'equal))
          (refreshed nil))
      (puthash "svc1" 0 supervisor--oneshot-completed)
      (puthash "svc1" t supervisor--remain-active)
      (cl-letf (((symbol-function 'tabulated-list-get-id)
                 (lambda () (cons :service "svc1")))
                ((symbol-function 'yes-or-no-p)
                 (lambda (_prompt) t))
                ((symbol-function 'supervisor--refresh-dashboard)
                 (lambda () (setq refreshed t))))
        (supervisor-dashboard-stop)
        ;; Latch cleared, manually-stopped set
        (should-not (gethash "svc1" supervisor--remain-active))
        (should (gethash "svc1" supervisor--manually-stopped))
        (should refreshed)))))

(ert-deftest supervisor-test-dashboard-restart-active-remain-after-exit ()
  "Dashboard restart succeeds on active remain-after-exit oneshot."
  (supervisor-test-with-unit-files
      '(("true" :id "svc1" :type oneshot :remain-after-exit t))
    (let ((supervisor--processes (make-hash-table :test 'equal))
          (supervisor--remain-active (make-hash-table :test 'equal))
          (supervisor--oneshot-completed (make-hash-table :test 'equal))
          (supervisor--manually-stopped (make-hash-table :test 'equal))
          (supervisor--manually-started (make-hash-table :test 'equal))
          (supervisor--failed (make-hash-table :test 'equal))
          (supervisor--restart-times (make-hash-table :test 'equal))
          (supervisor--entry-state (make-hash-table :test 'equal))
          (supervisor--invalid (make-hash-table :test 'equal))
          (supervisor--enabled-override (make-hash-table :test 'equal))
          (supervisor--restart-override (make-hash-table :test 'equal))
          (supervisor--mask-override (make-hash-table :test 'equal))
          (supervisor--logging (make-hash-table :test 'equal))
          (supervisor--programs-cache
           (list (list "true" :id "svc1" :type 'oneshot
                       :remain-after-exit t)))
          (refreshed nil)
          (started nil))
      (puthash "svc1" 0 supervisor--oneshot-completed)
      (puthash "svc1" t supervisor--remain-active)
      (cl-letf (((symbol-function 'tabulated-list-get-id)
                 (lambda () (cons :service "svc1")))
                ((symbol-function 'yes-or-no-p)
                 (lambda (_prompt) t))
                ((symbol-function 'supervisor--refresh-dashboard)
                 (lambda () (setq refreshed t)))
                ((symbol-function 'supervisor--start-process)
                 (lambda (&rest _args)
                   (setq started t)
                   (start-process "mock" nil "true")))
                ((symbol-function 'supervisor--unit-file-directory-for-id)
                 (lambda (_id) nil)))
        (supervisor-dashboard-restart)
        ;; Stop cleared latch, start re-ran
        (should started)
        (should refreshed)))))

(ert-deftest supervisor-test-cli-is-active-json-remain-after-exit ()
  "The `is-active --json' returns active=true for active latched oneshot."
  (supervisor-test-with-unit-files
      '(("true" :id "svc" :type oneshot :remain-after-exit t))
    (let* ((supervisor--processes (make-hash-table :test 'equal))
           (supervisor--entry-state (make-hash-table :test 'equal))
           (supervisor--remain-active (make-hash-table :test 'equal))
           (supervisor--oneshot-completed (make-hash-table :test 'equal))
           (supervisor--failed (make-hash-table :test 'equal))
           (supervisor--invalid (make-hash-table :test 'equal))
           (supervisor--enabled-override (make-hash-table :test 'equal))
           (supervisor--restart-override (make-hash-table :test 'equal))
           (supervisor--mask-override (make-hash-table :test 'equal))
           (supervisor--logging (make-hash-table :test 'equal))
           (supervisor--manually-started (make-hash-table :test 'equal))
           (supervisor--manually-stopped (make-hash-table :test 'equal)))
      (puthash "svc" 0 supervisor--oneshot-completed)
      (puthash "svc" t supervisor--remain-active)
      (let* ((result (supervisor--cli-dispatch '("is-active" "svc" "--json")))
             (parsed (json-read-from-string
                      (supervisor-cli-result-output result))))
        (should (= supervisor-cli-exit-success
                   (supervisor-cli-result-exitcode result)))
        (should (eq t (alist-get 'active parsed)))
        (should (equal "active" (alist-get 'status parsed)))))))

;;; V1: Plist shape guard tests

(ert-deftest supervisor-test-validate-entry-odd-plist ()
  "Odd-length plist is rejected by entry validation."
  (let ((result (supervisor--validate-entry '("cmd" :id "svc" :enabled))))
    (should (stringp result))
    (should (string-match-p "odd number of elements" result))))

(ert-deftest supervisor-test-validate-entry-dotted-plist ()
  "Dotted plist is rejected by entry validation."
  (let ((result (supervisor--validate-entry '("cmd" :enabled . t))))
    (should (stringp result))
    (should (string-match-p "must be a proper key/value list" result))))

(ert-deftest supervisor-test-validate-unit-file-odd-plist ()
  "Odd-length plist is rejected by unit-file validation."
  (let ((result (supervisor--validate-unit-file-plist
                 '(:id "svc" :command "cmd" :enabled) "test.el" 1)))
    (should (stringp result))
    (should (string-match-p "odd number of elements" result))))

(ert-deftest supervisor-test-validate-unit-file-dotted-plist ()
  "Dotted plist is rejected by unit-file validation."
  (let ((result (supervisor--validate-unit-file-plist
                 '(:id "svc" :command . "cmd") "test.el" 1)))
    (should (stringp result))
    (should (string-match-p "must be a proper key/value list" result))))

;;; V2: Command non-empty guard tests

(ert-deftest supervisor-test-validate-entry-empty-string-command ()
  "Empty string command is rejected by entry validation."
  (let ((result (supervisor--validate-entry "")))
    (should (stringp result))
    (should (string-match-p "empty or whitespace-only" result))))

(ert-deftest supervisor-test-validate-entry-whitespace-string-command ()
  "Whitespace-only string command is rejected by entry validation."
  (let ((result (supervisor--validate-entry "   ")))
    (should (stringp result))
    (should (string-match-p "empty or whitespace-only" result))))

(ert-deftest supervisor-test-validate-entry-empty-list-command ()
  "Empty command in list entry is rejected by entry validation."
  (let ((result (supervisor--validate-entry '("" :id "svc"))))
    (should (stringp result))
    (should (string-match-p "empty or whitespace-only" result))))

(ert-deftest supervisor-test-validate-unit-file-empty-command ()
  "Empty :command is rejected by unit-file validation."
  (let ((result (supervisor--validate-unit-file-plist
                 '(:id "svc" :command "") "test.el" 1)))
    (should (stringp result))
    (should (string-match-p "empty or whitespace-only" result))))

(ert-deftest supervisor-test-validate-unit-file-whitespace-command ()
  "Whitespace-only :command is rejected by unit-file validation."
  (let ((result (supervisor--validate-unit-file-plist
                 '(:id "svc" :command "   ") "test.el" 1)))
    (should (stringp result))
    (should (string-match-p "empty or whitespace-only" result))))

;;; V3: ID hardening tests

(ert-deftest supervisor-test-validate-entry-empty-id ()
  "Empty :id is rejected by entry validation."
  (let ((result (supervisor--validate-entry '("cmd" :id ""))))
    (should (stringp result))
    (should (string-match-p ":id must not be empty" result))))

(ert-deftest supervisor-test-validate-entry-id-with-slash ()
  "ID containing slash is rejected by entry validation."
  (let ((result (supervisor--validate-entry '("cmd" :id "../etc/passwd"))))
    (should (stringp result))
    (should (string-match-p "invalid characters" result))))

(ert-deftest supervisor-test-validate-entry-id-with-control-char ()
  "ID containing control characters is rejected by entry validation."
  (let ((result (supervisor--validate-entry '("cmd" :id "foo\nbar"))))
    (should (stringp result))
    (should (string-match-p "invalid characters" result))))

(ert-deftest supervisor-test-validate-entry-id-valid-chars ()
  "ID with valid characters passes entry validation."
  (let ((result (supervisor--validate-entry '("cmd" :id "my-svc_2.0:main@host"))))
    (should-not result)))

(ert-deftest supervisor-test-validate-unit-file-id-invalid-chars ()
  "ID with invalid characters is rejected by unit-file validation."
  (let ((result (supervisor--validate-unit-file-plist
                 '(:id "foo/bar" :command "cmd") "test.el" 1)))
    (should (stringp result))
    (should (string-match-p "invalid characters" result))))

;;; V4: Strict boolean flag tests

(ert-deftest supervisor-test-validate-boolean-enabled-string ()
  "String value for :enabled is rejected."
  (let ((result (supervisor--validate-entry '("cmd" :enabled "yes"))))
    (should (stringp result))
    (should (string-match-p ":enabled must be t or nil" result))))

(ert-deftest supervisor-test-validate-boolean-disabled-string ()
  "String value for :disabled is rejected."
  (let ((result (supervisor--validate-entry '("cmd" :disabled "no"))))
    (should (stringp result))
    (should (string-match-p ":disabled must be t or nil" result))))

(ert-deftest supervisor-test-validate-boolean-logging-number ()
  "Numeric value for :logging is rejected."
  (let ((result (supervisor--validate-entry '("cmd" :logging 1))))
    (should (stringp result))
    (should (string-match-p ":logging must be t or nil" result))))

(ert-deftest supervisor-test-validate-boolean-no-restart-string ()
  "String value for :no-restart is rejected."
  (let ((result (supervisor--validate-entry '("cmd" :no-restart "no"))))
    (should (stringp result))
    (should (string-match-p ":no-restart must be t or nil" result))))

(ert-deftest supervisor-test-validate-boolean-oneshot-blocking-string ()
  "String value for :oneshot-blocking is rejected."
  (let ((result (supervisor--validate-entry
                 '("cmd" :type oneshot :oneshot-blocking "no"))))
    (should (stringp result))
    (should (string-match-p ":oneshot-blocking must be t or nil" result))))

(ert-deftest supervisor-test-validate-boolean-oneshot-async-string ()
  "String value for :oneshot-async is rejected."
  (let ((result (supervisor--validate-entry
                 '("cmd" :type oneshot :oneshot-async "yes"))))
    (should (stringp result))
    (should (string-match-p ":oneshot-async must be t or nil" result))))

;;; V5: Tags validation tests

(ert-deftest supervisor-test-validate-tags-number ()
  "Numeric :tags value is rejected."
  (let ((result (supervisor--validate-entry '("cmd" :tags 42))))
    (should (stringp result))
    (should (string-match-p ":tags must be a symbol, string, or list" result))))

(ert-deftest supervisor-test-validate-tags-valid-symbol-list ()
  "List of symbols is valid for :tags."
  (should-not (supervisor--validate-entry '("cmd" :tags (web api)))))

(ert-deftest supervisor-test-validate-tags-valid-string-list ()
  "List of strings is valid for :tags."
  (should-not (supervisor--validate-entry '("cmd" :tags ("web" "api")))))

(ert-deftest supervisor-test-validate-tags-empty-string ()
  "Empty string in :tags is rejected."
  (let ((result (supervisor--validate-entry '("cmd" :tags ""))))
    (should (stringp result))
    (should (string-match-p "empty strings" result))))

(ert-deftest supervisor-test-validate-tags-nil-element ()
  "Nil element in :tags list is rejected."
  (let ((result (supervisor--validate-entry '("cmd" :tags (web nil)))))
    (should (stringp result))
    (should (string-match-p "nil values" result))))

;;; V6: Dependency and timeout hardening tests

(ert-deftest supervisor-test-validate-oneshot-timeout-negative ()
  "Negative :oneshot-timeout is rejected."
  (let ((result (supervisor--validate-entry
                 '("cmd" :type oneshot :oneshot-timeout -5))))
    (should (stringp result))
    (should (string-match-p ":oneshot-timeout must be a positive number" result))))

(ert-deftest supervisor-test-validate-oneshot-timeout-zero ()
  "Zero :oneshot-timeout is rejected."
  (let ((result (supervisor--validate-entry
                 '("cmd" :type oneshot :oneshot-timeout 0))))
    (should (stringp result))
    (should (string-match-p ":oneshot-timeout must be a positive number" result))))

(ert-deftest supervisor-test-validate-oneshot-timeout-valid ()
  "Positive :oneshot-timeout passes validation."
  (should-not (supervisor--validate-entry
               '("cmd" :type oneshot :oneshot-timeout 5))))

(ert-deftest supervisor-test-validate-after-empty-string ()
  "Empty string in :after is rejected."
  (let ((result (supervisor--validate-entry '("cmd" :after ""))))
    (should (stringp result))
    (should (string-match-p ":after must not contain empty" result))))

(ert-deftest supervisor-test-validate-requires-empty-string ()
  "Empty string in :requires is rejected."
  (let ((result (supervisor--validate-entry '("cmd" :requires ""))))
    (should (stringp result))
    (should (string-match-p ":requires must not contain empty" result))))

(ert-deftest supervisor-test-validate-before-empty-string ()
  "Empty string in :before is rejected."
  (let ((result (supervisor--validate-entry '("cmd" :before ""))))
    (should (stringp result))
    (should (string-match-p ":before must not contain empty" result))))

(ert-deftest supervisor-test-validate-wants-empty-string ()
  "Empty string in :wants is rejected."
  (let ((result (supervisor--validate-entry '("cmd" :wants ""))))
    (should (stringp result))
    (should (string-match-p ":wants must not contain empty" result))))

(ert-deftest supervisor-test-validate-after-self-dependency ()
  "Self-reference in :after is rejected."
  (let ((result (supervisor--validate-entry '("cmd" :id "a" :after "a"))))
    (should (stringp result))
    (should (string-match-p ":after must not reference the entry's own ID" result))))

(ert-deftest supervisor-test-validate-requires-self-dependency ()
  "Self-reference in :requires is rejected."
  (let ((result (supervisor--validate-entry '("cmd" :id "a" :requires "a"))))
    (should (stringp result))
    (should (string-match-p ":requires must not reference the entry's own ID" result))))

(ert-deftest supervisor-test-validate-before-self-dependency ()
  "Self-reference in :before is rejected."
  (let ((result (supervisor--validate-entry '("cmd" :id "a" :before "a"))))
    (should (stringp result))
    (should (string-match-p ":before must not reference the entry's own ID" result))))

(ert-deftest supervisor-test-validate-wants-self-dependency ()
  "Self-reference in :wants is rejected."
  (let ((result (supervisor--validate-entry '("cmd" :id "a" :wants "a"))))
    (should (stringp result))
    (should (string-match-p ":wants must not reference the entry's own ID" result))))

;;; V7: Cross-keyword contradiction tests

(ert-deftest supervisor-test-validate-restart-sec-with-no-restart-true ()
  "Restart-sec with :no-restart t is contradictory."
  (let ((result (supervisor--validate-entry
                 '("cmd" :no-restart t :restart-sec 5))))
    (should (stringp result))
    (should (string-match-p "contradictory" result))))

(ert-deftest supervisor-test-validate-restart-sec-with-restart-no ()
  "Restart-sec with :restart no is contradictory."
  (let ((result (supervisor--validate-entry
                 '("cmd" :restart no :restart-sec 5))))
    (should (stringp result))
    (should (string-match-p "contradictory" result))))

(ert-deftest supervisor-test-validate-restart-sec-with-restart-nil ()
  "Restart-sec with :restart nil is contradictory."
  (let ((result (supervisor--validate-entry
                 '("cmd" :restart nil :restart-sec 5))))
    (should (stringp result))
    (should (string-match-p "contradictory" result))))

(ert-deftest supervisor-test-validate-restart-sec-with-restart-always ()
  "Restart-sec with :restart always is valid."
  (should-not (supervisor--validate-entry
               '("cmd" :restart always :restart-sec 5))))

(ert-deftest supervisor-test-validate-restart-sec-nil-with-no-restart ()
  "Explicit :restart-sec nil with disabled restart is accepted."
  (should-not (supervisor--validate-entry
               '("cmd" :no-restart t :restart-sec nil))))

;;; V6 supplement: derived-ID self-reference regression

(ert-deftest supervisor-test-validate-after-self-dependency-derived-id ()
  "Self-reference in :after detected via derived command ID."
  (let ((result (supervisor--validate-entry '("svc" :after "svc"))))
    (should (stringp result))
    (should (string-match-p ":after must not reference the entry's own ID" result))))

(ert-deftest supervisor-test-validate-requires-self-dependency-derived-id ()
  "Self-reference in :requires detected via derived command ID."
  (let ((result (supervisor--validate-entry '("svc" :requires "svc"))))
    (should (stringp result))
    (should (string-match-p ":requires must not reference the entry's own ID" result))))

(ert-deftest supervisor-test-validate-before-self-dependency-derived-id ()
  "Self-reference in :before detected via derived command ID."
  (let ((result (supervisor--validate-entry '("svc" :before "svc"))))
    (should (stringp result))
    (should (string-match-p ":before must not reference the entry's own ID" result))))

(ert-deftest supervisor-test-validate-wants-self-dependency-derived-id ()
  "Self-reference in :wants detected via derived command ID."
  (let ((result (supervisor--validate-entry '("svc" :wants "svc"))))
    (should (stringp result))
    (should (string-match-p ":wants must not reference the entry's own ID" result))))

;;; V8: Environment validation tests

(ert-deftest supervisor-test-validate-environment-empty-key ()
  "Empty environment key is rejected."
  (let ((result (supervisor--validate-entry
                 '("cmd" :environment (("" . "val"))))))
    (should (stringp result))
    (should (string-match-p ":environment key .* is not a valid variable name"
                            result))))

(ert-deftest supervisor-test-validate-environment-key-with-space ()
  "Environment key with space is rejected."
  (let ((result (supervisor--validate-entry
                 '("cmd" :environment (("FOO BAR" . "val"))))))
    (should (stringp result))
    (should (string-match-p ":environment key .* is not a valid variable name"
                            result))))

(ert-deftest supervisor-test-validate-environment-key-with-equals ()
  "Environment key with equals sign is rejected."
  (let ((result (supervisor--validate-entry
                 '("cmd" :environment (("FOO=BAR" . "val"))))))
    (should (stringp result))
    (should (string-match-p ":environment key .* is not a valid variable name"
                            result))))

(ert-deftest supervisor-test-validate-environment-valid-key ()
  "Valid environment key is accepted."
  (should-not (supervisor--validate-entry
               '("cmd" :environment (("MY_VAR_1" . "val"))))))

(ert-deftest supervisor-test-validate-environment-duplicate-key ()
  "Duplicate environment key is rejected."
  (let ((result (supervisor--validate-entry
                 '("cmd" :environment (("FOO" . "a") ("FOO" . "b"))))))
    (should (stringp result))
    (should (string-match-p ":environment contains duplicate key" result))))

;;; V9: Exec and exit-status hardening tests

(ert-deftest supervisor-test-validate-exec-stop-empty-string ()
  "Empty :exec-stop string is rejected."
  (let ((result (supervisor--validate-entry '("cmd" :exec-stop ""))))
    (should (stringp result))
    (should (string-match-p ":exec-stop must not contain empty commands" result))))

(ert-deftest supervisor-test-validate-exec-stop-list-with-empty ()
  "List :exec-stop containing empty string is rejected."
  (let ((result (supervisor--validate-entry
                 '("cmd" :exec-stop ("valid" "  ")))))
    (should (stringp result))
    (should (string-match-p ":exec-stop must not contain empty commands" result))))

(ert-deftest supervisor-test-validate-exec-reload-empty-string ()
  "Empty :exec-reload string is rejected."
  (let ((result (supervisor--validate-entry '("cmd" :exec-reload ""))))
    (should (stringp result))
    (should (string-match-p ":exec-reload must not contain empty commands" result))))

(ert-deftest supervisor-test-validate-success-exit-status-negative ()
  "Negative :success-exit-status code is rejected."
  (let ((result (supervisor--validate-entry '("cmd" :success-exit-status (-1)))))
    (should (stringp result))
    (should (string-match-p ":success-exit-status code .* is outside valid range"
                            result))))

(ert-deftest supervisor-test-validate-success-exit-status-over-255 ()
  "Exit code over 255 in :success-exit-status is rejected."
  (let ((result (supervisor--validate-entry '("cmd" :success-exit-status (256)))))
    (should (stringp result))
    (should (string-match-p ":success-exit-status code .* is outside valid range"
                            result))))

(ert-deftest supervisor-test-validate-success-exit-status-valid-boundaries ()
  "Exit codes 0 and 255 in :success-exit-status are accepted."
  (should-not (supervisor--validate-entry
               '("cmd" :success-exit-status (0 255)))))

;;; V10: Unit-file delegation to entry validation tests

(ert-deftest supervisor-test-validate-unit-file-delegates-boolean ()
  "Unit-file validation delegates strict boolean check to entry validator."
  (let ((result (supervisor--validate-unit-file-plist
                 '(:id "svc" :command "cmd" :enabled "yes")
                 "/tmp/test.unit" 1)))
    (should (stringp result))
    (should (string-match-p ":enabled must be t or nil" result))))

(ert-deftest supervisor-test-validate-unit-file-delegates-type-gate ()
  "Unit-file validation delegates type-specific restriction check."
  (let ((result (supervisor--validate-unit-file-plist
                 '(:id "svc" :command "cmd" :type oneshot :restart always)
                 "/tmp/test.unit" 1)))
    (should (stringp result))
    (should (string-match-p ":restart is invalid for :type oneshot" result))))

(ert-deftest supervisor-test-validate-unit-file-delegates-self-dependency ()
  "Unit-file validation delegates self-dependency check."
  (let ((result (supervisor--validate-unit-file-plist
                 '(:id "svc" :command "cmd" :after "svc")
                 "/tmp/test.unit" 1)))
    (should (stringp result))
    (should (string-match-p ":after must not reference the entry's own ID" result))))

(ert-deftest supervisor-test-validate-unit-file-delegates-empty-command ()
  "Unit-file validation delegates empty exec-stop check."
  (let ((result (supervisor--validate-unit-file-plist
                 '(:id "svc" :command "cmd" :exec-stop "")
                 "/tmp/test.unit" 1)))
    (should (stringp result))
    (should (string-match-p ":exec-stop must not contain empty commands" result))))

;;; V11: Coverage sweep gap tests

(ert-deftest supervisor-test-validate-entry-invalid-entry-type ()
  "Non-string non-list entries are rejected."
  (should (string-match-p "entry must be a string or list"
                          (supervisor--validate-entry 123)))
  (should (string-match-p "entry must be a string or list"
                          (supervisor--validate-entry '(123 :id "x"))))
  (should (string-match-p "entry must be a string or list"
                          (supervisor--validate-entry nil))))

;;; Dashboard nested menu tests

(ert-deftest supervisor-test-dashboard-keymap-submenu-keys ()
  "Dashboard keymap binds l, p, i to submenu dispatchers."
  (should (eq (lookup-key supervisor-dashboard-mode-map "l")
              'supervisor-dashboard-lifecycle))
  (should (eq (lookup-key supervisor-dashboard-mode-map "p")
              'supervisor-dashboard-policy))
  (should (eq (lookup-key supervisor-dashboard-mode-map "i")
              'supervisor-dashboard-inspect)))

(ert-deftest supervisor-test-dashboard-keymap-top-level-only ()
  "Dashboard keymap has no direct lifecycle/policy/inspect bindings."
  ;; Old direct bindings should be gone
  (should-not (eq (lookup-key supervisor-dashboard-mode-map "s")
                  'supervisor-dashboard-start))
  (should-not (eq (lookup-key supervisor-dashboard-mode-map "x")
                  'supervisor-dashboard-stop))
  (should-not (eq (lookup-key supervisor-dashboard-mode-map "e")
                  'supervisor-dashboard-toggle-enabled))
  (should-not (eq (lookup-key supervisor-dashboard-mode-map "m")
                  'supervisor-dashboard-toggle-mask))
  (should-not (eq (lookup-key supervisor-dashboard-mode-map "r")
                  'supervisor-dashboard-toggle-restart))
  (should-not (eq (lookup-key supervisor-dashboard-mode-map "d")
                  'supervisor-dashboard-show-deps))
  (should-not (eq (lookup-key supervisor-dashboard-mode-map "c")
                  'supervisor-dashboard-cat)))

(ert-deftest supervisor-test-dashboard-keymap-proced-moved ()
  "Dashboard keymap binds proced to t (was p)."
  (should (eq (lookup-key supervisor-dashboard-mode-map "t")
              'proced))
  (should (eq (lookup-key supervisor-dashboard-mode-map "T")
              'supervisor-dashboard-toggle-proced-auto-update)))

(ert-deftest supervisor-test-dashboard-keymap-tag-filter-moved ()
  "Dashboard keymap binds tag filter to F (was t)."
  (should (eq (lookup-key supervisor-dashboard-mode-map "F")
              'supervisor-dashboard-cycle-tag-filter)))

(ert-deftest supervisor-test-dashboard-enable-explicit ()
  "Explicit enable sets enabled override."
  (let* ((entry (supervisor--parse-entry '("cmd" :id "svc" :disabled t)))
         (supervisor--enabled-override (make-hash-table :test 'equal))
         (supervisor--mask-override (make-hash-table :test 'equal))
         (supervisor--invalid (make-hash-table :test 'equal))
         (supervisor-overrides-file nil)
         (msg nil))
    (cl-letf (((symbol-function 'tabulated-list-get-id) (lambda () (cons :service "svc")))
              ((symbol-function 'supervisor--get-entry-for-id)
               (lambda (_id) entry))
              ((symbol-function 'supervisor--save-overrides) #'ignore)
              ((symbol-function 'supervisor--refresh-dashboard) #'ignore)
              ((symbol-function 'message)
               (lambda (fmt &rest args) (setq msg (apply #'format fmt args)))))
      (supervisor-dashboard-enable)
      (should (eq 'enabled (gethash "svc" supervisor--enabled-override)))
      (should (string-match-p "Enabled svc" msg)))))

(ert-deftest supervisor-test-dashboard-disable-explicit ()
  "Explicit disable sets disabled override."
  (let* ((entry (supervisor--parse-entry '("cmd" :id "svc")))
         (supervisor--enabled-override (make-hash-table :test 'equal))
         (supervisor--mask-override (make-hash-table :test 'equal))
         (supervisor--invalid (make-hash-table :test 'equal))
         (supervisor-overrides-file nil)
         (msg nil))
    (cl-letf (((symbol-function 'tabulated-list-get-id) (lambda () (cons :service "svc")))
              ((symbol-function 'supervisor--get-entry-for-id)
               (lambda (_id) entry))
              ((symbol-function 'supervisor--save-overrides) #'ignore)
              ((symbol-function 'supervisor--refresh-dashboard) #'ignore)
              ((symbol-function 'message)
               (lambda (fmt &rest args) (setq msg (apply #'format fmt args)))))
      (supervisor-dashboard-disable)
      (should (eq 'disabled (gethash "svc" supervisor--enabled-override)))
      (should (string-match-p "Disabled svc" msg)))))

(ert-deftest supervisor-test-dashboard-enable-already-enabled ()
  "Explicit enable on already-enabled entry shows message."
  (let* ((entry (supervisor--parse-entry '("cmd" :id "svc")))
         (supervisor--enabled-override (make-hash-table :test 'equal))
         (supervisor--mask-override (make-hash-table :test 'equal))
         (supervisor--invalid (make-hash-table :test 'equal))
         (supervisor-overrides-file nil)
         (msg nil))
    (cl-letf (((symbol-function 'tabulated-list-get-id) (lambda () (cons :service "svc")))
              ((symbol-function 'supervisor--get-entry-for-id)
               (lambda (_id) entry))
              ((symbol-function 'message)
               (lambda (fmt &rest args) (setq msg (apply #'format fmt args)))))
      (supervisor-dashboard-enable)
      (should (string-match-p "already enabled" msg)))))

(ert-deftest supervisor-test-dashboard-mask-explicit ()
  "Explicit mask sets mask override."
  (let* ((entry (supervisor--parse-entry '("cmd" :id "svc")))
         (supervisor--mask-override (make-hash-table :test 'equal))
         (supervisor--invalid (make-hash-table :test 'equal))
         (supervisor-overrides-file nil)
         (msg nil))
    (cl-letf (((symbol-function 'tabulated-list-get-id) (lambda () (cons :service "svc")))
              ((symbol-function 'supervisor--get-entry-for-id)
               (lambda (_id) entry))
              ((symbol-function 'supervisor--save-overrides) #'ignore)
              ((symbol-function 'supervisor--refresh-dashboard) #'ignore)
              ((symbol-function 'message)
               (lambda (fmt &rest args) (setq msg (apply #'format fmt args)))))
      (supervisor-dashboard-mask)
      (should (eq 'masked (gethash "svc" supervisor--mask-override)))
      (should (string-match-p "Masked svc" msg)))))

(ert-deftest supervisor-test-dashboard-unmask-explicit ()
  "Explicit unmask clears mask override."
  (let* ((entry (supervisor--parse-entry '("cmd" :id "svc")))
         (supervisor--mask-override (make-hash-table :test 'equal))
         (supervisor--invalid (make-hash-table :test 'equal))
         (supervisor-overrides-file nil)
         (msg nil))
    (puthash "svc" 'masked supervisor--mask-override)
    (cl-letf (((symbol-function 'tabulated-list-get-id) (lambda () (cons :service "svc")))
              ((symbol-function 'supervisor--get-entry-for-id)
               (lambda (_id) entry))
              ((symbol-function 'supervisor--save-overrides) #'ignore)
              ((symbol-function 'supervisor--refresh-dashboard) #'ignore)
              ((symbol-function 'message)
               (lambda (fmt &rest args) (setq msg (apply #'format fmt args)))))
      (supervisor-dashboard-unmask)
      (should-not (gethash "svc" supervisor--mask-override))
      (should (string-match-p "Unmasked svc" msg)))))

(ert-deftest supervisor-test-dashboard-unmask-not-masked ()
  "Explicit unmask on non-masked entry shows message."
  (let* ((entry (supervisor--parse-entry '("cmd" :id "svc")))
         (supervisor--mask-override (make-hash-table :test 'equal))
         (supervisor--invalid (make-hash-table :test 'equal))
         (supervisor-overrides-file nil)
         (msg nil))
    (cl-letf (((symbol-function 'tabulated-list-get-id) (lambda () (cons :service "svc")))
              ((symbol-function 'supervisor--get-entry-for-id)
               (lambda (_id) entry))
              ((symbol-function 'message)
               (lambda (fmt &rest args) (setq msg (apply #'format fmt args)))))
      (supervisor-dashboard-unmask)
      (should (string-match-p "not masked" msg)))))

(ert-deftest supervisor-test-dashboard-set-restart-policy ()
  "Set restart policy stores override via completing-read."
  (let* ((entry (supervisor--parse-entry '("cmd" :id "svc" :restart on-failure)))
         (supervisor--restart-override (make-hash-table :test 'equal))
         (supervisor--restart-timers (make-hash-table :test 'equal))
         (supervisor--invalid (make-hash-table :test 'equal))
         (supervisor-overrides-file nil)
         (msg nil))
    (cl-letf (((symbol-function 'tabulated-list-get-id) (lambda () (cons :service "svc")))
              ((symbol-function 'supervisor--get-entry-for-id)
               (lambda (_id) entry))
              ((symbol-function 'completing-read)
               (lambda (_prompt _coll &rest _) "always"))
              ((symbol-function 'supervisor--save-overrides) #'ignore)
              ((symbol-function 'supervisor--refresh-dashboard) #'ignore)
              ((symbol-function 'message)
               (lambda (fmt &rest args) (setq msg (apply #'format fmt args)))))
      (supervisor-dashboard-set-restart-policy)
      (should (eq 'always (gethash "svc" supervisor--restart-override)))
      (should (string-match-p "Restart policy for svc: always" msg)))))

(ert-deftest supervisor-test-dashboard-set-restart-policy-clears-on-match ()
  "Set restart policy clears override when matching config default."
  (let* ((entry (supervisor--parse-entry '("cmd" :id "svc" :restart on-failure)))
         (supervisor--restart-override (make-hash-table :test 'equal))
         (supervisor--restart-timers (make-hash-table :test 'equal))
         (supervisor--invalid (make-hash-table :test 'equal))
         (supervisor-overrides-file nil))
    ;; Pre-set an override
    (puthash "svc" 'always supervisor--restart-override)
    (cl-letf (((symbol-function 'tabulated-list-get-id) (lambda () (cons :service "svc")))
              ((symbol-function 'supervisor--get-entry-for-id)
               (lambda (_id) entry))
              ((symbol-function 'completing-read)
               (lambda (_prompt _coll &rest _) "on-failure"))
              ((symbol-function 'supervisor--save-overrides) #'ignore)
              ((symbol-function 'supervisor--refresh-dashboard) #'ignore)
              ((symbol-function 'message) #'ignore))
      (supervisor-dashboard-set-restart-policy)
      ;; Override should be cleared since on-failure matches config
      (should-not (gethash "svc" supervisor--restart-override)))))

(ert-deftest supervisor-test-dashboard-set-logging ()
  "Set logging stores override via completing-read."
  (let* ((entry (supervisor--parse-entry '("cmd" :id "svc" :logging t)))
         (supervisor--logging (make-hash-table :test 'equal))
         (supervisor--invalid (make-hash-table :test 'equal))
         (supervisor-overrides-file nil)
         (msg nil))
    (cl-letf (((symbol-function 'tabulated-list-get-id) (lambda () (cons :service "svc")))
              ((symbol-function 'supervisor--get-entry-for-id)
               (lambda (_id) entry))
              ((symbol-function 'completing-read)
               (lambda (_prompt _coll &rest _) "off"))
              ((symbol-function 'supervisor--refresh-dashboard) #'ignore)
              ((symbol-function 'message)
               (lambda (fmt &rest args) (setq msg (apply #'format fmt args)))))
      (supervisor-dashboard-set-logging)
      (should (eq 'disabled (gethash "svc" supervisor--logging)))
      (should (string-match-p "Logging for svc: off" msg)))))

(ert-deftest supervisor-test-dashboard-submenu-commands-defined ()
  "All submenu dispatcher commands are defined."
  (should (commandp 'supervisor-dashboard-lifecycle))
  (should (commandp 'supervisor-dashboard-policy))
  (should (commandp 'supervisor-dashboard-inspect)))

(ert-deftest supervisor-test-dashboard-explicit-policy-commands-defined ()
  "All explicit policy commands are defined."
  (should (commandp 'supervisor-dashboard-enable))
  (should (commandp 'supervisor-dashboard-disable))
  (should (commandp 'supervisor-dashboard-mask))
  (should (commandp 'supervisor-dashboard-unmask))
  (should (commandp 'supervisor-dashboard-set-restart-policy))
  (should (commandp 'supervisor-dashboard-set-logging)))

;;;; Telemetry Data Model Tests

(ert-deftest supervisor-test-last-exit-info-populated ()
  "Process sentinel populates `supervisor--last-exit-info'."
  (let* ((supervisor--processes (make-hash-table :test 'equal))
         (supervisor--failed (make-hash-table :test 'equal))
         (supervisor--restart-override (make-hash-table :test 'equal))
         (supervisor--enabled-override (make-hash-table :test 'equal))
         (supervisor--mask-override (make-hash-table :test 'equal))
         (supervisor--entry-state (make-hash-table :test 'equal))
         (supervisor--invalid (make-hash-table :test 'equal))
         (supervisor--manually-stopped (make-hash-table :test 'equal))
         (supervisor--manually-started (make-hash-table :test 'equal))
         (supervisor--oneshot-completed (make-hash-table :test 'equal))
         (supervisor--remain-active (make-hash-table :test 'equal))
         (supervisor--last-exit-info (make-hash-table :test 'equal))
         (supervisor--start-times (make-hash-table :test 'equal))
         (supervisor--ready-times (make-hash-table :test 'equal))
         (supervisor--restart-times (make-hash-table :test 'equal))
         (supervisor--restart-timers (make-hash-table :test 'equal))
         (supervisor--logging (make-hash-table :test 'equal))
         (supervisor--shutting-down nil)
         (proc (start-process "test-exit" nil "true")))
    (puthash "test-exit" proc supervisor--processes)
    (set-process-sentinel proc
                          (supervisor--make-process-sentinel
                           "test-exit" "true" nil 'simple 'no))
    ;; Wait for process to exit
    (while (process-live-p proc)
      (accept-process-output nil 0.01))
    (accept-process-output nil 0.05)
    ;; Verify exit info was recorded
    (let ((info (gethash "test-exit" supervisor--last-exit-info)))
      (should info)
      (should (eq 'exited (plist-get info :status)))
      (should (= 0 (plist-get info :code)))
      (should (numberp (plist-get info :timestamp))))))

(ert-deftest supervisor-test-telemetry-uptime-running ()
  "Uptime returns seconds for running process."
  (let ((supervisor--start-times (make-hash-table :test 'equal))
        (supervisor--processes (make-hash-table :test 'equal))
        (proc (start-process "uptime-test" nil "sleep" "300")))
    (unwind-protect
        (progn
          (puthash "uptime-test" (float-time) supervisor--start-times)
          (puthash "uptime-test" proc supervisor--processes)
          (let ((uptime (supervisor--telemetry-uptime "uptime-test")))
            (should uptime)
            (should (>= uptime 0))))
      (delete-process proc))))

(ert-deftest supervisor-test-telemetry-uptime-nil-when-not-running ()
  "Uptime returns nil when process is not running."
  (let ((supervisor--start-times (make-hash-table :test 'equal))
        (supervisor--processes (make-hash-table :test 'equal)))
    (puthash "dead-svc" (float-time) supervisor--start-times)
    (should-not (supervisor--telemetry-uptime "dead-svc"))))

(ert-deftest supervisor-test-telemetry-restart-count ()
  "Restart count reflects recent restarts in window."
  (let ((supervisor--restart-times (make-hash-table :test 'equal))
        (supervisor-restart-window 300))
    ;; No restarts
    (should (= 0 (supervisor--telemetry-restart-count "svc")))
    ;; Two recent restarts
    (puthash "svc" (list (float-time) (- (float-time) 10))
             supervisor--restart-times)
    (should (= 2 (supervisor--telemetry-restart-count "svc")))
    ;; Old restart outside window
    (puthash "svc" (list (- (float-time) 999))
             supervisor--restart-times)
    (should (= 0 (supervisor--telemetry-restart-count "svc")))))

(ert-deftest supervisor-test-telemetry-last-exit-format ()
  "Last exit returns formatted string."
  (let ((supervisor--last-exit-info (make-hash-table :test 'equal)))
    ;; No exit
    (should-not (supervisor--telemetry-last-exit "svc"))
    ;; Clean exit
    (puthash "svc" (list :status 'exited :code 0 :timestamp (float-time))
             supervisor--last-exit-info)
    (should (string= "exited successfully"
                      (supervisor--telemetry-last-exit "svc")))
    ;; Non-zero exit
    (puthash "svc" (list :status 'exited :code 1 :timestamp (float-time))
             supervisor--last-exit-info)
    (should (string= "exited with code 1"
                      (supervisor--telemetry-last-exit "svc")))
    ;; Signal
    (puthash "svc" (list :status 'signal :code 15 :timestamp (float-time))
             supervisor--last-exit-info)
    (should (string= "killed by signal 15"
                      (supervisor--telemetry-last-exit "svc")))))

(ert-deftest supervisor-test-telemetry-process-metrics-nil-graceful ()
  "Process metrics returns nil gracefully for non-existent PID."
  (should-not (supervisor--telemetry-process-metrics 999999999)))

(ert-deftest supervisor-test-telemetry-log-tail-missing ()
  "Log tail returns nil for non-existent log file."
  (let ((supervisor-log-directory "/tmp/nonexistent-sv-logs"))
    (should-not (supervisor--telemetry-log-tail "svc"))))

(ert-deftest supervisor-test-snapshot-includes-last-exit-info ()
  "Snapshot struct includes `last-exit-info' field."
  (let ((supervisor--processes (make-hash-table :test 'equal))
        (supervisor--failed (make-hash-table :test 'equal))
        (supervisor--oneshot-completed (make-hash-table :test 'equal))
        (supervisor--entry-state (make-hash-table :test 'equal))
        (supervisor--invalid (make-hash-table :test 'equal))
        (supervisor--enabled-override (make-hash-table :test 'equal))
        (supervisor--restart-override (make-hash-table :test 'equal))
        (supervisor--logging (make-hash-table :test 'equal))
        (supervisor--mask-override (make-hash-table :test 'equal))
        (supervisor--manually-started (make-hash-table :test 'equal))
        (supervisor--manually-stopped (make-hash-table :test 'equal))
        (supervisor--remain-active (make-hash-table :test 'equal))
        (supervisor--last-exit-info (make-hash-table :test 'equal)))
    ;; Put exit info in the hash
    (puthash "svc" (list :status 'exited :code 42 :timestamp 1000.0)
             supervisor--last-exit-info)
    (let ((snapshot (supervisor--build-snapshot)))
      ;; Verify the snapshot captured it
      (should (supervisor-snapshot-last-exit-info snapshot))
      (let ((info (gethash "svc" (supervisor-snapshot-last-exit-info snapshot))))
        (should info)
        (should (eq 'exited (plist-get info :status)))
        (should (= 42 (plist-get info :code)))))))

(ert-deftest supervisor-test-format-duration ()
  "Duration formatting produces human-readable strings."
  (should (string= "5s" (supervisor--describe-format-duration 5)))
  (should (string= "2m30s" (supervisor--describe-format-duration 150)))
  (should (string= "1h30m" (supervisor--describe-format-duration 5400)))
  (should (string= "2d3h" (supervisor--describe-format-duration 183600))))

(ert-deftest supervisor-test-cli-format-duration ()
  "CLI duration formatting produces human-readable strings."
  (should (string= "5s" (supervisor--cli-format-duration 5)))
  (should (string= "2m30s" (supervisor--cli-format-duration 150)))
  (should (string= "1h30m" (supervisor--cli-format-duration 5400)))
  (should (string= "2d3h" (supervisor--cli-format-duration 183600))))

(ert-deftest supervisor-test-set-logging-saves-overrides ()
  "Dashboard set-logging calls `supervisor--save-overrides'."
  (let* ((supervisor--processes (make-hash-table :test 'equal))
         (supervisor--failed (make-hash-table :test 'equal))
         (supervisor--restart-override (make-hash-table :test 'equal))
         (supervisor--enabled-override (make-hash-table :test 'equal))
         (supervisor--mask-override (make-hash-table :test 'equal))
         (supervisor--entry-state (make-hash-table :test 'equal))
         (supervisor--invalid (make-hash-table :test 'equal))
         (supervisor--manually-stopped (make-hash-table :test 'equal))
         (supervisor--manually-started (make-hash-table :test 'equal))
         (supervisor--oneshot-completed (make-hash-table :test 'equal))
         (supervisor--remain-active (make-hash-table :test 'equal))
         (supervisor--last-exit-info (make-hash-table :test 'equal))
         (supervisor--start-times (make-hash-table :test 'equal))
         (supervisor--ready-times (make-hash-table :test 'equal))
         (supervisor--restart-times (make-hash-table :test 'equal))
         (supervisor--restart-timers (make-hash-table :test 'equal))
         (supervisor--logging (make-hash-table :test 'equal))
         (supervisor--logging-override (make-hash-table :test 'equal))
         (supervisor-overrides-file nil)
         (saved nil)
         (entry (supervisor--parse-entry
                 '("cmd" :id "svc" :type simple :logging))))
    (cl-letf (((symbol-function 'tabulated-list-get-id) (lambda () (cons :service "svc")))
              ((symbol-function 'supervisor--get-entry-for-id)
               (lambda (_id) entry))
              ((symbol-function 'supervisor--save-overrides)
               (lambda () (setq saved t)))
              ((symbol-function 'supervisor--refresh-dashboard) #'ignore)
              ((symbol-function 'completing-read)
               (lambda (_prompt _coll &rest _) "off")))
      (supervisor-dashboard-set-logging)
      (should saved))))

(ert-deftest supervisor-test-cli-entry-info-telemetry-fields ()
  "CLI entry-info includes telemetry fields."
  (let* ((supervisor--processes (make-hash-table :test 'equal))
         (supervisor--failed (make-hash-table :test 'equal))
         (supervisor--restart-override (make-hash-table :test 'equal))
         (supervisor--enabled-override (make-hash-table :test 'equal))
         (supervisor--mask-override (make-hash-table :test 'equal))
         (supervisor--entry-state (make-hash-table :test 'equal))
         (supervisor--invalid (make-hash-table :test 'equal))
         (supervisor--manually-stopped (make-hash-table :test 'equal))
         (supervisor--manually-started (make-hash-table :test 'equal))
         (supervisor--oneshot-completed (make-hash-table :test 'equal))
         (supervisor--remain-active (make-hash-table :test 'equal))
         (supervisor--last-exit-info (make-hash-table :test 'equal))
         (supervisor--start-times (make-hash-table :test 'equal))
         (supervisor--ready-times (make-hash-table :test 'equal))
         (supervisor--restart-times (make-hash-table :test 'equal))
         (supervisor--restart-timers (make-hash-table :test 'equal))
         (supervisor--logging (make-hash-table :test 'equal))
         (entry (supervisor--parse-entry
                 '("cmd" :id "svc" :type simple :restart always))))
    ;; Add some exit info
    (puthash "svc" (list :status 'exited :code 1 :timestamp (float-time))
             supervisor--last-exit-info)
    (puthash "svc" (list (float-time)) supervisor--restart-times)
    (let ((info (supervisor--cli-entry-info entry)))
      (should (assq 'uptime info))
      (should (assq 'restart-count info))
      (should (assq 'last-exit info))
      (should (assq 'next-restart-eta info))
      (should (assq 'metrics info))
      ;; Verify last-exit was populated
      (let ((exit-info (alist-get 'last-exit info)))
        (should exit-info)
        (should (eq 'exited (plist-get exit-info :status))))
      ;; Verify restart count
      (should (= 1 (alist-get 'restart-count info))))))

;;; Core Policy Mutator Tests

(ert-deftest supervisor-test-policy-enable-sets-override ()
  "Core enable mutator sets override for disabled entry."
  (supervisor-test-with-unit-files
      '(("sleep 300" :id "svc" :type simple :enabled nil))
    (let ((supervisor--enabled-override (make-hash-table :test 'equal))
          (supervisor--mask-override (make-hash-table :test 'equal))
          (supervisor--invalid (make-hash-table :test 'equal))
          (supervisor-overrides-file nil))
      (let ((result (supervisor--policy-enable "svc")))
        (should (eq 'applied (plist-get result :status)))
        (should (eq 'enabled (gethash "svc" supervisor--enabled-override)))))))

(ert-deftest supervisor-test-policy-enable-skips-already-enabled ()
  "Core enable mutator returns skipped for already-enabled entry."
  (supervisor-test-with-unit-files
      '(("sleep 300" :id "svc" :type simple))
    (let ((supervisor--enabled-override (make-hash-table :test 'equal))
          (supervisor--mask-override (make-hash-table :test 'equal))
          (supervisor--invalid (make-hash-table :test 'equal))
          (supervisor-overrides-file nil))
      (let ((result (supervisor--policy-enable "svc")))
        (should (eq 'skipped (plist-get result :status)))))))

(ert-deftest supervisor-test-policy-enable-clears-stale-override ()
  "Core enable mutator clears override when config default is enabled."
  (supervisor-test-with-unit-files
      '(("sleep 300" :id "svc" :type simple))
    (let ((supervisor--enabled-override (make-hash-table :test 'equal))
          (supervisor--mask-override (make-hash-table :test 'equal))
          (supervisor--invalid (make-hash-table :test 'equal))
          (supervisor-overrides-file nil))
      ;; Disable via override, then re-enable
      (puthash "svc" 'disabled supervisor--enabled-override)
      (let ((result (supervisor--policy-enable "svc")))
        (should (eq 'applied (plist-get result :status)))
        ;; Override cleared (config default is enabled)
        (should-not (gethash "svc" supervisor--enabled-override))))))

(ert-deftest supervisor-test-policy-disable-normalization ()
  "Core disable mutator clears override when config default is disabled."
  (supervisor-test-with-unit-files
      '(("sleep 300" :id "svc" :type simple :enabled nil))
    (let ((supervisor--enabled-override (make-hash-table :test 'equal))
          (supervisor--mask-override (make-hash-table :test 'equal))
          (supervisor--invalid (make-hash-table :test 'equal))
          (supervisor-overrides-file nil))
      ;; Enable via override, then disable
      (puthash "svc" 'enabled supervisor--enabled-override)
      (let ((result (supervisor--policy-disable "svc")))
        (should (eq 'applied (plist-get result :status)))
        ;; Override cleared (config default is disabled)
        (should-not (gethash "svc" supervisor--enabled-override))))))

(ert-deftest supervisor-test-policy-enable-rejects-invalid ()
  "Core enable mutator rejects invalid entries."
  (supervisor-test-with-unit-files
      '(("sleep 300" :id "svc" :type simple))
    (let ((supervisor--enabled-override (make-hash-table :test 'equal))
          (supervisor--mask-override (make-hash-table :test 'equal))
          (supervisor--invalid (make-hash-table :test 'equal))
          (supervisor-overrides-file nil))
      (puthash "svc" "bad type" supervisor--invalid)
      (let ((result (supervisor--policy-enable "svc")))
        (should (eq 'error (plist-get result :status)))))))

(ert-deftest supervisor-test-policy-enable-rejects-unknown ()
  "Core enable mutator rejects unknown entry ID."
  (supervisor-test-with-unit-files
      '(("sleep 300" :id "svc" :type simple))
    (let ((supervisor--enabled-override (make-hash-table :test 'equal))
          (supervisor--mask-override (make-hash-table :test 'equal))
          (supervisor--invalid (make-hash-table :test 'equal))
          (supervisor-overrides-file nil))
      (let ((result (supervisor--policy-enable "nonexistent")))
        (should (eq 'error (plist-get result :status)))
        (should (string-match-p "Unknown" (plist-get result :message)))))))

(ert-deftest supervisor-test-policy-mask-idempotent ()
  "Core mask mutator returns skipped when already masked."
  (supervisor-test-with-unit-files
      '(("sleep 300" :id "svc" :type simple))
    (let ((supervisor--mask-override (make-hash-table :test 'equal))
          (supervisor--invalid (make-hash-table :test 'equal))
          (supervisor-overrides-file nil))
      (puthash "svc" 'masked supervisor--mask-override)
      (let ((result (supervisor--policy-mask "svc")))
        (should (eq 'skipped (plist-get result :status)))))))

(ert-deftest supervisor-test-policy-unmask-idempotent ()
  "Core unmask mutator returns skipped when not masked."
  (supervisor-test-with-unit-files
      '(("sleep 300" :id "svc" :type simple))
    (let ((supervisor--mask-override (make-hash-table :test 'equal))
          (supervisor--invalid (make-hash-table :test 'equal))
          (supervisor-overrides-file nil))
      (let ((result (supervisor--policy-unmask "svc")))
        (should (eq 'skipped (plist-get result :status)))))))

(ert-deftest supervisor-test-policy-restart-rejects-oneshot ()
  "Core restart-policy mutator rejects oneshot entries."
  (supervisor-test-with-unit-files
      '(("true" :id "svc" :type oneshot))
    (let ((supervisor--restart-override (make-hash-table :test 'equal))
          (supervisor--invalid (make-hash-table :test 'equal))
          (supervisor-overrides-file nil))
      (let ((result (supervisor--policy-set-restart "svc" 'always)))
        (should (eq 'error (plist-get result :status)))
        (should (string-match-p "oneshot" (plist-get result :message)))))))

(ert-deftest supervisor-test-policy-restart-normalizes-config ()
  "Core restart-policy mutator clears override matching config."
  (supervisor-test-with-unit-files
      '(("sleep 300" :id "svc" :type simple :restart t))
    (let ((supervisor--restart-override (make-hash-table :test 'equal))
          (supervisor--restart-timers (make-hash-table :test 'equal))
          (supervisor--invalid (make-hash-table :test 'equal))
          (supervisor-overrides-file nil))
      ;; Setting to 'always matches config default (t normalizes to always)
      (let ((result (supervisor--policy-set-restart "svc" 'always)))
        (should (eq 'applied (plist-get result :status)))
        ;; Override cleared since it matches config
        (should-not (gethash "svc" supervisor--restart-override))))))

(ert-deftest supervisor-test-policy-logging-normalizes-config ()
  "Core logging mutator clears override matching config default."
  (supervisor-test-with-unit-files
      '(("sleep 300" :id "svc" :type simple))
    (let ((supervisor--logging (make-hash-table :test 'equal))
          (supervisor--invalid (make-hash-table :test 'equal))
          (supervisor-overrides-file nil))
      ;; Config default is logging=t; setting on matches
      (let ((result (supervisor--policy-set-logging "svc" t)))
        (should (eq 'applied (plist-get result :status)))
        (should-not (gethash "svc" supervisor--logging))))))

(ert-deftest supervisor-test-cli-policy-batch-reports-errors ()
  "CLI policy batch reports errors for unknown entries."
  (supervisor-test-with-unit-files
      '(("sleep 300" :id "svc" :type simple :enabled nil))
    (let ((supervisor--enabled-override (make-hash-table :test 'equal))
          (supervisor-overrides-file nil))
      (let ((result (supervisor--cli-dispatch
                     '("enable" "svc" "bogus" "--json"))))
        ;; Should fail because of unknown entry
        (should (= supervisor-cli-exit-failure
                    (supervisor-cli-result-exitcode result)))
        ;; But svc should still be enabled
        (should (eq 'enabled
                    (gethash "svc" supervisor--enabled-override)))))))

;;; P5 Telemetry Presentation Tests

(ert-deftest supervisor-test-telemetry-process-tree-no-children ()
  "Process tree returns nil when PID has no children."
  (let ((proc (start-process "tree-test" nil "sleep" "300")))
    (unwind-protect
        (let ((pid (process-id proc)))
          ;; A bare sleep process has no children
          (should-not (supervisor--telemetry-process-tree pid)))
      (delete-process proc))))

(ert-deftest supervisor-test-telemetry-process-tree-bogus-pid ()
  "Process tree returns nil for non-existent PID."
  (should-not (supervisor--telemetry-process-tree 999999999)))

(ert-deftest supervisor-test-telemetry-process-metrics-thcount ()
  "Process metrics includes :thcount when available."
  (let ((proc (start-process "thcount-test" nil "sleep" "300")))
    (unwind-protect
        (let* ((pid (process-id proc))
               (metrics (supervisor--telemetry-process-metrics pid)))
          ;; We can only verify the plist structure, not the exact value,
          ;; since not all OSes provide thcount
          (when metrics
            (should (listp metrics))))
      (delete-process proc))))

(ert-deftest supervisor-test-cli-entry-info-log-tail ()
  "Entry info includes log-tail field."
  (let ((entry (supervisor--parse-entry '("cmd" :id "svc"))))
    (let ((info (supervisor--cli-entry-info entry)))
      (should (assq 'log-tail info)))))

(ert-deftest supervisor-test-cli-entry-info-process-tree ()
  "Entry info includes process-tree field."
  (let ((entry (supervisor--parse-entry '("cmd" :id "svc"))))
    (let ((info (supervisor--cli-entry-info entry)))
      (should (assq 'process-tree info)))))

(ert-deftest supervisor-test-cli-entry-info-authority-tier ()
  "Entry info includes authority-tier field."
  (let ((entry (supervisor--parse-entry '("cmd" :id "svc"))))
    (let ((info (supervisor--cli-entry-info entry)))
      (should (assq 'authority-tier info)))))

(ert-deftest supervisor-test-cli-describe-human-log-tail ()
  "Describe human output includes log tail when present."
  (let ((info '((id . "svc") (type . simple) (stage . stage1)
                (enabled . t) (enabled-config . t)
                (restart . always) (restart-config . always)
                (logging . t) (logging-config . t)
                (delay . 0) (after . nil) (requires . nil)
                (status . "running") (reason . nil)
                (pid . nil) (start-time . nil) (ready-time . nil)
                (duration . nil)
                (log-tail . "line1\nline2\n"))))
    (let ((output (supervisor--cli-describe-human info)))
      (should (string-match-p "Recent log:" output))
      (should (string-match-p "line1" output)))))

(ert-deftest supervisor-test-cli-describe-human-process-tree ()
  "Describe human output includes process tree when present."
  (let ((info '((id . "svc") (type . simple) (stage . stage1)
                (enabled . t) (enabled-config . t)
                (restart . always) (restart-config . always)
                (logging . t) (logging-config . t)
                (delay . 0) (after . nil) (requires . nil)
                (status . "running") (reason . nil)
                (pid . 1234) (start-time . nil) (ready-time . nil)
                (duration . nil)
                (process-tree . (:count 3 :pids (5678 5679 5680))))))
    (let ((output (supervisor--cli-describe-human info)))
      (should (string-match-p "Process tree: 3 descendants" output))
      (should (string-match-p "5678" output)))))

(ert-deftest supervisor-test-cli-describe-human-authority-tier ()
  "Describe human output shows tier when unit-file and tier are present."
  (let ((info '((id . "svc") (type . simple) (stage . stage1)
                (enabled . t) (enabled-config . t)
                (restart . always) (restart-config . always)
                (logging . t) (logging-config . t)
                (delay . 0) (after . nil) (requires . nil)
                (status . "running") (reason . nil)
                (pid . nil) (start-time . nil) (ready-time . nil)
                (duration . nil)
                (unit-file . "/etc/supervisor/svc.sv")
                (authority-tier . 2))))
    (let ((output (supervisor--cli-describe-human info)))
      (should (string-match-p "Unit file: /etc/supervisor/svc\\.sv (tier 2)" output)))))

(ert-deftest supervisor-test-cli-json-includes-log-tail ()
  "JSON output includes log_tail field."
  (let ((info '((id . "svc") (type . simple) (stage . stage1)
                (enabled . t) (status . "running")
                (restart . always) (logging . t)
                (pid . nil) (reason . nil) (delay . 0)
                (after . nil) (requires . nil)
                (log-tail . "hello\n"))))
    (let ((json (supervisor--cli-entry-to-json-obj info)))
      (should (equal "hello\n" (alist-get 'log_tail json))))))

(ert-deftest supervisor-test-cli-json-includes-process-tree ()
  "JSON output includes process_tree field."
  (let ((info '((id . "svc") (type . simple) (stage . stage1)
                (enabled . t) (status . "running")
                (restart . always) (logging . t)
                (pid . nil) (reason . nil) (delay . 0)
                (after . nil) (requires . nil)
                (process-tree . (:count 2 :pids (100 101))))))
    (let ((json (supervisor--cli-entry-to-json-obj info)))
      (let ((tree (alist-get 'process_tree json)))
        (should tree)
        (should (= 2 (alist-get 'count tree)))
        (should (equal '(100 101) (alist-get 'pids tree)))))))

(ert-deftest supervisor-test-cli-json-includes-authority-tier ()
  "JSON output includes authority_tier field."
  (let ((info '((id . "svc") (type . simple) (stage . stage1)
                (enabled . t) (status . "running")
                (restart . always) (logging . t)
                (pid . nil) (reason . nil) (delay . 0)
                (after . nil) (requires . nil)
                (authority-tier . 1))))
    (let ((json (supervisor--cli-entry-to-json-obj info)))
      (should (= 1 (alist-get 'authority_tier json))))))

;;; Dashboard Detail Rendering Tests

(ert-deftest supervisor-test-dashboard-describe-shows-process-tree ()
  "Dashboard detail view renders process-tree line when descendants exist."
  (let* ((entry (supervisor--parse-entry '("cmd" :id "svc")))
         (supervisor--processes (make-hash-table :test 'equal))
         (supervisor--failed (make-hash-table :test 'equal))
         (supervisor--restart-override (make-hash-table :test 'equal))
         (supervisor--enabled-override (make-hash-table :test 'equal))
         (supervisor--mask-override (make-hash-table :test 'equal))
         (supervisor--entry-state (make-hash-table :test 'equal))
         (supervisor--invalid (make-hash-table :test 'equal))
         (supervisor--manually-stopped (make-hash-table :test 'equal))
         (supervisor--manually-started (make-hash-table :test 'equal))
         (supervisor--oneshot-completed (make-hash-table :test 'equal))
         (supervisor--remain-active (make-hash-table :test 'equal))
         (supervisor--last-exit-info (make-hash-table :test 'equal))
         (supervisor--start-times (make-hash-table :test 'equal))
         (supervisor--ready-times (make-hash-table :test 'equal))
         (supervisor--restart-times (make-hash-table :test 'equal))
         (supervisor--restart-timers (make-hash-table :test 'equal))
         (supervisor--logging (make-hash-table :test 'equal))
         (supervisor--logging-override (make-hash-table :test 'equal))
         (fake-proc (start-process "tree-dash" nil "sleep" "300")))
    (unwind-protect
        (progn
          (puthash "svc" fake-proc supervisor--processes)
          (cl-letf (((symbol-function 'supervisor--unit-file-path)
                     (lambda (_id) nil))
                    ((symbol-function 'supervisor--telemetry-log-tail)
                     (lambda (_id &optional _lines) nil))
                    ((symbol-function 'supervisor--telemetry-process-tree)
                     (lambda (_pid) '(:count 3 :pids (100 101 102))))
                    ((symbol-function 'supervisor--telemetry-process-metrics)
                     (lambda (_pid) nil)))
            (supervisor--describe-entry-detail "svc" entry)
            (let ((info-buf (get-buffer "*supervisor-info*")))
              (unwind-protect
                  (let ((output (with-current-buffer info-buf
                                  (buffer-string))))
                    (should (string-match-p "Tree: 3 descendants" output))
                    (should (string-match-p "100, 101, 102" output)))
                (when info-buf (kill-buffer info-buf))))))
      (delete-process fake-proc))))

(ert-deftest supervisor-test-dashboard-describe-shows-etime-thcount ()
  "Dashboard detail view renders ETIME and TASKS in metrics line."
  (let* ((entry (supervisor--parse-entry '("cmd" :id "svc")))
         (supervisor--processes (make-hash-table :test 'equal))
         (supervisor--failed (make-hash-table :test 'equal))
         (supervisor--restart-override (make-hash-table :test 'equal))
         (supervisor--enabled-override (make-hash-table :test 'equal))
         (supervisor--mask-override (make-hash-table :test 'equal))
         (supervisor--entry-state (make-hash-table :test 'equal))
         (supervisor--invalid (make-hash-table :test 'equal))
         (supervisor--manually-stopped (make-hash-table :test 'equal))
         (supervisor--manually-started (make-hash-table :test 'equal))
         (supervisor--oneshot-completed (make-hash-table :test 'equal))
         (supervisor--remain-active (make-hash-table :test 'equal))
         (supervisor--last-exit-info (make-hash-table :test 'equal))
         (supervisor--start-times (make-hash-table :test 'equal))
         (supervisor--ready-times (make-hash-table :test 'equal))
         (supervisor--restart-times (make-hash-table :test 'equal))
         (supervisor--restart-timers (make-hash-table :test 'equal))
         (supervisor--logging (make-hash-table :test 'equal))
         (supervisor--logging-override (make-hash-table :test 'equal))
         (fake-proc (start-process "met-dash" nil "sleep" "300")))
    (unwind-protect
        (progn
          (puthash "svc" fake-proc supervisor--processes)
          (cl-letf (((symbol-function 'supervisor--unit-file-path)
                     (lambda (_id) nil))
                    ((symbol-function 'supervisor--telemetry-log-tail)
                     (lambda (_id &optional _lines) nil))
                    ((symbol-function 'supervisor--telemetry-process-tree)
                     (lambda (_pid) nil))
                    ((symbol-function 'supervisor--telemetry-process-metrics)
                     (lambda (_pid)
                       '(:rss 1024 :pcpu 5.0 :pmem 1.2
                         :etime 3661 :thcount 4))))
            (supervisor--describe-entry-detail "svc" entry)
            (let ((info-buf (get-buffer "*supervisor-info*")))
              (unwind-protect
                  (let ((output (with-current-buffer info-buf
                                  (buffer-string))))
                    (should (string-match-p "RSS=1024KB" output))
                    (should (string-match-p "ETIME=1h1m" output))
                    (should (string-match-p "TASKS=4" output)))
                (when info-buf (kill-buffer info-buf))))))
      (delete-process fake-proc))))

(ert-deftest supervisor-test-dashboard-describe-shows-authority-tier ()
  "Dashboard detail view appends tier to unit-file line."
  (let* ((entry (supervisor--parse-entry '("cmd" :id "svc")))
         (supervisor--processes (make-hash-table :test 'equal))
         (supervisor--failed (make-hash-table :test 'equal))
         (supervisor--restart-override (make-hash-table :test 'equal))
         (supervisor--enabled-override (make-hash-table :test 'equal))
         (supervisor--mask-override (make-hash-table :test 'equal))
         (supervisor--entry-state (make-hash-table :test 'equal))
         (supervisor--invalid (make-hash-table :test 'equal))
         (supervisor--manually-stopped (make-hash-table :test 'equal))
         (supervisor--manually-started (make-hash-table :test 'equal))
         (supervisor--oneshot-completed (make-hash-table :test 'equal))
         (supervisor--remain-active (make-hash-table :test 'equal))
         (supervisor--last-exit-info (make-hash-table :test 'equal))
         (supervisor--start-times (make-hash-table :test 'equal))
         (supervisor--ready-times (make-hash-table :test 'equal))
         (supervisor--restart-times (make-hash-table :test 'equal))
         (supervisor--restart-timers (make-hash-table :test 'equal))
         (supervisor--logging (make-hash-table :test 'equal))
         (supervisor--logging-override (make-hash-table :test 'equal)))
    (cl-letf (((symbol-function 'supervisor--unit-file-existing-path)
               (lambda (_id) "/etc/supervisor/svc.sv"))
              ((symbol-function 'supervisor--authority-tier-for-id)
               (lambda (_id) 2))
              ((symbol-function 'supervisor--telemetry-log-tail)
               (lambda (_id &optional _lines) nil)))
      (supervisor--describe-entry-detail "svc" entry)
      (let ((info-buf (get-buffer "*supervisor-info*")))
        (unwind-protect
            (let ((output (with-current-buffer info-buf
                            (buffer-string))))
              (should (string-match-p
                       "Unit file: /etc/supervisor/svc\\.sv (tier 2)"
                       output)))
          (when info-buf (kill-buffer info-buf)))))))

(ert-deftest supervisor-test-dashboard-describe-shows-log-tail ()
  "Dashboard detail view renders Recent log section."
  (let* ((entry (supervisor--parse-entry '("cmd" :id "svc")))
         (supervisor--processes (make-hash-table :test 'equal))
         (supervisor--failed (make-hash-table :test 'equal))
         (supervisor--restart-override (make-hash-table :test 'equal))
         (supervisor--enabled-override (make-hash-table :test 'equal))
         (supervisor--mask-override (make-hash-table :test 'equal))
         (supervisor--entry-state (make-hash-table :test 'equal))
         (supervisor--invalid (make-hash-table :test 'equal))
         (supervisor--manually-stopped (make-hash-table :test 'equal))
         (supervisor--manually-started (make-hash-table :test 'equal))
         (supervisor--oneshot-completed (make-hash-table :test 'equal))
         (supervisor--remain-active (make-hash-table :test 'equal))
         (supervisor--last-exit-info (make-hash-table :test 'equal))
         (supervisor--start-times (make-hash-table :test 'equal))
         (supervisor--ready-times (make-hash-table :test 'equal))
         (supervisor--restart-times (make-hash-table :test 'equal))
         (supervisor--restart-timers (make-hash-table :test 'equal))
         (supervisor--logging (make-hash-table :test 'equal))
         (supervisor--logging-override (make-hash-table :test 'equal)))
    (cl-letf (((symbol-function 'supervisor--unit-file-path)
               (lambda (_id) nil))
              ((symbol-function 'supervisor--telemetry-log-tail)
               (lambda (_id &optional _lines)
                 "2024-01-01 started\n2024-01-01 ready\n")))
      (supervisor--describe-entry-detail "svc" entry)
      (let ((info-buf (get-buffer "*supervisor-info*")))
        (unwind-protect
            (let ((output (with-current-buffer info-buf
                            (buffer-string))))
              (should (string-match-p "Recent log:" output))
              (should (string-match-p "2024-01-01 started" output))
              (should (string-match-p "2024-01-01 ready" output)))
          (when info-buf (kill-buffer info-buf)))))))

;;; User/Group Schema Tests (Phase 1)

(ert-deftest supervisor-test-parse-user-string ()
  "Parse entry accepts :user as string."
  (let ((entry (supervisor--parse-entry '("cmd" :id "svc" :user "postgres"))))
    (should (equal (supervisor-entry-user entry) "postgres"))
    (should-not (supervisor-entry-group entry))))

(ert-deftest supervisor-test-parse-user-integer ()
  "Parse entry accepts :user as integer."
  (let ((entry (supervisor--parse-entry '("cmd" :id "svc" :user 1000))))
    (should (= (supervisor-entry-user entry) 1000))))

(ert-deftest supervisor-test-parse-group-string ()
  "Parse entry accepts :group as string."
  (let ((entry (supervisor--parse-entry '("cmd" :id "svc" :group "www-data"))))
    (should (equal (supervisor-entry-group entry) "www-data"))
    (should-not (supervisor-entry-user entry))))

(ert-deftest supervisor-test-parse-group-integer ()
  "Parse entry accepts :group as integer."
  (let ((entry (supervisor--parse-entry '("cmd" :id "svc" :group 33))))
    (should (= (supervisor-entry-group entry) 33))))

(ert-deftest supervisor-test-parse-user-group-both ()
  "Parse entry accepts both :user and :group."
  (let ((entry (supervisor--parse-entry
                '("cmd" :id "svc" :user "postgres" :group "postgres"))))
    (should (equal (supervisor-entry-user entry) "postgres"))
    (should (equal (supervisor-entry-group entry) "postgres"))))

(ert-deftest supervisor-test-parse-user-nil-default ()
  "Parse entry defaults :user to nil when absent."
  (let ((entry (supervisor--parse-entry '("cmd" :id "svc"))))
    (should-not (supervisor-entry-user entry))
    (should-not (supervisor-entry-group entry))))

(ert-deftest supervisor-test-validate-user-invalid-symbol ()
  "Validation rejects :user as symbol."
  (should (string-match-p ":user must be"
                          (supervisor--validate-entry
                           '("cmd" :user postgres)))))

(ert-deftest supervisor-test-validate-user-invalid-list ()
  "Validation rejects :user as list."
  (should (string-match-p ":user must be"
                          (supervisor--validate-entry
                           '("cmd" :user ("a" "b"))))))

(ert-deftest supervisor-test-validate-group-invalid-symbol ()
  "Validation rejects :group as symbol."
  (should (string-match-p ":group must be"
                          (supervisor--validate-entry
                           '("cmd" :group www-data)))))

(ert-deftest supervisor-test-validate-group-invalid-list ()
  "Validation rejects :group as list."
  (should (string-match-p ":group must be"
                          (supervisor--validate-entry
                           '("cmd" :group (33 34))))))

(ert-deftest supervisor-test-validate-user-string-valid ()
  "Validation accepts :user as string."
  (should-not (supervisor--validate-entry '("cmd" :user "postgres"))))

(ert-deftest supervisor-test-validate-user-integer-valid ()
  "Validation accepts :user as integer."
  (should-not (supervisor--validate-entry '("cmd" :user 1000))))

(ert-deftest supervisor-test-validate-group-string-valid ()
  "Validation accepts :group as string."
  (should-not (supervisor--validate-entry '("cmd" :group "www-data"))))

(ert-deftest supervisor-test-validate-group-integer-valid ()
  "Validation accepts :group as integer."
  (should-not (supervisor--validate-entry '("cmd" :group 33))))

(ert-deftest supervisor-test-service-roundtrip-user-group ()
  "Service struct roundtrip preserves :user and :group."
  (let* ((entry (supervisor--parse-entry
                 '("cmd" :id "svc" :user "alice" :group 100)))
         (svc (supervisor-entry-to-service entry))
         (back (supervisor-service-to-entry svc)))
    (should (equal (supervisor-entry-user back) "alice"))
    (should (= (supervisor-entry-group back) 100))))

;;; Spawn Abstraction Tests (Phase 2)

(ert-deftest supervisor-test-build-launch-command-simple ()
  "Build launch command splits command string into args."
  (should (equal (supervisor--build-launch-command "sleep 300")
                 '("sleep" "300"))))

(ert-deftest supervisor-test-build-launch-command-quoted ()
  "Build launch command handles quoted arguments."
  (should (equal (supervisor--build-launch-command "echo \"hello world\"")
                 '("echo" "hello world"))))

(ert-deftest supervisor-test-build-launch-command-single ()
  "Build launch command handles single-word command."
  (should (equal (supervisor--build-launch-command "nginx")
                 '("nginx"))))

(ert-deftest supervisor-test-build-launch-command-user-only ()
  "Build launch command prepends helper with --user when user is set."
  (let ((supervisor-runas-command "/usr/libexec/supervisor-runas"))
    (let ((result (supervisor--build-launch-command "sleep 300" "alice" nil)))
      (should (equal (car result) "/usr/libexec/supervisor-runas"))
      (should (member "--user" result))
      (should (equal (nth (1+ (cl-position "--user" result :test #'equal))
                          result)
                     "alice"))
      (should (member "--" result))
      ;; Program after "--" is resolved to absolute path
      (should (string-suffix-p "sleep" (nth (1+ (cl-position "--" result
                                                             :test #'equal))
                                            result)))
      (should (equal (car (last result)) "300")))))

(ert-deftest supervisor-test-build-launch-command-group-only ()
  "Build launch command prepends helper with --group when group is set."
  (let ((supervisor-runas-command "/usr/libexec/supervisor-runas"))
    (let ((result (supervisor--build-launch-command "sleep 300" nil "staff")))
      (should (equal (car result) "/usr/libexec/supervisor-runas"))
      (should (member "--group" result))
      (should (equal (nth (1+ (cl-position "--group" result :test #'equal))
                          result)
                     "staff"))
      (should (member "--" result)))))

(ert-deftest supervisor-test-build-launch-command-user-and-group ()
  "Build launch command prepends helper with both --user and --group."
  (let ((supervisor-runas-command "/usr/libexec/supervisor-runas"))
    (let ((result (supervisor--build-launch-command "echo hi" "postgres" "postgres")))
      (should (equal (car result) "/usr/libexec/supervisor-runas"))
      (should (member "--user" result))
      (should (member "--group" result))
      (should (member "--" result)))))

(ert-deftest supervisor-test-build-launch-command-integer-uid ()
  "Build launch command converts integer uid to string for helper."
  (let ((supervisor-runas-command "/usr/libexec/supervisor-runas"))
    (let ((result (supervisor--build-launch-command "sleep 300" 1000 33)))
      (should (equal (nth (1+ (cl-position "--user" result :test #'equal))
                          result)
                     "1000"))
      (should (equal (nth (1+ (cl-position "--group" result :test #'equal))
                          result)
                     "33")))))

(ert-deftest supervisor-test-build-launch-command-no-wrapper-nil ()
  "Build launch command returns plain args when user and group are nil."
  (should (equal (supervisor--build-launch-command "sleep 300" nil nil)
                 '("sleep" "300"))))

(ert-deftest supervisor-test-shell-metachar-p ()
  "Detect shell metacharacters in command strings."
  (should (supervisor--shell-metachar-p "cmd1 && cmd2"))
  (should (supervisor--shell-metachar-p "cmd1 || cmd2"))
  (should (supervisor--shell-metachar-p "cmd1 | cmd2"))
  (should (supervisor--shell-metachar-p "cmd1 ; cmd2"))
  (should (supervisor--shell-metachar-p "cmd > file"))
  (should (supervisor--shell-metachar-p "cmd < file"))
  (should (supervisor--shell-metachar-p "echo $HOME"))
  (should (supervisor--shell-metachar-p "echo `date`"))
  (should-not (supervisor--shell-metachar-p "sleep 300"))
  (should-not (supervisor--shell-metachar-p "/usr/bin/logrotate --log-dir /tmp")))

(ert-deftest supervisor-test-build-launch-command-shell-metachar ()
  "Build launch command wraps in sh -c when shell operators present."
  (let ((result (supervisor--build-launch-command "cmd1 && cmd2")))
    (should (equal (car result) shell-file-name))
    (should (equal (nth 1 result) shell-command-switch))
    (should (equal (nth 2 result) "cmd1 && cmd2"))))

(ert-deftest supervisor-test-build-launch-command-pipe ()
  "Build launch command wraps piped commands in sh -c."
  (let ((result (supervisor--build-launch-command "ls | grep foo")))
    (should (equal (car result) shell-file-name))
    (should (equal (nth 2 result) "ls | grep foo"))))

(ert-deftest supervisor-test-build-launch-command-no-shell-for-simple ()
  "Build launch command does not wrap simple commands in sh -c."
  (let ((result (supervisor--build-launch-command "sleep 300")))
    (should (equal result '("sleep" "300")))))

;;; supervisor-runas Helper Tests (Phase 3)
;;
;; These tests exercise the helper binary's error paths.
;; Full privilege-drop tests require root and are gated by
;; SUPERVISOR_TEST_ROOT env var (not run in normal CI).

(defvar supervisor-test-runas-binary
  (expand-file-name "libexec/supervisor-runas"
                    (file-name-directory (or load-file-name
                                             buffer-file-name
                                             default-directory)))
  "Path to compiled supervisor-runas binary for testing.")

(ert-deftest supervisor-test-runas-missing-command ()
  "Helper exits 111 when no command is given after \"--\"."
  (skip-unless (file-executable-p supervisor-test-runas-binary))
  (with-temp-buffer
    (let ((code (call-process supervisor-test-runas-binary nil t nil
                              "--user" "nobody")))
      (should (= code 111)))))

(ert-deftest supervisor-test-runas-no-identity ()
  "Helper exits 111 when neither --user nor --group is specified."
  (skip-unless (file-executable-p supervisor-test-runas-binary))
  (with-temp-buffer
    (let ((code (call-process supervisor-test-runas-binary nil t nil
                              "--" "echo" "hi")))
      (should (= code 111)))))

(ert-deftest supervisor-test-runas-unknown-user ()
  "Helper exits 112 for unknown user name."
  (skip-unless (file-executable-p supervisor-test-runas-binary))
  (with-temp-buffer
    (let ((code (call-process supervisor-test-runas-binary nil t nil
                              "--user" "nonexistent_user_xyz_sv"
                              "--" "echo" "hi")))
      (should (= code 112))
      (should (string-match-p "unknown user"
                              (buffer-string))))))

(ert-deftest supervisor-test-runas-unknown-group ()
  "Helper exits 112 for unknown group name."
  (skip-unless (file-executable-p supervisor-test-runas-binary))
  (with-temp-buffer
    (let ((code (call-process supervisor-test-runas-binary nil t nil
                              "--group" "nonexistent_group_xyz_sv"
                              "--" "echo" "hi")))
      (should (= code 112))
      (should (string-match-p "unknown group"
                              (buffer-string))))))

(ert-deftest supervisor-test-runas-unknown-option ()
  "Helper exits 111 for unknown option."
  (skip-unless (file-executable-p supervisor-test-runas-binary))
  (with-temp-buffer
    (let ((code (call-process supervisor-test-runas-binary nil t nil
                              "--bogus" "--" "echo" "hi")))
      (should (= code 111)))))

(ert-deftest supervisor-test-runas-privdrop-fails-non-root ()
  "Helper exits 113 when non-root tries to drop to another user."
  (skip-unless (file-executable-p supervisor-test-runas-binary))
  (skip-unless (not (= (user-uid) 0)))
  (with-temp-buffer
    (let ((code (call-process supervisor-test-runas-binary nil t nil
                              "--user" "root" "--" "echo" "hi")))
      (should (= code 113)))))

(ert-deftest supervisor-test-runas-exec-fails-bare-name ()
  "Helper exits 114 when target is a bare name (execv has no PATH search)."
  (skip-unless (file-executable-p supervisor-test-runas-binary))
  ;; Use numeric uid/gid of current user to avoid initgroups permission error
  ;; on non-root.  On non-root this still fails at setgid, but if we are root
  ;; (CI lane) it reaches execv.  Use skip-unless to gate on root.
  (skip-unless (= (user-uid) 0))
  (skip-unless (getenv "SUPERVISOR_TEST_ROOT"))
  (with-temp-buffer
    (let ((code (call-process supervisor-test-runas-binary nil t nil
                              "--user" (number-to-string (user-uid))
                              "--" "nonexistent_binary_xyz")))
      (should (= code 114))
      (should (string-match-p "exec nonexistent_binary_xyz"
                              (buffer-string))))))

(ert-deftest supervisor-test-runas-root-success ()
  "Helper runs command as target user when invoked by root."
  (skip-unless (file-executable-p supervisor-test-runas-binary))
  (skip-unless (= (user-uid) 0))
  (skip-unless (getenv "SUPERVISOR_TEST_ROOT"))
  (with-temp-buffer
    (let ((code (call-process supervisor-test-runas-binary nil t nil
                              "--user" "nobody"
                              "--" "/usr/bin/id" "-u")))
      (should (= code 0))
      ;; nobody's uid is 65534 on most systems
      (should (string-match-p "^[0-9]+$"
                              (string-trim (buffer-string)))))))

(ert-deftest supervisor-test-build-launch-command-resolves-path ()
  "Build launch command resolves program to absolute path when wrapping."
  (let ((supervisor-runas-command "/usr/libexec/supervisor-runas"))
    (let ((result (supervisor--build-launch-command "sleep 300" "alice" nil)))
      ;; The program after "--" should be an absolute path
      (let ((cmd-after-sep (cdr (member "--" result))))
        (should cmd-after-sep)
        (should (file-name-absolute-p (car cmd-after-sep)))))))

;;;; Phase 4  Core integration (user/group threading)

(ert-deftest supervisor-test-start-process-nonroot-rejects-identity ()
  "Non-root supervisor returns nil when user/group identity is requested."
  (skip-unless (not (zerop (user-uid))))
  (let ((supervisor--processes (make-hash-table :test 'equal))
        (supervisor--restart-timers (make-hash-table :test 'equal))
        (supervisor--manually-stopped (make-hash-table :test 'equal))
        (supervisor--failed (make-hash-table :test 'equal))
        (supervisor--enabled-override (make-hash-table :test 'equal))
        (supervisor--shutting-down nil))
    ;; Should return nil because non-root cannot change identity
    (should-not (supervisor--start-process
                 "svc" "sleep 300" nil 'simple 'yes nil
                 nil nil nil nil nil "alice" nil))))

(ert-deftest supervisor-test-start-process-nonroot-rejects-group-only ()
  "Non-root supervisor returns nil when only group identity is requested."
  (skip-unless (not (zerop (user-uid))))
  (let ((supervisor--processes (make-hash-table :test 'equal))
        (supervisor--restart-timers (make-hash-table :test 'equal))
        (supervisor--manually-stopped (make-hash-table :test 'equal))
        (supervisor--failed (make-hash-table :test 'equal))
        (supervisor--enabled-override (make-hash-table :test 'equal))
        (supervisor--shutting-down nil))
    (should-not (supervisor--start-process
                 "svc" "sleep 300" nil 'simple 'yes nil
                 nil nil nil nil nil nil "staff"))))

(ert-deftest supervisor-test-start-process-nil-identity-ok-nonroot ()
  "Non-root supervisor starts normally when user/group are nil."
  (skip-unless (not (zerop (user-uid))))
  (let ((supervisor--processes (make-hash-table :test 'equal))
        (supervisor--restart-timers (make-hash-table :test 'equal))
        (supervisor--manually-stopped (make-hash-table :test 'equal))
        (supervisor--failed (make-hash-table :test 'equal))
        (supervisor--enabled-override (make-hash-table :test 'equal))
        (supervisor--shutting-down nil)
        (proc nil))
    (unwind-protect
        (progn
          (setq proc (supervisor--start-process
                      "svc-p4-test" "sleep 300" nil 'simple 'yes nil
                      nil nil nil nil nil nil nil))
          (should proc)
          (should (process-live-p proc)))
      (when (and proc (process-live-p proc))
        (delete-process proc)))))

(ert-deftest supervisor-test-manual-start-nonroot-rejects-identity ()
  "Manual start returns error when non-root and user/group set."
  (skip-unless (not (zerop (user-uid))))
  (supervisor-test-with-unit-files
      '(("sleep 300" :id "svc1" :user "alice"))
    (let* ((supervisor--processes (make-hash-table :test 'equal))
           (supervisor--restart-timers (make-hash-table :test 'equal))
           (supervisor--manually-stopped (make-hash-table :test 'equal))
           (supervisor--manually-started (make-hash-table :test 'equal))
           (supervisor--failed (make-hash-table :test 'equal))
           (supervisor--restart-times (make-hash-table :test 'equal))
           (supervisor--enabled-override (make-hash-table :test 'equal))
           (supervisor--mask-override (make-hash-table :test 'equal))
           (supervisor--oneshot-completed (make-hash-table :test 'equal))
           (supervisor--remain-active (make-hash-table :test 'equal))
           (supervisor--invalid (make-hash-table :test 'equal))
           (supervisor--cycle-fallback-ids (make-hash-table :test 'equal))
           (supervisor--computed-deps (make-hash-table :test 'equal))
           (supervisor--logging (make-hash-table :test 'equal)))
      (let ((result (supervisor--manual-start "svc1")))
        (should (eq (plist-get result :status) 'error))
        (should (string-match-p "identity change requires root"
                                (plist-get result :reason)))))))

(ert-deftest supervisor-test-dag-start-threads-user-group ()
  "DAG start passes user/group from entry through to start-process."
  (let* ((entry (supervisor--parse-entry
                 '("sleep 300" :id "svc1" :user "www-data" :group "www-data")))
         (supervisor--dag-started (make-hash-table :test 'equal))
         (supervisor--start-times (make-hash-table :test 'equal))
         (supervisor--dag-active-starts 0)
         (captured-user nil)
         (captured-group nil))
    (cl-letf (((symbol-function 'supervisor--start-process)
               (lambda (_id _cmd _log _type _restart &rest args)
                 ;; args = (is-restart wd env env-file restart-sec ufd user group)
                 ;; user is at position 6, group at 7
                 (setq captured-user (nth 6 args))
                 (setq captured-group (nth 7 args))
                 t))
              ((symbol-function 'supervisor--dag-handle-spawn-success) #'ignore)
              ((symbol-function 'executable-find) (lambda (_) t)))
      (supervisor--dag-do-start
       (supervisor-entry-id entry)
       (supervisor-entry-command entry)
       (supervisor-entry-logging-p entry)
       (supervisor-entry-stdout-log-file entry)
       (supervisor-entry-stderr-log-file entry)
       (supervisor-entry-type entry)
       (supervisor-entry-restart-policy entry)
       (supervisor-entry-oneshot-blocking entry)
       (supervisor-entry-oneshot-timeout entry)
       (supervisor-entry-working-directory entry)
       (supervisor-entry-environment entry)
       (supervisor-entry-environment-file entry)
       (supervisor-entry-restart-sec entry)
       nil  ; unit-file-directory
       "www-data"
       "www-data"))
    (should (equal captured-user "www-data"))
    (should (equal captured-group "www-data"))))

(ert-deftest supervisor-test-dag-start-entry-extracts-user-group ()
  "DAG start-entry-async extracts user/group from entry tuple."
  (let* ((entry (supervisor--parse-entry
                 '("sleep 300" :id "svc-ug" :user "postgres" :group "postgres")))
         (supervisor--dag-started (make-hash-table :test 'equal))
         (supervisor--dag-entries (make-hash-table :test 'equal))
         (supervisor--start-times (make-hash-table :test 'equal))
         (supervisor--dag-active-starts 0)
         (supervisor--enabled-override (make-hash-table :test 'equal))
         (supervisor--mask-override (make-hash-table :test 'equal))
         (supervisor--dag-delay-timers (make-hash-table :test 'equal))
         (supervisor--unit-file-dirs (make-hash-table :test 'equal))
         (captured-user nil)
         (captured-group nil))
    (puthash "svc-ug" entry supervisor--dag-entries)
    (cl-letf (((symbol-function 'supervisor--start-process)
               (lambda (_id _cmd _log _type _restart &rest args)
                 (setq captured-user (nth 6 args))
                 (setq captured-group (nth 7 args))
                 t))
              ((symbol-function 'supervisor--dag-handle-spawn-success) #'ignore)
              ((symbol-function 'executable-find) (lambda (_) t)))
      (supervisor--dag-start-entry-async entry))
    (should (equal captured-user "postgres"))
    (should (equal captured-group "postgres"))))

(ert-deftest supervisor-test-sentinel-preserves-identity-for-restart ()
  "Process sentinel forwards user/group to schedule-restart."
  (let* ((captured-user nil)
         (captured-group nil)
         (sentinel (supervisor--make-process-sentinel
                    "svc-rs" "sleep 300" nil 'simple 'yes
                    nil nil nil nil nil
                    "alice" "staff")))
    (cl-letf (((symbol-function 'supervisor--schedule-restart)
               (lambda (_id _cmd _log _type _restart _status _code &rest args)
                 ;; args = (wd env env-file restart-sec ufd user group)
                 (setq captured-user (nth 5 args))
                 (setq captured-group (nth 6 args))))
              ((symbol-function 'supervisor--should-restart-p) (lambda (&rest _) t))
              ((symbol-function 'supervisor--check-crash-loop) (lambda (_) nil))
              ((symbol-function 'supervisor--get-effective-restart)
               (lambda (_id _cfg) 'yes))
              ((symbol-function 'supervisor--maybe-refresh-dashboard) #'ignore)
              ((symbol-function 'supervisor--emit-event) #'ignore)
              ((symbol-function 'supervisor--get-entry-for-id) (lambda (_) nil)))
      (let* ((supervisor--processes (make-hash-table :test 'equal))
             (supervisor--last-exit-info (make-hash-table :test 'equal))
             (supervisor--shutting-down nil)
             (supervisor--manually-stopped (make-hash-table :test 'equal))
             (supervisor--enabled-override (make-hash-table :test 'equal))
             (supervisor--failed (make-hash-table :test 'equal))
             (proc (start-process "svc-rs" nil "sleep" "300")))
        (puthash "svc-rs" proc supervisor--processes)
        (unwind-protect
            (progn
              (delete-process proc)
              ;; Give sentinel time to fire
              (sleep-for 0.1)
              (funcall sentinel proc "finished\n")
              (should (equal captured-user "alice"))
              (should (equal captured-group "staff")))
          (when (process-live-p proc)
            (delete-process proc)))))))

(ert-deftest supervisor-test-build-launch-command-threads-through-start-process ()
  "Start-process passes user/group to build-launch-command."
  (let ((captured-user nil)
        (captured-group nil)
        (supervisor--processes (make-hash-table :test 'equal))
        (supervisor--restart-timers (make-hash-table :test 'equal))
        (supervisor--manually-stopped (make-hash-table :test 'equal))
        (supervisor--failed (make-hash-table :test 'equal))
        (supervisor--enabled-override (make-hash-table :test 'equal))
        (supervisor--shutting-down nil)
        (proc nil))
    ;; Mock user-uid to 0 and trust check so guards do not reject
    (cl-letf (((symbol-function 'user-uid) (lambda () 0))
              ((symbol-function 'supervisor--identity-source-trusted-p)
               (lambda (_id) t))
              ((symbol-function 'supervisor--build-launch-command)
               (lambda (cmd &optional user group _sandbox-entry)
                 (setq captured-user user)
                 (setq captured-group group)
                 (split-string-and-unquote cmd))))
      (unwind-protect
          (progn
            (setq proc (supervisor--start-process
                        "svc-blc" "sleep 300" nil 'simple 'yes nil
                        nil nil nil nil nil "bob" "users"))
            (should (equal captured-user "bob"))
            (should (equal captured-group "users")))
        (when (and proc (process-live-p proc))
          (delete-process proc))))))

;;;; Phase 5  Trust enforcement for identity-changing units

(ert-deftest supervisor-test-identity-trust-no-units-module ()
  "Trust check fails closed when units module is not loaded."
  (cl-letf (((symbol-function 'supervisor--unit-file-path)
             nil))
    (should-not (supervisor--identity-source-trusted-p "svc1"))))

(ert-deftest supervisor-test-identity-trust-no-unit-file ()
  "Trust check fails closed when unit file path is nil."
  (cl-letf (((symbol-function 'supervisor--unit-file-path)
             (lambda (_id) nil)))
    (should-not (supervisor--identity-source-trusted-p "svc1"))))

(ert-deftest supervisor-test-identity-trust-file-not-found ()
  "Trust check fails closed when unit file does not exist."
  (cl-letf (((symbol-function 'supervisor--unit-file-path)
             (lambda (_id) "/nonexistent/path/svc1.el")))
    (should-not (supervisor--identity-source-trusted-p "svc1"))))

(ert-deftest supervisor-test-identity-trust-non-root-owned ()
  "Trust check rejects unit file not owned by root."
  (skip-unless (not (zerop (user-uid))))
  (let ((temp-file (make-temp-file "trust-test-" nil ".el")))
    (unwind-protect
        (progn
          (with-temp-file temp-file
            (insert "(:id \"svc1\" :command \"echo hi\" :user \"alice\")\n"))
          (cl-letf (((symbol-function 'supervisor--unit-file-path)
                     (lambda (_id) temp-file)))
            ;; File is owned by current (non-root) user
            (should-not (supervisor--identity-source-trusted-p "svc1"))))
      (delete-file temp-file))))

(ert-deftest supervisor-test-identity-trust-world-writable ()
  "Trust check rejects world-writable unit file even if root-owned."
  (skip-unless (= (user-uid) 0))
  (skip-unless (getenv "SUPERVISOR_TEST_ROOT"))
  (let ((temp-file (make-temp-file "trust-test-" nil ".el")))
    (unwind-protect
        (progn
          (with-temp-file temp-file
            (insert "(:id \"svc1\" :command \"echo hi\" :user \"alice\")\n"))
          ;; Make world-writable
          (set-file-modes temp-file #o666)
          (cl-letf (((symbol-function 'supervisor--unit-file-path)
                     (lambda (_id) temp-file)))
            (should-not (supervisor--identity-source-trusted-p "svc1"))))
      (delete-file temp-file))))

(ert-deftest supervisor-test-identity-trust-root-owned-ok ()
  "Trust check accepts root-owned, non-world-writable unit file."
  (skip-unless (= (user-uid) 0))
  (skip-unless (getenv "SUPERVISOR_TEST_ROOT"))
  (let ((temp-file (make-temp-file "trust-test-" nil ".el")))
    (unwind-protect
        (progn
          (with-temp-file temp-file
            (insert "(:id \"svc1\" :command \"echo hi\" :user \"alice\")\n"))
          ;; Ensure proper mode (root-owned by default in root context)
          (set-file-modes temp-file #o644)
          (cl-letf (((symbol-function 'supervisor--unit-file-path)
                     (lambda (_id) temp-file)))
            (should (supervisor--identity-source-trusted-p "svc1"))))
      (delete-file temp-file))))

(ert-deftest supervisor-test-manual-start-root-untrusted-source ()
  "Manual start returns error when root but unit source is untrusted."
  (supervisor-test-with-unit-files
      '(("sleep 300" :id "svc1" :user "alice"))
    (let* ((supervisor--processes (make-hash-table :test 'equal))
           (supervisor--restart-timers (make-hash-table :test 'equal))
           (supervisor--manually-stopped (make-hash-table :test 'equal))
           (supervisor--manually-started (make-hash-table :test 'equal))
           (supervisor--failed (make-hash-table :test 'equal))
           (supervisor--restart-times (make-hash-table :test 'equal))
           (supervisor--enabled-override (make-hash-table :test 'equal))
           (supervisor--mask-override (make-hash-table :test 'equal))
           (supervisor--oneshot-completed (make-hash-table :test 'equal))
           (supervisor--remain-active (make-hash-table :test 'equal))
           (supervisor--invalid (make-hash-table :test 'equal))
           (supervisor--cycle-fallback-ids (make-hash-table :test 'equal))
           (supervisor--computed-deps (make-hash-table :test 'equal))
           (supervisor--logging (make-hash-table :test 'equal)))
      ;; Mock root euid, but trust check fails (file not root-owned)
      (cl-letf (((symbol-function 'user-uid) (lambda () 0))
                ((symbol-function 'supervisor--identity-source-trusted-p)
                 (lambda (_id) nil)))
        (let ((result (supervisor--manual-start "svc1")))
          (should (eq (plist-get result :status) 'error))
          (should (string-match-p "not trusted"
                                  (plist-get result :reason))))))))

(ert-deftest supervisor-test-manual-start-root-trusted-source ()
  "Manual start succeeds when root and unit source is trusted."
  (supervisor-test-with-unit-files
      '(("sleep 300" :id "svc1" :user "alice"))
    (let* ((supervisor--processes (make-hash-table :test 'equal))
           (supervisor--restart-timers (make-hash-table :test 'equal))
           (supervisor--manually-stopped (make-hash-table :test 'equal))
           (supervisor--manually-started (make-hash-table :test 'equal))
           (supervisor--failed (make-hash-table :test 'equal))
           (supervisor--restart-times (make-hash-table :test 'equal))
           (supervisor--enabled-override (make-hash-table :test 'equal))
           (supervisor--mask-override (make-hash-table :test 'equal))
           (supervisor--oneshot-completed (make-hash-table :test 'equal))
           (supervisor--remain-active (make-hash-table :test 'equal))
           (supervisor--invalid (make-hash-table :test 'equal))
           (supervisor--cycle-fallback-ids (make-hash-table :test 'equal))
           (supervisor--computed-deps (make-hash-table :test 'equal))
           (supervisor--logging (make-hash-table :test 'equal))
           (supervisor--spawn-failure-reason (make-hash-table :test 'equal))
           (supervisor--writers (make-hash-table :test 'equal))
           (fake-proc (start-process "svc1" nil "sleep" "300"))
           (proc nil))
      (unwind-protect
          ;; Mock root euid, trusted source, executable-find, and
          ;; make-process (runas binary is gitignored and absent in CI)
          (cl-letf (((symbol-function 'user-uid) (lambda () 0))
                    ((symbol-function 'supervisor--identity-source-trusted-p)
                     (lambda (_id) t))
                    ((symbol-function 'executable-find)
                     (lambda (_cmd) "/usr/bin/sleep"))
                    ((symbol-function 'make-process)
                     (lambda (&rest _args) fake-proc)))
            (let ((result (supervisor--manual-start "svc1")))
              (should (eq (plist-get result :status) 'started))
              (setq proc (gethash "svc1" supervisor--processes))))
        (when (process-live-p fake-proc)
          (delete-process fake-proc))))))

(ert-deftest supervisor-test-start-process-root-untrusted-blocked ()
  "Start-process returns nil when root but source untrusted."
  (let ((supervisor--processes (make-hash-table :test 'equal))
        (supervisor--restart-timers (make-hash-table :test 'equal))
        (supervisor--manually-stopped (make-hash-table :test 'equal))
        (supervisor--failed (make-hash-table :test 'equal))
        (supervisor--enabled-override (make-hash-table :test 'equal))
        (supervisor--shutting-down nil))
    (cl-letf (((symbol-function 'user-uid) (lambda () 0))
              ((symbol-function 'supervisor--identity-source-trusted-p)
               (lambda (_id) nil)))
      (should-not (supervisor--start-process
                   "svc" "sleep 300" nil 'simple 'yes nil
                   nil nil nil nil nil "alice" nil)))))

;;; Phase 7: Identity fields in CLI/dashboard detail surfaces

(ert-deftest supervisor-test-cli-entry-info-includes-user-group ()
  "Entry info alist includes user and group fields."
  (supervisor-test-with-unit-files
      '(("sleep 300" :id "svc" :type simple :user "alice" :group "staff"))
    (let* ((supervisor--processes (make-hash-table :test 'equal))
           (supervisor--entry-state (make-hash-table :test 'equal))
           (plan (supervisor--build-plan (supervisor--effective-programs)))
           (entry (car (supervisor-plan-entries plan)))
           (info (supervisor--cli-entry-info entry)))
      (should (equal "alice" (alist-get 'user info)))
      (should (equal "staff" (alist-get 'group info))))))

(ert-deftest supervisor-test-cli-entry-info-nil-user-group ()
  "Entry info alist has nil user and group when not set."
  (supervisor-test-with-unit-files
      '(("sleep 300" :id "svc" :type simple))
    (let* ((supervisor--processes (make-hash-table :test 'equal))
           (supervisor--entry-state (make-hash-table :test 'equal))
           (plan (supervisor--build-plan (supervisor--effective-programs)))
           (entry (car (supervisor-plan-entries plan)))
           (info (supervisor--cli-entry-info entry)))
      (should-not (alist-get 'user info))
      (should-not (alist-get 'group info)))))

(ert-deftest supervisor-test-cli-describe-human-shows-user-group ()
  "Human describe output includes User and Group lines."
  (supervisor-test-with-unit-files
      '(("sleep 300" :id "svc" :type simple :user "alice" :group "staff"))
    (let* ((supervisor--processes (make-hash-table :test 'equal))
           (supervisor--entry-state (make-hash-table :test 'equal))
           (plan (supervisor--build-plan (supervisor--effective-programs)))
           (entry (car (supervisor-plan-entries plan)))
           (info (supervisor--cli-entry-info entry))
           (output (supervisor--cli-describe-human info)))
      (should (string-match "User: alice" output))
      (should (string-match "Group: staff" output)))))

(ert-deftest supervisor-test-cli-describe-human-omits-user-when-nil ()
  "Human describe output omits User and Group lines when not set."
  (supervisor-test-with-unit-files
      '(("sleep 300" :id "svc" :type simple))
    (let* ((supervisor--processes (make-hash-table :test 'equal))
           (supervisor--entry-state (make-hash-table :test 'equal))
           (plan (supervisor--build-plan (supervisor--effective-programs)))
           (entry (car (supervisor-plan-entries plan)))
           (info (supervisor--cli-entry-info entry))
           (output (supervisor--cli-describe-human info)))
      (should-not (string-match "User:" output))
      (should-not (string-match "Group:" output)))))

(ert-deftest supervisor-test-cli-json-includes-user-group ()
  "JSON output includes user and group fields."
  (supervisor-test-with-unit-files
      '(("sleep 300" :id "svc" :type simple :user "bob" :group "wheel"))
    (let* ((supervisor--processes (make-hash-table :test 'equal))
           (supervisor--entry-state (make-hash-table :test 'equal))
           (plan (supervisor--build-plan (supervisor--effective-programs)))
           (entry (car (supervisor-plan-entries plan)))
           (info (supervisor--cli-entry-info entry))
           (json-obj (supervisor--cli-entry-to-json-obj info)))
      (should (equal "bob" (alist-get 'user json-obj)))
      (should (equal "wheel" (alist-get 'group json-obj))))))

(ert-deftest supervisor-test-cli-entry-info-sandbox-fields ()
  "CLI entry-info includes sandbox profile, effective network, and enabled."
  (let* ((supervisor--processes (make-hash-table :test 'equal))
         (supervisor--failed (make-hash-table :test 'equal))
         (supervisor--restart-override (make-hash-table :test 'equal))
         (supervisor--enabled-override (make-hash-table :test 'equal))
         (supervisor--mask-override (make-hash-table :test 'equal))
         (supervisor--entry-state (make-hash-table :test 'equal))
         (supervisor--invalid (make-hash-table :test 'equal))
         (supervisor--manually-stopped (make-hash-table :test 'equal))
         (supervisor--manually-started (make-hash-table :test 'equal))
         (supervisor--oneshot-completed (make-hash-table :test 'equal))
         (supervisor--remain-active (make-hash-table :test 'equal))
         (supervisor--last-exit-info (make-hash-table :test 'equal))
         (supervisor--start-times (make-hash-table :test 'equal))
         (supervisor--ready-times (make-hash-table :test 'equal))
         (supervisor--restart-times (make-hash-table :test 'equal))
         (supervisor--restart-timers (make-hash-table :test 'equal))
         (supervisor--logging (make-hash-table :test 'equal))
         (entry (supervisor--parse-entry
                 '("sleep 300" :id "svc" :sandbox-profile strict))))
    (let ((info (supervisor--cli-entry-info entry)))
      (should (eq 'strict (alist-get 'sandbox-profile info)))
      (should (eq 'isolated (alist-get 'sandbox-network info)))
      (should (eq t (alist-get 'sandbox-enabled info))))))

(ert-deftest supervisor-test-cli-entry-info-sandbox-disabled ()
  "CLI entry-info shows sandbox-enabled nil for non-sandbox entries."
  (let* ((supervisor--processes (make-hash-table :test 'equal))
         (supervisor--failed (make-hash-table :test 'equal))
         (supervisor--restart-override (make-hash-table :test 'equal))
         (supervisor--enabled-override (make-hash-table :test 'equal))
         (supervisor--mask-override (make-hash-table :test 'equal))
         (supervisor--entry-state (make-hash-table :test 'equal))
         (supervisor--invalid (make-hash-table :test 'equal))
         (supervisor--manually-stopped (make-hash-table :test 'equal))
         (supervisor--manually-started (make-hash-table :test 'equal))
         (supervisor--oneshot-completed (make-hash-table :test 'equal))
         (supervisor--remain-active (make-hash-table :test 'equal))
         (supervisor--last-exit-info (make-hash-table :test 'equal))
         (supervisor--start-times (make-hash-table :test 'equal))
         (supervisor--ready-times (make-hash-table :test 'equal))
         (supervisor--restart-times (make-hash-table :test 'equal))
         (supervisor--restart-timers (make-hash-table :test 'equal))
         (supervisor--logging (make-hash-table :test 'equal))
         (entry (supervisor--parse-entry '("sleep 300" :id "svc"))))
    (let ((info (supervisor--cli-entry-info entry)))
      (should-not (alist-get 'sandbox-enabled info)))))

(ert-deftest supervisor-test-cli-describe-human-sandbox-line ()
  "Human describe output includes sandbox line for sandbox entries."
  (let* ((supervisor--processes (make-hash-table :test 'equal))
         (supervisor--failed (make-hash-table :test 'equal))
         (supervisor--restart-override (make-hash-table :test 'equal))
         (supervisor--enabled-override (make-hash-table :test 'equal))
         (supervisor--mask-override (make-hash-table :test 'equal))
         (supervisor--entry-state (make-hash-table :test 'equal))
         (supervisor--invalid (make-hash-table :test 'equal))
         (supervisor--manually-stopped (make-hash-table :test 'equal))
         (supervisor--manually-started (make-hash-table :test 'equal))
         (supervisor--oneshot-completed (make-hash-table :test 'equal))
         (supervisor--remain-active (make-hash-table :test 'equal))
         (supervisor--last-exit-info (make-hash-table :test 'equal))
         (supervisor--start-times (make-hash-table :test 'equal))
         (supervisor--ready-times (make-hash-table :test 'equal))
         (supervisor--restart-times (make-hash-table :test 'equal))
         (supervisor--restart-timers (make-hash-table :test 'equal))
         (supervisor--logging (make-hash-table :test 'equal))
         (entry (supervisor--parse-entry
                 '("sleep 300" :id "svc" :sandbox-profile service
                   :sandbox-network shared))))
    (let* ((info (supervisor--cli-entry-info entry))
           (output (supervisor--cli-describe-human info)))
      (should (string-match-p "Sandbox: service (network shared)" output)))))

(ert-deftest supervisor-test-cli-describe-human-no-sandbox-line ()
  "Human describe output omits sandbox line for non-sandbox entries."
  (let* ((supervisor--processes (make-hash-table :test 'equal))
         (supervisor--failed (make-hash-table :test 'equal))
         (supervisor--restart-override (make-hash-table :test 'equal))
         (supervisor--enabled-override (make-hash-table :test 'equal))
         (supervisor--mask-override (make-hash-table :test 'equal))
         (supervisor--entry-state (make-hash-table :test 'equal))
         (supervisor--invalid (make-hash-table :test 'equal))
         (supervisor--manually-stopped (make-hash-table :test 'equal))
         (supervisor--manually-started (make-hash-table :test 'equal))
         (supervisor--oneshot-completed (make-hash-table :test 'equal))
         (supervisor--remain-active (make-hash-table :test 'equal))
         (supervisor--last-exit-info (make-hash-table :test 'equal))
         (supervisor--start-times (make-hash-table :test 'equal))
         (supervisor--ready-times (make-hash-table :test 'equal))
         (supervisor--restart-times (make-hash-table :test 'equal))
         (supervisor--restart-timers (make-hash-table :test 'equal))
         (supervisor--logging (make-hash-table :test 'equal))
         (entry (supervisor--parse-entry '("sleep 300" :id "svc"))))
    (let* ((info (supervisor--cli-entry-info entry))
           (output (supervisor--cli-describe-human info)))
      (should-not (string-match-p "Sandbox:" output)))))

(ert-deftest supervisor-test-cli-json-sandbox-fields ()
  "JSON output includes sandbox fields."
  (cl-letf (((symbol-function 'executable-find)
             (lambda (name) (when (equal name "bwrap") "/usr/bin/bwrap"))))
    (supervisor-test-with-unit-files
        '(("sleep 300" :id "svc" :type simple :sandbox-profile strict))
      (let* ((supervisor--processes (make-hash-table :test 'equal))
             (supervisor--entry-state (make-hash-table :test 'equal))
             (plan (supervisor--build-plan (supervisor--effective-programs)))
             (entry (car (supervisor-plan-entries plan)))
             (info (supervisor--cli-entry-info entry))
             (json-obj (supervisor--cli-entry-to-json-obj info)))
        (should (eq t (alist-get 'sandbox_enabled json-obj)))
        (should (equal "strict" (alist-get 'sandbox_profile json-obj)))
        (should (equal "isolated" (alist-get 'sandbox_network json-obj)))))))

(ert-deftest supervisor-test-cli-json-sandbox-disabled ()
  "JSON output shows sandbox_enabled false for non-sandbox entries."
  (supervisor-test-with-unit-files
      '(("sleep 300" :id "svc" :type simple))
    (let* ((supervisor--processes (make-hash-table :test 'equal))
           (supervisor--entry-state (make-hash-table :test 'equal))
           (plan (supervisor--build-plan (supervisor--effective-programs)))
           (entry (car (supervisor-plan-entries plan)))
           (info (supervisor--cli-entry-info entry))
           (json-obj (supervisor--cli-entry-to-json-obj info)))
      (should (eq :json-false (alist-get 'sandbox_enabled json-obj))))))

(ert-deftest supervisor-test-dashboard-detail-sandbox-indicator ()
  "Dashboard detail panel shows sandbox indicator for sandbox entries."
  (let* ((supervisor--processes (make-hash-table :test 'equal))
         (supervisor--failed (make-hash-table :test 'equal))
         (supervisor--restart-override (make-hash-table :test 'equal))
         (supervisor--enabled-override (make-hash-table :test 'equal))
         (supervisor--mask-override (make-hash-table :test 'equal))
         (supervisor--entry-state (make-hash-table :test 'equal))
         (supervisor--invalid (make-hash-table :test 'equal))
         (supervisor--manually-stopped (make-hash-table :test 'equal))
         (supervisor--manually-started (make-hash-table :test 'equal))
         (supervisor--oneshot-completed (make-hash-table :test 'equal))
         (supervisor--remain-active (make-hash-table :test 'equal))
         (supervisor--last-exit-info (make-hash-table :test 'equal))
         (supervisor--start-times (make-hash-table :test 'equal))
         (supervisor--ready-times (make-hash-table :test 'equal))
         (supervisor--restart-times (make-hash-table :test 'equal))
         (supervisor--restart-timers (make-hash-table :test 'equal))
         (supervisor--logging (make-hash-table :test 'equal))
         (supervisor--target-convergence (make-hash-table :test 'equal))
         (supervisor--target-convergence-reasons (make-hash-table :test 'equal))
         (supervisor--target-members (make-hash-table :test 'equal))
         (entry (supervisor--parse-entry
                 '("sleep 300" :id "svc" :sandbox-profile desktop))))
    (supervisor--describe-entry-detail "svc" entry)
    (unwind-protect
        (let ((output (with-current-buffer "*supervisor-info*"
                        (buffer-string))))
          (should (string-match-p "Sandbox: desktop (network shared)" output)))
      (when (get-buffer "*supervisor-info*")
        (kill-buffer "*supervisor-info*")))))

(ert-deftest supervisor-test-dashboard-detail-no-sandbox-for-plain ()
  "Dashboard detail panel omits sandbox indicator for plain entries."
  (let* ((supervisor--processes (make-hash-table :test 'equal))
         (supervisor--failed (make-hash-table :test 'equal))
         (supervisor--restart-override (make-hash-table :test 'equal))
         (supervisor--enabled-override (make-hash-table :test 'equal))
         (supervisor--mask-override (make-hash-table :test 'equal))
         (supervisor--entry-state (make-hash-table :test 'equal))
         (supervisor--invalid (make-hash-table :test 'equal))
         (supervisor--manually-stopped (make-hash-table :test 'equal))
         (supervisor--manually-started (make-hash-table :test 'equal))
         (supervisor--oneshot-completed (make-hash-table :test 'equal))
         (supervisor--remain-active (make-hash-table :test 'equal))
         (supervisor--last-exit-info (make-hash-table :test 'equal))
         (supervisor--start-times (make-hash-table :test 'equal))
         (supervisor--ready-times (make-hash-table :test 'equal))
         (supervisor--restart-times (make-hash-table :test 'equal))
         (supervisor--restart-timers (make-hash-table :test 'equal))
         (supervisor--logging (make-hash-table :test 'equal))
         (supervisor--target-convergence (make-hash-table :test 'equal))
         (supervisor--target-convergence-reasons (make-hash-table :test 'equal))
         (supervisor--target-members (make-hash-table :test 'equal))
         (entry (supervisor--parse-entry '("sleep 300" :id "svc"))))
    (supervisor--describe-entry-detail "svc" entry)
    (unwind-protect
        (let ((output (with-current-buffer "*supervisor-info*"
                        (buffer-string))))
          (should-not (string-match-p "Sandbox:" output)))
      (when (get-buffer "*supervisor-info*")
        (kill-buffer "*supervisor-info*")))))

(ert-deftest supervisor-test-spawn-failure-reason-identity-non-root ()
  "Spawn failure reason records identity context for non-root."
  (let ((supervisor--spawn-failure-reason (make-hash-table :test 'equal))
        (supervisor--processes (make-hash-table :test 'equal))
        (supervisor--failed (make-hash-table :test 'equal))
        (supervisor--restart-times (make-hash-table :test 'equal))
        (supervisor--restart-timers (make-hash-table :test 'equal))
        (supervisor--enabled-override (make-hash-table :test 'equal))
        (supervisor--manually-stopped (make-hash-table :test 'equal))
        (supervisor--start-times (make-hash-table :test 'equal))
        (supervisor--ready-times (make-hash-table :test 'equal))
        (supervisor--shutting-down nil))
    ;; Non-root check: user-uid returns non-zero for test runner
    (unless (zerop (user-uid))
      (supervisor--start-process
       "svc" "sleep 300" nil 'simple 'yes nil
       nil nil nil nil nil "alice" "staff")
      (let ((reason (gethash "svc" supervisor--spawn-failure-reason)))
        (should reason)
        (should (string-match "identity change requires root" reason))
        (should (string-match "user=alice" reason))
        (should (string-match "group=staff" reason))))))

(ert-deftest supervisor-test-compute-entry-reason-identity-context ()
  "Entry reason returns specific identity context instead of generic."
  (let ((supervisor--entry-state (make-hash-table :test 'equal))
        (supervisor--spawn-failure-reason (make-hash-table :test 'equal))
        (supervisor--mask-override (make-hash-table :test 'equal))
        (supervisor--processes (make-hash-table :test 'equal))
        (supervisor--failed (make-hash-table :test 'equal))
        (supervisor--oneshot-completed (make-hash-table :test 'equal)))
    (puthash "svc" 'failed-to-spawn supervisor--entry-state)
    (puthash "svc" "identity change requires root (user=alice group=staff)"
             supervisor--spawn-failure-reason)
    (let ((reason (supervisor--compute-entry-reason "svc" 'simple)))
      (should (string-match "identity change requires root" reason))
      (should (string-match "user=alice" reason)))))

(ert-deftest supervisor-test-compute-entry-reason-generic-spawn-failure ()
  "Entry reason returns generic message when no specific reason stored."
  (let ((supervisor--entry-state (make-hash-table :test 'equal))
        (supervisor--spawn-failure-reason (make-hash-table :test 'equal))
        (supervisor--mask-override (make-hash-table :test 'equal))
        (supervisor--processes (make-hash-table :test 'equal))
        (supervisor--failed (make-hash-table :test 'equal))
        (supervisor--oneshot-completed (make-hash-table :test 'equal)))
    (puthash "svc" 'failed-to-spawn supervisor--entry-state)
    (should (equal "failed-to-spawn"
                   (supervisor--compute-entry-reason "svc" 'simple)))))

(ert-deftest supervisor-test-reset-failed-clears-spawn-failure-reason ()
  "Reset-failed clears specific spawn failure reason."
  (let ((supervisor--failed (make-hash-table :test 'equal))
        (supervisor--restart-times (make-hash-table :test 'equal))
        (supervisor--spawn-failure-reason (make-hash-table :test 'equal))
        (supervisor--oneshot-completed (make-hash-table :test 'equal)))
    (puthash "svc" t supervisor--failed)
    (puthash "svc" "identity change requires root (user=alice group=nil)"
             supervisor--spawn-failure-reason)
    (supervisor--reset-failed "svc")
    (should-not (gethash "svc" supervisor--spawn-failure-reason))))

;;; Phase 8: reload path preserves configured identity

(ert-deftest supervisor-test-reload-running-simple-passes-user-group ()
  "Reload of a running simple unit threads user and group to start-process."
  (let ((supervisor--processes (make-hash-table :test 'equal))
        (supervisor--manually-stopped (make-hash-table :test 'equal))
        (supervisor--manually-started (make-hash-table :test 'equal))
        (supervisor--mask-override (make-hash-table :test 'equal))
        (supervisor--invalid (make-hash-table :test 'equal))
        (supervisor--failed (make-hash-table :test 'equal))
        (supervisor--restart-times (make-hash-table :test 'equal))
        (captured-user nil)
        (captured-group nil)
        (proc (start-process "test-reload-id" nil "sleep" "300")))
    (unwind-protect
        (progn
          (puthash "test-reload-id" proc supervisor--processes)
          ;; Legacy entry with :user / :group at trailing positions.
          (cl-letf (((symbol-function 'supervisor--reload-find-entry)
                     (lambda (_id)
                       (list "test-reload-id" "sleep 300" 0 t 'always t
                             'simple 'stage3 nil nil 30 nil nil
                             nil nil nil nil nil nil
                             nil nil nil nil nil nil nil nil
                             "webuser" "webgrp")))
                    ((symbol-function 'supervisor--manual-stop)
                     (lambda (_id)
                       (list :status 'stopped :reason nil)))
                    ((symbol-function 'supervisor--start-process)
                     (lambda (_id _cmd _logging _type _restart
                              &optional _is-restart _wd _env _ef _rs _ufd
                              user group _stdout-log-file _stderr-log-file
                              _sandbox-entry)
                       (setq captured-user user)
                       (setq captured-group group)
                       t))
                    ((symbol-function 'supervisor--unit-file-directory-for-id)
                     (lambda (_id) nil))
                    ((symbol-function 'executable-find)
                     (lambda (_cmd) "/usr/bin/sleep")))
            (let ((result (supervisor--reload-unit "test-reload-id")))
              (should (equal "reloaded" (plist-get result :action)))
              (should (equal "webuser" captured-user))
              (should (equal "webgrp" captured-group)))))
      (when (process-live-p proc)
        (delete-process proc)))))

;;; Logging config contract (PLAN-logging.md Phase 1)

(ert-deftest supervisor-test-logd-command-path ()
  "Log writer command path points to libexec/supervisor-logd."
  (should (stringp supervisor-logd-command))
  (should (string-match "libexec/supervisor-logd\\'" supervisor-logd-command)))

(ert-deftest supervisor-test-libexec-build-on-startup-default ()
  "Libexec helper build policy defaults to prompt."
  (should (eq 'prompt
              (default-value 'supervisor-libexec-build-on-startup))))

(ert-deftest supervisor-test-logrotate-command-path ()
  "Logrotate script path points to sbin/supervisor-logrotate."
  (should (stringp supervisor-logrotate-command))
  (should (string-match "sbin/supervisor-logrotate\\'" supervisor-logrotate-command)))

(ert-deftest supervisor-test-log-prune-command-path ()
  "Log prune script path points to sbin/supervisor-log-prune."
  (should (stringp supervisor-log-prune-command))
  (should (string-match "sbin/supervisor-log-prune\\'" supervisor-log-prune-command)))

(ert-deftest supervisor-test-logrotate-keep-days-default ()
  "Logrotate keep-days defaults to 14."
  (should (= 14 (default-value 'supervisor-logrotate-keep-days))))

(ert-deftest supervisor-test-logd-max-file-size-default ()
  "Log writer max file size defaults to 50 MiB."
  (should (= 52428800 (default-value 'supervisor-logd-max-file-size))))

(ert-deftest supervisor-test-log-prune-max-total-default ()
  "Log prune max total bytes defaults to 1 GiB."
  (should (= 1073741824 (default-value 'supervisor-log-prune-max-total-bytes))))

(ert-deftest supervisor-test-logd-prune-min-interval-default ()
  "Log writer prune throttle defaults to 60 seconds."
  (should (= 60 (default-value 'supervisor-logd-prune-min-interval))))

(ert-deftest supervisor-test-logd-pid-directory-default-nil ()
  "Log writer PID directory defaults to nil (falls back to log-directory)."
  (should-not (default-value 'supervisor-logd-pid-directory)))

(ert-deftest supervisor-test-libexec-pending-build-targets-missing-binary ()
  "Pending helper detection includes targets missing compiled binaries."
  (let* ((tmp (make-temp-file "sv-libexec-" t))
         (logd-bin (expand-file-name "supervisor-logd" tmp))
         (runas-bin (expand-file-name "supervisor-runas" tmp))
         (logd-src (concat logd-bin ".c"))
         (runas-src (concat runas-bin ".c")))
    (unwind-protect
        (progn
          (with-temp-file logd-src (insert "int main(void){return 0;}\n"))
          (with-temp-file runas-src (insert "int main(void){return 0;}\n"))
          (with-temp-file runas-bin (insert "binary"))
          (set-file-modes runas-bin #o755)
          ;; runas binary is newer than source, so only logd should be pending.
          (set-file-times runas-src
                          (time-subtract (current-time) (seconds-to-time 60)))
          (set-file-times runas-bin (current-time))
          (let ((supervisor-logd-command logd-bin)
                (supervisor-runas-command runas-bin))
            (let ((pending (supervisor--libexec-pending-build-targets)))
              (should (= 1 (length pending)))
              (should (equal "supervisor-logd"
                             (plist-get (car pending) :name))))))
      (delete-directory tmp t))))

(ert-deftest supervisor-test-libexec-pending-build-targets-missing-source ()
  "Pending helper detection includes missing binaries without sources."
  (let* ((tmp (make-temp-file "sv-libexec-" t))
         (logd-bin (expand-file-name "supervisor-logd" tmp))
         (runas-bin (expand-file-name "supervisor-runas" tmp)))
    (unwind-protect
        (let ((supervisor-logd-command logd-bin)
              (supervisor-runas-command runas-bin))
          (let ((pending (supervisor--libexec-pending-build-targets)))
            (should (= 2 (length pending)))
            (should (equal '("supervisor-logd" "supervisor-runas")
                           (mapcar (lambda (target)
                                     (plist-get target :name))
                                   pending)))))
      (delete-directory tmp t))))

(ert-deftest supervisor-test-build-libexec-helpers-invokes-compiler ()
  "Helper build path invokes the compiler for each pending source."
  (let* ((tmp (make-temp-file "sv-libexec-" t))
         (logd-bin (expand-file-name "supervisor-logd" tmp))
         (runas-bin (expand-file-name "supervisor-runas" tmp))
         (logd-src (concat logd-bin ".c"))
         (runas-src (concat runas-bin ".c"))
         (calls nil))
    (unwind-protect
        (progn
          (with-temp-file logd-src (insert "int main(void){return 0;}\n"))
          (with-temp-file runas-src (insert "int main(void){return 0;}\n"))
          (let ((supervisor-logd-command logd-bin)
                (supervisor-runas-command runas-bin))
            (cl-letf (((symbol-function 'supervisor--find-libexec-compiler)
                       (lambda () "cc-test"))
                      ((symbol-function 'call-process)
                       (lambda (program _infile destination _display &rest args)
                         (push (list :program program
                                     :destination destination
                                     :args args)
                               calls)
                         0)))
              (let ((result (supervisor-build-libexec-helpers)))
                (should (= 2 (plist-get result :attempted)))
                (should (= 2 (plist-get result :built)))
                (should-not (plist-get result :failed))
                (should (= 2 (length calls)))
                (dolist (call calls)
                  (should (equal "cc-test" (plist-get call :program)))
                  (should (eq t (plist-get call :destination))))))))
      (delete-directory tmp t))))

(ert-deftest supervisor-test-build-libexec-helpers-fails-without-compiler ()
  "Helper build returns failure when no compiler is available."
  (let* ((tmp (make-temp-file "sv-libexec-" t))
         (logd-bin (expand-file-name "supervisor-logd" tmp))
         (runas-bin (expand-file-name "supervisor-runas" tmp))
         (logd-src (concat logd-bin ".c"))
         (runas-src (concat runas-bin ".c")))
    (unwind-protect
        (progn
          (with-temp-file logd-src (insert "int main(void){return 0;}\n"))
          (with-temp-file runas-src (insert "int main(void){return 0;}\n"))
          (let ((supervisor-logd-command logd-bin)
                (supervisor-runas-command runas-bin))
            (cl-letf (((symbol-function 'supervisor--find-libexec-compiler)
                       (lambda () nil)))
              (let ((result (supervisor-build-libexec-helpers)))
                (should (= 2 (plist-get result :attempted)))
                (should (= 0 (plist-get result :built)))
                (should (= 1 (length (plist-get result :failed))))
                (should (string-match-p "No C compiler found"
                                        (car (plist-get result :failed))))))))
      (delete-directory tmp t))))

(ert-deftest supervisor-test-maybe-build-libexec-helpers-prompt ()
  "Prompt policy builds helpers in graphical Emacs when confirmed."
  (let ((supervisor-libexec-build-on-startup 'prompt)
        (noninteractive nil)
        (asked nil)
        (built nil))
    (cl-letf (((symbol-function 'supervisor--libexec-pending-build-targets)
               (lambda ()
                 (list (list :name "supervisor-logd"))))
              ((symbol-function 'y-or-n-p)
               (lambda (_prompt)
                 (setq asked t)
                 t))
              ((symbol-function 'supervisor-build-libexec-helpers)
               (lambda ()
                 (setq built t)
                 (list :built 1 :attempted 1 :failed nil :missing-source nil)))
              ((symbol-function 'supervisor--log-libexec-build-result) #'ignore))
      (supervisor--maybe-build-libexec-helpers)
      (should asked)
      (should built))))

(ert-deftest supervisor-test-maybe-build-libexec-helpers-automatic ()
  "Automatic policy builds helpers without prompting."
  (let ((supervisor-libexec-build-on-startup 'automatic)
        (built nil))
    (cl-letf (((symbol-function 'supervisor--libexec-pending-build-targets)
               (lambda ()
                 (list (list :name "supervisor-logd"))))
              ((symbol-function 'supervisor-build-libexec-helpers)
               (lambda ()
                 (setq built t)
                 (list :built 1 :attempted 1 :failed nil :missing-source nil)))
              ((symbol-function 'supervisor--log-libexec-build-result) #'ignore))
      (supervisor--maybe-build-libexec-helpers)
      (should built))))

;;;; Log writer lifecycle tests

(ert-deftest supervisor-test-writer-spawns-when-logging-enabled ()
  "Start-writer spawns logd with correct arguments."
  (let ((supervisor--writers (make-hash-table :test 'equal))
        (supervisor-logd-command "/usr/bin/logd-stub")
        (supervisor-logd-max-file-size 1000)
        (supervisor-log-directory "/tmp/logs")
        (spawned-args nil)
        ;; Create fake process before mocking make-process
        (fake-proc (start-process "fake" nil "sleep" "300")))
    (unwind-protect
        (cl-letf (((symbol-function 'make-process)
                   (lambda (&rest args)
                     (setq spawned-args args)
                     fake-proc)))
          (let ((proc (supervisor--start-writer "svc1" "/tmp/logs/log-svc1.log")))
            (should (eq proc fake-proc))
            ;; Verify logd in writers hash
            (should (eq proc (gethash "svc1" supervisor--writers)))
            ;; Verify command arguments
            (let ((cmd (plist-get spawned-args :command)))
              (should (equal (nth 0 cmd) "/usr/bin/logd-stub"))
              (should (equal (nth 1 cmd) "--file"))
              (should (equal (nth 2 cmd) "/tmp/logs/log-svc1.log"))
              (should (equal (nth 3 cmd) "--max-file-size-bytes"))
              (should (equal (nth 4 cmd) "1000"))
              (should (equal (nth 5 cmd) "--log-dir"))
              (should (equal (nth 6 cmd) "/tmp/logs")))
            ;; Verify connection type is pipe
            (should (eq (plist-get spawned-args :connection-type) 'pipe))))
      (when (process-live-p fake-proc)
        (delete-process fake-proc)))))

(ert-deftest supervisor-test-writer-not-spawned-when-logging-disabled ()
  "No writer spawned when logging is disabled in start-process."
  (let ((supervisor--writers (make-hash-table :test 'equal))
        (supervisor--processes (make-hash-table :test 'equal))
        (supervisor--shutting-down nil)
        (supervisor--restart-timers (make-hash-table :test 'equal))
        (supervisor--manually-stopped (make-hash-table :test 'equal))
        (supervisor--enabled-override (make-hash-table :test 'equal))
        (supervisor--failed (make-hash-table :test 'equal))
        (supervisor--logging (make-hash-table :test 'equal))
        (supervisor--spawn-failure-reason (make-hash-table :test 'equal))
        (writer-started nil)
        (fake-proc (start-process "fake-svc" nil "sleep" "300")))
    (unwind-protect
        (cl-letf (((symbol-function 'supervisor--get-effective-logging)
                   (lambda (_id _default) nil))
                  ((symbol-function 'supervisor--start-writer)
                   (lambda (_id _file)
                     (setq writer-started t)
                     nil))
                  ((symbol-function 'make-process)
                   (lambda (&rest _args) fake-proc))
                  ((symbol-function 'supervisor--make-process-sentinel)
                   (lambda (&rest _args) #'ignore))
                  ((symbol-function 'supervisor--build-launch-command)
                   (lambda (_cmd &rest _args) (list "sleep" "300"))))
          (let ((proc (supervisor--start-process
                       "svc2" "sleep 300" nil 'simple 'always)))
            (should proc)
            (should-not writer-started)
            (should (zerop (hash-table-count supervisor--writers)))))
      (when (process-live-p fake-proc)
        (delete-process fake-proc)))))

(ert-deftest supervisor-test-writer-stopped-on-service-exit ()
  "Sentinel stops the writer when the service process exits."
  (let ((supervisor--writers (make-hash-table :test 'equal))
        (supervisor--processes (make-hash-table :test 'equal))
        (supervisor--last-exit-info (make-hash-table :test 'equal))
        (supervisor--shutting-down nil)
        (supervisor--oneshot-completed (make-hash-table :test 'equal))
        (supervisor--manually-stopped (make-hash-table :test 'equal))
        (supervisor--enabled-override (make-hash-table :test 'equal))
        (supervisor--failed (make-hash-table :test 'equal))
        (supervisor--restart-times (make-hash-table :test 'equal))
        (supervisor--restart-timers (make-hash-table :test 'equal))
        (writer-stopped nil))
    (cl-letf (((symbol-function 'supervisor--stop-writer)
               (lambda (id)
                 (when (string= id "svc3")
                   (setq writer-stopped t))))
              ((symbol-function 'supervisor--emit-event) #'ignore)
              ((symbol-function 'supervisor--maybe-refresh-dashboard) #'ignore)
              ((symbol-function 'supervisor--should-restart-p)
               (lambda (&rest _) nil)))
      ;; Create a real process we can kill
      (let ((proc (start-process "svc3" nil "sleep" "300")))
        (puthash "svc3" proc supervisor--processes)
        (set-process-sentinel
         proc
         (supervisor--make-process-sentinel
          "svc3" "sleep 300" nil 'simple 'no))
        (delete-process proc)
        ;; Give sentinel a chance to run
        (sit-for 0.1)
        (should writer-stopped)))))

(ert-deftest supervisor-test-stop-all-writers-clears-hash ()
  "Stop-all-writers sends SIGTERM to live writers and clears the hash."
  (let ((supervisor--writers (make-hash-table :test 'equal))
        (signaled nil))
    (cl-letf (((symbol-function 'signal-process)
               (lambda (proc sig)
                 (when (eq sig 'SIGTERM)
                   (push (process-name proc) signaled))
                 0)))
      ;; Add a fake live writer
      (let ((w1 (start-process "logd-a" nil "sleep" "300"))
            (w2 (start-process "logd-b" nil "sleep" "300")))
        (puthash "a" w1 supervisor--writers)
        (puthash "b" w2 supervisor--writers)
        (unwind-protect
            (progn
              (supervisor--stop-all-writers)
              (should (zerop (hash-table-count supervisor--writers)))
              (should (member "logd-a" signaled))
              (should (member "logd-b" signaled)))
          (when (process-live-p w1) (delete-process w1))
          (when (process-live-p w2) (delete-process w2)))))))

(ert-deftest supervisor-test-filter-routes-to-writer ()
  "Process filter routes output to writer via process-send-string."
  (let ((supervisor--writers (make-hash-table :test 'equal))
        (supervisor--processes (make-hash-table :test 'equal))
        (supervisor--shutting-down nil)
        (supervisor--restart-timers (make-hash-table :test 'equal))
        (supervisor--manually-stopped (make-hash-table :test 'equal))
        (supervisor--enabled-override (make-hash-table :test 'equal))
        (supervisor--failed (make-hash-table :test 'equal))
        (supervisor--logging (make-hash-table :test 'equal))
        (supervisor--spawn-failure-reason (make-hash-table :test 'equal))
        (sent-data nil)
        (captured-filter nil)
        (fake-writer (start-process "fake-writer" nil "sleep" "300"))
        (fake-svc (start-process "fake-svc" nil "sleep" "300")))
    (unwind-protect
        (cl-letf (((symbol-function 'supervisor--get-effective-logging)
                   (lambda (_id _default) t))
                  ((symbol-function 'supervisor--ensure-log-directory) #'ignore)
                  ((symbol-function 'supervisor--log-file)
                   (lambda (_id) "/tmp/test.log"))
                  ((symbol-function 'supervisor--start-writer)
                   (lambda (id _file)
                     (puthash id fake-writer supervisor--writers)
                     fake-writer))
                  ((symbol-function 'make-process)
                   (lambda (&rest args)
                     (setq captured-filter (plist-get args :filter))
                     fake-svc))
                  ((symbol-function 'supervisor--make-process-sentinel)
                   (lambda (&rest _args) #'ignore))
                  ((symbol-function 'supervisor--build-launch-command)
                   (lambda (_cmd &rest _args) (list "sleep" "300")))
                  ((symbol-function 'process-send-string)
                   (lambda (_proc data)
                     (push data sent-data))))
          (let ((proc (supervisor--start-process
                       "svc4" "sleep 300" t 'simple 'always)))
            (should proc)
            (should captured-filter)
            ;; Invoke the filter as Emacs would
            (funcall captured-filter proc "hello world\n")
            (should (equal sent-data '("hello world\n")))))
      (when (process-live-p fake-writer)
        (delete-process fake-writer))
      (when (process-live-p fake-svc)
        (delete-process fake-svc)))))

(ert-deftest supervisor-test-writers-cleared-on-start ()
  "Supervisor-start clears the writers hash table."
  (let ((supervisor--writers (make-hash-table :test 'equal)))
    (puthash "stale" t supervisor--writers)
    ;; We cannot easily call supervisor-start fully, but we can verify
    ;; the hash is among those cleared.  Check the variable is mentioned
    ;; in the clrhash calls by verifying the state after a controlled call.
    (clrhash supervisor--writers)
    (should (zerop (hash-table-count supervisor--writers)))))

(ert-deftest supervisor-test-stop-writer-removes-from-hash ()
  "Stop-writer removes the entry from the writers hash."
  (let ((supervisor--writers (make-hash-table :test 'equal)))
    (let ((w (start-process "logd-x" nil "sleep" "300")))
      (puthash "x" w supervisor--writers)
      (unwind-protect
          (progn
            (supervisor--stop-writer "x")
            (should (zerop (hash-table-count supervisor--writers))))
        (when (process-live-p w) (delete-process w))))))

(ert-deftest supervisor-test-stop-writer-noop-for-unknown-id ()
  "Stop-writer is a no-op for an ID not in the writers hash."
  (let ((supervisor--writers (make-hash-table :test 'equal)))
    (supervisor--stop-writer "nonexistent")
    (should (zerop (hash-table-count supervisor--writers)))))

(ert-deftest supervisor-test-writer-pid-file-written ()
  "Start-writer writes a PID file for the logd process."
  (let* ((pid-dir (make-temp-file "sv-pid-" t))
         (supervisor--writers (make-hash-table :test 'equal))
         (supervisor-logd-pid-directory pid-dir)
         (supervisor-logd-command "sleep")
         (supervisor-logd-max-file-size 1000)
         (supervisor-log-directory pid-dir)
         (supervisor-logd-prune-min-interval 60)
         (supervisor-log-prune-command "/bin/true")
         (supervisor-log-prune-max-total-bytes 1000000)
         (fake-proc (start-process "fake-logd" nil "sleep" "300")))
    (unwind-protect
        (cl-letf (((symbol-function 'make-process)
                   (lambda (&rest _args) fake-proc)))
          (supervisor--start-writer "svc1" "/tmp/log-svc1.log")
          (let ((pid-file (expand-file-name "logd-svc1.pid" pid-dir)))
            (should (file-exists-p pid-file))
            (should (equal (string-trim
                            (with-temp-buffer
                              (insert-file-contents pid-file)
                              (buffer-string)))
                           (number-to-string (process-id fake-proc))))))
      (when (process-live-p fake-proc) (delete-process fake-proc))
      (delete-directory pid-dir t))))

(ert-deftest supervisor-test-stop-writer-removes-pid-file ()
  "Stop-writer removes the PID file."
  (let* ((pid-dir (make-temp-file "sv-pid-" t))
         (supervisor--writers (make-hash-table :test 'equal))
         (supervisor-logd-pid-directory pid-dir))
    (let ((w (start-process "logd-y" nil "sleep" "300")))
      (puthash "y" w supervisor--writers)
      (let ((pid-file (expand-file-name "logd-y.pid" pid-dir)))
        (write-region "12345" nil pid-file nil 'silent)
        (unwind-protect
            (progn
              (supervisor--stop-writer "y")
              (should-not (file-exists-p pid-file))
              (should (zerop (hash-table-count supervisor--writers))))
          (when (process-live-p w) (delete-process w))
          (delete-directory pid-dir t))))))

(ert-deftest supervisor-test-stop-all-writers-removes-pid-files ()
  "Stop-all-writers removes PID files for all writers."
  (let* ((pid-dir (make-temp-file "sv-pid-" t))
         (supervisor--writers (make-hash-table :test 'equal))
         (supervisor-logd-pid-directory pid-dir)
         (w1 (start-process "logd-a" nil "sleep" "300"))
         (w2 (start-process "logd-b" nil "sleep" "300")))
    (puthash "a" w1 supervisor--writers)
    (puthash "b" w2 supervisor--writers)
    (write-region "111" nil (expand-file-name "logd-a.pid" pid-dir) nil 'silent)
    (write-region "222" nil (expand-file-name "logd-b.pid" pid-dir) nil 'silent)
    (unwind-protect
        (progn
          (supervisor--stop-all-writers)
          (should-not (file-exists-p (expand-file-name "logd-a.pid" pid-dir)))
          (should-not (file-exists-p (expand-file-name "logd-b.pid" pid-dir)))
          (should (zerop (hash-table-count supervisor--writers))))
      (when (process-live-p w1) (delete-process w1))
      (when (process-live-p w2) (delete-process w2))
      (delete-directory pid-dir t))))

(ert-deftest supervisor-test-writer-failure-degrades-gracefully ()
  "Start-writer returns nil and logs warning when make-process signals."
  (let ((supervisor--writers (make-hash-table :test 'equal))
        (supervisor-logd-command "/usr/bin/logd-stub")
        (supervisor-logd-max-file-size 1000)
        (supervisor-log-directory "/tmp/logs")
        (logged nil))
    (cl-letf (((symbol-function 'make-process)
               (lambda (&rest _args)
                 (error "Doing vfork: No such file or directory")))
              ((symbol-function 'supervisor--log)
               (lambda (level fmt &rest args)
                 (when (eq level 'warning)
                   (push (apply #'format fmt args) logged)))))
      (let ((result (supervisor--start-writer "svc-fail" "/tmp/logs/log-svc-fail.log")))
        (should-not result)
        (should (zerop (hash-table-count supervisor--writers)))
        (should logged)
        (should (string-match-p "log writer failed to start" (car logged)))))))

(ert-deftest supervisor-test-start-process-succeeds-despite-writer-failure ()
  "Service starts without logging when writer spawn fails."
  (let ((supervisor--writers (make-hash-table :test 'equal))
        (supervisor--processes (make-hash-table :test 'equal))
        (supervisor--shutting-down nil)
        (supervisor--restart-timers (make-hash-table :test 'equal))
        (supervisor--manually-stopped (make-hash-table :test 'equal))
        (supervisor--enabled-override (make-hash-table :test 'equal))
        (supervisor--failed (make-hash-table :test 'equal))
        (supervisor--logging (make-hash-table :test 'equal))
        (supervisor--spawn-failure-reason (make-hash-table :test 'equal))
        (captured-filter nil)
        (fake-proc (start-process "fake-svc" nil "sleep" "300")))
    (unwind-protect
        (cl-letf (((symbol-function 'supervisor--get-effective-logging)
                   (lambda (_id _default) t))
                  ((symbol-function 'supervisor--ensure-log-directory) #'ignore)
                  ((symbol-function 'supervisor--log-file)
                   (lambda (_id) "/tmp/test.log"))
                  ((symbol-function 'supervisor--start-writer)
                   (lambda (_id _file) nil))
                  ((symbol-function 'make-process)
                   (lambda (&rest args)
                     (setq captured-filter (plist-get args :filter))
                     fake-proc))
                  ((symbol-function 'supervisor--make-process-sentinel)
                   (lambda (&rest _args) #'ignore))
                  ((symbol-function 'supervisor--build-launch-command)
                   (lambda (_cmd &rest _args) (list "sleep" "300"))))
          (let ((proc (supervisor--start-process
                       "svc-nolog" "sleep 300" t 'simple 'always)))
            ;; Service should still start
            (should proc)
            ;; No filter when writer is nil
            (should-not captured-filter)))
      (when (process-live-p fake-proc)
        (delete-process fake-proc)))))

(ert-deftest supervisor-test-graceful-stop-writers-after-services ()
  "Graceful stop keeps writers alive until services actually exit."
  (let ((supervisor--writers (make-hash-table :test 'equal))
        (supervisor--processes (make-hash-table :test 'equal))
        (supervisor--shutting-down nil)
        (supervisor--shutdown-complete-flag nil)
        (supervisor--shutdown-remaining 0)
        (supervisor--shutdown-callback nil)
        (supervisor--shutdown-timer nil)
        (supervisor--timers nil)
        (supervisor--restart-timers (make-hash-table :test 'equal))
        (supervisor--last-exit-info (make-hash-table :test 'equal))
        (supervisor--oneshot-completed (make-hash-table :test 'equal))
        (supervisor--manually-stopped (make-hash-table :test 'equal))
        (supervisor--enabled-override (make-hash-table :test 'equal))
        (supervisor--failed (make-hash-table :test 'equal))
        (supervisor--restart-times (make-hash-table :test 'equal))
        (writers-stopped-at nil))
    ;; Create real processes for service and writer
    (let ((svc (start-process "svc-gs" nil "sleep" "300"))
          (writer (start-process "logd-gs" nil "sleep" "300")))
      (puthash "svc-gs" svc supervisor--processes)
      (puthash "svc-gs" writer supervisor--writers)
      (unwind-protect
          (cl-letf (((symbol-function 'supervisor--kill-signal-for-id)
                     (lambda (_id) 'SIGTERM))
                    ((symbol-function 'supervisor--run-exec-stop-for-id) #'ignore)
                    ((symbol-function 'supervisor--dag-cleanup) #'ignore)
                    ((symbol-function 'supervisor--emit-event) #'ignore)
                    ((symbol-function 'supervisor-timer-scheduler-stop) #'ignore)
                    ((symbol-function 'supervisor--stop-all-writers)
                     (lambda ()
                       (setq writers-stopped-at
                             (hash-table-count supervisor--processes))
                       (clrhash supervisor--writers)))
                    ((symbol-function 'run-at-time)
                     (lambda (&rest _args) nil)))
            ;; Call supervisor-stop  writers should NOT be stopped eagerly
            (supervisor-stop)
            ;; Writers should not have been stopped yet (services still live)
            ;; They will be stopped when handle-shutdown-exit completes
            (should-not writers-stopped-at))
        (when (process-live-p svc) (delete-process svc))
        (when (process-live-p writer) (delete-process writer))))))

(ert-deftest supervisor-test-writer-cleaned-up-on-service-spawn-failure ()
  "Writer is stopped and removed when service make-process fails."
  (let ((supervisor--writers (make-hash-table :test 'equal))
        (supervisor--processes (make-hash-table :test 'equal))
        (supervisor--shutting-down nil)
        (supervisor--restart-timers (make-hash-table :test 'equal))
        (supervisor--manually-stopped (make-hash-table :test 'equal))
        (supervisor--enabled-override (make-hash-table :test 'equal))
        (supervisor--failed (make-hash-table :test 'equal))
        (supervisor--logging (make-hash-table :test 'equal))
        (supervisor--spawn-failure-reason (make-hash-table :test 'equal))
        (writer-stopped nil)
        (fake-writer (start-process "fake-writer" nil "sleep" "300"))
        (call-count 0))
    (unwind-protect
        (cl-letf (((symbol-function 'supervisor--get-effective-logging)
                   (lambda (_id _default) t))
                  ((symbol-function 'supervisor--ensure-log-directory) #'ignore)
                  ((symbol-function 'supervisor--log-file)
                   (lambda (_id) "/tmp/test.log"))
                  ((symbol-function 'supervisor--start-writer)
                   (lambda (id _file)
                     (puthash id fake-writer supervisor--writers)
                     fake-writer))
                  ((symbol-function 'supervisor--stop-writer)
                   (lambda (id)
                     (setq writer-stopped id)
                     (remhash id supervisor--writers)))
                  ((symbol-function 'make-process)
                   (lambda (&rest _args)
                     (cl-incf call-count)
                     ;; First call is from start-writer (mocked above),
                     ;; second call is the service spawn which fails
                     (error "Doing vfork: No such file or directory")))
                  ((symbol-function 'supervisor--make-process-sentinel)
                   (lambda (&rest _args) #'ignore))
                  ((symbol-function 'supervisor--build-launch-command)
                   (lambda (_cmd &rest _args) (list "/nonexistent/cmd")))
                  ((symbol-function 'supervisor--log) #'ignore))
          (let ((proc (supervisor--start-process
                       "svc-fail" "/nonexistent/cmd" t 'simple 'always)))
            ;; Service should return nil (spawn failed)
            (should-not proc)
            ;; Writer should have been cleaned up
            (should (equal writer-stopped "svc-fail"))
            (should (zerop (hash-table-count supervisor--writers)))
            ;; Spawn failure reason should be recorded
            (should (gethash "svc-fail" supervisor--spawn-failure-reason))))
      (when (process-live-p fake-writer)
        (delete-process fake-writer)))))

;;;; supervisor-logrotate script tests

(ert-deftest supervisor-test-logrotate-help-exits-zero ()
  "The --help flag exits 0 and prints usage."
  (let* ((root (file-name-directory (locate-library "supervisor")))
         (script (expand-file-name "sbin/supervisor-logrotate" root)))
    (with-temp-buffer
      (let ((exit-code (call-process script nil t nil "--help")))
        (should (= exit-code 0))
        (should (string-match-p "Usage:" (buffer-string)))))))

(ert-deftest supervisor-test-logrotate-missing-log-dir-exits-nonzero ()
  "Missing --log-dir exits non-zero with an error message."
  (let* ((root (file-name-directory (locate-library "supervisor")))
         (script (expand-file-name "sbin/supervisor-logrotate" root)))
    (with-temp-buffer
      (let ((exit-code (call-process script nil t nil)))
        (should-not (= exit-code 0))
        (should (string-match-p "--log-dir" (buffer-string)))))))

(ert-deftest supervisor-test-logrotate-dry-run-no-modification ()
  "Dry-run mode prints actions without modifying files."
  (let* ((root (file-name-directory (locate-library "supervisor")))
         (script (expand-file-name "sbin/supervisor-logrotate" root))
         (dir (make-temp-file "logrotate-" t)))
    (unwind-protect
        (progn
          ;; Create active log files
          (write-region "data" nil (expand-file-name "supervisor.log" dir))
          (write-region "data" nil (expand-file-name "log-svc1.log" dir))
          (with-temp-buffer
            (let ((exit-code (call-process script nil t nil
                                          "--log-dir" dir "--dry-run")))
              (should (= exit-code 0))
              (let ((output (buffer-string)))
                (should (string-match-p "rotate:" output)))))
          ;; Files should still exist (not moved)
          (should (file-exists-p (expand-file-name "supervisor.log" dir)))
          (should (file-exists-p (expand-file-name "log-svc1.log" dir))))
      (delete-directory dir t))))

(ert-deftest supervisor-test-logrotate-rotation-renames-active-files ()
  "Rotation renames active files with a timestamp suffix."
  (let* ((root (file-name-directory (locate-library "supervisor")))
         (script (expand-file-name "sbin/supervisor-logrotate" root))
         (dir (make-temp-file "logrotate-" t)))
    (unwind-protect
        (progn
          (write-region "supervisor-data" nil
                        (expand-file-name "supervisor.log" dir))
          (write-region "svc-data" nil
                        (expand-file-name "log-myapp.log" dir))
          ;; Also create a rotated file that should NOT be re-rotated
          (write-region "old" nil
                        (expand-file-name "log-myapp.20250101-120000.log" dir))
          (let ((exit-code (call-process script nil nil nil
                                        "--log-dir" dir)))
            (should (= exit-code 0)))
          ;; Active files should be gone
          (should-not (file-exists-p
                       (expand-file-name "supervisor.log" dir)))
          (should-not (file-exists-p
                       (expand-file-name "log-myapp.log" dir)))
          ;; The old rotated file should still exist (not re-rotated)
          (should (file-exists-p
                   (expand-file-name "log-myapp.20250101-120000.log" dir)))
          ;; New rotated files should exist with timestamp pattern
          (let ((files (directory-files dir nil
                                       "^supervisor\\.[0-9].*\\.log$")))
            (should (= (length files) 1)))
          (let ((files (directory-files dir nil
                                       "^log-myapp\\.[0-9].*\\.log$")))
            ;; Should be 2: the pre-existing rotated + the newly rotated
            (should (= (length files) 2))))
      (delete-directory dir t))))

(ert-deftest supervisor-test-logrotate-dotted-id-not-misclassified ()
  "Active log for a dotted ID is rotated, not skipped or pruned."
  (let* ((root (file-name-directory (locate-library "supervisor")))
         (script (expand-file-name "sbin/supervisor-logrotate" root))
         (dir (make-temp-file "logrotate-" t)))
    (unwind-protect
        (progn
          ;; Active log for dotted ID like svc.1
          (write-region "data" nil
                        (expand-file-name "log-svc.1.log" dir))
          ;; Also a normal active log
          (write-region "data" nil
                        (expand-file-name "log-plain.log" dir))
          (let ((exit-code (call-process script nil nil nil
                                        "--log-dir" dir)))
            (should (= exit-code 0)))
          ;; Both active files should be gone (rotated)
          (should-not (file-exists-p
                       (expand-file-name "log-svc.1.log" dir)))
          (should-not (file-exists-p
                       (expand-file-name "log-plain.log" dir)))
          ;; Rotated versions should exist
          (let ((files (directory-files dir nil "^log-svc\\.1\\." t)))
            (should (= (length files) 1)))
          (let ((files (directory-files dir nil "^log-plain\\." t)))
            (should (= (length files) 1))))
      (delete-directory dir t))))

(ert-deftest supervisor-test-logrotate-prune-spares-dotted-id-active ()
  "Prune does not delete active log files for dotted IDs."
  (let* ((root (file-name-directory (locate-library "supervisor")))
         (script (expand-file-name "sbin/supervisor-logrotate" root))
         (dir (make-temp-file "logrotate-" t)))
    (unwind-protect
        (progn
          ;; Active log for dotted ID (current mtime, will be rotated)
          (write-region "data" nil
                        (expand-file-name "log-svc.1.log" dir))
          ;; An actual rotated file that IS old and should be pruned
          (let ((rotated (expand-file-name
                          "log-svc.1.20250101-120000.log" dir)))
            (write-region "old" nil rotated)
            (set-file-times rotated
                            (time-subtract (current-time)
                                           (days-to-time 30))))
          ;; Run rotation + prune (keep-days 14)
          ;; The active file gets rotated (moved), the old rotated gets pruned
          (let ((exit-code (call-process script nil nil nil
                                        "--log-dir" dir
                                        "--keep-days" "14")))
            (should (= exit-code 0)))
          ;; Old rotated file should be pruned
          (should-not (file-exists-p
                       (expand-file-name
                        "log-svc.1.20250101-120000.log" dir)))
          ;; The newly rotated file from the active log should still exist
          ;; (its mtime is current, well within 14 days)
          (let ((files (directory-files dir nil "^log-svc\\.1\\." t)))
            (should (= (length files) 1))))
      (delete-directory dir t))))

(ert-deftest supervisor-test-logrotate-prune-removes-old-keeps-recent ()
  "Prune removes old rotated files but keeps active and recent rotated."
  (let* ((root (file-name-directory (locate-library "supervisor")))
         (script (expand-file-name "sbin/supervisor-logrotate" root))
         (dir (make-temp-file "logrotate-" t)))
    (unwind-protect
        (progn
          ;; Create a rotated file and backdate its mtime to 30 days ago
          (let ((old-file (expand-file-name
                           "log-svc1.20250101-120000.log" dir)))
            (write-region "old-data" nil old-file)
            (set-file-times old-file
                            (time-subtract (current-time)
                                           (days-to-time 30))))
          ;; Create a recent rotated file (mtime is now)
          (write-region "recent-data" nil
                        (expand-file-name
                         "log-svc1.20250201-120000.log" dir))
          ;; Create an active file that should never be pruned
          (write-region "active" nil
                        (expand-file-name "log-svc1.log" dir))
          ;; Run with --keep-days 14
          (let ((exit-code (call-process script nil nil nil
                                        "--log-dir" dir
                                        "--keep-days" "14")))
            (should (= exit-code 0)))
          ;; Old rotated file should be gone
          (should-not (file-exists-p
                       (expand-file-name
                        "log-svc1.20250101-120000.log" dir)))
          ;; Recent rotated file should remain (mtime is now, within 14 days)
          ;; Note: rotation also renamed the active file, so we check that
          ;; the recent rotated file we created is still there
          (should (file-exists-p
                   (expand-file-name
                    "log-svc1.20250201-120000.log" dir)))
          ;; Active file was rotated (moved), but that's the rotation step
          ;; The important thing is the old file was pruned
          )
      (delete-directory dir t))))

(ert-deftest supervisor-test-logrotate-signal-reopen-sends-hup ()
  "Signal-reopen sends SIGHUP to PIDs found in pid files."
  (let* ((root (file-name-directory (locate-library "supervisor")))
         (script (expand-file-name "sbin/supervisor-logrotate" root))
         (dir (make-temp-file "logrotate-" t))
         (pid-dir (make-temp-file "logrotate-pid-" t))
         (proc (start-process "logrotate-test-target" nil "sleep" "300"))
         (pid (number-to-string (process-id proc))))
    (unwind-protect
        (progn
          ;; Write a PID file
          (write-region pid nil
                        (expand-file-name "logd-svc1.pid" pid-dir))
          ;; Also write a stale PID file with a bogus PID
          (write-region "999999999" nil
                        (expand-file-name "logd-stale.pid" pid-dir))
          ;; Create an active log so rotation has something to do
          (write-region "data" nil
                        (expand-file-name "log-svc1.log" dir))
          ;; Run with --signal-reopen and --dry-run to verify output
          (with-temp-buffer
            (let ((exit-code (call-process script nil t nil
                                          "--log-dir" dir
                                          "--pid-dir" pid-dir
                                          "--signal-reopen"
                                          "--dry-run")))
              (should (= exit-code 0))
              (let ((output (buffer-string)))
                ;; Should mention the valid PID
                (should (string-match-p (regexp-quote pid) output))
                (should (string-match-p "signal:" output))))))
      (when (process-live-p proc)
        (delete-process proc))
      (delete-directory dir t)
      (delete-directory pid-dir t))))

;;;; Log-prune script tests

(ert-deftest supervisor-test-log-prune-help-exits-zero ()
  "The --help flag exits 0 and prints usage."
  (let* ((root (file-name-directory (locate-library "supervisor")))
         (script (expand-file-name "sbin/supervisor-log-prune" root)))
    (with-temp-buffer
      (let ((exit-code (call-process script nil t nil "--help")))
        (should (= exit-code 0))
        (should (string-match-p "Usage:" (buffer-string)))))))

(ert-deftest supervisor-test-log-prune-missing-log-dir-exits-nonzero ()
  "Missing --log-dir exits non-zero with an error message."
  (let* ((root (file-name-directory (locate-library "supervisor")))
         (script (expand-file-name "sbin/supervisor-log-prune" root)))
    (with-temp-buffer
      (let ((exit-code (call-process script nil t nil)))
        (should-not (= exit-code 0))
        (should (string-match-p "--log-dir" (buffer-string)))))))

(ert-deftest supervisor-test-log-prune-under-cap-no-delete ()
  "When total size is under cap, no files are deleted."
  (let* ((root (file-name-directory (locate-library "supervisor")))
         (script (expand-file-name "sbin/supervisor-log-prune" root))
         (dir (make-temp-file "log-prune-" t)))
    (unwind-protect
        (progn
          ;; Create a small rotated file (well under the default 1GiB cap)
          (write-region (make-string 1024 ?x) nil
                        (expand-file-name
                         "log-svc1.20250101-120000.log" dir))
          (let ((exit-code (call-process script nil nil nil
                                        "--log-dir" dir
                                        "--max-total-bytes" "1000000")))
            (should (= exit-code 0)))
          ;; File should still exist
          (should (file-exists-p
                   (expand-file-name
                    "log-svc1.20250101-120000.log" dir))))
      (delete-directory dir t))))

(ert-deftest supervisor-test-log-prune-over-cap-deletes-oldest-rotated ()
  "Over cap deletes oldest rotated files first, keeping newest."
  (let* ((root (file-name-directory (locate-library "supervisor")))
         (script (expand-file-name "sbin/supervisor-log-prune" root))
         (dir (make-temp-file "log-prune-" t))
         (oldest (expand-file-name "log-svc1.20250101-120000.log" dir))
         (middle (expand-file-name "log-svc2.20250102-120000.log" dir))
         (newest (expand-file-name "log-svc3.20250103-120000.log" dir)))
    (unwind-protect
        (progn
          ;; Parent active logs must exist so the parent-exists guard
          ;; confirms these as rotated children.
          (write-region "" nil (expand-file-name "log-svc1.log" dir))
          (write-region "" nil (expand-file-name "log-svc2.log" dir))
          (write-region "" nil (expand-file-name "log-svc3.log" dir))
          ;; Create three rotated files with staggered mtimes.
          ;; Each is 4096 bytes; total ~12288 + dir overhead.
          (write-region (make-string 4096 ?a) nil oldest)
          ;; Set mtime to oldest
          (set-file-times oldest (encode-time 0 0 0 1 1 2025))
          (write-region (make-string 4096 ?b) nil middle)
          (set-file-times middle (encode-time 0 0 0 2 1 2025))
          (write-region (make-string 4096 ?c) nil newest)
          (set-file-times newest (encode-time 0 0 0 3 1 2025))
          ;; Set cap so that only one rotated file can remain (4096 + dir)
          ;; Use a cap of 8192 so the newest file fits but not all three.
          (let ((exit-code (call-process script nil nil nil
                                        "--log-dir" dir
                                        "--max-total-bytes" "8192")))
            (should (= exit-code 0)))
          ;; Oldest should be deleted first
          (should-not (file-exists-p oldest))
          ;; Middle may also be deleted depending on dir overhead
          ;; Newest should be kept
          (should (file-exists-p newest)))
      (delete-directory dir t))))

(ert-deftest supervisor-test-log-prune-active-files-never-deleted ()
  "Active files are preserved even when over cap."
  (let* ((root (file-name-directory (locate-library "supervisor")))
         (script (expand-file-name "sbin/supervisor-log-prune" root))
         (dir (make-temp-file "log-prune-" t))
         (active1 (expand-file-name "log-svc1.log" dir))
         (active2 (expand-file-name "supervisor.log" dir)))
    (unwind-protect
        (progn
          ;; Create only active files, no rotated files
          (write-region (make-string 8192 ?x) nil active1)
          (write-region (make-string 8192 ?y) nil active2)
          ;; Set a very low cap  should still not delete active files
          (let ((exit-code (call-process script nil nil nil
                                        "--log-dir" dir
                                        "--max-total-bytes" "100")))
            (should (= exit-code 0)))
          (should (file-exists-p active1))
          (should (file-exists-p active2)))
      (delete-directory dir t))))

(ert-deftest supervisor-test-log-prune-dry-run-no-modification ()
  "Dry-run prints actions without deleting files."
  (let* ((root (file-name-directory (locate-library "supervisor")))
         (script (expand-file-name "sbin/supervisor-log-prune" root))
         (dir (make-temp-file "log-prune-" t))
         (rotated (expand-file-name "log-svc1.20250101-120000.log" dir)))
    (unwind-protect
        (progn
          ;; Parent active log confirms this is a rotated child.
          (write-region "" nil (expand-file-name "log-svc1.log" dir))
          (write-region (make-string 8192 ?x) nil rotated)
          (with-temp-buffer
            (let ((exit-code (call-process script nil t nil
                                          "--log-dir" dir
                                          "--max-total-bytes" "100"
                                          "--dry-run")))
              (should (= exit-code 0))
              (let ((output (buffer-string)))
                (should (string-match-p "prune:" output))
                (should (string-match-p "log-svc1\\.20250101-120000\\.log"
                                        output)))))
          ;; File must still exist
          (should (file-exists-p rotated)))
      (delete-directory dir t))))

(ert-deftest supervisor-test-log-prune-lock-prevents-concurrent ()
  "A held lock causes prune to exit 0 without deleting."
  (let* ((root (file-name-directory (locate-library "supervisor")))
         (script (expand-file-name "sbin/supervisor-log-prune" root))
         (dir (make-temp-file "log-prune-" t))
         (lock-file (expand-file-name ".prune.lock" dir))
         (rotated (expand-file-name "log-svc1.20250101-120000.log" dir))
         (holder nil))
    (unwind-protect
        (progn
          (write-region (make-string 8192 ?x) nil rotated)
          ;; Hold an exclusive flock on the lock file via a background
          ;; process that keeps fd open for 30 seconds.
          (setq holder
                (start-process "flock-holder" nil
                               "sh" "-c"
                               (format "exec 9>%s; flock -n 9; sleep 30"
                                       (shell-quote-argument lock-file))))
          ;; Give the holder time to acquire the lock
          (sleep-for 0.5)
          ;; Run prune with the same lock file  should exit 0 silently
          (let ((exit-code (call-process script nil nil nil
                                        "--log-dir" dir
                                        "--max-total-bytes" "100"
                                        "--lock-file" lock-file)))
            (should (= exit-code 0)))
          ;; File must still exist because prune couldn't acquire lock
          (should (file-exists-p rotated)))
      (when (and holder (process-live-p holder))
        (delete-process holder))
      (delete-directory dir t))))

(ert-deftest supervisor-test-log-prune-timestamp-id-not-deleted ()
  "Active log for a timestamp-like ID is protected when it has rotated children."
  (let* ((root (file-name-directory (locate-library "supervisor")))
         (script (expand-file-name "sbin/supervisor-log-prune" root))
         (dir (make-temp-file "log-prune-" t))
         ;; Active log for service ID "svc.20250101-120000"
         (active (expand-file-name "log-svc.20250101-120000.log" dir))
         ;; A rotated child of that active log (proves it is a parent)
         (child (expand-file-name
                 "log-svc.20250101-120000.20260101-120000.log" dir)))
    (unwind-protect
        (progn
          (write-region (make-string 8192 ?x) nil active)
          (write-region (make-string 2048 ?y) nil child)
          (set-file-times child (encode-time 0 0 0 1 1 2026))
          ;; Very low cap  the child should be deleted but the active
          ;; log (confirmed as a parent by the child's presence) must
          ;; be preserved.
          (let ((exit-code (call-process script nil nil nil
                                        "--log-dir" dir
                                        "--max-total-bytes" "100")))
            (should (= exit-code 0)))
          (should (file-exists-p active))
          (should-not (file-exists-p child)))
      (delete-directory dir t))))

(ert-deftest supervisor-test-log-prune-timestamp-id-coexists-with-rotated ()
  "Rotated files are pruned while timestamp-like active logs are kept."
  (let* ((root (file-name-directory (locate-library "supervisor")))
         (script (expand-file-name "sbin/supervisor-log-prune" root))
         (dir (make-temp-file "log-prune-" t))
         ;; Active log for service ID "svc.20250101-120000"
         (ts-active (expand-file-name "log-svc.20250101-120000.log" dir))
         ;; Rotated child of the timestamp-like active log (confirms it
         ;; as a parent that must be protected).
         (ts-child (expand-file-name
                    "log-svc.20250101-120000.20260101-120000.log" dir))
         ;; Active log for plain service "plain"
         (plain-active (expand-file-name "log-plain.log" dir))
         ;; Rotated file for service "plain"
         (plain-rotated (expand-file-name
                         "log-plain.20250101-120000.log" dir)))
    (unwind-protect
        (progn
          (write-region (make-string 4096 ?a) nil ts-active)
          (write-region (make-string 1024 ?d) nil ts-child)
          (set-file-times ts-child (encode-time 0 0 0 1 1 2026))
          (write-region (make-string 100 ?b) nil plain-active)
          (write-region (make-string 8192 ?c) nil plain-rotated)
          (set-file-times plain-rotated (encode-time 0 0 0 1 1 2025))
          ;; Cap is low  rotated files should be deleted.
          ;; The timestamp-like active log must be preserved.
          (let ((exit-code (call-process script nil nil nil
                                        "--log-dir" dir
                                        "--max-total-bytes" "4096")))
            (should (= exit-code 0)))
          ;; Timestamp-like active log preserved (has rotated child)
          (should (file-exists-p ts-active))
          ;; Plain active log preserved (not rotated pattern)
          (should (file-exists-p plain-active))
          ;; Rotated files deleted
          (should-not (file-exists-p plain-rotated))
          (should-not (file-exists-p ts-child)))
      (delete-directory dir t))))

(ert-deftest supervisor-test-log-prune-lone-orphan-preserved ()
  "A single orphaned rotated file with no parent and no siblings is preserved.
Without parent or sibling confirmation, the file could be an active log
for a service whose ID contains a timestamp pattern."
  (let* ((root (file-name-directory (locate-library "supervisor")))
         (script (expand-file-name "sbin/supervisor-log-prune" root))
         (dir (make-temp-file "log-prune-" t))
         (orphan (expand-file-name "log-oldsvc.20240101-010101.log" dir)))
    (unwind-protect
        (progn
          (write-region (make-string 8192 ?x) nil orphan)
          ;; No log-oldsvc.log and no sibling rotated files.
          (let ((exit-code (call-process script nil nil nil
                                        "--log-dir" dir
                                        "--max-total-bytes" "100")))
            (should (= exit-code 0)))
          ;; File preserved (no evidence it is rotated vs active).
          (should (file-exists-p orphan)))
      (delete-directory dir t))))

(ert-deftest supervisor-test-log-prune-orphan-siblings-deleted ()
  "Orphaned rotated siblings are deleted even when parent is absent.
Multiple rotated files sharing the same parent name confirm each other
as rotated children of a now-removed service."
  (let* ((root (file-name-directory (locate-library "supervisor")))
         (script (expand-file-name "sbin/supervisor-log-prune" root))
         (dir (make-temp-file "log-prune-" t))
         (orphan1 (expand-file-name "log-oldsvc.20240101-010101.log" dir))
         (orphan2 (expand-file-name "log-oldsvc.20240201-010101.log" dir)))
    (unwind-protect
        (progn
          ;; No log-oldsvc.log exists, but two siblings with the same
          ;; parent confirm these are rotated children.
          (write-region (make-string 4096 ?x) nil orphan1)
          (set-file-times orphan1 (encode-time 0 0 0 1 1 2024))
          (write-region (make-string 4096 ?y) nil orphan2)
          (set-file-times orphan2 (encode-time 0 0 0 1 2 2024))
          (let ((exit-code (call-process script nil nil nil
                                        "--log-dir" dir
                                        "--max-total-bytes" "100")))
            (should (= exit-code 0)))
          ;; Both orphans deleted (siblings confirmed rotated).
          (should-not (file-exists-p orphan1))
          (should-not (file-exists-p orphan2)))
      (delete-directory dir t))))

(ert-deftest supervisor-test-log-prune-protect-id-preserves-file ()
  "The --protect-id flag prevents deletion of a specific service log."
  (let* ((root (file-name-directory (locate-library "supervisor")))
         (script (expand-file-name "sbin/supervisor-log-prune" root))
         (dir (make-temp-file "log-prune-" t))
         (protected (expand-file-name "log-svc.20250101-120000.log" dir))
         (deletable (expand-file-name "log-other.20240101-010101.log" dir)))
    (unwind-protect
        (progn
          ;; Parent active logs confirm both as rotated children.
          (write-region "" nil (expand-file-name "log-svc.log" dir))
          (write-region "" nil (expand-file-name "log-other.log" dir))
          (write-region (make-string 4096 ?x) nil protected)
          (write-region (make-string 4096 ?y) nil deletable)
          (set-file-times deletable (encode-time 0 0 0 1 1 2024))
          (let ((exit-code (call-process script nil nil nil
                                        "--log-dir" dir
                                        "--max-total-bytes" "100"
                                        "--protect-id"
                                        "svc.20250101-120000")))
            (should (= exit-code 0)))
          ;; Protected file preserved by --protect-id
          (should (file-exists-p protected))
          ;; Unprotected file deleted
          (should-not (file-exists-p deletable)))
      (delete-directory dir t))))

(ert-deftest supervisor-test-log-prune-parent-confirms-rotated ()
  "A rotated file whose parent active log exists is confirmed and deleted."
  (let* ((root (file-name-directory (locate-library "supervisor")))
         (script (expand-file-name "sbin/supervisor-log-prune" root))
         (dir (make-temp-file "log-prune-" t))
         (parent (expand-file-name "log-svc1.log" dir))
         (rotated (expand-file-name "log-svc1.20250101-120000.log" dir)))
    (unwind-protect
        (progn
          (write-region "" nil parent)
          (write-region (make-string 8192 ?x) nil rotated)
          (let ((exit-code (call-process script nil nil nil
                                        "--log-dir" dir
                                        "--max-total-bytes" "100")))
            (should (= exit-code 0)))
          ;; Parent active log preserved (not rotated).
          (should (file-exists-p parent))
          ;; Rotated child deleted (parent confirms it as rotated).
          (should-not (file-exists-p rotated)))
      (delete-directory dir t))))

(ert-deftest supervisor-test-log-prune-no-fuser-timestamp-id-safe ()
  "Active log for timestamp-like ID is safe even without fuser.
Verifies the unconditional parent-exists guard by running with
PATH set to exclude fuser."
  (let* ((root (file-name-directory (locate-library "supervisor")))
         (script (expand-file-name "sbin/supervisor-log-prune" root))
         (dir (make-temp-file "log-prune-" t))
         ;; Active log for service svc.20250101-120000  no parent
         ;; log-svc.log exists, so the parent-exists guard preserves it.
         (active (expand-file-name "log-svc.20250101-120000.log" dir)))
    (unwind-protect
        (progn
          (write-region (make-string 8192 ?x) nil active)
          ;; Run with a minimal PATH that excludes fuser.
          (let ((process-environment
                 (cons "PATH=/usr/bin:/bin" process-environment))
                (exit-code (call-process script nil nil nil
                                        "--log-dir" dir
                                        "--max-total-bytes" "100")))
            (should (= exit-code 0)))
          ;; File must be preserved  parent-exists guard is sufficient.
          (should (file-exists-p active)))
      (delete-directory dir t))))

(ert-deftest supervisor-test-log-prune-fuser-protects-open-file ()
  "Files currently open by a process are not deleted (fuser guard)."
  (skip-unless (= 0 (call-process "sh" nil nil nil
                                   "-c" "command -v fuser")))
  (let* ((root (file-name-directory (locate-library "supervisor")))
         (script (expand-file-name "sbin/supervisor-log-prune" root))
         (dir (make-temp-file "log-prune-" t))
         ;; A timestamp-like active log with no rotated children --
         ;; exactly the case the children guard cannot protect.
         (open-file (expand-file-name
                     "log-svc.20250101-120000.log" dir))
         (holder nil))
    (unwind-protect
        (progn
          (write-region (make-string 8192 ?x) nil open-file)
          ;; Hold the file open on fd 3 so fuser detects it.
          (setq holder
                (start-process "file-holder" nil
                               "sh" "-c"
                               (format "exec 3<%s; sleep 300"
                                       (shell-quote-argument open-file))))
          (sleep-for 0.3)
          ;; Run prune with a very low cap.
          (let ((exit-code (call-process script nil nil nil
                                        "--log-dir" dir
                                        "--max-total-bytes" "100")))
            (should (= exit-code 0)))
          ;; File must still exist -- fuser detected it as open.
          (should (file-exists-p open-file)))
      (when (and holder (process-live-p holder))
        (delete-process holder))
      (delete-directory dir t))))

(ert-deftest supervisor-test-log-prune-fuser-allows-closed-file ()
  "Closed files are deleted normally even when fuser is available."
  (skip-unless (= 0 (call-process "sh" nil nil nil
                                   "-c" "command -v fuser")))
  (let* ((root (file-name-directory (locate-library "supervisor")))
         (script (expand-file-name "sbin/supervisor-log-prune" root))
         (dir (make-temp-file "log-prune-" t))
         (closed-file (expand-file-name
                       "log-oldsvc.20240101-010101.log" dir)))
    (unwind-protect
        (progn
          ;; Parent active log confirms this is a rotated child.
          (write-region "" nil (expand-file-name "log-oldsvc.log" dir))
          (write-region (make-string 8192 ?x) nil closed-file)
          ;; No process holds the file open.
          (let ((exit-code (call-process script nil nil nil
                                        "--log-dir" dir
                                        "--max-total-bytes" "100")))
            (should (= exit-code 0)))
          ;; File should be deleted normally.
          (should-not (file-exists-p closed-file)))
      (delete-directory dir t))))

;;;; Phase 7  rotate/prune integration

(ert-deftest supervisor-test-start-writer-passes-prune-flags ()
  "Start-writer includes --prune-cmd and --prune-min-interval-sec."
  (let ((supervisor--writers (make-hash-table :test 'equal))
        (supervisor-logd-command "/usr/bin/logd-stub")
        (supervisor-logd-max-file-size 1000)
        (supervisor-log-directory "/tmp/logs")
        (supervisor-log-prune-command "/usr/bin/prune-stub")
        (supervisor-log-prune-max-total-bytes 5000)
        (supervisor-logd-prune-min-interval 30)
        (spawned-args nil)
        (fake-proc (start-process "fake" nil "sleep" "300")))
    (unwind-protect
        (cl-letf (((symbol-function 'make-process)
                   (lambda (&rest args)
                     (setq spawned-args args)
                     fake-proc)))
          (supervisor--start-writer "svc1" "/tmp/logs/log-svc1.log")
          (let ((cmd (plist-get spawned-args :command)))
            (should (member "--prune-cmd" cmd))
            (should (member "--prune-min-interval-sec" cmd))
            ;; Verify values follow flags
            (let ((prune-pos (cl-position "--prune-cmd" cmd :test #'equal))
                  (interval-pos (cl-position "--prune-min-interval-sec"
                                             cmd :test #'equal)))
              (should (string-match-p "prune-stub"
                                      (nth (1+ prune-pos) cmd)))
              (should (equal "30" (nth (1+ interval-pos) cmd))))))
      (when (process-live-p fake-proc)
        (delete-process fake-proc)))))

(ert-deftest supervisor-test-build-prune-command-format ()
  "Build-prune-command returns a properly formatted command string."
  (let ((log-directory (make-temp-file "logs-" t)))
    (unwind-protect
        (let ((supervisor-log-prune-command "/opt/prune")
              (supervisor-log-directory log-directory)
              (supervisor-log-prune-max-total-bytes 2048))
          (let ((cmd (supervisor--build-prune-command)))
            (should (stringp cmd))
            (should (string-match-p (regexp-quote "/opt/prune") cmd))
            (should (string-match-p "--log-dir" cmd))
            (should (string-match-p (regexp-quote log-directory) cmd))
            (should (string-match-p "--max-total-bytes" cmd))
            (should (string-match-p "2048" cmd))))
      (delete-directory log-directory t))))

(ert-deftest supervisor-test-effective-log-directory-falls-back ()
  "Unwritable configured log directory falls back to user-local default."
  (let ((supervisor-log-directory "/root/locked-supervisor")
        (user-emacs-directory "/tmp/emacs-user/")
        (warnings nil))
    (cl-letf (((symbol-function 'supervisor--ensure-directory-writable)
               (lambda (directory)
                 (cond
                  ((equal directory "/root/locked-supervisor") nil)
                  ((equal directory "/tmp/emacs-user/supervisor")
                   directory)
                  (t nil))))
              ((symbol-function 'message)
               (lambda (format-string &rest args)
                 (push (apply #'format format-string args) warnings))))
      (should (equal "/tmp/emacs-user/supervisor"
                     (supervisor--effective-log-directory)))
      (should (car warnings))
      (should (string-match-p "using /tmp/emacs-user/supervisor"
                              (car warnings))))))

(ert-deftest supervisor-test-effective-log-directory-unavailable ()
  "No writable log directory returns nil and emits a warning."
  (let ((supervisor-log-directory "/root/locked-supervisor")
        (user-emacs-directory "/tmp/emacs-user/")
        (warnings nil))
    (cl-letf (((symbol-function 'supervisor--ensure-directory-writable)
               (lambda (_directory) nil))
              ((symbol-function 'message)
               (lambda (format-string &rest args)
                 (push (apply #'format format-string args) warnings))))
      (should-not (supervisor--effective-log-directory))
      (should (car warnings))
      (should (string-match-p "file logging disabled" (car warnings))))))

(ert-deftest supervisor-test-signal-writers-reopen ()
  "Signal-writers-reopen sends SIGHUP to live writers."
  (let ((supervisor--writers (make-hash-table :test 'equal))
        (supervisor--stderr-writers (make-hash-table :test 'equal))
        (signals-sent nil)
        (fake-proc (start-process "fake-writer" nil "sleep" "300")))
    (unwind-protect
        (cl-letf (((symbol-function 'signal-process)
                   (lambda (proc sig)
                     (push (cons proc sig) signals-sent)
                     0)))
          (puthash "svc1" fake-proc supervisor--writers)
          (should (process-live-p fake-proc))
          (supervisor--signal-writers-reopen)
          (should (= 1 (length signals-sent)))
          (should (eq (caar signals-sent) fake-proc))
          (should (eq (cdar signals-sent) 'SIGHUP)))
      (when (process-live-p fake-proc)
        (delete-process fake-proc)))))

(ert-deftest supervisor-test-run-log-maintenance-chains ()
  "Log maintenance chains rotate, writer reopen, then prune."
  (let ((supervisor--writers (make-hash-table :test 'equal))
        (supervisor-log-directory "/tmp/test-logs")
        (supervisor-logrotate-command "/usr/bin/rotate-stub")
        (supervisor-logrotate-keep-days 7)
        (supervisor-log-prune-command "/usr/bin/prune-stub")
        (supervisor-log-prune-max-total-bytes 4096)
        (supervisor-verbose nil)
        (calls nil)
        (captured-sentinel nil))
    (cl-letf (((symbol-function 'start-process)
               (lambda (name _buf cmd &rest args)
                 (let ((entry (cons cmd args)))
                   (push (cons name entry) calls))
                 ;; Return a fake process object
                 (let ((proc (generate-new-buffer " *fake*")))
                   ;; start-process sentinel will be set externally
                   proc)))
              ((symbol-function 'set-process-sentinel)
               (lambda (_proc sentinel)
                 (setq captured-sentinel sentinel)))
              ((symbol-function 'supervisor--signal-writers-reopen)
               (lambda ()
                 (push (cons "reopen" nil) calls)))
              ((symbol-function 'supervisor--log)
               #'ignore))
      (supervisor-run-log-maintenance)
      ;; First call should be logrotate
      (should (= 1 (length calls)))
      (let ((first (car calls)))
        (should (equal (car first) "supervisor-logrotate"))
        (should (equal (cadr first) "/usr/bin/rotate-stub"))
        (should (member "--log-dir" (cdr first)))
        (should (member "--keep-days" (cdr first))))
      ;; Fire the sentinel with "finished"
      (should captured-sentinel)
      (funcall captured-sentinel nil "finished\n")
      ;; Should now have reopen + prune calls
      (should (= 3 (length calls)))
      ;; Most recent is prune (pushed last)
      (let ((prune-call (car calls)))
        (should (equal (car prune-call) "supervisor-log-prune"))
        (should (equal (cadr prune-call) "/usr/bin/prune-stub"))
        (should (member "--log-dir" (cdr prune-call)))
        (should (member "--max-total-bytes" (cdr prune-call))))
      ;; Reopen was called between rotate and prune
      (let ((reopen-call (cadr calls)))
        (should (equal (car reopen-call) "reopen"))))))

;;;; Phase 8: Default Daily Unit + Timer Wiring

(ert-deftest supervisor-test-builtin-programs-log-maintenance-pair ()
  "Built-in programs include logrotate, log-prune, and built-in targets."
  (let ((builtins (supervisor--builtin-programs)))
    (should (= 17 (length builtins)))
    (let* ((ids (mapcar (lambda (e) (plist-get (cdr e) :id)) builtins))
           (rotate (cl-find "logrotate" builtins
                            :key (lambda (e) (plist-get (cdr e) :id))
                            :test #'equal))
           (prune (cl-find "log-prune" builtins
                           :key (lambda (e) (plist-get (cdr e) :id))
                           :test #'equal)))
      (should (member "logrotate" ids))
      (should (member "log-prune" ids))
      (should (eq 'oneshot (plist-get (cdr rotate) :type)))
      (should-not (plist-get (cdr rotate) :stage))
      (should-not (plist-member (cdr rotate) :wanted-by))
      (should (eq 'oneshot (plist-get (cdr prune) :type)))
      (should-not (plist-get (cdr prune) :stage))
      (should (equal '("logrotate") (plist-get (cdr prune) :after)))
      (should (equal '("logrotate") (plist-get (cdr prune) :requires)))
      (should-not (plist-member (cdr prune) :wanted-by)))))

(ert-deftest supervisor-test-default-target-defcustom ()
  "Default target defcustom has expected default value."
  (should (equal supervisor-default-target "default.target")))

(ert-deftest supervisor-test-default-target-link-defcustom ()
  "Default target link defcustom has expected default value."
  (should (equal supervisor-default-target-link "graphical.target")))

(ert-deftest supervisor-test-builtin-targets-present ()
  "Built-in programs include the four standard targets."
  (let* ((builtins (supervisor--builtin-programs))
         (ids (mapcar (lambda (e) (plist-get (cdr e) :id)) builtins)))
    (should (member "basic.target" ids))
    (should (member "multi-user.target" ids))
    (should (member "graphical.target" ids))
    (should (member "default.target" ids))))

(ert-deftest supervisor-test-builtin-targets-valid ()
  "Built-in targets parse without validation errors."
  (let* ((builtins (supervisor--builtin-programs))
         (targets (cl-remove-if-not
                   (lambda (e) (eq 'target (plist-get (cdr e) :type)))
                   builtins)))
    (should (= 15 (length targets)))
    (dolist (entry targets)
      (let ((parsed (supervisor--parse-entry entry)))
        (should (eq 'target (supervisor-entry-type parsed)))
        (should (string-suffix-p ".target" (supervisor-entry-id parsed)))))))

(ert-deftest supervisor-test-builtin-target-topology ()
  "Built-in targets have correct dependency chain."
  (let* ((builtins (supervisor--builtin-programs))
         (multi (cl-find "multi-user.target" builtins
                         :key (lambda (e) (plist-get (cdr e) :id))
                         :test #'equal))
         (graphical (cl-find "graphical.target" builtins
                             :key (lambda (e) (plist-get (cdr e) :id))
                             :test #'equal))
         (basic (cl-find "basic.target" builtins
                         :key (lambda (e) (plist-get (cdr e) :id))
                         :test #'equal))
         (default-tgt (cl-find "default.target" builtins
                               :key (lambda (e) (plist-get (cdr e) :id))
                               :test #'equal)))
    ;; basic.target has no deps
    (should-not (plist-get (cdr basic) :requires))
    (should-not (plist-get (cdr basic) :after))
    ;; multi-user.target depends on basic.target via :requires (no explicit :after)
    (should (equal '("basic.target") (plist-get (cdr multi) :requires)))
    (should-not (plist-get (cdr multi) :after))
    ;; graphical.target depends on multi-user.target via :requires (no explicit :after)
    (should (equal '("multi-user.target") (plist-get (cdr graphical) :requires)))
    (should-not (plist-get (cdr graphical) :after))
    ;; default.target has no static edges
    (should-not (plist-get (cdr default-tgt) :requires))
    (should-not (plist-get (cdr default-tgt) :after))))

(ert-deftest supervisor-test-resolve-default-chain ()
  "Default resolution chain: default.target -> graphical.target."
  (let ((supervisor-default-target "default.target")
        (supervisor-default-target-link "graphical.target")
        (supervisor--default-target-link-override nil)
        (valid-id-set (make-hash-table :test 'equal)))
    (puthash "graphical.target" t valid-id-set)
    (should (equal "graphical.target"
                   (supervisor--resolve-startup-root valid-id-set)))))

(ert-deftest supervisor-test-resolve-custom-link ()
  "Override link resolves correctly."
  (let ((supervisor-default-target "default.target")
        (supervisor-default-target-link "graphical.target")
        (supervisor--default-target-link-override "multi-user.target")
        (valid-id-set (make-hash-table :test 'equal)))
    (puthash "multi-user.target" t valid-id-set)
    (should (equal "multi-user.target"
                   (supervisor--resolve-startup-root valid-id-set)))))

(ert-deftest supervisor-test-resolve-direct-target ()
  "Non-default.target resolves directly without alias."
  (let ((supervisor-default-target "custom.target")
        (supervisor-default-target-link "graphical.target")
        (supervisor--default-target-link-override nil)
        (valid-id-set (make-hash-table :test 'equal)))
    (puthash "custom.target" t valid-id-set)
    (should (equal "custom.target"
                   (supervisor--resolve-startup-root valid-id-set)))))

(ert-deftest supervisor-test-resolve-missing-target-errors ()
  "Missing resolved target signals user-error."
  (let ((supervisor-default-target "default.target")
        (supervisor-default-target-link "graphical.target")
        (supervisor--default-target-link-override nil)
        (valid-id-set (make-hash-table :test 'equal)))
    ;; graphical.target not in valid-id-set
    (should-error (supervisor--resolve-startup-root valid-id-set)
                  :type 'user-error)))

(ert-deftest supervisor-test-resolve-non-target-errors ()
  "Resolved root that is not a .target signals user-error."
  (let ((supervisor-default-target "my-service")
        (supervisor--default-target-link-override nil)
        (valid-id-set (make-hash-table :test 'equal)))
    (puthash "my-service" 0 valid-id-set)
    (should-error (supervisor--resolve-startup-root valid-id-set)
                  :type 'user-error)))

(ert-deftest supervisor-test-resolve-non-target-link-errors ()
  "Link that resolves to non-.target signals user-error."
  (let ((supervisor-default-target "default.target")
        (supervisor-default-target-link "my-service")
        (supervisor--default-target-link-override nil)
        (valid-id-set (make-hash-table :test 'equal)))
    (puthash "my-service" 0 valid-id-set)
    (should-error (supervisor--resolve-startup-root valid-id-set)
                  :type 'user-error)))

(ert-deftest supervisor-test-resolve-circular-alias-errors ()
  "Setting default-target-link to default.target signals user-error."
  (let ((supervisor-default-target "default.target")
        (supervisor-default-target-link "default.target")
        (supervisor--default-target-link-override nil)
        (valid-id-set (make-hash-table :test 'equal)))
    (puthash "default.target" t valid-id-set)
    (should-error (supervisor--resolve-startup-root valid-id-set)
                  :type 'user-error)))

(ert-deftest supervisor-test-resolve-circular-alias-override-errors ()
  "Override link to default.target signals user-error."
  (let ((supervisor-default-target "default.target")
        (supervisor-default-target-link "graphical.target")
        (supervisor--default-target-link-override "default.target")
        (valid-id-set (make-hash-table :test 'equal)))
    (puthash "default.target" t valid-id-set)
    (should-error (supervisor--resolve-startup-root valid-id-set)
                  :type 'user-error)))

(ert-deftest supervisor-test-maintenance-unit-content-no-stage ()
  "Seeded maintenance unit content does not contain :stage."
  (let ((content (supervisor--maintenance-unit-content
                  '(:id "logrotate"
                    :command "/usr/bin/logrotate"
                    :description "Rotate logs"))))
    (should-not (string-match-p ":stage" content))))

(ert-deftest supervisor-test-resolve-rejects-invalid-entry-id ()
  "Startup root resolution uses valid entries only, not raw order-index.
An invalid entry ID that happens to end in .target must not pass."
  (let* ((programs '(("invalid-entry" :id "bad.target" :type target
                      :unknown-keyword t)
                     ("true" :id "svc")))
         (plan (supervisor--build-plan programs)))
    ;; bad.target is in order-index (raw) but not in valid entries
    (should (gethash "bad.target" (supervisor-plan-order-index plan)))
    (should-not (cl-find "bad.target" (supervisor-plan-entries plan)
                         :key #'supervisor-entry-id :test #'equal))
    ;; Validation with valid-only set should reject it
    (let ((valid-ids (make-hash-table :test 'equal)))
      (dolist (entry (supervisor-plan-entries plan))
        (puthash (supervisor-entry-id entry) t valid-ids))
      (let ((supervisor-default-target "bad.target")
            (supervisor--default-target-link-override nil))
        (should-error (supervisor--resolve-startup-root valid-ids)
                      :type 'user-error)))))

(ert-deftest supervisor-test-scaffold-no-stage ()
  "Unit-file scaffold does not contain :stage."
  (let ((content (supervisor--unit-file-scaffold "my-svc")))
    (should-not (string-match-p ":stage" content))))

;;; Phase 2 Commit B: Hard cutover tests

(ert-deftest supervisor-test-plan-version-2 ()
  "Plan struct version is 2 after stage removal."
  (should (= 2 supervisor-plan-version)))

(ert-deftest supervisor-test-plan-by-target-global-sort ()
  "Plan by-target is a flat list, not an alist keyed by stage."
  (let* ((programs '(("true" :id "a")
                     ("true" :id "b" :after "a")))
         (plan (supervisor--build-plan programs)))
    ;; by-target should be a flat list of entries
    (let ((sorted (supervisor-plan-by-target plan)))
      (should (listp sorted))
      ;; Not an alist -- first element should be an entry, not a cons of (int . list)
      (should (stringp (supervisor-entry-id (car sorted))))
      ;; a before b (b depends on a)
      (should (equal (mapcar #'supervisor-entry-id sorted) '("a" "b"))))))

(ert-deftest supervisor-test-builtin-target-ordering-in-plan ()
  "Built-in targets appear in dependency order in plan."
  (let* ((programs
          '((nil :id "basic.target" :type target)
            (nil :id "multi-user.target" :type target
                 :requires ("basic.target") :after ("basic.target"))
            (nil :id "graphical.target" :type target
                 :requires ("multi-user.target") :after ("multi-user.target"))
            (nil :id "default.target" :type target)))
         (plan (supervisor--build-plan programs)))
    (let* ((sorted (supervisor-plan-by-target plan))
           (ids (mapcar #'supervisor-entry-id sorted)))
      ;; basic.target before multi-user.target before graphical.target
      (should (< (cl-position "basic.target" ids :test #'equal)
                 (cl-position "multi-user.target" ids :test #'equal)))
      (should (< (cl-position "multi-user.target" ids :test #'equal)
                 (cl-position "graphical.target" ids :test #'equal))))))

(ert-deftest supervisor-test-no-cross-stage-concept ()
  "Entries with different former stages can depend on each other."
  (let* ((programs '(("true" :id "a")
                     ("true" :id "b" :after "a")))
         (plan (supervisor--build-plan programs)))
    ;; Both entries are in a single flat list (no stage separation)
    (let ((sorted (supervisor-plan-by-target plan)))
      (should (= 2 (length sorted)))
      (should (equal (mapcar #'supervisor-entry-id sorted) '("a" "b"))))))

(ert-deftest supervisor-test-startup-timeout-defcustom ()
  "Startup timeout defcustom exists with correct default."
  (should (boundp 'supervisor-startup-timeout))
  ;; Default is nil (no timeout)
  (should-not (default-value 'supervisor-startup-timeout)))

(ert-deftest supervisor-test-builtin-programs-overridden-by-disk ()
  "Disk unit file with same ID overrides the built-in entry."
  (let* ((dir (make-temp-file "units-" t))
         (supervisor-unit-authority-path (list dir))
         (supervisor-unit-directory dir)
         (supervisor--programs-cache :not-yet-loaded)
         (supervisor--unit-file-invalid (make-hash-table :test 'equal)))
    (supervisor-test--write-unit-files dir '(("echo hi" :id "logrotate" :type oneshot)))
    (unwind-protect
        (progn
          (supervisor--load-programs)
          (let ((ids (mapcar (lambda (e) (plist-get (cdr e) :id))
                             supervisor--programs-cache)))
            ;; Should appear exactly once (disk version, not builtin)
            (should (= 1 (cl-count "logrotate" ids :test #'equal)))
            ;; The command should be the disk version, not the builtin
            (let ((entry (cl-find "logrotate" supervisor--programs-cache
                                  :key (lambda (e) (plist-get (cdr e) :id))
                                  :test #'equal)))
              (should (string-match-p "echo hi" (car entry))))))
      (delete-directory dir t))))

(ert-deftest supervisor-test-builtin-timers-present ()
  "Built-in timers are included when `supervisor-timers' is nil."
  (let* ((dir (make-temp-file "units-" t))
         (supervisor-unit-authority-path (list dir))
         (supervisor-unit-directory dir)
         (supervisor--programs-cache :not-yet-loaded)
         (supervisor--unit-file-invalid (make-hash-table :test 'equal)))
    (supervisor-test--write-unit-files
     dir '(("echo rotate" :id "logrotate" :type oneshot)))
    (unwind-protect
        (let* ((supervisor-timers nil)
               (programs (supervisor--effective-programs))
               (plan (supervisor--build-plan programs))
               (timers (supervisor-timer-build-list plan)))
          (should (cl-find "logrotate-daily" timers
                           :key #'supervisor-timer-id
                           :test #'equal))
          (should (cl-find "log-prune-daily" timers
                           :key #'supervisor-timer-id
                           :test #'equal)))
      (delete-directory dir t))))

(ert-deftest supervisor-test-builtin-timers-overridden-by-user ()
  "User timer with same ID overrides the built-in timer."
  (let* ((dir (make-temp-file "units-" t))
         (supervisor-unit-authority-path (list dir))
         (supervisor-unit-directory dir)
         (supervisor--programs-cache :not-yet-loaded)
         (supervisor--unit-file-invalid (make-hash-table :test 'equal)))
    (supervisor-test--write-unit-files
     dir '(("echo rotate" :id "logrotate" :type oneshot)))
    (unwind-protect
        (let* ((supervisor-timers '((:id "logrotate-daily"
                                     :target "logrotate"
                                     :on-startup-sec 300
                                     :enabled t)))
               (programs (supervisor--effective-programs))
               (plan (supervisor--build-plan programs))
               (timers (supervisor-timer-build-list plan)))
          ;; Should appear exactly once
          (should (= 1 (cl-count "logrotate-daily" timers
                                  :key #'supervisor-timer-id
                                  :test #'equal)))
          ;; Should have user's on-startup-sec, not builtin's on-calendar
          (let ((timer (cl-find "logrotate-daily" timers
                                :key #'supervisor-timer-id
                                :test #'equal)))
            (should (= 300 (supervisor-timer-on-startup-sec timer))))
          ;; Other built-in timer remains present.
          (should (cl-find "log-prune-daily" timers
                           :key #'supervisor-timer-id
                           :test #'equal)))
      (delete-directory dir t))))

(ert-deftest supervisor-test-timer-subsystem-default-enabled ()
  "Timer subsystem mode defaults to enabled."
  ;; init-value is t, so the variable should be t by default
  (should (eq t (default-value 'supervisor-timer-subsystem-mode))))

(ert-deftest supervisor-test-timer-completion-does-not-signal-writers ()
  "Timer completion does not send reopen signals implicitly."
  (supervisor-test-with-unit-files
      '(("true" :id "s1" :type oneshot))
    (let* ((supervisor-timer-subsystem-mode t)
           (supervisor-mode t)
           (timer (supervisor-timer--create :id "t1" :target "s1" :enabled t))
           (supervisor--timer-state (make-hash-table :test 'equal))
           (supervisor--processes (make-hash-table :test 'equal))
           (supervisor--enabled-override (make-hash-table :test 'equal))
           (supervisor--invalid (make-hash-table :test 'equal))
           (supervisor--scheduler-startup-time (float-time))
           (captured-callback nil)
           (reopen-called nil))
      (cl-letf (((symbol-function 'supervisor--start-entry-async)
                 (lambda (_entry callback) (setq captured-callback callback)))
                ((symbol-function 'supervisor--signal-writers-reopen)
                 (lambda () (setq reopen-called t)))
                ((symbol-function 'supervisor-timer--on-target-complete)
                 (lambda (_id _target-id _success) nil)))
        (unwind-protect
            (progn
              (supervisor-timer--trigger timer 'scheduled)
              ;; Callback should have been captured
              (should captured-callback)
              ;; Completion callback should run without signaling writers.
              (funcall captured-callback t)
              (funcall captured-callback nil)
              (should-not reopen-called))
          (clrhash supervisor--invalid)
          (clrhash supervisor--timer-state)
          (clrhash supervisor--processes)
          (clrhash supervisor--enabled-override))))))

;;;; Phase 9: Test Coverage Expansion

(ert-deftest supervisor-test-logging-toggle-deferred-until-restart ()
  "Policy toggle changes the override hash but does not affect running writer."
  (supervisor-test-with-unit-files
      '(("sleep 300" :id "svc" :type simple))
    (let ((supervisor--logging (make-hash-table :test 'equal))
          (supervisor--writers (make-hash-table :test 'equal))
          (supervisor--invalid (make-hash-table :test 'equal))
          (supervisor-overrides-file nil)
          (fake-writer (start-process "fake-writer" nil "sleep" "300")))
      (unwind-protect
          (progn
            ;; Simulate a running writer for "svc"
            (puthash "svc" fake-writer supervisor--writers)
            ;; Toggle logging off via policy mutator
            (let ((result (supervisor--policy-set-logging "svc" nil)))
              (should (eq 'applied (plist-get result :status)))
              ;; Override hash should record disabled
              (should (eq 'disabled (gethash "svc" supervisor--logging)))
              ;; Writer should still be in the hash (not stopped mid-flight)
              (should (eq fake-writer (gethash "svc" supervisor--writers)))
              ;; Writer process should still be live
              (should (process-live-p fake-writer))))
        (when (process-live-p fake-writer)
          (delete-process fake-writer))))))

(ert-deftest supervisor-test-logging-enabled-on-restart-spawns-writer ()
  "Start-process spawns a writer when effective logging is enabled."
  (let ((supervisor--writers (make-hash-table :test 'equal))
        (supervisor--processes (make-hash-table :test 'equal))
        (supervisor--shutting-down nil)
        (supervisor--restart-timers (make-hash-table :test 'equal))
        (supervisor--manually-stopped (make-hash-table :test 'equal))
        (supervisor--enabled-override (make-hash-table :test 'equal))
        (supervisor--failed (make-hash-table :test 'equal))
        (supervisor--logging (make-hash-table :test 'equal))
        (supervisor--spawn-failure-reason (make-hash-table :test 'equal))
        (supervisor-log-directory "/tmp/test-logs")
        (writer-started nil)
        (fake-proc (start-process "fake-svc" nil "sleep" "300")))
    (unwind-protect
        (cl-letf (((symbol-function 'supervisor--get-effective-logging)
                   (lambda (_id _default) t))
                  ((symbol-function 'supervisor--ensure-log-directory)
                   #'ignore)
                  ((symbol-function 'supervisor--log-file)
                   (lambda (id) (format "/tmp/test-logs/log-%s.log" id)))
                  ((symbol-function 'supervisor--start-writer)
                   (lambda (_id _file)
                     (setq writer-started t)
                     fake-proc))
                  ((symbol-function 'make-process)
                   (lambda (&rest _args) fake-proc))
                  ((symbol-function 'supervisor--make-process-sentinel)
                   (lambda (&rest _args) #'ignore))
                  ((symbol-function 'supervisor--build-launch-command)
                   (lambda (_cmd &rest _args) (list "sleep" "300"))))
          (let ((proc (supervisor--start-process
                       "svc" "sleep 300" nil 'simple 'always)))
            (should proc)
            (should writer-started)))
      (when (process-live-p fake-proc)
        (delete-process fake-proc)))))

(ert-deftest supervisor-test-start-process-split-stderr-wiring ()
  "Start-process uses split stderr wiring when stream targets differ."
  (let ((supervisor--writers (make-hash-table :test 'equal))
        (supervisor--stderr-writers (make-hash-table :test 'equal))
        (supervisor--stderr-pipes (make-hash-table :test 'equal))
        (supervisor--processes (make-hash-table :test 'equal))
        (supervisor--shutting-down nil)
        (supervisor--restart-timers (make-hash-table :test 'equal))
        (supervisor--manually-stopped (make-hash-table :test 'equal))
        (supervisor--enabled-override (make-hash-table :test 'equal))
        (supervisor--failed (make-hash-table :test 'equal))
        (supervisor--logging (make-hash-table :test 'equal))
        (supervisor--spawn-failure-reason (make-hash-table :test 'equal))
        (stdout-file nil)
        (stderr-file nil)
        (captured-stderr nil)
        (captured-filter nil)
        (fake-stdout (start-process "fake-stdout-writer" nil "sleep" "300"))
        (fake-stderr (start-process "fake-stderr-writer" nil "sleep" "300"))
        (fake-proc (start-process "fake-svc" nil "sleep" "300"))
        (fake-stderr-pipe 'fake-stderr-pipe))
    (unwind-protect
        (cl-letf (((symbol-function 'supervisor--get-effective-logging)
                   (lambda (_id _default) t))
                  ((symbol-function 'supervisor--start-writer)
                   (lambda (_id file)
                     (setq stdout-file file)
                     fake-stdout))
                  ((symbol-function 'supervisor--start-stderr-writer)
                   (lambda (_id file)
                     (setq stderr-file file)
                     fake-stderr))
                  ((symbol-function 'supervisor--start-stderr-pipe)
                   (lambda (_id _writer) fake-stderr-pipe))
                  ((symbol-function 'make-process)
                   (lambda (&rest args)
                     (setq captured-stderr (plist-get args :stderr))
                     (setq captured-filter (plist-get args :filter))
                     fake-proc))
                  ((symbol-function 'supervisor--make-process-sentinel)
                   (lambda (&rest _args) #'ignore))
                  ((symbol-function 'supervisor--build-launch-command)
                   (lambda (_cmd &rest _args) (list "sleep" "300"))))
          (let ((proc (supervisor--start-process
                       "svc" "sleep 300" t 'simple 'always
                       nil nil nil nil nil nil nil nil
                       "/tmp/svc.out.log" "/tmp/svc.err.log")))
            (should proc)
            (should (equal stdout-file "/tmp/svc.out.log"))
            (should (equal stderr-file "/tmp/svc.err.log"))
            (should (eq captured-stderr fake-stderr-pipe))
            (should captured-filter)))
      (when (process-live-p fake-proc) (delete-process fake-proc))
      (when (process-live-p fake-stdout) (delete-process fake-stdout))
      (when (process-live-p fake-stderr) (delete-process fake-stderr)))))

(ert-deftest supervisor-test-start-process-merged-stderr-when-targets-equal ()
  "Start-process keeps merged stderr when stream targets are the same."
  (let ((supervisor--writers (make-hash-table :test 'equal))
        (supervisor--stderr-writers (make-hash-table :test 'equal))
        (supervisor--stderr-pipes (make-hash-table :test 'equal))
        (supervisor--processes (make-hash-table :test 'equal))
        (supervisor--shutting-down nil)
        (supervisor--restart-timers (make-hash-table :test 'equal))
        (supervisor--manually-stopped (make-hash-table :test 'equal))
        (supervisor--enabled-override (make-hash-table :test 'equal))
        (supervisor--failed (make-hash-table :test 'equal))
        (supervisor--logging (make-hash-table :test 'equal))
        (supervisor--spawn-failure-reason (make-hash-table :test 'equal))
        (stderr-writer-called nil)
        (captured-stderr 'unset)
        (fake-writer (start-process "fake-writer" nil "sleep" "300"))
        (fake-proc (start-process "fake-svc" nil "sleep" "300")))
    (unwind-protect
        (cl-letf (((symbol-function 'supervisor--get-effective-logging)
                   (lambda (_id _default) t))
                  ((symbol-function 'supervisor--start-writer)
                   (lambda (_id _file) fake-writer))
                  ((symbol-function 'supervisor--start-stderr-writer)
                   (lambda (&rest _args)
                     (setq stderr-writer-called t)
                     nil))
                  ((symbol-function 'make-process)
                   (lambda (&rest args)
                     (setq captured-stderr (plist-get args :stderr))
                     fake-proc))
                  ((symbol-function 'supervisor--make-process-sentinel)
                   (lambda (&rest _args) #'ignore))
                  ((symbol-function 'supervisor--build-launch-command)
                   (lambda (_cmd &rest _args) (list "sleep" "300"))))
          (let ((proc (supervisor--start-process
                       "svc" "sleep 300" t 'simple 'always
                       nil nil nil nil nil nil nil nil
                       "/tmp/svc.shared.log" "/tmp/svc.shared.log")))
            (should proc)
            (should-not stderr-writer-called)
            (should-not captured-stderr)))
      (when (process-live-p fake-proc) (delete-process fake-proc))
      (when (process-live-p fake-writer) (delete-process fake-writer)))))

(ert-deftest supervisor-test-writer-reopen-sighup-real-process ()
  "Signal-writers-reopen sends SIGHUP to live writer processes."
  (let ((supervisor--writers (make-hash-table :test 'equal))
        (supervisor--stderr-writers (make-hash-table :test 'equal))
        (proc (start-process "test-sleep" nil "sleep" "300")))
    (unwind-protect
        (progn
          (puthash "svc1" proc supervisor--writers)
          (should (process-live-p proc))
          (supervisor--signal-writers-reopen)
          ;; sleep does not handle SIGHUP, so it dies
          (sleep-for 0.1)
          (should-not (process-live-p proc)))
      (when (process-live-p proc)
        (delete-process proc)))))

(ert-deftest supervisor-test-builtin-timer-schedule-is-03-00 ()
  "Built-in logrotate-daily timer has on-calendar at 03:00."
  (let ((timer (cl-find "logrotate-daily" supervisor--builtin-timers
                         :key (lambda (t) (plist-get t :id))
                         :test #'equal)))
    (should timer)
    (let ((cal (plist-get timer :on-calendar)))
      (should (equal 3 (plist-get cal :hour)))
      (should (equal 0 (plist-get cal :minute))))))

(ert-deftest supervisor-test-builtin-log-prune-timer-schedule-is-03-05 ()
  "Built-in log-prune-daily timer has on-calendar at 03:05."
  (let ((timer (cl-find "log-prune-daily" supervisor--builtin-timers
                        :key (lambda (t) (plist-get t :id))
                        :test #'equal)))
    (should timer)
    (let ((cal (plist-get timer :on-calendar)))
      (should (equal 3 (plist-get cal :hour)))
      (should (equal 5 (plist-get cal :minute))))))

(ert-deftest supervisor-test-logrotate-daily-not-scheduled-when-timer-off ()
  "Scheduler does not process timers when subsystem is off."
  (let ((supervisor-timer-subsystem-mode nil)
        (supervisor-mode nil)
        (build-list-called nil))
    (cl-letf (((symbol-function 'supervisor--log) #'ignore))
      ;; supervisor-timer-scheduler-start guards on subsystem-active-p
      ;; and returns early without building or processing any timers
      (cl-letf (((symbol-function 'supervisor-timer-build-list)
                 (lambda (_plan)
                   (setq build-list-called t)
                   nil)))
        (supervisor-timer-scheduler-start)
        ;; build-list should not have been called
        (should-not build-list-called)))))

(ert-deftest supervisor-test-scheduler-not-started-when-timer-off ()
  "Timer scheduler is a no-op when subsystem is not active."
  (let ((supervisor-timer-subsystem-mode nil)
        (supervisor-mode nil)
        (build-list-called nil))
    (cl-letf (((symbol-function 'supervisor--log) #'ignore)
              ((symbol-function 'supervisor-timer-build-list)
               (lambda (_plan)
                 (setq build-list-called t)
                 nil)))
      ;; Call the real scheduler-start with subsystem off
      (supervisor-timer-scheduler-start)
      ;; The guard should have returned early without building timers
      (should-not build-list-called))))

(ert-deftest supervisor-test-logd-rotates-on-size-cap-exceed ()
  "Logd rotates the log file when it exceeds the size cap."
  (let* ((root (file-name-directory (locate-library "supervisor")))
         (logd (expand-file-name "libexec/supervisor-logd" root))
         (dir (make-temp-file "logd-rotate-" t))
         (log-file (expand-file-name "log-svc.log" dir)))
    ;; Build the binary if it is missing or stale.
    (unless (file-executable-p logd)
      (let ((result (supervisor-build-libexec-helpers t)))
        (unless (file-executable-p logd)
          (error "Cannot build supervisor-logd: %S"
                 (or (plist-get result :failed)
                     (plist-get result :missing-source))))))
    (unwind-protect
        (let* ((proc (make-process
                      :name "test-logd"
                      :command (list logd
                                    "--file" log-file
                                    "--max-file-size-bytes" "50")
                      :connection-type 'pipe))
               (wrote nil))
          (unwind-protect
              (progn
                ;; Write enough data to exceed the 50-byte cap
                (process-send-string proc (make-string 80 ?x))
                (setq wrote t)
                ;; Give logd time to write and rotate
                (sleep-for 0.3)
                ;; Close stdin to trigger clean exit
                (process-send-eof proc)
                (sleep-for 0.3)
                ;; A rotated file should exist alongside the fresh log
                (let ((rotated (directory-files dir nil
                                               "^log-svc\\.[0-9].*\\.log$")))
                  (should (>= (length rotated) 1)))
                ;; The active log file should exist (reopened after rotation)
                (should (file-exists-p log-file))
                ;; Active log should be smaller than the cap (fresh after rotate)
                (let ((size (nth 7 (file-attributes log-file))))
                  (should (< size 50))))
            (when (process-live-p proc)
              (delete-process proc))))
      (delete-directory dir t))))

(ert-deftest supervisor-test-timer-enabled-triggers-maintenance ()
  "Enabled logrotate-daily timer triggers target oneshot on schedule."
  (supervisor-test-with-unit-files
      '(("echo maintenance" :id "logrotate" :type oneshot))
    (let* ((supervisor-timer-subsystem-mode t)
           (supervisor-mode t)
           (timer (supervisor-timer--create :id "logrotate-daily"
                                            :target "logrotate"
                                            :enabled t))
           (supervisor--timer-state (make-hash-table :test 'equal))
           (supervisor--processes (make-hash-table :test 'equal))
           (supervisor--enabled-override (make-hash-table :test 'equal))
           (supervisor--invalid (make-hash-table :test 'equal))
           (supervisor--scheduler-startup-time (float-time))
           (triggered-target nil))
      (cl-letf (((symbol-function 'supervisor--start-entry-async)
                 (lambda (entry callback)
                   (setq triggered-target (supervisor-entry-id entry))
                   ;; Simulate success
                   (when callback (funcall callback t))))
                ((symbol-function 'supervisor--signal-writers-reopen) #'ignore)
                ((symbol-function 'supervisor-timer--on-target-complete)
                 (lambda (_id _target-id _success) nil))
                ((symbol-function 'supervisor-timer--save-state) #'ignore))
        (unwind-protect
            (progn
              (supervisor-timer--trigger timer 'scheduled)
              ;; The trigger should have started the "logrotate" target
              (should (equal "logrotate" triggered-target)))
          (clrhash supervisor--invalid)
          (clrhash supervisor--timer-state)
          (clrhash supervisor--processes)
          (clrhash supervisor--enabled-override))))))

;;; Target entry tests

(ert-deftest supervisor-test-target-entry-without-command-valid ()
  "Target entry with empty or nil command and valid :id passes validation."
  ;; Empty string sentinel form
  (should-not (supervisor--validate-entry
               '("" :type target :id "multi.target")))
  ;; Nil car form (first-class inline target)
  (should-not (supervisor--validate-entry
               '(nil :type target :id "multi.target"))))

(ert-deftest supervisor-test-target-entry-with-command-invalid ()
  "Target entry with a non-empty command is rejected."
  ;; Even with a valid .target ID, a non-empty command is rejected
  (should (string-match-p "target entry must not have a command"
                          (supervisor--validate-entry
                           '("my-app" :type target :id "foo.target"))))
  ;; Without explicit :id, the suffix rule also catches it
  (should (supervisor--validate-entry '("my-app" :type target))))

(ert-deftest supervisor-test-target-invalid-keywords-rejected ()
  "Keywords invalid for :type target produce errors."
  (dolist (kw '(:delay :restart :logging :working-directory
                :exec-stop :kill-signal :user :group))
    (let* ((entry (list "" :type 'target :id "test.target" kw t))
           (result (supervisor--validate-entry entry)))
      (should (string-match-p (format "%s is invalid for :type target" kw)
                              result)))))

(ert-deftest supervisor-test-entry-parses-wanted-by-required-by ()
  "Parsed entry contains :wanted-by and :required-by at correct indices."
  (let ((entry (supervisor--parse-entry
                '("sleep 300" :id "myapp"
                  :wanted-by "multi.target"
                  :required-by ("net.target" "gui.target")))))
    (should (equal (supervisor-entry-wanted-by entry) '("multi.target")))
    (should (equal (supervisor-entry-required-by entry)
                   '("net.target" "gui.target")))
    ;; Verify index positions
    (should (equal (nth 31 entry) '("multi.target")))
    (should (equal (nth 32 entry) '("net.target" "gui.target")))))

(ert-deftest supervisor-test-target-id-without-suffix-invalid ()
  "Target entry ID not ending in .target is rejected."
  (should (string-match-p ":type target requires ID ending in .target"
                          (supervisor--validate-entry
                           '("" :type target :id "myservice")))))

(ert-deftest supervisor-test-non-target-id-with-suffix-invalid ()
  "Non-target entry with ID ending in .target is rejected."
  (should (string-match-p "non-target ID must not end in .target"
                          (supervisor--validate-entry
                           '("sleep 300" :id "oops.target")))))

(ert-deftest supervisor-test-target-parses-to-nil-command ()
  "Target entry parses with nil command from both entry forms."
  ;; Empty string sentinel form
  (let ((entry (supervisor--parse-entry
                '("" :type target :id "multi.target"))))
    (should (equal (supervisor-entry-id entry) "multi.target"))
    (should (null (supervisor-entry-command entry)))
    (should (eq (supervisor-entry-type entry) 'target))
    (should (= (length entry) 39)))
  ;; Nil car form
  (let ((entry (supervisor--parse-entry
                '(nil :type target :id "multi.target"))))
    (should (equal (supervisor-entry-id entry) "multi.target"))
    (should (null (supervisor-entry-command entry)))
    (should (eq (supervisor-entry-type entry) 'target))
    (should (= (length entry) 39))))

(ert-deftest supervisor-test-wanted-by-shape-string-valid ()
  ":wanted-by as a string passes validation."
  (should-not (supervisor--validate-entry
               '("sleep 300" :wanted-by "multi.target"))))

(ert-deftest supervisor-test-wanted-by-shape-list-valid ()
  ":wanted-by as a list of strings passes validation."
  (should-not (supervisor--validate-entry
               '("sleep 300" :wanted-by ("a.target" "b.target")))))

(ert-deftest supervisor-test-wanted-by-shape-invalid ()
  ":wanted-by as a non-string, non-list is rejected."
  (should (string-match-p ":wanted-by must be a string or list of strings"
                          (supervisor--validate-entry
                           '("sleep 300" :wanted-by 42)))))

(ert-deftest supervisor-test-required-by-shape-invalid ()
  ":required-by with non-string element is rejected."
  (should (string-match-p ":required-by must be a string or list of strings"
                          (supervisor--validate-entry
                           '("sleep 300" :required-by (42))))))

(ert-deftest supervisor-test-wanted-by-missing-target-invalidates-owner ()
  ":wanted-by referencing non-existent target invalidates the entry."
  (let* ((programs '(("" :type target :id "multi.target")
                     ("sleep 300" :id "myapp"
                      :wanted-by "missing.target")))
         (plan (supervisor--build-plan programs)))
    (should (gethash "myapp" (supervisor-plan-invalid plan)))
    (should (string-match-p "non-existent target"
                            (gethash "myapp" (supervisor-plan-invalid plan))))))

(ert-deftest supervisor-test-wanted-by-non-target-invalidates-owner ()
  ":wanted-by referencing a non-target entry invalidates the entry."
  (let* ((programs '(("sleep 100" :id "svc-a")
                     ("sleep 300" :id "myapp"
                      :wanted-by "svc-a")))
         (plan (supervisor--build-plan programs)))
    (should (gethash "myapp" (supervisor-plan-invalid plan)))
    (should (string-match-p "which is not a target"
                            (gethash "myapp" (supervisor-plan-invalid plan))))))

(ert-deftest supervisor-test-required-by-non-target-invalidates-owner ()
  ":required-by referencing a non-target entry invalidates the entry."
  (let* ((programs '(("sleep 100" :id "svc-a")
                     ("sleep 300" :id "myapp"
                      :required-by "svc-a")))
         (plan (supervisor--build-plan programs)))
    (should (gethash "myapp" (supervisor-plan-invalid plan)))
    (should (string-match-p "which is not a target"
                            (gethash "myapp" (supervisor-plan-invalid plan))))))

(ert-deftest supervisor-test-wanted-by-valid-target-accepted ()
  ":wanted-by referencing an existing target passes reference validation."
  (let* ((programs '(("" :type target :id "multi.target")
                     ("sleep 300" :id "myapp"
                      :wanted-by "multi.target")))
         (plan (supervisor--build-plan programs)))
    (should-not (gethash "myapp" (supervisor-plan-invalid plan)))
    (should (cl-find "myapp" (supervisor-plan-entries plan)
                     :key #'supervisor-entry-id :test #'equal))))

(ert-deftest supervisor-test-target-requires-missing-ref-invalid ()
  "Target with :requires referencing non-existent ID is invalid."
  (let* ((programs '(("" :type target :id "multi.target"
                      :requires "missing-service")))
         (plan (supervisor--build-plan programs)))
    (should (gethash "multi.target" (supervisor-plan-invalid plan)))
    (should (string-match-p ":requires 'missing-service' does not exist"
                            (gethash "multi.target"
                                     (supervisor-plan-invalid plan))))))

(ert-deftest supervisor-test-target-requires-valid-ref-accepted ()
  "Target with :requires referencing an existing entry is valid."
  (let* ((programs '(("sleep 300" :id "myapp")
                     ("" :type target :id "multi.target"
                      :requires "myapp")))
         (plan (supervisor--build-plan programs)))
    (should-not (gethash "multi.target" (supervisor-plan-invalid plan)))))

(ert-deftest supervisor-test-target-missing-wants-drops-with-warning ()
  "Target with :wants referencing non-existent ID drops it with warning."
  (let ((warnings nil))
    (cl-letf (((symbol-function 'supervisor--log)
               (lambda (_level fmt &rest args)
                 (push (apply #'format fmt args) warnings))))
      (let* ((programs '(("" :type target :id "multi.target"
                          :wants "missing-svc")))
             (plan (supervisor--build-plan programs)))
        ;; Target should still be valid (soft dep dropped, not error)
        (should-not (gethash "multi.target" (supervisor-plan-invalid plan)))
        ;; A warning should have been emitted
        (should (cl-some (lambda (w) (string-match-p "missing-svc.*does not exist" w))
                         warnings))))))

(ert-deftest supervisor-test-target-requires-cycle-invalid ()
  "Cycle in target :requires graph marks participants invalid."
  (let* ((programs '(("" :type target :id "a.target"
                      :requires "b.target")
                     ("" :type target :id "b.target"
                      :requires "a.target")))
         (plan (supervisor--build-plan programs)))
    (should (gethash "a.target" (supervisor-plan-invalid plan)))
    (should (gethash "b.target" (supervisor-plan-invalid plan)))
    (should (string-match-p "cycle detected"
                            (gethash "a.target"
                                     (supervisor-plan-invalid plan))))))

(ert-deftest supervisor-test-target-requires-three-way-cycle ()
  "Three-way cycle in target :requires marks all participants invalid."
  (let* ((programs '(("" :type target :id "a.target"
                      :requires "b.target")
                     ("" :type target :id "b.target"
                      :requires "c.target")
                     ("" :type target :id "c.target"
                      :requires "a.target")))
         (plan (supervisor--build-plan programs)))
    (should (gethash "a.target" (supervisor-plan-invalid plan)))
    (should (gethash "b.target" (supervisor-plan-invalid plan)))
    (should (gethash "c.target" (supervisor-plan-invalid plan)))))

(ert-deftest supervisor-test-target-entry-type-returns-target ()
  "`supervisor-entry-type' returns target for target entries."
  (let ((entry (supervisor--parse-entry
                '("" :type target :id "multi.target"))))
    (should (eq (supervisor-entry-type entry) 'target))))

(ert-deftest supervisor-test-target-with-after-valid ()
  "Target entry with :after passes validation."
  (should-not (supervisor--validate-entry
               '("" :type target :id "multi.target"
                 :after "some-service"))))

(ert-deftest supervisor-test-backward-compat-31-element-tuple-accessors ()
  "Accessors for wanted-by and required-by return nil for shorter tuples."
  ;; Simulate a 31-element tuple (pre-extension)
  (let ((short-entry (make-list 31 nil)))
    (should (null (supervisor-entry-wanted-by short-entry)))
    (should (null (supervisor-entry-required-by short-entry)))))

(ert-deftest supervisor-test-target-self-wanted-by-rejected ()
  ":wanted-by referencing own ID is rejected."
  (should (string-match-p ":wanted-by must not reference the entry's own ID"
                          (supervisor--validate-entry
                           '("" :type target :id "multi.target"
                             :wanted-by "multi.target")))))

(ert-deftest supervisor-test-target-required-by-self-rejected ()
  ":required-by referencing own ID is rejected."
  (should (string-match-p ":required-by must not reference the entry's own ID"
                          (supervisor--validate-entry
                           '("sleep 300" :id "svc"
                             :required-by "svc")))))

(ert-deftest supervisor-test-nil-car-target-duplicate-id-detected ()
  "Duplicate nil-car target entries are correctly deduplicated by ID."
  (let* ((programs '((nil :type target :id "a.target")
                     (nil :type target :id "a.target")))
         (plan (supervisor--build-plan programs)))
    ;; Only one should survive (first wins)
    (should (= 1 (length (supervisor-plan-entries plan))))))

(ert-deftest supervisor-test-extract-id-nil-car-target ()
  "`supervisor--extract-id' returns :id for nil-car target entries."
  (should (equal "a.target"
                 (supervisor--extract-id
                  '(nil :type target :id "a.target") 0))))

;;;; Phase 3: Transaction Expansion Engine

(ert-deftest supervisor-test-materialize-target-members-basic ()
  "Materialize target members from :wanted-by declarations."
  (let* ((programs '(("sleep 1" :id "svc-a" :wanted-by ("multi-user.target"))
                     ("sleep 2" :id "svc-b" :wanted-by ("multi-user.target"))
                     (nil :id "multi-user.target" :type target)))
         (plan (supervisor--build-plan programs))
         (members (supervisor--materialize-target-members
                   (supervisor-plan-entries plan))))
    (should (hash-table-p members))
    (let ((mu (gethash "multi-user.target" members)))
      (should mu)
      ;; :wanted-by produces :wants membership
      (should (equal '("svc-a" "svc-b") (plist-get mu :wants)))
      ;; No :requires members
      (should-not (plist-get mu :requires)))))

(ert-deftest supervisor-test-materialize-target-members-empty ()
  "Materialize returns empty hash when no services declare membership."
  (let* ((programs '((nil :id "basic.target" :type target)
                     ("sleep 1" :id "svc-a")))
         (plan (supervisor--build-plan programs))
         (members (supervisor--materialize-target-members
                   (supervisor-plan-entries plan))))
    (should (hash-table-p members))
    (should (= 0 (hash-table-count members)))))

(ert-deftest supervisor-test-materialize-required-by-members ()
  "Services with :required-by produce :requires membership in target."
  (let* ((programs '(("sleep 1" :id "svc-a" :required-by ("basic.target"))
                     (nil :id "basic.target" :type target)))
         (plan (supervisor--build-plan programs))
         (members (supervisor--materialize-target-members
                   (supervisor-plan-entries plan))))
    (let ((bt (gethash "basic.target" members)))
      (should bt)
      (should (equal '("svc-a") (plist-get bt :requires)))
      (should-not (plist-get bt :wants)))))

(ert-deftest supervisor-test-expand-transaction-single-target ()
  "Expansion of a single target with wanted-by services."
  (let* ((programs '(("sleep 1" :id "svc-a" :wanted-by ("basic.target"))
                     ("sleep 2" :id "svc-b" :wanted-by ("basic.target"))
                     ("sleep 3" :id "svc-c")
                     (nil :id "basic.target" :type target)))
         (plan (supervisor--build-plan programs))
         (entries-by-id (make-hash-table :test 'equal))
         (_ (dolist (e (supervisor-plan-entries plan))
              (puthash (supervisor-entry-id e) e entries-by-id)))
         (members (supervisor--materialize-target-members
                   (supervisor-plan-entries plan)))
         (closure (supervisor--expand-transaction
                   "basic.target" entries-by-id members
                   (supervisor-plan-order-index plan))))
    ;; basic.target and its two wanted services are in closure
    (should (gethash "basic.target" closure))
    (should (gethash "svc-a" closure))
    (should (gethash "svc-b" closure))
    ;; svc-c has no membership, not activated
    (should-not (gethash "svc-c" closure))))

(ert-deftest supervisor-test-expand-transaction-target-chain ()
  "Expansion follows target :requires chain."
  (let* ((programs '(("sleep 1" :id "svc-a" :wanted-by ("basic.target"))
                     (nil :id "basic.target" :type target)
                     (nil :id "multi-user.target" :type target
                          :requires ("basic.target")
                          :after ("basic.target"))))
         (plan (supervisor--build-plan programs))
         (entries-by-id (make-hash-table :test 'equal))
         (_ (dolist (e (supervisor-plan-entries plan))
              (puthash (supervisor-entry-id e) e entries-by-id)))
         (members (supervisor--materialize-target-members
                   (supervisor-plan-entries plan)))
         (closure (supervisor--expand-transaction
                   "multi-user.target" entries-by-id members
                   (supervisor-plan-order-index plan))))
    ;; multi-user pulls in basic via :requires
    (should (gethash "multi-user.target" closure))
    (should (gethash "basic.target" closure))
    ;; basic pulls in svc-a via membership
    (should (gethash "svc-a" closure))))

(ert-deftest supervisor-test-expand-transaction-service-pull-in ()
  "Expansion follows service :requires for pull-in."
  (let* ((programs '(("sleep 1" :id "svc-a"
                                :wanted-by ("basic.target")
                                :requires ("svc-dep"))
                     ("sleep 2" :id "svc-dep")
                     (nil :id "basic.target" :type target)))
         (plan (supervisor--build-plan programs))
         (entries-by-id (make-hash-table :test 'equal))
         (_ (dolist (e (supervisor-plan-entries plan))
              (puthash (supervisor-entry-id e) e entries-by-id)))
         (members (supervisor--materialize-target-members
                   (supervisor-plan-entries plan)))
         (closure (supervisor--expand-transaction
                   "basic.target" entries-by-id members
                   (supervisor-plan-order-index plan))))
    ;; svc-a is pulled in by basic.target, and svc-dep by svc-a's :requires
    (should (gethash "basic.target" closure))
    (should (gethash "svc-a" closure))
    (should (gethash "svc-dep" closure))))

(ert-deftest supervisor-test-expand-transaction-transitive-service-requires ()
  "Expansion follows transitive service :requires chains."
  (let* ((programs '(("sleep 1" :id "svc-a"
                                :wanted-by ("basic.target")
                                :requires ("svc-b"))
                     ("sleep 2" :id "svc-b" :requires ("svc-c"))
                     ("sleep 3" :id "svc-c")
                     (nil :id "basic.target" :type target)))
         (plan (supervisor--build-plan programs))
         (entries-by-id (make-hash-table :test 'equal))
         (_ (dolist (e (supervisor-plan-entries plan))
              (puthash (supervisor-entry-id e) e entries-by-id)))
         (members (supervisor--materialize-target-members
                   (supervisor-plan-entries plan)))
         (closure (supervisor--expand-transaction
                   "basic.target" entries-by-id members
                   (supervisor-plan-order-index plan))))
    (should (gethash "basic.target" closure))
    (should (gethash "svc-a" closure))
    (should (gethash "svc-b" closure))
    (should (gethash "svc-c" closure))))

(ert-deftest supervisor-test-expand-transaction-deterministic ()
  "Expansion output is deterministic across identical input."
  (let* ((programs '(("sleep 1" :id "svc-a" :wanted-by ("basic.target"))
                     ("sleep 2" :id "svc-b" :wanted-by ("basic.target"))
                     ("sleep 3" :id "svc-c" :wanted-by ("basic.target"))
                     (nil :id "basic.target" :type target)))
         (plan (supervisor--build-plan programs))
         (entries-by-id (make-hash-table :test 'equal))
         (_ (dolist (e (supervisor-plan-entries plan))
              (puthash (supervisor-entry-id e) e entries-by-id)))
         (members (supervisor--materialize-target-members
                   (supervisor-plan-entries plan)))
         (c1 (supervisor--expand-transaction
              "basic.target" entries-by-id members
              (supervisor-plan-order-index plan)))
         (c2 (supervisor--expand-transaction
              "basic.target" entries-by-id members
              (supervisor-plan-order-index plan))))
    ;; Same number of entries
    (should (= (hash-table-count c1) (hash-table-count c2)))
    ;; Same entries
    (maphash (lambda (k _v) (should (gethash k c2))) c1)))

(ert-deftest supervisor-test-expand-transaction-missing-dep-ignored ()
  "Expansion ignores :requires deps that don't exist in entries-by-id."
  (let* ((programs '(("sleep 1" :id "svc-a"
                                :wanted-by ("basic.target")
                                :requires ("nonexistent"))
                     (nil :id "basic.target" :type target)))
         (plan (supervisor--build-plan programs)))
    ;; svc-a has :requires "nonexistent" which is invalid and removed
    ;; during validation, so the plan entries should not reference it.
    ;; Build expansion from plan entries:
    (let ((entries-by-id (make-hash-table :test 'equal)))
      (dolist (e (supervisor-plan-entries plan))
        (puthash (supervisor-entry-id e) e entries-by-id))
      (let* ((members (supervisor--materialize-target-members
                       (supervisor-plan-entries plan)))
             (closure (supervisor--expand-transaction
                       "basic.target" entries-by-id members
                       (supervisor-plan-order-index plan))))
        (should (gethash "basic.target" closure))
        ;; svc-a still activated (its wanted-by is valid)
        (should (gethash "svc-a" closure))
        ;; nonexistent is not in closure
        (should-not (gethash "nonexistent" closure))))))

(ert-deftest supervisor-test-expand-transaction-no-membership-not-activated ()
  "Services without target membership are not activated."
  (let* ((programs '(("sleep 1" :id "svc-member" :wanted-by ("basic.target"))
                     ("sleep 2" :id "svc-orphan")
                     (nil :id "basic.target" :type target)))
         (plan (supervisor--build-plan programs))
         (entries-by-id (make-hash-table :test 'equal))
         (_ (dolist (e (supervisor-plan-entries plan))
              (puthash (supervisor-entry-id e) e entries-by-id)))
         (members (supervisor--materialize-target-members
                   (supervisor-plan-entries plan)))
         (closure (supervisor--expand-transaction
                   "basic.target" entries-by-id members
                   (supervisor-plan-order-index plan))))
    (should (gethash "svc-member" closure))
    (should-not (gethash "svc-orphan" closure))))

(ert-deftest supervisor-test-plan-with-root-filters-by-target ()
  "When supervisor-start resolves a root, by-target is filtered to closure."
  ;; Use build-plan directly and compute expansion post-hoc (as start does)
  (let* ((programs '(("sleep 1" :id "svc-a" :wanted-by ("basic.target"))
                     ("sleep 2" :id "svc-orphan")
                     (nil :id "basic.target" :type target)))
         (plan (supervisor--build-plan programs)))
    ;; by-target before expansion has all entries
    (let ((all-ids (mapcar #'supervisor-entry-id
                           (supervisor-plan-by-target plan))))
      (should (member "svc-a" all-ids))
      (should (member "svc-orphan" all-ids))
      (should (member "basic.target" all-ids)))
    ;; Now compute expansion and filter (as supervisor-start would)
    (let ((entries-by-id (make-hash-table :test 'equal)))
      (dolist (e (supervisor-plan-entries plan))
        (puthash (supervisor-entry-id e) e entries-by-id))
      (let* ((members (supervisor--materialize-target-members
                       (supervisor-plan-entries plan)))
             (closure (supervisor--expand-transaction
                       "basic.target" entries-by-id members
                       (supervisor-plan-order-index plan))))
        (setf (supervisor-plan-by-target plan)
              (cl-remove-if-not
               (lambda (e) (gethash (supervisor-entry-id e) closure))
               (supervisor-plan-by-target plan)))
        ;; Now by-target only has closure entries
        (let ((filtered-ids (mapcar #'supervisor-entry-id
                                    (supervisor-plan-by-target plan))))
          (should (member "svc-a" filtered-ids))
          (should (member "basic.target" filtered-ids))
          (should-not (member "svc-orphan" filtered-ids)))))))

(ert-deftest supervisor-test-plan-without-root-full-list ()
  "Without activation root, by-target contains full sorted list."
  (let* ((programs '(("sleep 1" :id "a")
                     ("sleep 2" :id "b" :after "a")))
         (plan (supervisor--build-plan programs)))
    ;; No root computed -- by-target is full list
    (should-not (supervisor-plan-activation-root plan))
    (should (= 2 (length (supervisor-plan-by-target plan))))))

(ert-deftest supervisor-test-passive-target-in-dag ()
  "Target entries are started as passive nodes in the DAG."
  (let* ((programs '((nil :id "basic.target" :type target)
                     ("sleep 1" :id "svc-a"
                                :after ("basic.target")
                                :wanted-by ("basic.target"))))
         (plan (supervisor--build-plan programs))
         (entries-by-id (make-hash-table :test 'equal))
         (_ (dolist (e (supervisor-plan-entries plan))
              (puthash (supervisor-entry-id e) e entries-by-id)))
         (members (supervisor--materialize-target-members
                   (supervisor-plan-entries plan)))
         (closure (supervisor--expand-transaction
                   "basic.target" entries-by-id members
                   (supervisor-plan-order-index plan)))
         (activated (cl-remove-if-not
                     (lambda (e) (gethash (supervisor-entry-id e) closure))
                     (supervisor-plan-by-target plan))))
    ;; Set up DAG globals
    (let ((supervisor--dag-blocking (make-hash-table :test 'equal))
          (supervisor--dag-in-degree (make-hash-table :test 'equal))
          (supervisor--dag-dependents (make-hash-table :test 'equal))
          (supervisor--dag-entries (make-hash-table :test 'equal))
          (supervisor--dag-started (make-hash-table :test 'equal))
          (supervisor--dag-ready (make-hash-table :test 'equal))
          (supervisor--dag-timeout-timers (make-hash-table :test 'equal))
          (supervisor--dag-delay-timers (make-hash-table :test 'equal))
          (supervisor--dag-id-to-index (make-hash-table :test 'equal))
          (supervisor--mask-override (make-hash-table :test 'equal))
          (supervisor--entry-state (make-hash-table :test 'equal))
          (supervisor--enabled-override (make-hash-table :test 'equal))
          (supervisor--target-members members)
          (supervisor--target-convergence (make-hash-table :test 'equal))
          (supervisor--target-convergence-reasons (make-hash-table :test 'equal))
          (supervisor--target-converging (make-hash-table :test 'equal))
          (supervisor--target-member-reverse (make-hash-table :test 'equal)))
      (supervisor--dag-init activated)
      ;; Target should have 0 in-degree (no deps)
      (should (= 0 (gethash "basic.target" supervisor--dag-in-degree)))
      ;; Now start the target entry
      (let ((target-entry (gethash "basic.target" entries-by-id)))
        (supervisor--dag-start-entry-async target-entry))
      ;; Target should be started and ready immediately
      (should (gethash "basic.target" supervisor--dag-started))
      (should (gethash "basic.target" supervisor--dag-ready))
      ;; State should be 'started
      (should (eq 'started (gethash "basic.target"
                                    supervisor--entry-state))))))

(ert-deftest supervisor-test-dag-deps-filtered-to-entry-set ()
  "DAG init filters :after and :requires deps to entries in the DAG."
  (let* ((programs '(("sleep 1" :id "svc-a" :after ("missing-dep"))
                     ("sleep 2" :id "svc-b")))
         (plan (supervisor--build-plan programs)))
    ;; svc-a references "missing-dep" in :after which will be invalid
    ;; at validation time. Build a plan where svc-a has no after deps
    ;; since missing-dep is invalid. Now test DAG filtering directly:
    (let ((supervisor--dag-blocking (make-hash-table :test 'equal))
          (supervisor--dag-in-degree (make-hash-table :test 'equal))
          (supervisor--dag-dependents (make-hash-table :test 'equal))
          (supervisor--dag-entries (make-hash-table :test 'equal))
          (supervisor--dag-started (make-hash-table :test 'equal))
          (supervisor--dag-ready (make-hash-table :test 'equal))
          (supervisor--dag-timeout-timers (make-hash-table :test 'equal))
          (supervisor--dag-delay-timers (make-hash-table :test 'equal))
          (supervisor--dag-id-to-index (make-hash-table :test 'equal))
          (supervisor--mask-override (make-hash-table :test 'equal))
          (supervisor--entry-state (make-hash-table :test 'equal))
          (supervisor--enabled-override (make-hash-table :test 'equal)))
      ;; Initialize with plan entries (no "missing-dep" entry)
      (supervisor--dag-init (supervisor-plan-by-target plan))
      ;; svc-a should have 0 in-degree (missing-dep filtered out)
      (should (= 0 (gethash "svc-a" supervisor--dag-in-degree))))))

(ert-deftest supervisor-test-builtin-maintenance-no-wanted-by ()
  "Built-in logrotate and log-prune do not declare wanted-by.
They are inert fallback definitions activated only by timers."
  (let* ((builtins (supervisor--builtin-programs))
         (rotate (cl-find "logrotate" builtins
                          :key (lambda (e) (plist-get (cdr e) :id))
                          :test #'equal))
         (prune (cl-find "log-prune" builtins
                         :key (lambda (e) (plist-get (cdr e) :id))
                         :test #'equal)))
    (should-not (plist-member (cdr rotate) :wanted-by))
    (should-not (plist-member (cdr prune) :wanted-by))))

(ert-deftest supervisor-test-startup-activates-only-closure ()
  "Full expansion from graphical.target includes the standard chain."
  (let* ((programs '(("sleep 1" :id "svc-basic" :wanted-by ("basic.target"))
                     ("sleep 2" :id "svc-gui" :wanted-by ("graphical.target"))
                     ("sleep 3" :id "svc-orphan")
                     (nil :id "basic.target" :type target)
                     (nil :id "multi-user.target" :type target
                          :requires ("basic.target")
                          :after ("basic.target"))
                     (nil :id "graphical.target" :type target
                          :requires ("multi-user.target")
                          :after ("multi-user.target"))))
         (plan (supervisor--build-plan programs))
         (entries-by-id (make-hash-table :test 'equal))
         (_ (dolist (e (supervisor-plan-entries plan))
              (puthash (supervisor-entry-id e) e entries-by-id)))
         (members (supervisor--materialize-target-members
                   (supervisor-plan-entries plan)))
         (closure (supervisor--expand-transaction
                   "graphical.target" entries-by-id members
                   (supervisor-plan-order-index plan))))
    ;; All three targets reachable via :requires chain
    (should (gethash "graphical.target" closure))
    (should (gethash "multi-user.target" closure))
    (should (gethash "basic.target" closure))
    ;; Services with membership are activated
    (should (gethash "svc-basic" closure))
    (should (gethash "svc-gui" closure))
    ;; Orphan service is not activated
    (should-not (gethash "svc-orphan" closure))))

(ert-deftest supervisor-test-expand-transaction-wants-soft-pull-in ()
  "Expansion follows :wants edges on both targets and services."
  (let* ((programs '(("sleep 1" :id "svc-a"
                                :wanted-by ("basic.target")
                                :wants ("svc-opt"))
                     ("sleep 2" :id "svc-opt")
                     (nil :id "basic.target" :type target)))
         (plan (supervisor--build-plan programs))
         (entries-by-id (make-hash-table :test 'equal))
         (_ (dolist (e (supervisor-plan-entries plan))
              (puthash (supervisor-entry-id e) e entries-by-id)))
         (members (supervisor--materialize-target-members
                   (supervisor-plan-entries plan)))
         (closure (supervisor--expand-transaction
                   "basic.target" entries-by-id members
                   (supervisor-plan-order-index plan))))
    ;; svc-opt pulled in via svc-a's :wants
    (should (gethash "basic.target" closure))
    (should (gethash "svc-a" closure))
    (should (gethash "svc-opt" closure))))

;;; Phase 4: Target-Aware Plan Builder Tests

(ert-deftest supervisor-test-target-auto-ordering-requires-implies-after ()
  "Target :requires automatically implies :after ordering edge."
  (let* ((programs '((nil :id "basic.target" :type target)
                     ("true" :id "svc-a")
                     (nil :id "multi.target" :type target
                          :requires ("basic.target" "svc-a"))))
         (plan (supervisor--build-plan programs))
         (after-deps (gethash "multi.target"
                              (supervisor-plan-deps plan)))
         (multi-entry (cl-find "multi.target"
                               (supervisor-plan-entries plan)
                               :key #'supervisor-entry-id :test #'equal)))
    ;; Target's :requires should appear in :after deps
    (should (member "basic.target" after-deps))
    (should (member "svc-a" after-deps))
    ;; Structural integrity: :type preserved, :requires preserved
    (should (eq 'target (supervisor-entry-type multi-entry)))
    (should (member "basic.target" (supervisor-entry-requires multi-entry)))
    (should (member "svc-a" (supervisor-entry-requires multi-entry)))
    ;; Tuple length unchanged
    (should (= 39 (length multi-entry)))))

(ert-deftest supervisor-test-target-auto-ordering-wants-implies-after ()
  "Target :wants automatically implies :after ordering edge."
  (let* ((programs '((nil :id "basic.target" :type target)
                     ("true" :id "svc-opt")
                     (nil :id "multi.target" :type target
                          :wants ("basic.target" "svc-opt"))))
         (plan (supervisor--build-plan programs))
         (after-deps (gethash "multi.target"
                              (supervisor-plan-deps plan)))
         (multi-entry (cl-find "multi.target"
                               (supervisor-plan-entries plan)
                               :key #'supervisor-entry-id :test #'equal)))
    ;; Target's :wants should appear in :after deps
    (should (member "basic.target" after-deps))
    (should (member "svc-opt" after-deps))
    ;; Structural integrity: :type preserved, :wants preserved
    (should (eq 'target (supervisor-entry-type multi-entry)))
    (should (member "basic.target" (supervisor-entry-wants multi-entry)))
    (should (member "svc-opt" (supervisor-entry-wants multi-entry)))
    ;; Tuple length unchanged
    (should (= 39 (length multi-entry)))))

(ert-deftest supervisor-test-service-requires-no-auto-after ()
  "Service :requires does NOT auto-inject :after (only targets do)."
  (let* ((programs '(("true" :id "svc-a")
                     ("true" :id "svc-b" :requires ("svc-a"))))
         (plan (supervisor--build-plan programs))
         (after-deps (gethash "svc-b"
                              (supervisor-plan-deps plan)))
         (svc-b (cl-find "svc-b" (supervisor-plan-entries plan)
                         :key #'supervisor-entry-id :test #'equal)))
    ;; Service :requires should NOT appear in :after deps
    (should-not (member "svc-a" after-deps))
    ;; Structural integrity: :type and :requires preserved
    (should (eq 'simple (supervisor-entry-type svc-b)))
    (should (equal '("svc-a") (supervisor-entry-requires svc-b)))
    (should (= 39 (length svc-b)))))

(ert-deftest supervisor-test-builtin-targets-no-redundant-after ()
  "Built-in targets rely on auto-ordering, no explicit :after."
  (let* ((builtins (supervisor--builtin-programs)))
    (dolist (entry builtins)
      (when (eq (plist-get (cdr entry) :type) 'target)
        (should-not (plist-get (cdr entry) :after))))))

(ert-deftest supervisor-test-plan-fingerprint-deterministic ()
  "Plan fingerprint is deterministic for same input."
  (let* ((programs '(("cmd-a" :id "a")
                     ("cmd-b" :id "b" :after ("a"))))
         (plan1 (supervisor--build-plan programs))
         (plan2 (supervisor--build-plan programs)))
    (should (equal (plist-get (supervisor-plan-meta plan1) :fingerprint)
                   (plist-get (supervisor-plan-meta plan2) :fingerprint)))))

(ert-deftest supervisor-test-plan-fingerprint-changes-with-input ()
  "Plan fingerprint changes when input changes."
  (let* ((programs1 '(("cmd-a" :id "a")
                      ("cmd-b" :id "b" :after ("a"))))
         (programs2 '(("cmd-a" :id "a")
                      ("cmd-c" :id "c" :after ("a"))))
         (plan1 (supervisor--build-plan programs1))
         (plan2 (supervisor--build-plan programs2)))
    (should-not (equal (plist-get (supervisor-plan-meta plan1) :fingerprint)
                       (plist-get (supervisor-plan-meta plan2) :fingerprint)))))

(ert-deftest supervisor-test-default-target-alias-and-closure-combined ()
  "Default target alias resolution and closure exactness combined."
  (let* ((programs '((nil :id "basic.target" :type target)
                     (nil :id "graphical.target" :type target
                          :requires ("basic.target"))
                     (nil :id "default.target" :type target)
                     ("cmd-a" :id "svc-a" :wanted-by ("basic.target"))
                     ("cmd-b" :id "svc-b" :wanted-by ("graphical.target"))
                     ("cmd-c" :id "svc-orphan")))
         (plan (supervisor--build-plan programs))
         (entries-by-id (make-hash-table :test 'equal))
         (valid-ids (make-hash-table :test 'equal)))
    (dolist (e (supervisor-plan-entries plan))
      (puthash (supervisor-entry-id e) e entries-by-id)
      (puthash (supervisor-entry-id e) t valid-ids))
    ;; Resolve via default.target -> graphical.target alias
    (let* ((supervisor-default-target "default.target")
           (supervisor-default-target-link "graphical.target")
           (supervisor--default-target-link-override nil)
           (root (supervisor--resolve-startup-root valid-ids))
           (members (supervisor--materialize-target-members
                     (supervisor-plan-entries plan)))
           (closure (supervisor--expand-transaction
                     root entries-by-id members
                     (supervisor-plan-order-index plan))))
      ;; Root resolved to graphical.target
      (should (equal "graphical.target" root))
      ;; Closure includes graphical.target and its transitive deps
      (should (gethash "graphical.target" closure))
      (should (gethash "basic.target" closure))
      (should (gethash "svc-a" closure))
      (should (gethash "svc-b" closure))
      ;; Orphan service not in any target's closure
      (should-not (gethash "svc-orphan" closure)))))

(ert-deftest supervisor-test-dep-normalization-preserves-tuple-integrity ()
  "Dep normalization in build-plan preserves all tuple fields."
  (let* ((programs '(("true" :id "svc-a")
                     ("true" :id "svc-b" :after ("svc-a" "nonexistent")
                             :requires ("svc-a" "also-missing"))))
         (plan (supervisor--build-plan programs))
         ;; by-target has the dep-normalized entries
         (svc-b (cl-find "svc-b" (supervisor-plan-by-target plan)
                         :key #'supervisor-entry-id :test #'equal)))
    ;; After invalid dep removal, entry must retain correct structure
    (should (= 39 (length svc-b)))
    (should (equal "svc-b" (supervisor-entry-id svc-b)))
    (should (equal "true" (supervisor-entry-command svc-b)))
    (should (eq 'simple (supervisor-entry-type svc-b)))
    ;; :after normalized to only valid dep
    (should (equal '("svc-a") (supervisor-entry-after svc-b)))
    ;; :requires normalized to only valid dep
    (should (equal '("svc-a") (supervisor-entry-requires svc-b)))))

(ert-deftest supervisor-test-target-dep-normalization-preserves-type ()
  "Target auto-ordering does not corrupt :type during entry rewrite."
  (let* ((programs '((nil :id "base.target" :type target)
                     ("true" :id "svc-x")
                     (nil :id "upper.target" :type target
                          :requires ("base.target")
                          :after ("nonexistent"))))
         (plan (supervisor--build-plan programs))
         ;; by-target has the dep-normalized entries
         (upper (cl-find "upper.target" (supervisor-plan-by-target plan)
                         :key #'supervisor-entry-id :test #'equal)))
    ;; After removing invalid :after "nonexistent", auto-ordering
    ;; injects :requires into :after.  :type must survive.
    (should (eq 'target (supervisor-entry-type upper)))
    (should (member "base.target" (supervisor-entry-after upper)))
    (should (equal '("base.target") (supervisor-entry-requires upper)))
    (should (= 39 (length upper)))))

(ert-deftest supervisor-test-mixed-target-service-cycle-fallback ()
  "Cycle involving both target and service entries triggers fallback."
  (let* ((programs '((nil :id "app.target" :type target
                          :requires ("svc-a"))
                     ("true" :id "svc-a" :after ("app.target"))))
         (plan (supervisor--build-plan programs)))
    ;; Both should be in cycle-fallback (target's auto-ordering creates
    ;; app.target -> svc-a edge, plus svc-a -> app.target explicit edge)
    (should (gethash "app.target" (supervisor-plan-cycle-fallback-ids plan)))
    (should (gethash "svc-a" (supervisor-plan-cycle-fallback-ids plan)))
    ;; Deps cleared after fallback
    (should (null (gethash "app.target" (supervisor-plan-deps plan))))
    (should (null (gethash "svc-a" (supervisor-plan-deps plan))))
    ;; Both entries still present and structurally intact
    (should (= 2 (length (supervisor-plan-by-target plan))))
    (let ((app (cl-find "app.target" (supervisor-plan-by-target plan)
                        :key #'supervisor-entry-id :test #'equal)))
      (should (eq 'target (supervisor-entry-type app))))))

;;; Target Convergence Tests

(ert-deftest supervisor-test-target-convergence-reached ()
  "Target with all required members ready reaches `reached' state."
  (let ((supervisor--dag-ready (make-hash-table :test 'equal))
        (supervisor--dag-started (make-hash-table :test 'equal))
        (supervisor--dag-entries (make-hash-table :test 'equal))
        (supervisor--dag-in-degree (make-hash-table :test 'equal))
        (supervisor--dag-dependents (make-hash-table :test 'equal))
        (supervisor--dag-id-to-index (make-hash-table :test 'equal))
        (supervisor--dag-blocking (make-hash-table :test 'equal))
        (supervisor--dag-timeout-timers (make-hash-table :test 'equal))
        (supervisor--dag-delay-timers (make-hash-table :test 'equal))
        (supervisor--dag-complete-callback nil)
        (supervisor--entry-state (make-hash-table :test 'equal))
        (supervisor--target-convergence (make-hash-table :test 'equal))
        (supervisor--target-convergence-reasons (make-hash-table :test 'equal))
        (supervisor--target-converging (make-hash-table :test 'equal))
        (supervisor--target-member-reverse (make-hash-table :test 'equal))
        (supervisor--target-members (make-hash-table :test 'equal)))
    ;; Set up: two required members, both already ready
    (puthash "app.target" '(:requires ("svc-a" "svc-b") :wants nil)
             supervisor--target-members)
    (puthash "svc-a" t supervisor--dag-ready)
    (puthash "svc-b" t supervisor--dag-ready)
    (puthash "svc-a" 'started supervisor--entry-state)
    (puthash "svc-b" 'started supervisor--entry-state)
    ;; Need target in DAG for mark-ready to work
    (puthash "app.target" t supervisor--dag-entries)
    (puthash "app.target" 0 supervisor--dag-in-degree)
    (puthash "app.target" nil supervisor--dag-dependents)
    ;; Begin convergence
    (supervisor--target-begin-convergence "app.target")
    ;; Should resolve immediately as reached
    (should (eq 'reached (gethash "app.target"
                                  supervisor--target-convergence)))
    (should-not (gethash "app.target" supervisor--target-converging))
    (should (gethash "app.target" supervisor--dag-ready))))

(ert-deftest supervisor-test-target-convergence-degraded-on-failure ()
  "Target with a failed required member resolves as degraded."
  (let ((supervisor--dag-ready (make-hash-table :test 'equal))
        (supervisor--dag-started (make-hash-table :test 'equal))
        (supervisor--dag-entries (make-hash-table :test 'equal))
        (supervisor--dag-in-degree (make-hash-table :test 'equal))
        (supervisor--dag-dependents (make-hash-table :test 'equal))
        (supervisor--dag-id-to-index (make-hash-table :test 'equal))
        (supervisor--dag-blocking (make-hash-table :test 'equal))
        (supervisor--dag-timeout-timers (make-hash-table :test 'equal))
        (supervisor--dag-delay-timers (make-hash-table :test 'equal))
        (supervisor--dag-complete-callback nil)
        (supervisor--entry-state (make-hash-table :test 'equal))
        (supervisor--target-convergence (make-hash-table :test 'equal))
        (supervisor--target-convergence-reasons (make-hash-table :test 'equal))
        (supervisor--target-converging (make-hash-table :test 'equal))
        (supervisor--target-member-reverse (make-hash-table :test 'equal))
        (supervisor--target-members (make-hash-table :test 'equal)))
    (puthash "app.target" '(:requires ("svc-a") :wants nil)
             supervisor--target-members)
    (puthash "svc-a" t supervisor--dag-ready)
    (puthash "svc-a" 'failed-to-spawn supervisor--entry-state)
    (puthash "app.target" t supervisor--dag-entries)
    (puthash "app.target" 0 supervisor--dag-in-degree)
    (puthash "app.target" nil supervisor--dag-dependents)
    (supervisor--target-begin-convergence "app.target")
    (should (eq 'degraded (gethash "app.target"
                                   supervisor--target-convergence)))
    (should (gethash "app.target" supervisor--target-convergence-reasons))
    (should (gethash "app.target" supervisor--dag-ready))))

(ert-deftest supervisor-test-target-convergence-wanted-failure-no-block ()
  "Wanted member failure does not block target convergence."
  (let ((supervisor--dag-ready (make-hash-table :test 'equal))
        (supervisor--dag-started (make-hash-table :test 'equal))
        (supervisor--dag-entries (make-hash-table :test 'equal))
        (supervisor--dag-in-degree (make-hash-table :test 'equal))
        (supervisor--dag-dependents (make-hash-table :test 'equal))
        (supervisor--dag-id-to-index (make-hash-table :test 'equal))
        (supervisor--dag-blocking (make-hash-table :test 'equal))
        (supervisor--dag-timeout-timers (make-hash-table :test 'equal))
        (supervisor--dag-delay-timers (make-hash-table :test 'equal))
        (supervisor--dag-complete-callback nil)
        (supervisor--entry-state (make-hash-table :test 'equal))
        (supervisor--target-convergence (make-hash-table :test 'equal))
        (supervisor--target-convergence-reasons (make-hash-table :test 'equal))
        (supervisor--target-converging (make-hash-table :test 'equal))
        (supervisor--target-member-reverse (make-hash-table :test 'equal))
        (supervisor--target-members (make-hash-table :test 'equal)))
    ;; No required members, only wanted (wanted failures do not affect state)
    (puthash "app.target" '(:requires nil :wants ("svc-w"))
             supervisor--target-members)
    (puthash "app.target" t supervisor--dag-entries)
    (puthash "app.target" 0 supervisor--dag-in-degree)
    (puthash "app.target" nil supervisor--dag-dependents)
    (supervisor--target-begin-convergence "app.target")
    ;; Empty required -> immediate reached
    (should (eq 'reached (gethash "app.target"
                                  supervisor--target-convergence)))
    (should (gethash "app.target" supervisor--dag-ready))))

(ert-deftest supervisor-test-target-convergence-empty-members ()
  "Target with no members resolves immediately as reached."
  (let ((supervisor--dag-ready (make-hash-table :test 'equal))
        (supervisor--dag-started (make-hash-table :test 'equal))
        (supervisor--dag-entries (make-hash-table :test 'equal))
        (supervisor--dag-in-degree (make-hash-table :test 'equal))
        (supervisor--dag-dependents (make-hash-table :test 'equal))
        (supervisor--dag-id-to-index (make-hash-table :test 'equal))
        (supervisor--dag-blocking (make-hash-table :test 'equal))
        (supervisor--dag-timeout-timers (make-hash-table :test 'equal))
        (supervisor--dag-delay-timers (make-hash-table :test 'equal))
        (supervisor--dag-complete-callback nil)
        (supervisor--entry-state (make-hash-table :test 'equal))
        (supervisor--target-convergence (make-hash-table :test 'equal))
        (supervisor--target-convergence-reasons (make-hash-table :test 'equal))
        (supervisor--target-converging (make-hash-table :test 'equal))
        (supervisor--target-member-reverse (make-hash-table :test 'equal))
        (supervisor--target-members (make-hash-table :test 'equal)))
    ;; Target not even in target-members hash -> nil members -> reached
    (puthash "empty.target" t supervisor--dag-entries)
    (puthash "empty.target" 0 supervisor--dag-in-degree)
    (puthash "empty.target" nil supervisor--dag-dependents)
    (supervisor--target-begin-convergence "empty.target")
    (should (eq 'reached (gethash "empty.target"
                                  supervisor--target-convergence)))
    (should (gethash "empty.target" supervisor--dag-ready))))

(ert-deftest supervisor-test-target-convergence-blocks-check-complete ()
  "Converging target prevents startup completion callback."
  (let ((supervisor--dag-ready (make-hash-table :test 'equal))
        (supervisor--dag-started (make-hash-table :test 'equal))
        (supervisor--dag-entries (make-hash-table :test 'equal))
        (supervisor--dag-in-degree (make-hash-table :test 'equal))
        (supervisor--dag-dependents (make-hash-table :test 'equal))
        (supervisor--dag-id-to-index (make-hash-table :test 'equal))
        (supervisor--dag-blocking (make-hash-table :test 'equal))
        (supervisor--dag-timeout-timers (make-hash-table :test 'equal))
        (supervisor--dag-delay-timers (make-hash-table :test 'equal))
        (supervisor--entry-state (make-hash-table :test 'equal))
        (supervisor--target-convergence (make-hash-table :test 'equal))
        (supervisor--target-convergence-reasons (make-hash-table :test 'equal))
        (supervisor--target-converging (make-hash-table :test 'equal))
        (supervisor--target-member-reverse (make-hash-table :test 'equal))
        (supervisor--target-members (make-hash-table :test 'equal))
        (completed nil))
    ;; Single target entry, still converging
    (puthash "app.target" t supervisor--dag-entries)
    (puthash "app.target" t supervisor--dag-started)
    (puthash "app.target" t supervisor--target-converging)
    (setq supervisor--dag-complete-callback (lambda () (setq completed t)))
    ;; check-complete should NOT fire because target is converging
    (supervisor--dag-check-complete)
    (should-not completed)))

(ert-deftest supervisor-test-target-convergence-force-complete-resolves ()
  "Force-complete resolves converging targets as degraded."
  (let ((supervisor--dag-ready (make-hash-table :test 'equal))
        (supervisor--dag-started (make-hash-table :test 'equal))
        (supervisor--dag-entries (make-hash-table :test 'equal))
        (supervisor--dag-in-degree (make-hash-table :test 'equal))
        (supervisor--dag-dependents (make-hash-table :test 'equal))
        (supervisor--dag-id-to-index (make-hash-table :test 'equal))
        (supervisor--dag-blocking (make-hash-table :test 'equal))
        (supervisor--dag-timeout-timers (make-hash-table :test 'equal))
        (supervisor--dag-delay-timers (make-hash-table :test 'equal))
        (supervisor--entry-state (make-hash-table :test 'equal))
        (supervisor--target-convergence (make-hash-table :test 'equal))
        (supervisor--target-convergence-reasons (make-hash-table :test 'equal))
        (supervisor--target-converging (make-hash-table :test 'equal))
        (supervisor--target-member-reverse (make-hash-table :test 'equal))
        (supervisor--target-members (make-hash-table :test 'equal))
        (completed nil))
    (puthash "app.target" t supervisor--dag-entries)
    (puthash "app.target" t supervisor--dag-started)
    (puthash "app.target" t supervisor--target-converging)
    (setq supervisor--dag-complete-callback (lambda () (setq completed t)))
    (supervisor--dag-force-complete)
    ;; Target should be degraded
    (should (eq 'degraded (gethash "app.target"
                                   supervisor--target-convergence)))
    (should (equal '("startup timeout")
                   (gethash "app.target"
                            supervisor--target-convergence-reasons)))
    ;; Converging hash should be empty
    (should (= 0 (hash-table-count supervisor--target-converging)))
    ;; Callback should have fired
    (should completed)))

(ert-deftest supervisor-test-target-convergence-delayed-member ()
  "Required member not yet ready keeps target converging until member ready."
  (let ((supervisor--dag-ready (make-hash-table :test 'equal))
        (supervisor--dag-started (make-hash-table :test 'equal))
        (supervisor--dag-entries (make-hash-table :test 'equal))
        (supervisor--dag-in-degree (make-hash-table :test 'equal))
        (supervisor--dag-dependents (make-hash-table :test 'equal))
        (supervisor--dag-id-to-index (make-hash-table :test 'equal))
        (supervisor--dag-blocking (make-hash-table :test 'equal))
        (supervisor--dag-timeout-timers (make-hash-table :test 'equal))
        (supervisor--dag-delay-timers (make-hash-table :test 'equal))
        (supervisor--dag-complete-callback nil)
        (supervisor--entry-state (make-hash-table :test 'equal))
        (supervisor--target-convergence (make-hash-table :test 'equal))
        (supervisor--target-convergence-reasons (make-hash-table :test 'equal))
        (supervisor--target-converging (make-hash-table :test 'equal))
        (supervisor--target-member-reverse (make-hash-table :test 'equal))
        (supervisor--target-members (make-hash-table :test 'equal)))
    ;; Set up target with one required member not yet ready
    (puthash "app.target" '(:requires ("svc-a") :wants nil)
             supervisor--target-members)
    (puthash "app.target" t supervisor--dag-entries)
    (puthash "app.target" 0 supervisor--dag-in-degree)
    (puthash "app.target" nil supervisor--dag-dependents)
    ;; Build reverse index
    (puthash "svc-a" '("app.target") supervisor--target-member-reverse)
    ;; svc-a not yet in dag-ready
    (supervisor--target-begin-convergence "app.target")
    ;; Should still be converging
    (should (eq 'converging (gethash "app.target"
                                     supervisor--target-convergence)))
    (should (gethash "app.target" supervisor--target-converging))
    (should-not (gethash "app.target" supervisor--dag-ready))
    ;; Now svc-a becomes ready -- simulate via mark-ready
    ;; First set up svc-a in DAG so mark-ready works
    (puthash "svc-a" t supervisor--dag-entries)
    (puthash "svc-a" 0 supervisor--dag-in-degree)
    (puthash "svc-a" nil supervisor--dag-dependents)
    (puthash "svc-a" 'started supervisor--entry-state)
    (supervisor--dag-mark-ready "svc-a")
    ;; Now target should be reached
    (should (eq 'reached (gethash "app.target"
                                  supervisor--target-convergence)))
    (should-not (gethash "app.target" supervisor--target-converging))
    (should (gethash "app.target" supervisor--dag-ready))))

(ert-deftest supervisor-test-target-convergence-disabled-member-ok ()
  "Disabled required member in dag-ready results in reached, not degraded."
  (let ((supervisor--dag-ready (make-hash-table :test 'equal))
        (supervisor--dag-started (make-hash-table :test 'equal))
        (supervisor--dag-entries (make-hash-table :test 'equal))
        (supervisor--dag-in-degree (make-hash-table :test 'equal))
        (supervisor--dag-dependents (make-hash-table :test 'equal))
        (supervisor--dag-id-to-index (make-hash-table :test 'equal))
        (supervisor--dag-blocking (make-hash-table :test 'equal))
        (supervisor--dag-timeout-timers (make-hash-table :test 'equal))
        (supervisor--dag-delay-timers (make-hash-table :test 'equal))
        (supervisor--dag-complete-callback nil)
        (supervisor--entry-state (make-hash-table :test 'equal))
        (supervisor--target-convergence (make-hash-table :test 'equal))
        (supervisor--target-convergence-reasons (make-hash-table :test 'equal))
        (supervisor--target-converging (make-hash-table :test 'equal))
        (supervisor--target-member-reverse (make-hash-table :test 'equal))
        (supervisor--target-members (make-hash-table :test 'equal)))
    (puthash "app.target" '(:requires ("svc-a") :wants nil)
             supervisor--target-members)
    (puthash "svc-a" t supervisor--dag-ready)
    (puthash "svc-a" 'disabled supervisor--entry-state)
    (puthash "app.target" t supervisor--dag-entries)
    (puthash "app.target" 0 supervisor--dag-in-degree)
    (puthash "app.target" nil supervisor--dag-dependents)
    (supervisor--target-begin-convergence "app.target")
    ;; Disabled is not a failure state, so should be reached
    (should (eq 'reached (gethash "app.target"
                                  supervisor--target-convergence)))
    (should (gethash "app.target" supervisor--dag-ready))))

(ert-deftest supervisor-test-target-convergence-event-types ()
  "Event types list includes target-reached and target-degraded."
  (should (memq 'target-reached supervisor--event-types))
  (should (memq 'target-degraded supervisor--event-types)))

(ert-deftest supervisor-test-target-convergence-reverse-index ()
  "Reverse member index built correctly from target-members."
  (let ((members (make-hash-table :test 'equal))
        (supervisor--target-members nil)
        (supervisor--target-convergence nil)
        (supervisor--target-convergence-reasons nil)
        (supervisor--target-converging nil)
        (supervisor--target-member-reverse nil))
    (puthash "t1.target" '(:requires ("svc-a" "svc-b") :wants ("svc-c"))
             members)
    (puthash "t2.target" '(:requires ("svc-b") :wants nil)
             members)
    (supervisor--target-init-convergence members)
    ;; svc-a should map to t1.target only
    (should (equal '("t1.target")
                   (gethash "svc-a" supervisor--target-member-reverse)))
    ;; svc-b should map to both targets
    (let ((targets (gethash "svc-b" supervisor--target-member-reverse)))
      (should (= 2 (length targets)))
      (should (member "t1.target" targets))
      (should (member "t2.target" targets)))
    ;; svc-c (wanted) should also be in reverse index
    (should (equal '("t1.target")
                   (gethash "svc-c" supervisor--target-member-reverse)))))

(ert-deftest supervisor-test-materialize-target-members-includes-target-requires ()
  "Target with :requires produces :requires membership from target itself."
  (let* ((programs '(("sleep 1" :id "svc-a")
                     (nil :id "app.target" :type target
                          :requires ("svc-a"))))
         (plan (supervisor--build-plan programs))
         (members (supervisor--materialize-target-members
                   (supervisor-plan-entries plan))))
    (let ((app (gethash "app.target" members)))
      (should app)
      (should (equal '("svc-a") (plist-get app :requires))))))

(ert-deftest supervisor-test-materialize-target-members-deduplicates ()
  "Service :required-by and target :requires for same service deduplicates."
  (let* ((programs '(("sleep 1" :id "svc-a"
                       :required-by ("app.target"))
                     (nil :id "app.target" :type target
                          :requires ("svc-a"))))
         (plan (supervisor--build-plan programs))
         (members (supervisor--materialize-target-members
                   (supervisor-plan-entries plan))))
    (let ((app (gethash "app.target" members)))
      (should app)
      ;; Should have svc-a exactly once, not duplicated
      (should (equal '("svc-a") (plist-get app :requires))))))

(ert-deftest supervisor-test-target-requires-failure-produces-degraded ()
  "Target with own :requires, member fails -> convergence is degraded."
  (let ((supervisor--dag-ready (make-hash-table :test 'equal))
        (supervisor--dag-started (make-hash-table :test 'equal))
        (supervisor--dag-entries (make-hash-table :test 'equal))
        (supervisor--dag-in-degree (make-hash-table :test 'equal))
        (supervisor--dag-dependents (make-hash-table :test 'equal))
        (supervisor--dag-id-to-index (make-hash-table :test 'equal))
        (supervisor--dag-blocking (make-hash-table :test 'equal))
        (supervisor--dag-timeout-timers (make-hash-table :test 'equal))
        (supervisor--dag-delay-timers (make-hash-table :test 'equal))
        (supervisor--dag-complete-callback nil)
        (supervisor--entry-state (make-hash-table :test 'equal))
        (supervisor--target-convergence (make-hash-table :test 'equal))
        (supervisor--target-convergence-reasons (make-hash-table :test 'equal))
        (supervisor--target-converging (make-hash-table :test 'equal))
        (supervisor--target-member-reverse (make-hash-table :test 'equal))
        (supervisor--target-members (make-hash-table :test 'equal)))
    ;; Build plan so materialize-target-members picks up
    ;; target's own :requires
    (let* ((programs '(("sleep 1" :id "svc-a")
                       (nil :id "app.target" :type target
                            :requires ("svc-a"))))
           (plan (supervisor--build-plan programs))
           (members (supervisor--materialize-target-members
                     (supervisor-plan-entries plan))))
      ;; Install membership from build
      (setq supervisor--target-members members)
      ;; svc-a is ready but failed
      (puthash "svc-a" t supervisor--dag-ready)
      (puthash "svc-a" 'failed-to-spawn supervisor--entry-state)
      (puthash "app.target" t supervisor--dag-entries)
      (puthash "app.target" 0 supervisor--dag-in-degree)
      (puthash "app.target" nil supervisor--dag-dependents)
      (supervisor--target-begin-convergence "app.target")
      (should (eq 'degraded (gethash "app.target"
                                     supervisor--target-convergence))))))

(ert-deftest supervisor-test-target-requires-invalid-ref-invalidates-target ()
  "Target :requires ref invalidated during validation -> target invalid."
  (let* ((programs '(("sleep 1" :id "svc-a"
                       :required-by ("nonexistent.target"))
                     (nil :id "app.target" :type target
                          :requires ("svc-a"))))
         (plan (supervisor--build-plan programs)))
    ;; svc-a is invalidated because its :required-by ref is invalid
    ;; (nonexistent.target doesn't exist).  app.target :requires
    ;; "svc-a" but svc-a was dropped, so dep normalization should
    ;; invalidate the target.
    (should (gethash "app.target" (supervisor-plan-invalid plan)))))

;;; Dashboard Target UX Tests (Phase 6)

(ert-deftest supervisor-test-dashboard-target-type-face ()
  "Target entry renders with `supervisor-type-target' face in TYPE column."
  (let* ((snapshot (supervisor-snapshot--create
                    :process-alive (make-hash-table :test 'equal)
                    :process-pids (make-hash-table :test 'equal)
                    :failed (make-hash-table :test 'equal)
                    :oneshot-exit (make-hash-table :test 'equal)
                    :entry-state (make-hash-table :test 'equal)
                    :invalid (make-hash-table :test 'equal)
                    :enabled-override (make-hash-table :test 'equal)
                    :restart-override (make-hash-table :test 'equal)
                    :logging-override (make-hash-table :test 'equal)
                    :mask-override (make-hash-table :test 'equal)
                    :manually-started (make-hash-table :test 'equal)
                    :manually-stopped (make-hash-table :test 'equal)
                    :remain-active (make-hash-table :test 'equal)
                    :timestamp (float-time)))
         (supervisor--target-convergence (make-hash-table :test 'equal))
         (supervisor--target-convergence-reasons (make-hash-table :test 'equal))
         (vec (supervisor--make-dashboard-entry
               "app.target" 'target nil t nil nil snapshot)))
    ;; TYPE column (index 1) should have target face
    (should (eq 'supervisor-type-target
                (get-text-property 0 'face (aref vec 1))))
    ;; TYPE text should be "target"
    (should (equal "target" (substring-no-properties (aref vec 1))))))

(ert-deftest supervisor-test-dashboard-target-convergence-in-status ()
  "Target with convergence state shows correct STATUS column."
  (let* ((conv-hash (make-hash-table :test 'equal))
         (supervisor--target-convergence conv-hash)
         (supervisor--target-convergence-reasons
          (make-hash-table :test 'equal))
         (snapshot (supervisor-snapshot--create
                    :process-alive (make-hash-table :test 'equal)
                    :process-pids (make-hash-table :test 'equal)
                    :failed (make-hash-table :test 'equal)
                    :oneshot-exit (make-hash-table :test 'equal)
                    :entry-state (make-hash-table :test 'equal)
                    :invalid (make-hash-table :test 'equal)
                    :enabled-override (make-hash-table :test 'equal)
                    :restart-override (make-hash-table :test 'equal)
                    :logging-override (make-hash-table :test 'equal)
                    :mask-override (make-hash-table :test 'equal)
                    :manually-started (make-hash-table :test 'equal)
                    :manually-stopped (make-hash-table :test 'equal)
                    :remain-active (make-hash-table :test 'equal)
                    :timestamp (float-time))))
    ;; Test reached
    (puthash "app.target" 'reached conv-hash)
    (let ((vec (supervisor--make-dashboard-entry
                "app.target" 'target nil t nil nil snapshot)))
      (should (equal "reached"
                     (substring-no-properties (aref vec 4)))))
    ;; Test degraded
    (puthash "app.target" 'degraded conv-hash)
    (let ((vec (supervisor--make-dashboard-entry
                "app.target" 'target nil t nil nil snapshot)))
      (should (equal "degraded"
                     (substring-no-properties (aref vec 4)))))
    ;; Test converging
    (puthash "app.target" 'converging conv-hash)
    (let ((vec (supervisor--make-dashboard-entry
                "app.target" 'target nil t nil nil snapshot)))
      (should (equal "converging"
                     (substring-no-properties (aref vec 4)))))))

(ert-deftest supervisor-test-dashboard-target-reason-shows-degraded ()
  "Target with degraded reasons shows joined reasons in REASON column."
  (let* ((conv-hash (make-hash-table :test 'equal))
         (reasons-hash (make-hash-table :test 'equal))
         (supervisor--target-convergence conv-hash)
         (supervisor--target-convergence-reasons reasons-hash)
         (snapshot (supervisor-snapshot--create
                    :process-alive (make-hash-table :test 'equal)
                    :process-pids (make-hash-table :test 'equal)
                    :failed (make-hash-table :test 'equal)
                    :oneshot-exit (make-hash-table :test 'equal)
                    :entry-state (make-hash-table :test 'equal)
                    :invalid (make-hash-table :test 'equal)
                    :enabled-override (make-hash-table :test 'equal)
                    :restart-override (make-hash-table :test 'equal)
                    :logging-override (make-hash-table :test 'equal)
                    :mask-override (make-hash-table :test 'equal)
                    :manually-started (make-hash-table :test 'equal)
                    :manually-stopped (make-hash-table :test 'equal)
                    :remain-active (make-hash-table :test 'equal)
                    :timestamp (float-time))))
    (puthash "app.target" 'degraded conv-hash)
    (puthash "app.target" '("svc-a failed" "svc-b failed") reasons-hash)
    (let ((vec (supervisor--make-dashboard-entry
                "app.target" 'target nil t nil nil snapshot)))
      (should (equal "svc-a failed; svc-b failed"
                     (substring-no-properties (aref vec 8)))))))

(ert-deftest supervisor-test-dashboard-target-filter-cycle ()
  "Cycle filter: nil -> first-target -> second-target -> nil."
  (let* ((members-hash (make-hash-table :test 'equal))
         (supervisor--current-plan
          (supervisor-plan--create
           :target-members members-hash
           :entries nil
           :invalid (make-hash-table :test 'equal)
           :by-target nil
           :deps (make-hash-table :test 'equal)
           :requires-deps (make-hash-table :test 'equal)
           :dependents (make-hash-table :test 'equal)
           :cycle-fallback-ids (make-hash-table :test 'equal)
           :order-index (make-hash-table :test 'equal)
           :meta nil)))
    (puthash "alpha.target" '(:requires ("svc-a") :wants nil) members-hash)
    (puthash "beta.target" '(:requires nil :wants ("svc-b")) members-hash)
    (with-temp-buffer
      (let ((supervisor--dashboard-target-filter nil))
        ;; First cycle: nil -> alpha.target
        (let ((all-targets (supervisor--all-target-ids)))
          (should (equal '("alpha.target" "beta.target") all-targets)))
        (setq supervisor--dashboard-target-filter
              (car (supervisor--all-target-ids)))
        (should (equal "alpha.target" supervisor--dashboard-target-filter))
        ;; Second cycle: alpha.target -> beta.target
        (let* ((all-targets (supervisor--all-target-ids))
               (idx (cl-position supervisor--dashboard-target-filter
                                all-targets :test #'equal)))
          (setq supervisor--dashboard-target-filter
                (nth (1+ idx) all-targets)))
        (should (equal "beta.target" supervisor--dashboard-target-filter))
        ;; Third cycle: beta.target -> nil
        (let* ((all-targets (supervisor--all-target-ids))
               (idx (cl-position supervisor--dashboard-target-filter
                                all-targets :test #'equal)))
          (setq supervisor--dashboard-target-filter
                (when (< idx (1- (length all-targets)))
                  (nth (1+ idx) all-targets))))
        (should (null supervisor--dashboard-target-filter))))))

(ert-deftest supervisor-test-dashboard-target-filter-includes-members ()
  "Filtered view includes target and its members only."
  (supervisor-test-with-unit-files
      '(("sleep 1" :id "svc-a" :wanted-by ("app.target"))
        ("sleep 1" :id "svc-b")
        (nil :id "app.target" :type target))
    (let* ((supervisor--processes (make-hash-table :test 'equal))
           (supervisor--failed (make-hash-table :test 'equal))
           (supervisor--oneshot-completed (make-hash-table :test 'equal))
           (supervisor--entry-state (make-hash-table :test 'equal))
           (supervisor--invalid (make-hash-table :test 'equal))
           (supervisor--enabled-override (make-hash-table :test 'equal))
           (supervisor--restart-override (make-hash-table :test 'equal))
           (supervisor--logging (make-hash-table :test 'equal))
           (supervisor--target-convergence (make-hash-table :test 'equal))
           (supervisor--target-convergence-reasons
            (make-hash-table :test 'equal))
           (members-hash (make-hash-table :test 'equal))
           (supervisor--current-plan
            (supervisor-plan--create
             :target-members members-hash
             :entries nil
             :invalid (make-hash-table :test 'equal)
             :by-target nil
             :deps (make-hash-table :test 'equal)
             :requires-deps (make-hash-table :test 'equal)
             :dependents (make-hash-table :test 'equal)
             :cycle-fallback-ids (make-hash-table :test 'equal)
             :order-index (make-hash-table :test 'equal)
             :meta nil))
           (supervisor--dashboard-target-filter "app.target"))
      (puthash "app.target" '(:requires nil :wants ("svc-a")) members-hash)
      (let* ((snapshot (supervisor--build-snapshot))
             (all-entries (supervisor--get-entries snapshot))
             ;; Filter out separator rows
             (service-ids
              (cl-loop for entry in all-entries
                       when (supervisor--service-row-p (car entry))
                       collect (cdr (car entry)))))
        ;; Should include svc-a (member) and app.target, not svc-b
        (should (member "svc-a" service-ids))
        (should (member "app.target" service-ids))
        (should-not (member "svc-b" service-ids))))))

(ert-deftest supervisor-test-dashboard-target-members-command ()
  "On target row: shows requires and wants members."
  (let* ((members-hash (make-hash-table :test 'equal))
         (supervisor--target-members members-hash))
    (puthash "app.target" '(:requires ("svc-a") :wants ("svc-b")) members-hash)
    ;; Simulate calling on a target entry
    (let* ((entry (list "app.target" nil 0 t nil nil nil nil
                        'target nil nil nil nil nil nil
                        nil nil nil nil nil nil nil nil nil nil
                        nil nil nil nil nil nil nil nil))
           (msg nil))
      ;; Verify entry type accessor works
      (should (eq 'target (supervisor-entry-type entry)))
      ;; Test the message formatting logic directly
      (let ((members (gethash "app.target" members-hash)))
        (let ((req (plist-get members :requires))
              (wants (plist-get members :wants)))
          (setq msg (format "%s members: requires=[%s] wants=[%s]"
                            "app.target"
                            (if req (mapconcat #'identity req ", ") "none")
                            (if wants
                                (mapconcat #'identity wants ", ")
                              "none")))))
      (should (string-match-p "requires=\\[svc-a\\]" msg))
      (should (string-match-p "wants=\\[svc-b\\]" msg)))))

(ert-deftest supervisor-test-dashboard-target-members-non-target ()
  "On non-target row: shows error message."
  (let* ((supervisor--target-members (make-hash-table :test 'equal))
         ;; A simple entry, not a target
         (entry (list "svc-a" "sleep 1" 0 t nil nil nil nil
                      'simple 'stage3 nil nil nil nil nil
                      nil nil nil nil nil nil nil nil nil nil
                      nil nil nil nil nil nil nil nil)))
    (should (eq 'simple (supervisor-entry-type entry)))
    ;; Not a target, so members command should say so
    (should-not (eq (supervisor-entry-type entry) 'target))))

(ert-deftest supervisor-test-dashboard-header-shows-root ()
  "When plan has activation-root, header includes root info."
  (let* ((supervisor--current-plan
          (supervisor-plan--create
           :activation-root "graphical.target"
           :entries nil
           :invalid (make-hash-table :test 'equal)
           :by-target nil
           :deps (make-hash-table :test 'equal)
           :requires-deps (make-hash-table :test 'equal)
           :dependents (make-hash-table :test 'equal)
           :cycle-fallback-ids (make-hash-table :test 'equal)
           :order-index (make-hash-table :test 'equal)
           :target-members (make-hash-table :test 'equal)
           :meta nil))
         (supervisor--processes (make-hash-table :test 'equal))
         (supervisor--failed (make-hash-table :test 'equal))
         (supervisor--oneshot-completed (make-hash-table :test 'equal))
         (supervisor--entry-state (make-hash-table :test 'equal))
         (supervisor--invalid (make-hash-table :test 'equal))
         (supervisor--enabled-override (make-hash-table :test 'equal))
         (supervisor--restart-override (make-hash-table :test 'equal))
         (supervisor--logging (make-hash-table :test 'equal))
         (header (supervisor--dashboard-header-line)))
    (should (string-match-p "root" (substring-no-properties header)))
    (should (string-match-p "graphical\\.target"
                            (substring-no-properties header)))))

(ert-deftest supervisor-test-dashboard-header-no-root-when-no-plan ()
  "Without a plan, header does not include root info."
  (let* ((supervisor--current-plan nil)
         (supervisor--processes (make-hash-table :test 'equal))
         (supervisor--failed (make-hash-table :test 'equal))
         (supervisor--oneshot-completed (make-hash-table :test 'equal))
         (supervisor--entry-state (make-hash-table :test 'equal))
         (supervisor--invalid (make-hash-table :test 'equal))
         (supervisor--enabled-override (make-hash-table :test 'equal))
         (supervisor--restart-override (make-hash-table :test 'equal))
         (supervisor--logging (make-hash-table :test 'equal))
         (header (supervisor--dashboard-header-line)))
    (should-not (string-match-p "root"
                                (substring-no-properties header)))))

(ert-deftest supervisor-test-dashboard-describe-target-shows-convergence ()
  "Describe entry detail for target shows convergence state and members."
  (let* ((supervisor--target-convergence (make-hash-table :test 'equal))
         (supervisor--target-convergence-reasons
          (make-hash-table :test 'equal))
         (supervisor--target-members (make-hash-table :test 'equal))
         (supervisor--processes (make-hash-table :test 'equal))
         (supervisor--failed (make-hash-table :test 'equal))
         (supervisor--oneshot-completed (make-hash-table :test 'equal))
         (supervisor--entry-state (make-hash-table :test 'equal))
         (supervisor--enabled-override (make-hash-table :test 'equal))
         (supervisor--restart-override (make-hash-table :test 'equal))
         (supervisor--logging (make-hash-table :test 'equal))
         (supervisor--mask-override (make-hash-table :test 'equal))
         (supervisor--remain-active (make-hash-table :test 'equal))
         (supervisor--manually-stopped (make-hash-table :test 'equal))
         (supervisor--start-times (make-hash-table :test 'equal))
         (supervisor--ready-times (make-hash-table :test 'equal))
         (supervisor--restart-times (make-hash-table :test 'equal))
         (supervisor--restart-timers (make-hash-table :test 'equal))
         (supervisor--logging-override (make-hash-table :test 'equal))
         (supervisor--last-exit-info (make-hash-table :test 'equal))
         (supervisor--spawn-failure-reason (make-hash-table :test 'equal))
         ;; 39-element target entry
         (entry (list "app.target" nil 0 t nil nil nil nil
                      'target nil nil nil nil nil nil
                      nil nil nil nil nil nil
                      "Test target" nil nil nil nil nil nil nil nil nil
                      '("multi-user.target") nil
                      nil nil nil nil nil nil)))
    (puthash "app.target" 'degraded supervisor--target-convergence)
    (puthash "app.target" '("svc-x failed")
             supervisor--target-convergence-reasons)
    (puthash "app.target" '(:requires ("svc-a") :wants ("svc-b"))
             supervisor--target-members)
    (cl-letf (((symbol-function 'supervisor--unit-file-path)
               (lambda (_id) nil))
              ((symbol-function 'supervisor--telemetry-log-tail)
               (lambda (_id &optional _lines) nil)))
      (supervisor--describe-entry-detail "app.target" entry)
      (let ((info-buf (get-buffer "*supervisor-info*")))
        (unwind-protect
            (progn
              (should info-buf)
              (let ((output (with-current-buffer info-buf
                              (buffer-string))))
                (should (string-match-p "Converge: degraded" output))
                (should (string-match-p "Reasons: svc-x failed" output))
                (should (string-match-p "Req-mem: svc-a" output))
                (should (string-match-p "Want-mem: svc-b" output))))
          (when info-buf (kill-buffer info-buf)))))))

(ert-deftest supervisor-test-dashboard-target-column-shows-convergence ()
  "TARGET column shows convergence state for target entries."
  (let* ((conv-hash (make-hash-table :test 'equal))
         (supervisor--target-convergence conv-hash)
         (supervisor--target-convergence-reasons
          (make-hash-table :test 'equal))
         (snapshot (supervisor-snapshot--create
                    :process-alive (make-hash-table :test 'equal)
                    :process-pids (make-hash-table :test 'equal)
                    :failed (make-hash-table :test 'equal)
                    :oneshot-exit (make-hash-table :test 'equal)
                    :entry-state (make-hash-table :test 'equal)
                    :invalid (make-hash-table :test 'equal)
                    :enabled-override (make-hash-table :test 'equal)
                    :restart-override (make-hash-table :test 'equal)
                    :logging-override (make-hash-table :test 'equal)
                    :mask-override (make-hash-table :test 'equal)
                    :manually-started (make-hash-table :test 'equal)
                    :manually-stopped (make-hash-table :test 'equal)
                    :remain-active (make-hash-table :test 'equal)
                    :timestamp (float-time))))
    ;; Target with reached convergence
    (puthash "app.target" 'reached conv-hash)
    (let ((vec (supervisor--make-dashboard-entry
                "app.target" 'target nil t nil nil snapshot)))
      ;; TARGET column (index 2) shows convergence
      (should (equal "reached"
                     (substring-no-properties (aref vec 2)))))
    ;; Simple service with parent-target shows it in TARGET column
    (let ((vec (supervisor--make-dashboard-entry
                "svc" 'simple "basic.target" t 'always t snapshot)))
      (should (equal "basic.target" (aref vec 2))))
    ;; Simple service without parent-target shows "-" in TARGET column
    (let ((vec (supervisor--make-dashboard-entry
                "svc" 'simple nil t 'always t snapshot)))
      (should (equal "-" (aref vec 2))))))

(ert-deftest supervisor-test-dashboard-target-restart-renders-na ()
  "Dashboard renders target restart column as n/a."
  (let* ((supervisor--target-convergence (make-hash-table :test 'equal))
         (supervisor--target-convergence-reasons
          (make-hash-table :test 'equal))
         (snapshot (supervisor-snapshot--create
                    :process-alive (make-hash-table :test 'equal)
                    :process-pids (make-hash-table :test 'equal)
                    :failed (make-hash-table :test 'equal)
                    :oneshot-exit (make-hash-table :test 'equal)
                    :entry-state (make-hash-table :test 'equal)
                    :invalid (make-hash-table :test 'equal)
                    :enabled-override (make-hash-table :test 'equal)
                    :restart-override (make-hash-table :test 'equal)
                    :logging-override (make-hash-table :test 'equal)
                    :mask-override (make-hash-table :test 'equal)
                    :manually-started (make-hash-table :test 'equal)
                    :manually-stopped (make-hash-table :test 'equal)
                    :remain-active (make-hash-table :test 'equal)
                    :timestamp (float-time)))
         (vec (supervisor--make-dashboard-entry
               "app.target" 'target nil t nil nil snapshot)))
    (should (equal "n/a" (aref vec 5)))))

(ert-deftest supervisor-test-dashboard-target-log-renders-dash ()
  "Dashboard renders target LOG column as dash."
  (let* ((supervisor--target-convergence (make-hash-table :test 'equal))
         (supervisor--target-convergence-reasons
          (make-hash-table :test 'equal))
         (snapshot (supervisor-snapshot--create
                    :process-alive (make-hash-table :test 'equal)
                    :process-pids (make-hash-table :test 'equal)
                    :failed (make-hash-table :test 'equal)
                    :oneshot-exit (make-hash-table :test 'equal)
                    :entry-state (make-hash-table :test 'equal)
                    :invalid (make-hash-table :test 'equal)
                    :enabled-override (make-hash-table :test 'equal)
                    :restart-override (make-hash-table :test 'equal)
                    :logging-override (make-hash-table :test 'equal)
                    :mask-override (make-hash-table :test 'equal)
                    :manually-started (make-hash-table :test 'equal)
                    :manually-stopped (make-hash-table :test 'equal)
                    :remain-active (make-hash-table :test 'equal)
                    :timestamp (float-time)))
         (vec (supervisor--make-dashboard-entry
               "app.target" 'target nil t nil nil snapshot)))
    (should (equal "-" (aref vec 6)))))

(ert-deftest supervisor-test-dashboard-services-separator-says-target ()
  "Services separator row uses TARGET not STAGE in column label."
  (let ((row (supervisor--make-services-separator)))
    (should (string-match-p "TARGET"
                            (substring-no-properties (aref (cadr row) 2))))))

(ert-deftest supervisor-test-dashboard-status-face-target-states ()
  "Status face returns correct faces for target convergence states."
  (should (eq 'supervisor-status-running
              (supervisor--status-face "reached")))
  (should (eq 'supervisor-status-failed
              (supervisor--status-face "degraded")))
  (should (eq 'supervisor-status-pending
              (supervisor--status-face "converging"))))

(ert-deftest supervisor-test-compute-entry-status-target-reached ()
  "Compute-entry-status returns reached for target with reached convergence."
  (let* ((supervisor--target-convergence (make-hash-table :test 'equal))
         (supervisor--mask-override (make-hash-table :test 'equal))
         (supervisor--processes (make-hash-table :test 'equal))
         (supervisor--failed (make-hash-table :test 'equal))
         (supervisor--oneshot-completed (make-hash-table :test 'equal))
         (supervisor--remain-active (make-hash-table :test 'equal))
         (supervisor--manually-stopped (make-hash-table :test 'equal)))
    (puthash "app.target" 'reached supervisor--target-convergence)
    (let ((result (supervisor--compute-entry-status "app.target" 'target)))
      (should (equal "reached" (car result))))))

(ert-deftest supervisor-test-compute-entry-status-target-degraded ()
  "Compute-entry-status returns degraded for target with degraded convergence."
  (let* ((supervisor--target-convergence (make-hash-table :test 'equal))
         (supervisor--mask-override (make-hash-table :test 'equal))
         (supervisor--processes (make-hash-table :test 'equal))
         (supervisor--failed (make-hash-table :test 'equal))
         (supervisor--oneshot-completed (make-hash-table :test 'equal))
         (supervisor--remain-active (make-hash-table :test 'equal))
         (supervisor--manually-stopped (make-hash-table :test 'equal)))
    (puthash "app.target" 'degraded supervisor--target-convergence)
    (let ((result (supervisor--compute-entry-status "app.target" 'target)))
      (should (equal "degraded" (car result))))))

(ert-deftest supervisor-test-compute-entry-reason-target-degraded ()
  "Compute-entry-reason returns joined reasons for degraded target."
  (let* ((supervisor--target-convergence-reasons
          (make-hash-table :test 'equal))
         (supervisor--mask-override (make-hash-table :test 'equal))
         (supervisor--processes (make-hash-table :test 'equal))
         (supervisor--failed (make-hash-table :test 'equal))
         (supervisor--oneshot-completed (make-hash-table :test 'equal))
         (supervisor--entry-state (make-hash-table :test 'equal))
         (supervisor--spawn-failure-reason (make-hash-table :test 'equal)))
    (puthash "app.target" '("svc-a failed" "svc-b timeout")
             supervisor--target-convergence-reasons)
    (let ((result (supervisor--compute-entry-reason "app.target" 'target)))
      (should (equal "svc-a failed; svc-b timeout" result)))))

;;; Phase 6 Review Fixes

(ert-deftest supervisor-test-all-target-ids-includes-empty-targets ()
  "All-target-ids includes targets with no members."
  (let* ((members-hash (make-hash-table :test 'equal))
         ;; 39-element target entry for empty-target (no members)
         (empty-entry (list "empty.target" nil 0 t nil nil nil nil
                            'target nil nil nil nil nil nil
                            nil nil nil nil nil nil nil nil nil nil
                            nil nil nil nil nil nil nil nil nil
                            nil nil nil nil nil nil))
         ;; 39-element target entry for pop.target (has members)
         (pop-entry (list "pop.target" nil 0 t nil nil nil nil
                          'target nil nil nil nil nil nil
                          nil nil nil nil nil nil nil nil nil nil
                          nil nil nil nil nil nil nil nil nil
                          nil nil nil nil nil nil))
         (supervisor--current-plan
          (supervisor-plan--create
           :target-members members-hash
           :entries (list empty-entry pop-entry)
           :invalid (make-hash-table :test 'equal)
           :by-target nil
           :deps (make-hash-table :test 'equal)
           :requires-deps (make-hash-table :test 'equal)
           :dependents (make-hash-table :test 'equal)
           :cycle-fallback-ids (make-hash-table :test 'equal)
           :order-index (make-hash-table :test 'equal)
           :meta nil)))
    ;; Only pop.target has members
    (puthash "pop.target" '(:requires ("svc-a") :wants nil) members-hash)
    (let ((ids (supervisor--all-target-ids)))
      ;; Both targets should appear
      (should (member "empty.target" ids))
      (should (member "pop.target" ids)))))

(ert-deftest supervisor-test-daemon-reload-populates-target-metadata ()
  "Daemon-reload populates target-members and activation-root in plan."
  (supervisor-test-with-unit-files
      '(("sleep 1" :id "svc-a" :wanted-by ("multi-user.target"))
        (nil :id "basic.target" :type target)
        (nil :id "multi-user.target" :type target
             :after ("basic.target"))
        (nil :id "graphical.target" :type target
             :after ("multi-user.target"))
        (nil :id "default.target" :type target))
    (let ((supervisor--current-plan nil)
          (supervisor--processes (make-hash-table :test 'equal))
          (supervisor--failed (make-hash-table :test 'equal))
          (supervisor--oneshot-completed (make-hash-table :test 'equal))
          (supervisor--entry-state (make-hash-table :test 'equal))
          (supervisor--invalid (make-hash-table :test 'equal))
          (supervisor--enabled-override (make-hash-table :test 'equal))
          (supervisor--restart-override (make-hash-table :test 'equal))
          (supervisor--logging (make-hash-table :test 'equal))
          (supervisor--target-members nil)
          (supervisor--target-convergence nil)
          (supervisor--target-convergence-reasons nil)
          (supervisor-default-target "default.target")
          (supervisor-default-target-link "graphical.target"))
      (supervisor-daemon-reload)
      ;; Plan should have activation-root
      (should supervisor--current-plan)
      (should (supervisor-plan-activation-root supervisor--current-plan))
      (should (equal "graphical.target"
                     (supervisor-plan-activation-root
                      supervisor--current-plan)))
      ;; Plan should have target-members populated
      (should (hash-table-p
               (supervisor-plan-target-members supervisor--current-plan)))
      ;; svc-a declared :wanted-by multi-user.target
      (let ((members (gethash "multi-user.target"
                              (supervisor-plan-target-members
                               supervisor--current-plan))))
        (should members)
        (should (member "svc-a" (plist-get members :wants))))
      ;; Runtime global should also be updated
      (should (hash-table-p supervisor--target-members))
      (should (gethash "multi-user.target" supervisor--target-members)))))

(ert-deftest supervisor-test-daemon-reload-all-target-ids-after-reload ()
  "All-target-ids returns all targets after daemon-reload."
  (supervisor-test-with-unit-files
      '(("sleep 1" :id "svc-a" :wanted-by ("multi-user.target"))
        (nil :id "basic.target" :type target)
        (nil :id "multi-user.target" :type target
             :after ("basic.target"))
        (nil :id "graphical.target" :type target
             :after ("multi-user.target"))
        (nil :id "default.target" :type target))
    (let ((supervisor--current-plan nil)
          (supervisor--processes (make-hash-table :test 'equal))
          (supervisor--failed (make-hash-table :test 'equal))
          (supervisor--oneshot-completed (make-hash-table :test 'equal))
          (supervisor--entry-state (make-hash-table :test 'equal))
          (supervisor--invalid (make-hash-table :test 'equal))
          (supervisor--enabled-override (make-hash-table :test 'equal))
          (supervisor--restart-override (make-hash-table :test 'equal))
          (supervisor--logging (make-hash-table :test 'equal))
          (supervisor--target-members nil)
          (supervisor--target-convergence nil)
          (supervisor--target-convergence-reasons nil)
          (supervisor-default-target "default.target")
          (supervisor-default-target-link "graphical.target"))
      (supervisor-daemon-reload)
      (let ((ids (supervisor--all-target-ids)))
        ;; All four targets should be present (including empty ones)
        (should (member "basic.target" ids))
        (should (member "multi-user.target" ids))
        (should (member "graphical.target" ids))
        (should (member "default.target" ids))))))

;;;; CLI Target Command Tests

(ert-deftest supervisor-test-cli-get-default ()
  "The `get-default' command returns effective default-target-link."
  (let ((supervisor-default-target-link "graphical.target")
        (supervisor--default-target-link-override nil))
    (let ((result (supervisor--cli-dispatch '("get-default"))))
      (should (= supervisor-cli-exit-success
                  (supervisor-cli-result-exitcode result)))
      (should (string-match "graphical\\.target"
                            (supervisor-cli-result-output result))))))

(ert-deftest supervisor-test-cli-get-default-json ()
  "The `get-default --json' returns JSON with default-target key."
  (let ((supervisor-default-target-link "graphical.target")
        (supervisor--default-target-link-override nil))
    (let ((result (supervisor--cli-dispatch '("get-default" "--json"))))
      (should (= supervisor-cli-exit-success
                  (supervisor-cli-result-exitcode result)))
      (should (eq 'json (supervisor-cli-result-format result)))
      (let ((parsed (json-read-from-string
                     (supervisor-cli-result-output result))))
        (should (equal "graphical.target"
                       (alist-get 'default-target parsed)))))))

(ert-deftest supervisor-test-cli-get-default-with-override ()
  "The `get-default' returns override when set."
  (let ((supervisor-default-target-link "graphical.target")
        (supervisor--default-target-link-override "basic.target"))
    (let ((result (supervisor--cli-dispatch '("get-default"))))
      (should (= supervisor-cli-exit-success
                  (supervisor-cli-result-exitcode result)))
      (should (string-match "basic\\.target"
                            (supervisor-cli-result-output result))))))

(ert-deftest supervisor-test-cli-set-default-persists ()
  "The `set-default' sets override and persists."
  (supervisor-test-with-unit-files
      '((nil :id "basic.target" :type target)
        (nil :id "multi-user.target" :type target
             :after ("basic.target"))
        (nil :id "graphical.target" :type target
             :after ("multi-user.target"))
        (nil :id "default.target" :type target))
    (let ((supervisor--default-target-link-override nil)
          (supervisor-overrides-file nil)
          (supervisor-default-target-link "graphical.target"))
      (let ((result (supervisor--cli-dispatch
                     '("set-default" "multi-user.target"))))
        (should (= supervisor-cli-exit-success
                    (supervisor-cli-result-exitcode result)))
        (should (equal "multi-user.target"
                       supervisor--default-target-link-override))
        ;; get-default should now return the new value
        (let ((get-result (supervisor--cli-dispatch '("get-default"))))
          (should (string-match "multi-user\\.target"
                                (supervisor-cli-result-output
                                 get-result))))))))

(ert-deftest supervisor-test-cli-set-default-rejects-default-target ()
  "Setting default to \"default.target\" is rejected."
  (let ((result (supervisor--cli-dispatch
                 '("set-default" "default.target"))))
    (should (= supervisor-cli-exit-invalid-args
                (supervisor-cli-result-exitcode result)))
    (should (string-match "circular"
                          (supervisor-cli-result-output result)))))

(ert-deftest supervisor-test-cli-set-default-rejects-non-target ()
  "Setting default to a non-.target ID is rejected."
  (let ((result (supervisor--cli-dispatch
                 '("set-default" "my-service"))))
    (should (= supervisor-cli-exit-invalid-args
                (supervisor-cli-result-exitcode result)))
    (should (string-match "\\.target"
                          (supervisor-cli-result-output result)))))

(ert-deftest supervisor-test-cli-set-default-rejects-nonexistent ()
  "Setting default to a nonexistent target is rejected with exit code 4."
  (supervisor-test-with-unit-files
      '((nil :id "basic.target" :type target)
        (nil :id "default.target" :type target))
    (let ((supervisor--default-target-link-override nil)
          (supervisor-default-target-link "basic.target"))
      (let ((result (supervisor--cli-dispatch
                     '("set-default" "nonexistent.target"))))
        (should (= supervisor-cli-exit-no-such-unit
                    (supervisor-cli-result-exitcode result)))))))

(ert-deftest supervisor-test-cli-list-targets ()
  "The `list-targets' command lists all targets with convergence state."
  (supervisor-test-with-unit-files
      '(("sleep 1" :id "svc-a" :wanted-by ("multi-user.target"))
        (nil :id "basic.target" :type target)
        (nil :id "multi-user.target" :type target
             :after ("basic.target"))
        (nil :id "graphical.target" :type target
             :after ("multi-user.target"))
        (nil :id "default.target" :type target))
    (let ((supervisor--current-plan t)
          (supervisor--target-convergence nil)
          (supervisor--target-convergence-reasons nil)
          (supervisor-default-target-link "graphical.target")
          (supervisor--default-target-link-override nil))
      (let ((result (supervisor--cli-dispatch '("list-targets"))))
        (should (= supervisor-cli-exit-success
                    (supervisor-cli-result-exitcode result)))
        (let ((output (supervisor-cli-result-output result)))
          (should (string-match "basic\\.target" output))
          (should (string-match "multi-user\\.target" output))
          (should (string-match "graphical\\.target" output))
          (should (string-match "default\\.target" output))
          ;; default.target should show resolved link
          (should (string-match "graphical\\.target" output)))))))

(ert-deftest supervisor-test-cli-list-targets-json ()
  "The `list-targets --json' returns JSON array."
  (supervisor-test-with-unit-files
      '((nil :id "basic.target" :type target)
        (nil :id "default.target" :type target))
    (let ((supervisor--current-plan t)
          (supervisor--target-convergence nil)
          (supervisor--target-convergence-reasons nil)
          (supervisor-default-target-link "basic.target")
          (supervisor--default-target-link-override nil))
      (let ((result (supervisor--cli-dispatch
                     '("list-targets" "--json"))))
        (should (= supervisor-cli-exit-success
                    (supervisor-cli-result-exitcode result)))
        (should (eq 'json (supervisor-cli-result-format result)))
        (let ((parsed (json-read-from-string
                       (supervisor-cli-result-output result))))
          (should (vectorp parsed))
          (should (> (length parsed) 0)))))))

(ert-deftest supervisor-test-cli-list-targets-includes-empty-targets ()
  "Targets with no members still appear in list-targets."
  (supervisor-test-with-unit-files
      '((nil :id "empty.target" :type target)
        (nil :id "default.target" :type target))
    (let ((supervisor--current-plan t)
          (supervisor--target-convergence nil)
          (supervisor--target-convergence-reasons nil)
          (supervisor-default-target-link "empty.target")
          (supervisor--default-target-link-override nil))
      (let ((result (supervisor--cli-dispatch '("list-targets"))))
        (should (= supervisor-cli-exit-success
                    (supervisor-cli-result-exitcode result)))
        (should (string-match "empty\\.target"
                              (supervisor-cli-result-output result)))))))

(ert-deftest supervisor-test-cli-target-status ()
  "The `target-status' shows convergence and member lists for a target."
  (supervisor-test-with-unit-files
      '(("sleep 1" :id "svc-a" :wanted-by ("multi-user.target"))
        (nil :id "basic.target" :type target)
        (nil :id "multi-user.target" :type target
             :after ("basic.target"))
        (nil :id "default.target" :type target))
    (let ((supervisor--current-plan t)
          (supervisor--processes (make-hash-table :test 'equal))
          (supervisor--entry-state (make-hash-table :test 'equal))
          (supervisor--failed (make-hash-table :test 'equal))
          (supervisor--oneshot-completed (make-hash-table :test 'equal))
          (supervisor--remain-active (make-hash-table :test 'equal))
          (supervisor--manually-stopped (make-hash-table :test 'equal))
          (supervisor--mask-override (make-hash-table :test 'equal))
          (supervisor--target-convergence nil)
          (supervisor--target-convergence-reasons nil)
          (supervisor-default-target-link "multi-user.target")
          (supervisor--default-target-link-override nil))
      (let ((result (supervisor--cli-dispatch
                     '("target-status" "multi-user.target"))))
        (should (= supervisor-cli-exit-success
                    (supervisor-cli-result-exitcode result)))
        (let ((output (supervisor-cli-result-output result)))
          (should (string-match "multi-user\\.target" output))
          (should (string-match "Status:" output))
          (should (string-match "Wants:" output)))))))

(ert-deftest supervisor-test-cli-target-status-default-shows-link ()
  "The `target-status default.target' shows resolved link."
  (supervisor-test-with-unit-files
      '((nil :id "basic.target" :type target)
        (nil :id "default.target" :type target))
    (let ((supervisor--current-plan t)
          (supervisor--processes (make-hash-table :test 'equal))
          (supervisor--entry-state (make-hash-table :test 'equal))
          (supervisor--failed (make-hash-table :test 'equal))
          (supervisor--oneshot-completed (make-hash-table :test 'equal))
          (supervisor--remain-active (make-hash-table :test 'equal))
          (supervisor--manually-stopped (make-hash-table :test 'equal))
          (supervisor--mask-override (make-hash-table :test 'equal))
          (supervisor--target-convergence nil)
          (supervisor--target-convergence-reasons nil)
          (supervisor-default-target-link "basic.target")
          (supervisor--default-target-link-override nil))
      (let ((result (supervisor--cli-dispatch
                     '("target-status" "default.target"))))
        (should (= supervisor-cli-exit-success
                    (supervisor-cli-result-exitcode result)))
        (should (string-match "basic\\.target"
                              (supervisor-cli-result-output result)))))))

(ert-deftest supervisor-test-cli-target-status-nonexistent ()
  "Unknown target returns exit code 4."
  (supervisor-test-with-unit-files
      '((nil :id "basic.target" :type target)
        (nil :id "default.target" :type target))
    (let ((supervisor--current-plan t)
          (supervisor-default-target-link "basic.target")
          (supervisor--default-target-link-override nil))
      (let ((result (supervisor--cli-dispatch
                     '("target-status" "nonexistent.target"))))
        (should (= supervisor-cli-exit-no-such-unit
                    (supervisor-cli-result-exitcode result)))))))

(ert-deftest supervisor-test-cli-target-status-json ()
  "The `target-status --json' returns structured JSON."
  (supervisor-test-with-unit-files
      '(("sleep 1" :id "svc-a" :wanted-by ("app.target"))
        (nil :id "app.target" :type target)
        (nil :id "default.target" :type target))
    (let ((supervisor--current-plan t)
          (supervisor--processes (make-hash-table :test 'equal))
          (supervisor--entry-state (make-hash-table :test 'equal))
          (supervisor--failed (make-hash-table :test 'equal))
          (supervisor--oneshot-completed (make-hash-table :test 'equal))
          (supervisor--remain-active (make-hash-table :test 'equal))
          (supervisor--manually-stopped (make-hash-table :test 'equal))
          (supervisor--mask-override (make-hash-table :test 'equal))
          (supervisor--target-convergence nil)
          (supervisor--target-convergence-reasons nil)
          (supervisor-default-target-link "app.target")
          (supervisor--default-target-link-override nil))
      (let ((result (supervisor--cli-dispatch
                     '("target-status" "app.target" "--json"))))
        (should (= supervisor-cli-exit-success
                    (supervisor-cli-result-exitcode result)))
        (should (eq 'json (supervisor-cli-result-format result)))
        (let ((parsed (json-read-from-string
                       (supervisor-cli-result-output result))))
          (should (equal "app.target" (alist-get 'id parsed)))
          (should (assoc 'status parsed))
          (should (assoc 'requires parsed))
          (should (assoc 'wants parsed)))))))

(ert-deftest supervisor-test-cli-explain-target-reached ()
  "Reached target shows all members healthy message."
  (supervisor-test-with-unit-files
      '(("sleep 1" :id "svc-a" :required-by ("app.target"))
        (nil :id "app.target" :type target)
        (nil :id "default.target" :type target))
    (let ((supervisor--current-plan t)
          (supervisor--processes (make-hash-table :test 'equal))
          (supervisor--entry-state (make-hash-table :test 'equal))
          (supervisor--failed (make-hash-table :test 'equal))
          (supervisor--oneshot-completed (make-hash-table :test 'equal))
          (supervisor--remain-active (make-hash-table :test 'equal))
          (supervisor--manually-stopped (make-hash-table :test 'equal))
          (supervisor--mask-override (make-hash-table :test 'equal))
          (supervisor--target-convergence (make-hash-table :test 'equal))
          (supervisor--target-convergence-reasons
           (make-hash-table :test 'equal))
          (supervisor-default-target-link "app.target")
          (supervisor--default-target-link-override nil))
      (puthash "app.target" 'reached supervisor--target-convergence)
      (let ((result (supervisor--cli-dispatch
                     '("explain-target" "app.target"))))
        (should (= supervisor-cli-exit-success
                    (supervisor-cli-result-exitcode result)))
        (should (string-match "reached"
                              (supervisor-cli-result-output result)))
        (should (string-match "healthy"
                              (supervisor-cli-result-output result)))))))

(ert-deftest supervisor-test-cli-explain-target-degraded ()
  "Degraded target lists failed members."
  (supervisor-test-with-unit-files
      '(("sleep 1" :id "svc-a" :required-by ("app.target"))
        (nil :id "app.target" :type target)
        (nil :id "default.target" :type target))
    (let ((supervisor--current-plan t)
          (supervisor--processes (make-hash-table :test 'equal))
          (supervisor--entry-state (make-hash-table :test 'equal))
          (supervisor--failed (make-hash-table :test 'equal))
          (supervisor--oneshot-completed (make-hash-table :test 'equal))
          (supervisor--remain-active (make-hash-table :test 'equal))
          (supervisor--manually-stopped (make-hash-table :test 'equal))
          (supervisor--mask-override (make-hash-table :test 'equal))
          (supervisor--target-convergence (make-hash-table :test 'equal))
          (supervisor--target-convergence-reasons
           (make-hash-table :test 'equal))
          (supervisor-default-target-link "app.target")
          (supervisor--default-target-link-override nil))
      (puthash "app.target" 'degraded supervisor--target-convergence)
      (puthash "app.target" '("svc-a: failed-to-spawn")
               supervisor--target-convergence-reasons)
      (puthash "svc-a" t supervisor--failed)
      (let ((result (supervisor--cli-dispatch
                     '("explain-target" "app.target"))))
        (should (= supervisor-cli-exit-success
                    (supervisor-cli-result-exitcode result)))
        (should (string-match "degraded"
                              (supervisor-cli-result-output result)))
        (should (string-match "svc-a"
                              (supervisor-cli-result-output result)))))))

(ert-deftest supervisor-test-cli-explain-target-pending ()
  "Pending target shows appropriate message."
  (supervisor-test-with-unit-files
      '((nil :id "app.target" :type target)
        (nil :id "default.target" :type target))
    (let ((supervisor--current-plan t)
          (supervisor--processes (make-hash-table :test 'equal))
          (supervisor--entry-state (make-hash-table :test 'equal))
          (supervisor--failed (make-hash-table :test 'equal))
          (supervisor--oneshot-completed (make-hash-table :test 'equal))
          (supervisor--remain-active (make-hash-table :test 'equal))
          (supervisor--manually-stopped (make-hash-table :test 'equal))
          (supervisor--mask-override (make-hash-table :test 'equal))
          (supervisor--target-convergence nil)
          (supervisor--target-convergence-reasons nil)
          (supervisor-default-target-link "app.target")
          (supervisor--default-target-link-override nil))
      (let ((result (supervisor--cli-dispatch
                     '("explain-target" "app.target"))))
        (should (= supervisor-cli-exit-success
                    (supervisor-cli-result-exitcode result)))
        (should (string-match "pending"
                              (supervisor-cli-result-output result)))))))

(ert-deftest supervisor-test-cli-explain-target-nonexistent ()
  "Explain-target with nonexistent target returns exit code 4."
  (supervisor-test-with-unit-files
      '((nil :id "basic.target" :type target)
        (nil :id "default.target" :type target))
    (let ((supervisor--current-plan t)
          (supervisor-default-target-link "basic.target")
          (supervisor--default-target-link-override nil))
      (let ((result (supervisor--cli-dispatch
                     '("explain-target" "nonexistent.target"))))
        (should (= supervisor-cli-exit-no-such-unit
                    (supervisor-cli-result-exitcode result)))))))

(ert-deftest supervisor-test-cli-isolate-requires-yes ()
  "Isolate without --yes returns error."
  (supervisor-test-with-unit-files
      '((nil :id "app.target" :type target)
        (nil :id "default.target" :type target))
    (let ((supervisor--current-plan t)
          (supervisor-default-target-link "app.target")
          (supervisor--default-target-link-override nil))
      (let ((result (supervisor--cli-dispatch
                     '("isolate" "app.target"))))
        (should (= supervisor-cli-exit-invalid-args
                    (supervisor-cli-result-exitcode result)))
        (should (string-match "--yes"
                              (supervisor-cli-result-output result)))))))

(ert-deftest supervisor-test-cli-isolate-stops-and-starts ()
  "Isolate with --yes stops non-closure entries and starts closure entries."
  (supervisor-test-with-unit-files
      '(("sleep 300" :id "svc-a" :required-by ("app.target"))
        ("sleep 300" :id "svc-b" :required-by ("other.target"))
        (nil :id "app.target" :type target)
        (nil :id "other.target" :type target)
        (nil :id "default.target" :type target))
    (let ((supervisor--current-plan t)
          (supervisor--processes (make-hash-table :test 'equal))
          (supervisor--entry-state (make-hash-table :test 'equal))
          (supervisor--failed (make-hash-table :test 'equal))
          (supervisor--oneshot-completed (make-hash-table :test 'equal))
          (supervisor--remain-active (make-hash-table :test 'equal))
          (supervisor--manually-stopped (make-hash-table :test 'equal))
          (supervisor--manually-started (make-hash-table :test 'equal))
          (supervisor--mask-override (make-hash-table :test 'equal))
          (supervisor--invalid (make-hash-table :test 'equal))
          (supervisor--restart-times (make-hash-table :test 'equal))
          (supervisor--spawn-failure-reason (make-hash-table :test 'equal))
          (supervisor--target-convergence nil)
          (supervisor--target-convergence-reasons nil)
          (supervisor--target-members nil)
          (supervisor-default-target-link "app.target")
          (supervisor--default-target-link-override nil)
          (dag-entries nil)
          (stopped nil))
      ;; Mock dag-start-with-deps to capture entries and manual-stop to track stops
      (cl-letf (((symbol-function 'supervisor--dag-start-with-deps)
                 (lambda (entries callback)
                   (setq dag-entries (mapcar #'supervisor-entry-id entries))
                   (funcall callback)))
                ((symbol-function 'supervisor--manual-stop)
                 (lambda (id) (push id stopped)
                   (list :status 'stopped :reason nil))))
        (let ((result (supervisor--cli-dispatch
                       '("isolate" "--yes" "app.target"))))
          (should (= supervisor-cli-exit-success
                      (supervisor-cli-result-exitcode result)))
          (should (string-match "Isolated"
                                (supervisor-cli-result-output result)))
          ;; svc-a should be submitted to DAG (in app.target closure)
          (should (member "svc-a" dag-entries))
          ;; svc-b should NOT be submitted (not in closure)
          (should-not (member "svc-b" dag-entries)))))))

(ert-deftest supervisor-test-dag-start-with-deps-oneshot-blocking ()
  "DAG start respects blocking oneshot: dependent waits for oneshot exit."
  (supervisor-test-with-unit-files
      '(("true" :id "setup" :type oneshot :oneshot-blocking t)
        ("sleep 300" :id "svc" :type simple :after ("setup")))
    (let ((supervisor--dag-in-degree (make-hash-table :test 'equal))
          (supervisor--dag-dependents (make-hash-table :test 'equal))
          (supervisor--dag-entries (make-hash-table :test 'equal))
          (supervisor--dag-blocking (make-hash-table :test 'equal))
          (supervisor--dag-started (make-hash-table :test 'equal))
          (supervisor--dag-ready (make-hash-table :test 'equal))
          (supervisor--dag-timeout-timers (make-hash-table :test 'equal))
          (supervisor--dag-delay-timers (make-hash-table :test 'equal))
          (supervisor--dag-id-to-index (make-hash-table :test 'equal))
          (supervisor--dag-complete-callback nil)
          (supervisor--dag-pending-starts nil)
          (supervisor--dag-active-starts 0)
          (supervisor--processes (make-hash-table :test 'equal))
          (supervisor--entry-state (make-hash-table :test 'equal))
          (supervisor--mask-override (make-hash-table :test 'equal))
          (supervisor--enabled-override (make-hash-table :test 'equal))
          (supervisor--ready-times (make-hash-table :test 'equal))
          (supervisor--start-times (make-hash-table :test 'equal))
          (supervisor--target-member-reverse nil)
          (supervisor--target-converging nil)
          (supervisor--shutting-down nil)
          (supervisor-max-concurrent-starts nil)
          (spawned nil)
          (complete nil))
      (let* ((plan (supervisor--build-plan (supervisor--effective-programs)))
             (entries (cl-remove-if
                       (lambda (e) (eq (supervisor-entry-type e) 'target))
                       (supervisor-plan-by-target plan))))
        ;; Mock start-process to track spawns without real processes
        (cl-letf (((symbol-function 'supervisor--start-process)
                   (lambda (id _cmd _log _type _restart &rest _args)
                     (push id spawned)
                     ;; Return a fake process object
                     (start-process (concat "fake-" id) nil "sleep" "300")))
                  ((symbol-function 'executable-find) (lambda (_) t))
                  ((symbol-function 'supervisor--emit-event) #'ignore)
                  ((symbol-function 'supervisor--maybe-refresh-dashboard)
                   #'ignore))
          (unwind-protect
              (progn
                ;; Start entries via DAG
                (supervisor--dag-start-with-deps
                 entries
                 (lambda () (setq complete t)))
                ;; Oneshot should be spawned first
                (should (member "setup" spawned))
                ;; Dependent should NOT be spawned yet (waiting for oneshot)
                (should-not (member "svc" spawned))
                ;; Simulate oneshot exit by marking ready
                (supervisor--dag-mark-ready "setup")
                ;; Now dependent should be spawned
                (should (member "svc" spawned)))
            ;; Cleanup fake processes
            (maphash (lambda (_id proc)
                       (when (process-live-p proc)
                         (delete-process proc)))
                     supervisor--processes)))))))

(ert-deftest supervisor-test-cli-isolate-nonexistent ()
  "Isolate with nonexistent target returns exit code 4."
  (supervisor-test-with-unit-files
      '((nil :id "basic.target" :type target)
        (nil :id "default.target" :type target))
    (let ((supervisor--current-plan t)
          (supervisor-default-target-link "basic.target")
          (supervisor--default-target-link-override nil))
      (let ((result (supervisor--cli-dispatch
                     '("isolate" "--yes" "nonexistent.target"))))
        (should (= supervisor-cli-exit-no-such-unit
                    (supervisor-cli-result-exitcode result)))))))

(ert-deftest supervisor-test-cli-start-target-override ()
  "The `start --target' uses specified root via let-bind."
  (supervisor-test-with-unit-files
      '(("sleep 1" :id "svc-a" :required-by ("basic.target"))
        (nil :id "basic.target" :type target)
        (nil :id "graphical.target" :type target
             :after ("basic.target"))
        (nil :id "default.target" :type target))
    (let ((supervisor--processes (make-hash-table :test 'equal))
          (supervisor--entry-state (make-hash-table :test 'equal))
          (supervisor--failed (make-hash-table :test 'equal))
          (supervisor--oneshot-completed (make-hash-table :test 'equal))
          (supervisor--remain-active (make-hash-table :test 'equal))
          (supervisor--manually-stopped (make-hash-table :test 'equal))
          (supervisor--manually-started (make-hash-table :test 'equal))
          (supervisor--mask-override (make-hash-table :test 'equal))
          (supervisor--invalid (make-hash-table :test 'equal))
          (supervisor--cycle-fallback-ids (make-hash-table :test 'equal))
          (supervisor--computed-deps (make-hash-table :test 'equal))
          (supervisor--restart-override (make-hash-table :test 'equal))
          (supervisor--enabled-override (make-hash-table :test 'equal))
          (supervisor--logging (make-hash-table :test 'equal))
          (supervisor--writers (make-hash-table :test 'equal))
          (supervisor--stderr-writers (make-hash-table :test 'equal))
          (supervisor--stderr-pipes (make-hash-table :test 'equal))
          (supervisor--restart-times (make-hash-table :test 'equal))
          (supervisor--restart-timers (make-hash-table :test 'equal))
          (supervisor--last-exit-info (make-hash-table :test 'equal))
          (supervisor--start-times (make-hash-table :test 'equal))
          (supervisor--ready-times (make-hash-table :test 'equal))
          (supervisor--spawn-failure-reason (make-hash-table :test 'equal))
          (supervisor--target-convergence nil)
          (supervisor--target-convergence-reasons nil)
          (supervisor--target-members nil)
          (supervisor--timers nil)
          (supervisor--current-plan nil)
          (supervisor--shutting-down nil)
          (supervisor--overrides-loaded nil)
          (supervisor-overrides-file nil)
          (supervisor-default-target "default.target")
          (supervisor-default-target-link "graphical.target")
          (supervisor--default-target-link-override nil)
          (captured-target nil))
      ;; Mock supervisor-start to capture what target was used
      (cl-letf (((symbol-function 'supervisor-start)
                 (lambda ()
                   (setq captured-target supervisor-default-target))))
        (let ((result (supervisor--cli-dispatch
                       '("start" "--target" "basic.target"))))
          (should (= supervisor-cli-exit-success
                      (supervisor-cli-result-exitcode result)))
          ;; The let-binding should have set supervisor-default-target
          ;; to basic.target during the call
          (should (equal "basic.target" captured-target)))))))

(ert-deftest supervisor-test-cli-start-target-invalid ()
  "The `start --target' with non-.target suffix returns error."
  (let ((result (supervisor--cli-dispatch
                 '("start" "--target" "my-service"))))
    (should (= supervisor-cli-exit-invalid-args
                (supervisor-cli-result-exitcode result)))
    (should (string-match "\\.target"
                          (supervisor-cli-result-output result)))))

(ert-deftest supervisor-test-cli-start-target-missing-value ()
  "The `start --target' without a value returns error."
  (let ((result (supervisor--cli-dispatch '("start" "--target"))))
    (should (= supervisor-cli-exit-invalid-args
                (supervisor-cli-result-exitcode result)))))

(ert-deftest supervisor-test-cli-start-target-with-ids-rejected ()
  "The `start --target T ID' is rejected -- cannot combine."
  (let ((result (supervisor--cli-dispatch
                 '("start" "--target" "basic.target" "svc-a"))))
    (should (= supervisor-cli-exit-invalid-args
                (supervisor-cli-result-exitcode result)))
    (should (string-match "cannot be combined"
                          (supervisor-cli-result-output result)))))

(ert-deftest supervisor-test-cli-help-text-includes-target-commands ()
  "Help text includes target command section."
  (let ((result (supervisor--cli-dispatch '())))
    (should (= supervisor-cli-exit-success
                (supervisor-cli-result-exitcode result)))
    (let ((output (supervisor-cli-result-output result)))
      (should (string-match "Target commands:" output))
      (should (string-match "list-targets" output))
      (should (string-match "target-status" output))
      (should (string-match "explain-target" output))
      (should (string-match "isolate" output))
      (should (string-match "get-default" output))
      (should (string-match "set-default" output)))))

(ert-deftest supervisor-test-cli-list-targets-not-running ()
  "The `list-targets' rejects when supervisor has no runtime context."
  (let ((supervisor--current-plan nil))
    (let ((result (supervisor--cli-dispatch '("list-targets"))))
      (should (= supervisor-cli-exit-failure
                  (supervisor-cli-result-exitcode result)))
      (should (string-match "not running"
                            (supervisor-cli-result-output result))))))

(ert-deftest supervisor-test-cli-target-status-not-running ()
  "The `target-status' rejects when supervisor has no runtime context."
  (let ((supervisor--current-plan nil))
    (let ((result (supervisor--cli-dispatch
                   '("target-status" "app.target"))))
      (should (= supervisor-cli-exit-failure
                  (supervisor-cli-result-exitcode result)))
      (should (string-match "not running"
                            (supervisor-cli-result-output result))))))

(ert-deftest supervisor-test-cli-explain-target-not-running ()
  "The `explain-target' rejects when supervisor has no runtime context."
  (let ((supervisor--current-plan nil))
    (let ((result (supervisor--cli-dispatch
                   '("explain-target" "app.target"))))
      (should (= supervisor-cli-exit-failure
                  (supervisor-cli-result-exitcode result)))
      (should (string-match "not running"
                            (supervisor-cli-result-output result))))))

(ert-deftest supervisor-test-cli-isolate-not-running ()
  "The `isolate --yes' rejects when supervisor has no runtime context."
  (let ((supervisor--current-plan nil))
    (let ((result (supervisor--cli-dispatch
                   '("isolate" "--yes" "app.target"))))
      (should (= supervisor-cli-exit-failure
                  (supervisor-cli-result-exitcode result)))
      (should (string-match "not running"
                            (supervisor-cli-result-output result))))))

(ert-deftest supervisor-test-cli-start-target-nonexistent-clean-error ()
  "The `start --target' with nonexistent target returns clean error."
  (supervisor-test-with-unit-files
      '((nil :id "basic.target" :type target)
        (nil :id "default.target" :type target))
    (let ((supervisor-default-target-link "basic.target")
          (supervisor--default-target-link-override nil))
      (let ((result (supervisor--cli-dispatch
                     '("start" "--target" "nonexistent.target"))))
        (should (= supervisor-cli-exit-no-such-unit
                    (supervisor-cli-result-exitcode result)))
        ;; Should be a clean error, not "Internal error"
        (should-not (string-match "Internal error"
                                  (supervisor-cli-result-output result)))))))

(ert-deftest supervisor-test-cli-start-no-args-calls-supervisor-start ()
  "Plain `start' with no arguments calls `supervisor-start'."
  (supervisor-test-with-unit-files
      '((nil :id "basic.target" :type target)
        (nil :id "default.target" :type target))
    (let ((supervisor-default-target-link "basic.target")
          (supervisor--default-target-link-override nil)
          (called nil))
      (cl-letf (((symbol-function 'supervisor-start)
                 (lambda () (setq called t))))
        (let ((result (supervisor--cli-dispatch '("start"))))
          (should (= supervisor-cli-exit-success
                      (supervisor-cli-result-exitcode result)))
          (should called))))))

(ert-deftest supervisor-test-cli-isolate-skips-running-entries ()
  "Isolate does not submit already-running entries to DAG for starting."
  (supervisor-test-with-unit-files
      '(("sleep 300" :id "svc-a" :required-by ("app.target"))
        ("sleep 300" :id "svc-b" :required-by ("app.target"))
        (nil :id "app.target" :type target)
        (nil :id "default.target" :type target))
    (let ((supervisor--current-plan t)
          (supervisor--processes (make-hash-table :test 'equal))
          (supervisor--entry-state (make-hash-table :test 'equal))
          (supervisor--failed (make-hash-table :test 'equal))
          (supervisor--oneshot-completed (make-hash-table :test 'equal))
          (supervisor--remain-active (make-hash-table :test 'equal))
          (supervisor--manually-stopped (make-hash-table :test 'equal))
          (supervisor--manually-started (make-hash-table :test 'equal))
          (supervisor--mask-override (make-hash-table :test 'equal))
          (supervisor--invalid (make-hash-table :test 'equal))
          (supervisor--restart-times (make-hash-table :test 'equal))
          (supervisor--spawn-failure-reason (make-hash-table :test 'equal))
          (supervisor--target-convergence nil)
          (supervisor--target-convergence-reasons nil)
          (supervisor--target-members nil)
          (supervisor-default-target-link "app.target")
          (supervisor--default-target-link-override nil)
          (dag-entries nil)
          (stopped nil))
      ;; Simulate svc-a already running
      (let ((fake-proc (start-process "fake-svc-a" nil "sleep" "300")))
        (unwind-protect
            (progn
              (puthash "svc-a" fake-proc supervisor--processes)
              (cl-letf (((symbol-function 'supervisor--dag-start-with-deps)
                         (lambda (entries callback)
                           (setq dag-entries
                                 (mapcar #'supervisor-entry-id entries))
                           (funcall callback)))
                        ((symbol-function 'supervisor--manual-stop)
                         (lambda (id) (push id stopped)
                           (list :status 'stopped :reason nil))))
                (let ((result (supervisor--cli-dispatch
                               '("isolate" "--yes" "app.target"))))
                  (should (= supervisor-cli-exit-success
                              (supervisor-cli-result-exitcode result)))
                  ;; svc-a should NOT be in DAG entries (already running)
                  (should-not (member "svc-a" dag-entries))
                  ;; svc-b should be in DAG entries (not running)
                  (should (member "svc-b" dag-entries)))))
          (when (process-live-p fake-proc)
            (delete-process fake-proc)))))))

(ert-deftest supervisor-test-cli-explain-target-converging ()
  "Converging target lists non-terminal members."
  (supervisor-test-with-unit-files
      '(("sleep 1" :id "svc-a" :required-by ("app.target"))
        ("sleep 1" :id "svc-b" :required-by ("app.target"))
        (nil :id "app.target" :type target)
        (nil :id "default.target" :type target))
    (let ((supervisor--current-plan t)
          (supervisor--processes (make-hash-table :test 'equal))
          (supervisor--entry-state (make-hash-table :test 'equal))
          (supervisor--failed (make-hash-table :test 'equal))
          (supervisor--oneshot-completed (make-hash-table :test 'equal))
          (supervisor--remain-active (make-hash-table :test 'equal))
          (supervisor--manually-stopped (make-hash-table :test 'equal))
          (supervisor--mask-override (make-hash-table :test 'equal))
          (supervisor--target-convergence (make-hash-table :test 'equal))
          (supervisor--target-convergence-reasons
           (make-hash-table :test 'equal))
          (supervisor-default-target-link "app.target")
          (supervisor--default-target-link-override nil))
      (puthash "app.target" 'converging supervisor--target-convergence)
      ;; svc-a is running, svc-b is pending (non-terminal)
      (puthash "svc-a" 'started supervisor--entry-state)
      (let ((result (supervisor--cli-dispatch
                     '("explain-target" "app.target"))))
        (should (= supervisor-cli-exit-success
                    (supervisor-cli-result-exitcode result)))
        (should (string-match "converging"
                              (supervisor-cli-result-output result)))
        (should (string-match "not yet terminal"
                              (supervisor-cli-result-output result)))))))

(ert-deftest supervisor-test-cli-explain-target-json ()
  "Explain-target JSON output includes id, status, reasons, members."
  (supervisor-test-with-unit-files
      '(("sleep 1" :id "svc-a" :required-by ("app.target"))
        (nil :id "app.target" :type target)
        (nil :id "default.target" :type target))
    (let ((supervisor--current-plan t)
          (supervisor--processes (make-hash-table :test 'equal))
          (supervisor--entry-state (make-hash-table :test 'equal))
          (supervisor--failed (make-hash-table :test 'equal))
          (supervisor--oneshot-completed (make-hash-table :test 'equal))
          (supervisor--remain-active (make-hash-table :test 'equal))
          (supervisor--manually-stopped (make-hash-table :test 'equal))
          (supervisor--mask-override (make-hash-table :test 'equal))
          (supervisor--target-convergence (make-hash-table :test 'equal))
          (supervisor--target-convergence-reasons
           (make-hash-table :test 'equal))
          (supervisor-default-target-link "app.target")
          (supervisor--default-target-link-override nil))
      (puthash "app.target" 'reached supervisor--target-convergence)
      (let ((result (supervisor--cli-dispatch
                     '("--json" "explain-target" "app.target"))))
        (should (= supervisor-cli-exit-success
                    (supervisor-cli-result-exitcode result)))
        (let ((json (json-read-from-string
                     (supervisor-cli-result-output result))))
          (should (equal "app.target" (alist-get 'id json)))
          (should (equal "reached" (alist-get 'status json)))
          (should (arrayp (alist-get 'reasons json)))
          (should (arrayp (alist-get 'members json))))))))

(ert-deftest supervisor-test-cli-isolate-json ()
  "Isolate JSON output includes status, target, stopped, started counts."
  (supervisor-test-with-unit-files
      '(("sleep 300" :id "svc-a" :required-by ("app.target"))
        (nil :id "app.target" :type target)
        (nil :id "default.target" :type target))
    (let ((supervisor--current-plan t)
          (supervisor--processes (make-hash-table :test 'equal))
          (supervisor--entry-state (make-hash-table :test 'equal))
          (supervisor--failed (make-hash-table :test 'equal))
          (supervisor--oneshot-completed (make-hash-table :test 'equal))
          (supervisor--remain-active (make-hash-table :test 'equal))
          (supervisor--manually-stopped (make-hash-table :test 'equal))
          (supervisor--manually-started (make-hash-table :test 'equal))
          (supervisor--mask-override (make-hash-table :test 'equal))
          (supervisor--invalid (make-hash-table :test 'equal))
          (supervisor--restart-times (make-hash-table :test 'equal))
          (supervisor--spawn-failure-reason (make-hash-table :test 'equal))
          (supervisor--target-convergence nil)
          (supervisor--target-convergence-reasons nil)
          (supervisor--target-members nil)
          (supervisor-default-target-link "app.target")
          (supervisor--default-target-link-override nil))
      (cl-letf (((symbol-function 'supervisor--dag-start-with-deps)
                 (lambda (_entries callback) (funcall callback)))
                ((symbol-function 'supervisor--manual-stop)
                 (lambda (_id) (list :status 'stopped :reason nil))))
        (let ((result (supervisor--cli-dispatch
                       '("--json" "isolate" "--yes" "app.target"))))
          (should (= supervisor-cli-exit-success
                      (supervisor-cli-result-exitcode result)))
          (let ((json (json-read-from-string
                       (supervisor-cli-result-output result))))
            (should (equal "applied" (alist-get 'status json)))
            (should (equal "app.target" (alist-get 'target json)))
            (should (numberp (alist-get 'stopped json)))
            (should (numberp (alist-get 'started json)))))))))

;;;; SysV Init Runlevel Compatibility Tests

(ert-deftest supervisor-test-runlevel-map-complete ()
  "Runlevel map covers all 7 runlevels 0-6."
  (dolist (n '(0 1 2 3 4 5 6))
    (should (assq n supervisor--runlevel-map))))

(ert-deftest supervisor-test-runlevel-map-values ()
  "Runlevel map matches systemd semantics exactly."
  (should (equal "poweroff.target" (cdr (assq 0 supervisor--runlevel-map))))
  (should (equal "rescue.target" (cdr (assq 1 supervisor--runlevel-map))))
  (should (equal "multi-user.target" (cdr (assq 2 supervisor--runlevel-map))))
  (should (equal "multi-user.target" (cdr (assq 3 supervisor--runlevel-map))))
  (should (equal "multi-user.target" (cdr (assq 4 supervisor--runlevel-map))))
  (should (equal "graphical.target" (cdr (assq 5 supervisor--runlevel-map))))
  (should (equal "reboot.target" (cdr (assq 6 supervisor--runlevel-map)))))

(ert-deftest supervisor-test-alias-resolution ()
  "Alias targets resolve to canonical targets."
  (should (equal "poweroff.target"
                 (supervisor--resolve-target-alias "runlevel0.target")))
  (should (equal "rescue.target"
                 (supervisor--resolve-target-alias "runlevel1.target")))
  (should (equal "multi-user.target"
                 (supervisor--resolve-target-alias "runlevel3.target")))
  (should (equal "graphical.target"
                 (supervisor--resolve-target-alias "runlevel5.target")))
  (should (equal "reboot.target"
                 (supervisor--resolve-target-alias "runlevel6.target"))))

(ert-deftest supervisor-test-alias-resolution-passthrough ()
  "Non-alias targets pass through unchanged."
  (should (equal "graphical.target"
                 (supervisor--resolve-target-alias "graphical.target")))
  (should (equal "basic.target"
                 (supervisor--resolve-target-alias "basic.target")))
  (should (equal "my-service"
                 (supervisor--resolve-target-alias "my-service"))))

(ert-deftest supervisor-test-alias-predicate ()
  "Alias predicate identifies aliases and non-aliases."
  (should (supervisor--target-alias-p "runlevel0.target"))
  (should (supervisor--target-alias-p "runlevel5.target"))
  (should-not (supervisor--target-alias-p "graphical.target"))
  (should-not (supervisor--target-alias-p "basic.target")))

(ert-deftest supervisor-test-builtin-init-targets-present ()
  "Built-in programs include init-transition canonical targets."
  (let* ((builtins (supervisor--builtin-programs))
         (ids (mapcar (lambda (e) (plist-get (cdr e) :id)) builtins)))
    (should (member "rescue.target" ids))
    (should (member "shutdown.target" ids))
    (should (member "poweroff.target" ids))
    (should (member "reboot.target" ids))))

(ert-deftest supervisor-test-builtin-alias-targets-present ()
  "Built-in programs include all runlevel alias targets."
  (let* ((builtins (supervisor--builtin-programs))
         (ids (mapcar (lambda (e) (plist-get (cdr e) :id)) builtins)))
    (dolist (n '(0 1 2 3 4 5 6))
      (should (member (format "runlevel%d.target" n) ids)))))

(ert-deftest supervisor-test-builtin-init-target-topology ()
  "Init-transition targets have correct dependency chain."
  (let* ((builtins (supervisor--builtin-programs))
         (rescue (cl-find "rescue.target" builtins
                          :key (lambda (e) (plist-get (cdr e) :id))
                          :test #'equal))
         (shutdown (cl-find "shutdown.target" builtins
                            :key (lambda (e) (plist-get (cdr e) :id))
                            :test #'equal))
         (poweroff (cl-find "poweroff.target" builtins
                            :key (lambda (e) (plist-get (cdr e) :id))
                            :test #'equal))
         (reboot (cl-find "reboot.target" builtins
                          :key (lambda (e) (plist-get (cdr e) :id))
                          :test #'equal)))
    ;; rescue.target requires basic.target
    (should (equal '("basic.target") (plist-get (cdr rescue) :requires)))
    ;; shutdown.target has no requires
    (should-not (plist-get (cdr shutdown) :requires))
    ;; poweroff.target requires shutdown.target
    (should (equal '("shutdown.target") (plist-get (cdr poweroff) :requires)))
    ;; reboot.target requires shutdown.target
    (should (equal '("shutdown.target") (plist-get (cdr reboot) :requires)))))

(ert-deftest supervisor-test-alias-target-with-deps-rejected-by-validation ()
  "Disk alias target with dependency edges is caught by validation."
  (let* ((dir (make-temp-file "units-" t))
         (supervisor-unit-authority-path (list dir))
         (supervisor-unit-directory dir)
         (supervisor--programs-cache :not-yet-loaded)
         (supervisor--unit-file-invalid (make-hash-table :test 'equal))
         (warnings nil))
    (supervisor-test--write-unit-files
     dir '((nil :id "runlevel5.target" :type target
                :requires ("basic.target"))))
    (unwind-protect
        (progn
          (cl-letf (((symbol-function 'supervisor--log)
                     (lambda (_level fmt &rest args)
                       (push (apply #'format fmt args) warnings))))
            (supervisor--load-programs))
          ;; The alias target should still be the built-in (no :requires)
          (let ((entry (cl-find "runlevel5.target"
                                supervisor--programs-cache
                                :key (lambda (e) (plist-get (cdr e) :id))
                                :test #'equal)))
            (should entry)
            (should-not (plist-get (cdr entry) :requires)))
          ;; Validation rejected with "passive" reason
          (should (cl-some (lambda (w)
                             (string-match-p "runlevel5\\.target.*passive" w))
                           warnings))
          ;; Invalid-hash must NOT contain the alias ID -- the valid
          ;; builtin replaces it, so the dashboard/CLI must not show
          ;; the rejected disk unit's invalid status.
          (should-not (gethash "runlevel5.target"
                               supervisor--unit-file-invalid)))
      (delete-directory dir t))))

(ert-deftest supervisor-test-alias-target-no-deps-rejected-by-merge ()
  "Disk alias target without deps passes validation but is rejected at merge."
  (let* ((dir (make-temp-file "units-" t))
         (supervisor-unit-authority-path (list dir))
         (supervisor-unit-directory dir)
         (supervisor--programs-cache :not-yet-loaded)
         (supervisor--unit-file-invalid (make-hash-table :test 'equal))
         (warnings nil))
    (supervisor-test--write-unit-files
     dir '((nil :id "runlevel3.target" :type target)))
    (unwind-protect
        (progn
          (cl-letf (((symbol-function 'supervisor--log)
                     (lambda (_level fmt &rest args)
                       (push (apply #'format fmt args) warnings))))
            (supervisor--load-programs))
          ;; Built-in alias still present
          (let ((entry (cl-find "runlevel3.target"
                                supervisor--programs-cache
                                :key (lambda (e) (plist-get (cdr e) :id))
                                :test #'equal)))
            (should entry))
          ;; Merge-time warning was emitted
          (should (cl-some (lambda (w)
                             (string-match-p "runlevel3\\.target.*immutable" w))
                           warnings))
          ;; Invalid-hash cleaned: builtin is valid, disk rejection must
          ;; not leak into dashboard/CLI invalid state.
          (should-not (gethash "runlevel3.target"
                               supervisor--unit-file-invalid)))
      (delete-directory dir t))))

(ert-deftest supervisor-test-alias-invalid-winner-does-not-suppress-builtin ()
  "Invalid disk alias target does not suppress the valid builtin in merged set.
Exercises the authority resolver invalid-winner-blocks-fallback semantics:
even when a disk alias target wins authority and is marked invalid, the
builtin alias target must still appear in the merged program cache and
the invalid-hash must not contain the alias ID."
  (let* ((dir (make-temp-file "units-" t))
         (supervisor-unit-authority-path (list dir))
         (supervisor-unit-directory dir)
         (supervisor--programs-cache :not-yet-loaded)
         (supervisor--unit-file-invalid (make-hash-table :test 'equal)))
    ;; Write a deliberately invalid alias target (has :after dep edge)
    (supervisor-test--write-unit-files
     dir '((nil :id "runlevel0.target" :type target
                :after ("basic.target"))))
    (unwind-protect
        (progn
          (supervisor--load-programs)
          ;; Builtin runlevel0.target must be in the cache
          (let ((entry (cl-find "runlevel0.target"
                                supervisor--programs-cache
                                :key (lambda (e) (plist-get (cdr e) :id))
                                :test #'equal)))
            (should entry)
            ;; Must be the builtin (no :after)
            (should-not (plist-get (cdr entry) :after))
            ;; Description should be the builtin's
            (should (string-match-p "poweroff"
                                    (plist-get (cdr entry) :description))))
          ;; Invalid-hash must not contain alias ID
          (should-not (gethash "runlevel0.target"
                               supervisor--unit-file-invalid))
          ;; Other builtins are unaffected
          (should (cl-find "runlevel5.target"
                           supervisor--programs-cache
                           :key (lambda (e) (plist-get (cdr e) :id))
                           :test #'equal)))
      (delete-directory dir t))))

(ert-deftest supervisor-test-alias-target-override-non-alias-still-works ()
  "Disk unit can still override non-alias built-in targets."
  (let* ((dir (make-temp-file "units-" t))
         (supervisor-unit-authority-path (list dir))
         (supervisor-unit-directory dir)
         (supervisor--programs-cache :not-yet-loaded)
         (supervisor--unit-file-invalid (make-hash-table :test 'equal)))
    ;; Override basic.target (canonical, not alias -- should be allowed)
    (supervisor-test--write-unit-files
     dir '((nil :id "basic.target" :type target
                :description "User-custom basic target")))
    (unwind-protect
        (progn
          (supervisor--load-programs)
          (let ((entry (cl-find "basic.target"
                                supervisor--programs-cache
                                :key (lambda (e) (plist-get (cdr e) :id))
                                :test #'equal)))
            (should entry)
            ;; Should be the disk version (user-custom description)
            (should (equal "User-custom basic target"
                           (plist-get (cdr entry) :description)))
            ;; Should appear exactly once
            (should (= 1 (cl-count "basic.target"
                                   supervisor--programs-cache
                                   :key (lambda (e) (plist-get (cdr e) :id))
                                   :test #'equal)))))
      (delete-directory dir t))))

(ert-deftest supervisor-test-merged-targets-include-canonical-and-alias ()
  "Merged runtime load path includes both canonical and alias targets."
  (let* ((dir (make-temp-file "units-" t))
         (supervisor-unit-authority-path (list dir))
         (supervisor-unit-directory dir)
         (supervisor--programs-cache :not-yet-loaded)
         (supervisor--unit-file-invalid (make-hash-table :test 'equal)))
    ;; No disk targets -- all built-in targets should appear in merged set
    (unwind-protect
        (progn
          (supervisor--load-programs)
          (let ((ids (mapcar (lambda (e) (plist-get (cdr e) :id))
                             supervisor--programs-cache)))
            ;; Canonical targets present
            (should (member "basic.target" ids))
            (should (member "multi-user.target" ids))
            (should (member "graphical.target" ids))
            (should (member "default.target" ids))
            ;; Init-transition targets present
            (should (member "rescue.target" ids))
            (should (member "shutdown.target" ids))
            (should (member "poweroff.target" ids))
            (should (member "reboot.target" ids))
            ;; Alias targets present
            (dolist (n '(0 1 2 3 4 5 6))
              (should (member (format "runlevel%d.target" n) ids)))))
      (delete-directory dir t))))

(ert-deftest supervisor-test-alias-target-validation-rejects-deps ()
  "Validation rejects alias target entries that carry dependency edges."
  (dolist (kw '(:requires :wants :after :before :wanted-by :required-by))
    (let* ((entry (list nil :id "runlevel3.target" :type 'target
                        kw '("basic.target")))
           (reason (supervisor--validate-entry entry)))
      (should reason)
      (should (string-match-p "alias target" reason))
      (should (string-match-p "passive" reason))
      (should (string-match-p (symbol-name kw) reason)))))

(ert-deftest supervisor-test-alias-target-validation-accepts-passive ()
  "Validation accepts alias target entries without dependency edges."
  (let* ((entry (list nil :id "runlevel5.target" :type 'target
                      :description "Alias for graphical.target"))
         (reason (supervisor--validate-entry entry)))
    (should-not reason)))

(ert-deftest supervisor-test-canonical-target-validation-allows-deps ()
  "Validation allows canonical (non-alias) targets to carry dependencies."
  (let* ((entry (list nil :id "multi-user.target" :type 'target
                      :requires '("basic.target")))
         (reason (supervisor--validate-entry entry)))
    (should-not reason)))

(ert-deftest supervisor-test-cli-init-valid-runlevels ()
  "The `init' command accepts all runlevels 0-6 and resolves correctly."
  (supervisor-test-with-unit-files
      '((nil :id "basic.target" :type target)
        (nil :id "multi-user.target" :type target)
        (nil :id "graphical.target" :type target)
        (nil :id "rescue.target" :type target)
        (nil :id "shutdown.target" :type target)
        (nil :id "poweroff.target" :type target)
        (nil :id "reboot.target" :type target)
        (nil :id "default.target" :type target))
    (let ((supervisor--current-plan t)
          (supervisor--processes (make-hash-table :test 'equal))
          (supervisor--entry-state (make-hash-table :test 'equal))
          (supervisor--failed (make-hash-table :test 'equal))
          (supervisor--oneshot-completed (make-hash-table :test 'equal))
          (supervisor--remain-active (make-hash-table :test 'equal))
          (supervisor--manually-stopped (make-hash-table :test 'equal))
          (supervisor--manually-started (make-hash-table :test 'equal))
          (supervisor--mask-override (make-hash-table :test 'equal))
          (supervisor--invalid (make-hash-table :test 'equal))
          (supervisor--restart-times (make-hash-table :test 'equal))
          (supervisor--spawn-failure-reason (make-hash-table :test 'equal))
          (supervisor--target-convergence nil)
          (supervisor--target-convergence-reasons nil)
          (supervisor--target-members nil)
          (supervisor-default-target-link "graphical.target")
          (supervisor--default-target-link-override nil))
      (cl-letf (((symbol-function 'supervisor--dag-start-with-deps)
                 (lambda (_entries callback) (funcall callback)))
                ((symbol-function 'supervisor--manual-stop)
                 (lambda (_id) (list :status 'stopped :reason nil))))
        ;; Test all runlevels with both target and runlevel identity
        (dolist (spec '((0 "poweroff\\.target" "runlevel 0")
                        (1 "rescue\\.target" "runlevel 1")
                        (2 "multi-user\\.target" "runlevel 2")
                        (3 "multi-user\\.target" "runlevel 3")
                        (4 "multi-user\\.target" "runlevel 4")
                        (5 "graphical\\.target" "runlevel 5")
                        (6 "reboot\\.target" "runlevel 6")))
          (let* ((rl (number-to-string (car spec)))
                 (target-pattern (nth 1 spec))
                 (runlevel-pattern (nth 2 spec))
                 (result (supervisor--cli-dispatch
                          (list "init" "--yes" rl)))
                 (output (supervisor-cli-result-output result)))
            (should (= supervisor-cli-exit-success
                        (supervisor-cli-result-exitcode result)))
            ;; Target identity in output
            (should (string-match target-pattern output))
            ;; Numeric runlevel identity in output
            (should (string-match runlevel-pattern output))))))))

(ert-deftest supervisor-test-cli-init-out-of-range ()
  "The `init' command rejects runlevels outside 0-6."
  (let ((result (supervisor--cli-dispatch '("init" "7"))))
    (should (= supervisor-cli-exit-invalid-args
                (supervisor-cli-result-exitcode result)))
    (should (string-match "out of range"
                          (supervisor-cli-result-output result)))))

(ert-deftest supervisor-test-cli-init-non-numeric ()
  "The `init' command rejects non-numeric arguments."
  (let ((result (supervisor--cli-dispatch '("init" "abc"))))
    (should (= supervisor-cli-exit-invalid-args
                (supervisor-cli-result-exitcode result)))
    (should (string-match "not a valid runlevel"
                          (supervisor-cli-result-output result)))))

(ert-deftest supervisor-test-cli-init-no-args ()
  "The `init' command rejects missing argument."
  (let ((result (supervisor--cli-dispatch '("init"))))
    (should (= supervisor-cli-exit-invalid-args
                (supervisor-cli-result-exitcode result)))))

(ert-deftest supervisor-test-cli-init-destructive-requires-yes ()
  "Runlevels 0 and 6 require --yes for destructive confirmation."
  ;; init 0 without --yes
  (let ((result (supervisor--cli-dispatch '("init" "0"))))
    (should (= supervisor-cli-exit-invalid-args
                (supervisor-cli-result-exitcode result)))
    (should (string-match "destructive"
                          (supervisor-cli-result-output result)))
    (should (string-match "--yes"
                          (supervisor-cli-result-output result))))
  ;; init 6 without --yes
  (let ((result (supervisor--cli-dispatch '("init" "6"))))
    (should (= supervisor-cli-exit-invalid-args
                (supervisor-cli-result-exitcode result)))
    (should (string-match "destructive"
                          (supervisor-cli-result-output result)))))

(ert-deftest supervisor-test-cli-init-interactive-prompt-accepts ()
  "Interactive destructive init succeeds when user confirms via y-or-n-p."
  (supervisor-test-with-unit-files
      '((nil :id "basic.target" :type target)
        (nil :id "shutdown.target" :type target)
        (nil :id "poweroff.target" :type target)
        (nil :id "default.target" :type target))
    (let ((supervisor--current-plan t)
          (supervisor--processes (make-hash-table :test 'equal))
          (supervisor--entry-state (make-hash-table :test 'equal))
          (supervisor--failed (make-hash-table :test 'equal))
          (supervisor--oneshot-completed (make-hash-table :test 'equal))
          (supervisor--remain-active (make-hash-table :test 'equal))
          (supervisor--manually-stopped (make-hash-table :test 'equal))
          (supervisor--manually-started (make-hash-table :test 'equal))
          (supervisor--mask-override (make-hash-table :test 'equal))
          (supervisor--invalid (make-hash-table :test 'equal))
          (supervisor--restart-times (make-hash-table :test 'equal))
          (supervisor--spawn-failure-reason (make-hash-table :test 'equal))
          (supervisor--target-convergence nil)
          (supervisor--target-convergence-reasons nil)
          (supervisor--target-members nil)
          (supervisor-default-target-link "poweroff.target")
          (supervisor--default-target-link-override nil)
          ;; Simulate interactive Emacs
          (noninteractive nil))
      (cl-letf (((symbol-function 'supervisor--dag-start-with-deps)
                 (lambda (_entries callback) (funcall callback)))
                ((symbol-function 'supervisor--manual-stop)
                 (lambda (_id) (list :status 'stopped :reason nil)))
                ((symbol-function 'y-or-n-p)
                 (lambda (_prompt) t)))
        ;; init 0 without --yes, but y-or-n-p returns t
        (let ((result (supervisor--cli-dispatch '("init" "0"))))
          (should (= supervisor-cli-exit-success
                      (supervisor-cli-result-exitcode result)))
          (should (string-match "poweroff\\.target"
                                (supervisor-cli-result-output result))))))))

(ert-deftest supervisor-test-cli-init-interactive-prompt-declines ()
  "Interactive destructive init fails when user declines via y-or-n-p."
  (let ((noninteractive nil))
    (cl-letf (((symbol-function 'y-or-n-p)
               (lambda (_prompt) nil)))
      ;; init 0 without --yes, y-or-n-p returns nil
      (let ((result (supervisor--cli-dispatch '("init" "0"))))
        (should (= supervisor-cli-exit-invalid-args
                    (supervisor-cli-result-exitcode result)))
        (should (string-match "destructive"
                              (supervisor-cli-result-output result)))))))

(ert-deftest supervisor-test-cli-init-json-includes-runlevel ()
  "JSON output from init includes runlevel field."
  (supervisor-test-with-unit-files
      '((nil :id "basic.target" :type target)
        (nil :id "multi-user.target" :type target)
        (nil :id "default.target" :type target))
    (let ((supervisor--current-plan t)
          (supervisor--processes (make-hash-table :test 'equal))
          (supervisor--entry-state (make-hash-table :test 'equal))
          (supervisor--failed (make-hash-table :test 'equal))
          (supervisor--oneshot-completed (make-hash-table :test 'equal))
          (supervisor--remain-active (make-hash-table :test 'equal))
          (supervisor--manually-stopped (make-hash-table :test 'equal))
          (supervisor--manually-started (make-hash-table :test 'equal))
          (supervisor--mask-override (make-hash-table :test 'equal))
          (supervisor--invalid (make-hash-table :test 'equal))
          (supervisor--restart-times (make-hash-table :test 'equal))
          (supervisor--spawn-failure-reason (make-hash-table :test 'equal))
          (supervisor--target-convergence nil)
          (supervisor--target-convergence-reasons nil)
          (supervisor--target-members nil)
          (supervisor-default-target-link "multi-user.target")
          (supervisor--default-target-link-override nil))
      (cl-letf (((symbol-function 'supervisor--dag-start-with-deps)
                 (lambda (_entries callback) (funcall callback)))
                ((symbol-function 'supervisor--manual-stop)
                 (lambda (_id) (list :status 'stopped :reason nil))))
        (let ((result (supervisor--cli-dispatch '("--json" "init" "--yes" "3"))))
          (should (= supervisor-cli-exit-success
                      (supervisor-cli-result-exitcode result)))
          (let ((obj (json-read-from-string
                      (supervisor-cli-result-output result))))
            ;; Must have runlevel field
            (should (assq 'runlevel obj))
            (should (= 3 (cdr (assq 'runlevel obj))))
            ;; Must also have target from isolate
            (should (assq 'target obj))
            (should (equal "multi-user.target"
                           (cdr (assq 'target obj))))))))))

(ert-deftest supervisor-test-cli-init-non-destructive-no-yes ()
  "Runlevels 1-5 do not require --yes."
  (supervisor-test-with-unit-files
      '((nil :id "basic.target" :type target)
        (nil :id "multi-user.target" :type target)
        (nil :id "default.target" :type target))
    (let ((supervisor--current-plan t)
          (supervisor--processes (make-hash-table :test 'equal))
          (supervisor--entry-state (make-hash-table :test 'equal))
          (supervisor--failed (make-hash-table :test 'equal))
          (supervisor--oneshot-completed (make-hash-table :test 'equal))
          (supervisor--remain-active (make-hash-table :test 'equal))
          (supervisor--manually-stopped (make-hash-table :test 'equal))
          (supervisor--manually-started (make-hash-table :test 'equal))
          (supervisor--mask-override (make-hash-table :test 'equal))
          (supervisor--invalid (make-hash-table :test 'equal))
          (supervisor--restart-times (make-hash-table :test 'equal))
          (supervisor--spawn-failure-reason (make-hash-table :test 'equal))
          (supervisor--target-convergence nil)
          (supervisor--target-convergence-reasons nil)
          (supervisor--target-members nil)
          (supervisor-default-target-link "multi-user.target")
          (supervisor--default-target-link-override nil))
      ;; init routes through isolate which requires --yes, but init
      ;; passes --yes automatically for non-destructive transitions
      (cl-letf (((symbol-function 'supervisor--dag-start-with-deps)
                 (lambda (_entries callback) (funcall callback)))
                ((symbol-function 'supervisor--manual-stop)
                 (lambda (_id) (list :status 'stopped :reason nil))))
        (let ((result (supervisor--cli-dispatch '("init" "3"))))
          (should (= supervisor-cli-exit-success
                      (supervisor-cli-result-exitcode result))))))))

(ert-deftest supervisor-test-cli-init-does-not-persist-default ()
  "The `init' command does not persist default target changes."
  (supervisor-test-with-unit-files
      '((nil :id "basic.target" :type target)
        (nil :id "multi-user.target" :type target)
        (nil :id "graphical.target" :type target)
        (nil :id "default.target" :type target))
    (let ((supervisor--current-plan t)
          (supervisor--processes (make-hash-table :test 'equal))
          (supervisor--entry-state (make-hash-table :test 'equal))
          (supervisor--failed (make-hash-table :test 'equal))
          (supervisor--oneshot-completed (make-hash-table :test 'equal))
          (supervisor--remain-active (make-hash-table :test 'equal))
          (supervisor--manually-stopped (make-hash-table :test 'equal))
          (supervisor--manually-started (make-hash-table :test 'equal))
          (supervisor--mask-override (make-hash-table :test 'equal))
          (supervisor--invalid (make-hash-table :test 'equal))
          (supervisor--restart-times (make-hash-table :test 'equal))
          (supervisor--spawn-failure-reason (make-hash-table :test 'equal))
          (supervisor--target-convergence nil)
          (supervisor--target-convergence-reasons nil)
          (supervisor--target-members nil)
          (supervisor-default-target-link "graphical.target")
          (supervisor--default-target-link-override nil))
      (cl-letf (((symbol-function 'supervisor--dag-start-with-deps)
                 (lambda (_entries callback) (funcall callback)))
                ((symbol-function 'supervisor--manual-stop)
                 (lambda (_id) (list :status 'stopped :reason nil))))
        (supervisor--cli-dispatch '("init" "--yes" "3"))
        ;; default-target-link-override must remain nil
        (should-not supervisor--default-target-link-override)
        ;; get-default must still return original
        (let ((result (supervisor--cli-dispatch '("get-default"))))
          (should (string-match "graphical\\.target"
                                (supervisor-cli-result-output result))))))))

(ert-deftest supervisor-test-cli-telinit-parity ()
  "The `telinit' command behaves identically to `init'."
  ;; Error paths: telinit without args
  (let ((result (supervisor--cli-dispatch '("telinit"))))
    (should (= supervisor-cli-exit-invalid-args
                (supervisor-cli-result-exitcode result))))
  ;; Error paths: telinit out of range
  (let ((result (supervisor--cli-dispatch '("telinit" "9"))))
    (should (= supervisor-cli-exit-invalid-args
                (supervisor-cli-result-exitcode result))))
  ;; Error paths: telinit destructive without --yes
  (let ((result (supervisor--cli-dispatch '("telinit" "0"))))
    (should (= supervisor-cli-exit-invalid-args
                (supervisor-cli-result-exitcode result)))
    (should (string-match "destructive"
                          (supervisor-cli-result-output result)))))

(ert-deftest supervisor-test-cli-telinit-success-parity ()
  "Successful telinit produces same exitcode and output as init."
  (supervisor-test-with-unit-files
      '((nil :id "basic.target" :type target)
        (nil :id "multi-user.target" :type target)
        (nil :id "graphical.target" :type target)
        (nil :id "rescue.target" :type target)
        (nil :id "shutdown.target" :type target)
        (nil :id "poweroff.target" :type target)
        (nil :id "reboot.target" :type target)
        (nil :id "default.target" :type target))
    (let ((supervisor--current-plan t)
          (supervisor--processes (make-hash-table :test 'equal))
          (supervisor--entry-state (make-hash-table :test 'equal))
          (supervisor--failed (make-hash-table :test 'equal))
          (supervisor--oneshot-completed (make-hash-table :test 'equal))
          (supervisor--remain-active (make-hash-table :test 'equal))
          (supervisor--manually-stopped (make-hash-table :test 'equal))
          (supervisor--manually-started (make-hash-table :test 'equal))
          (supervisor--mask-override (make-hash-table :test 'equal))
          (supervisor--invalid (make-hash-table :test 'equal))
          (supervisor--restart-times (make-hash-table :test 'equal))
          (supervisor--spawn-failure-reason (make-hash-table :test 'equal))
          (supervisor--target-convergence nil)
          (supervisor--target-convergence-reasons nil)
          (supervisor--target-members nil)
          (supervisor-default-target-link "graphical.target")
          (supervisor--default-target-link-override nil))
      (cl-letf (((symbol-function 'supervisor--dag-start-with-deps)
                 (lambda (_entries callback) (funcall callback)))
                ((symbol-function 'supervisor--manual-stop)
                 (lambda (_id) (list :status 'stopped :reason nil))))
        ;; Test representative runlevels: non-destructive and destructive
        (dolist (spec '(("1" "rescue\\.target" "runlevel 1")
                        ("3" "multi-user\\.target" "runlevel 3")
                        ("5" "graphical\\.target" "runlevel 5")
                        ("0" "poweroff\\.target" "runlevel 0")
                        ("6" "reboot\\.target" "runlevel 6")))
          (let* ((rl (car spec))
                 (target-pattern (nth 1 spec))
                 (rl-pattern (nth 2 spec))
                 (init-result (supervisor--cli-dispatch
                               (list "init" "--yes" rl)))
                 (telinit-result (supervisor--cli-dispatch
                                  (list "telinit" "--yes" rl))))
            ;; Same exitcode
            (should (= (supervisor-cli-result-exitcode init-result)
                        (supervisor-cli-result-exitcode telinit-result)))
            ;; Both succeed
            (should (= supervisor-cli-exit-success
                        (supervisor-cli-result-exitcode telinit-result)))
            ;; Both mention resolved target
            (should (string-match target-pattern
                                  (supervisor-cli-result-output init-result)))
            (should (string-match target-pattern
                                  (supervisor-cli-result-output telinit-result)))
            ;; Both include runlevel identity
            (should (string-match rl-pattern
                                  (supervisor-cli-result-output init-result)))
            (should (string-match rl-pattern
                                  (supervisor-cli-result-output telinit-result)))))))))

(ert-deftest supervisor-test-cli-list-targets-shows-kind ()
  "The `list-targets' output includes kind column (alias/canonical)."
  (supervisor-test-with-unit-files
      '(("sleep 1" :id "svc-a" :wanted-by ("multi-user.target"))
        (nil :id "basic.target" :type target)
        (nil :id "multi-user.target" :type target
             :after ("basic.target"))
        (nil :id "default.target" :type target))
    (let ((supervisor--current-plan t)
          (supervisor--target-convergence nil)
          (supervisor--target-convergence-reasons nil)
          (supervisor-default-target-link "multi-user.target")
          (supervisor--default-target-link-override nil))
      (let ((result (supervisor--cli-dispatch '("list-targets"))))
        (should (= supervisor-cli-exit-success
                    (supervisor-cli-result-exitcode result)))
        (let ((output (supervisor-cli-result-output result)))
          (should (string-match "KIND" output))
          (should (string-match "canonical" output)))))))

(ert-deftest supervisor-test-cli-list-targets-alias-shows-resolved ()
  "Alias targets in list-targets show resolved canonical target."
  (supervisor-test-with-unit-files
      '((nil :id "basic.target" :type target)
        (nil :id "multi-user.target" :type target)
        (nil :id "graphical.target" :type target)
        (nil :id "default.target" :type target)
        (nil :id "runlevel5.target" :type target))
    (let ((supervisor--current-plan t)
          (supervisor--target-convergence nil)
          (supervisor--target-convergence-reasons nil)
          (supervisor-default-target-link "graphical.target")
          (supervisor--default-target-link-override nil))
      (let ((result (supervisor--cli-dispatch '("list-targets"))))
        (should (= supervisor-cli-exit-success
                    (supervisor-cli-result-exitcode result)))
        (let ((output (supervisor-cli-result-output result)))
          (should (string-match "alias" output))
          (should (string-match "runlevel5\\.target" output))
          (should (string-match "graphical\\.target" output)))))))

(ert-deftest supervisor-test-cli-target-status-alias-shows-kind ()
  "Target-status for an alias target shows kind and resolved link."
  (supervisor-test-with-unit-files
      '((nil :id "basic.target" :type target)
        (nil :id "multi-user.target" :type target)
        (nil :id "runlevel3.target" :type target)
        (nil :id "default.target" :type target))
    (let ((supervisor--current-plan t)
          (supervisor--processes (make-hash-table :test 'equal))
          (supervisor--entry-state (make-hash-table :test 'equal))
          (supervisor--failed (make-hash-table :test 'equal))
          (supervisor--oneshot-completed (make-hash-table :test 'equal))
          (supervisor--remain-active (make-hash-table :test 'equal))
          (supervisor--manually-stopped (make-hash-table :test 'equal))
          (supervisor--mask-override (make-hash-table :test 'equal))
          (supervisor--target-convergence nil)
          (supervisor--target-convergence-reasons nil)
          (supervisor-default-target-link "multi-user.target")
          (supervisor--default-target-link-override nil))
      (let ((result (supervisor--cli-dispatch
                     '("target-status" "runlevel3.target"))))
        (should (= supervisor-cli-exit-success
                    (supervisor-cli-result-exitcode result)))
        (let ((output (supervisor-cli-result-output result)))
          (should (string-match "alias" output))
          (should (string-match "multi-user\\.target" output)))))))

(ert-deftest supervisor-test-cli-set-default-resolves-alias ()
  "The `set-default' with alias target persists canonical target."
  (supervisor-test-with-unit-files
      '((nil :id "basic.target" :type target)
        (nil :id "multi-user.target" :type target)
        (nil :id "graphical.target" :type target)
        (nil :id "runlevel5.target" :type target)
        (nil :id "default.target" :type target))
    (let ((supervisor--default-target-link-override nil)
          (supervisor-overrides-file nil)
          (supervisor-default-target-link "multi-user.target"))
      (let ((result (supervisor--cli-dispatch
                     '("set-default" "runlevel5.target"))))
        (should (= supervisor-cli-exit-success
                    (supervisor-cli-result-exitcode result)))
        ;; Must persist the canonical target, not the alias
        (should (equal "graphical.target"
                       supervisor--default-target-link-override))
        ;; Output should mention both
        (should (string-match "graphical\\.target"
                              (supervisor-cli-result-output result)))))))

(ert-deftest supervisor-test-cli-isolate-accepts-alias ()
  "Isolate accepts alias targets and resolves to canonical."
  (supervisor-test-with-unit-files
      '(("sleep 300" :id "svc-a" :required-by ("multi-user.target"))
        (nil :id "basic.target" :type target)
        (nil :id "multi-user.target" :type target)
        (nil :id "runlevel3.target" :type target)
        (nil :id "default.target" :type target))
    (let ((supervisor--current-plan t)
          (supervisor--processes (make-hash-table :test 'equal))
          (supervisor--entry-state (make-hash-table :test 'equal))
          (supervisor--failed (make-hash-table :test 'equal))
          (supervisor--oneshot-completed (make-hash-table :test 'equal))
          (supervisor--remain-active (make-hash-table :test 'equal))
          (supervisor--manually-stopped (make-hash-table :test 'equal))
          (supervisor--manually-started (make-hash-table :test 'equal))
          (supervisor--mask-override (make-hash-table :test 'equal))
          (supervisor--invalid (make-hash-table :test 'equal))
          (supervisor--restart-times (make-hash-table :test 'equal))
          (supervisor--spawn-failure-reason (make-hash-table :test 'equal))
          (supervisor--target-convergence nil)
          (supervisor--target-convergence-reasons nil)
          (supervisor--target-members nil)
          (supervisor-default-target-link "multi-user.target")
          (supervisor--default-target-link-override nil))
      (cl-letf (((symbol-function 'supervisor--dag-start-with-deps)
                 (lambda (_entries callback) (funcall callback)))
                ((symbol-function 'supervisor--manual-stop)
                 (lambda (_id) (list :status 'stopped :reason nil))))
        (let ((result (supervisor--cli-dispatch
                       '("isolate" "--yes" "runlevel3.target"))))
          (should (= supervisor-cli-exit-success
                      (supervisor-cli-result-exitcode result)))
          ;; Output should reference the canonical target
          (should (string-match "multi-user\\.target"
                                (supervisor-cli-result-output result))))))))

(ert-deftest supervisor-test-timer-rejects-init-transition-target ()
  "Timer validation rejects init-transition targets."
  (supervisor-test-with-unit-files
      '((nil :id "rescue.target" :type target)
        (nil :id "shutdown.target" :type target)
        (nil :id "poweroff.target" :type target)
        (nil :id "reboot.target" :type target)
        (nil :id "runlevel0.target" :type target)
        (nil :id "default.target" :type target))
    (let* ((plan (supervisor--build-plan (supervisor--effective-programs))))
      (dolist (tid '("rescue.target" "shutdown.target"
                     "poweroff.target" "reboot.target"
                     "runlevel0.target"))
        (let ((reason (supervisor-timer--validate
                       `(:id ,(format "timer-%s" tid)
                             :target ,tid
                             :on-calendar (:hour 3))
                       plan)))
          (should reason)
          (should (string-match "init-transition" reason)))))))

(ert-deftest supervisor-test-timer-allows-non-init-targets ()
  "Timer validation allows non-init-transition targets."
  (supervisor-test-with-unit-files
      '(("sleep 1" :id "svc-a" :type oneshot)
        ("sleep 1" :id "svc-b" :type simple)
        (nil :id "app.target" :type target)
        (nil :id "default.target" :type target))
    (let* ((plan (supervisor--build-plan (supervisor--effective-programs))))
      (dolist (tid '("svc-a" "svc-b" "app.target"))
        (let ((reason (supervisor-timer--validate
                       `(:id ,(format "timer-%s" tid)
                             :target ,tid
                             :on-calendar (:hour 3))
                       plan)))
          (should-not reason))))))

(ert-deftest supervisor-test-cli-list-timers-init-transition-human ()
  "The `list-timers' human output carries init-transition reason text."
  (supervisor-test-with-unit-files
      '((nil :id "poweroff.target" :type target))
    (let ((supervisor-timer-subsystem-mode t)
          (supervisor-mode t)
          (supervisor-timers '((:id "timer-poweroff"
                               :target "poweroff.target"
                               :on-startup-sec 60)))
          (supervisor--timer-list nil)
          (supervisor--timer-state (make-hash-table :test 'equal))
          (supervisor--invalid-timers (make-hash-table :test 'equal)))
      (let ((result (supervisor--cli-dispatch '("list-timers"))))
        (should (supervisor-cli-result-p result))
        (should (= supervisor-cli-exit-success
                    (supervisor-cli-result-exitcode result)))
        (let ((output (supervisor-cli-result-output result)))
          (should (string-match-p "timer-poweroff" output))
          (should (string-match-p "init-transition" output))
          (should (string-match-p "not timer-eligible" output)))))))

(ert-deftest supervisor-test-cli-list-timers-init-transition-json ()
  "The `list-timers --json' output carries init-transition reason text."
  (supervisor-test-with-unit-files
      '((nil :id "poweroff.target" :type target))
    (let ((supervisor-timer-subsystem-mode t)
          (supervisor-mode t)
          (supervisor-timers '((:id "timer-poweroff"
                               :target "poweroff.target"
                               :on-startup-sec 60)))
          (supervisor--timer-list nil)
          (supervisor--timer-state (make-hash-table :test 'equal))
          (supervisor--invalid-timers (make-hash-table :test 'equal)))
      (let ((result (supervisor--cli-dispatch '("--json" "list-timers"))))
        (should (supervisor-cli-result-p result))
        (should (= supervisor-cli-exit-success
                    (supervisor-cli-result-exitcode result)))
        (let* ((json-object-type 'alist)
               (json-array-type 'list)
               (data (json-read-from-string
                      (supervisor-cli-result-output result)))
               (invalid (alist-get 'invalid data))
               (entry (car invalid)))
          (should invalid)
          (should (equal "timer-poweroff" (alist-get 'id entry)))
          (should (string-match-p "init-transition"
                                  (alist-get 'reason entry)))
          (should (string-match-p "not timer-eligible"
                                  (alist-get 'reason entry))))))))

(ert-deftest supervisor-test-dashboard-timer-init-transition-reason ()
  "Dashboard timer section carries init-transition reason text."
  (supervisor-test-with-unit-files
      '(("sleep 60" :id "svc" :type simple))
    (let* ((supervisor--processes (make-hash-table :test 'equal))
           (supervisor--entry-state (make-hash-table :test 'equal))
           (supervisor--invalid (make-hash-table :test 'equal))
           (supervisor--timer-state (make-hash-table :test 'equal))
           (supervisor--invalid-timers (make-hash-table :test 'equal))
           (supervisor-dashboard-show-timers t)
           (supervisor-timer-subsystem-mode t)
           (supervisor--timer-list nil)
           (reason ":target 'poweroff.target' is an init-transition target and is not timer-eligible"))
      (puthash "timer-poweroff" reason supervisor--invalid-timers)
      (let ((entries (supervisor--get-entries)))
        (let ((bad-row (cl-find (cons :timer "timer-poweroff") entries
                                :key #'car :test #'equal)))
          (should bad-row)
          ;; Reason is at index 6 in dashboard vector
          (should (string-match-p "init-transition"
                                  (aref (cadr bad-row) 6)))
          (should (string-match-p "not timer-eligible"
                                  (aref (cadr bad-row) 6))))))))

(ert-deftest supervisor-test-cli-explain-target-alias-shows-resolved ()
  "Explain-target for alias shows resolved canonical target."
  (supervisor-test-with-unit-files
      '((nil :id "basic.target" :type target)
        (nil :id "multi-user.target" :type target)
        (nil :id "runlevel3.target" :type target)
        (nil :id "default.target" :type target))
    (let ((supervisor--current-plan t)
          (supervisor--processes (make-hash-table :test 'equal))
          (supervisor--entry-state (make-hash-table :test 'equal))
          (supervisor--failed (make-hash-table :test 'equal))
          (supervisor--oneshot-completed (make-hash-table :test 'equal))
          (supervisor--remain-active (make-hash-table :test 'equal))
          (supervisor--manually-stopped (make-hash-table :test 'equal))
          (supervisor--mask-override (make-hash-table :test 'equal))
          (supervisor--target-convergence nil)
          (supervisor--target-convergence-reasons nil)
          (supervisor-default-target-link "multi-user.target")
          (supervisor--default-target-link-override nil))
      (let ((result (supervisor--cli-dispatch
                     '("explain-target" "runlevel3.target"))))
        (should (= supervisor-cli-exit-success
                    (supervisor-cli-result-exitcode result)))
        (let ((output (supervisor-cli-result-output result)))
          (should (string-match "alias" output))
          (should (string-match "multi-user\\.target" output)))))))

(ert-deftest supervisor-test-cli-list-targets-alias-shows-canonical-convergence ()
  "Alias target in list-targets shows convergence from canonical target."
  (supervisor-test-with-unit-files
      '(("sleep 1" :id "svc-a" :wanted-by ("multi-user.target"))
        (nil :id "basic.target" :type target)
        (nil :id "multi-user.target" :type target)
        (nil :id "runlevel3.target" :type target)
        (nil :id "default.target" :type target))
    (let ((supervisor--current-plan t)
          (supervisor--target-convergence (make-hash-table :test 'equal))
          (supervisor--target-convergence-reasons
           (make-hash-table :test 'equal))
          (supervisor-default-target-link "multi-user.target")
          (supervisor--default-target-link-override nil))
      (puthash "multi-user.target" 'reached supervisor--target-convergence)
      (let ((result (supervisor--cli-dispatch '("list-targets"))))
        (should (= supervisor-cli-exit-success
                    (supervisor-cli-result-exitcode result)))
        (let ((output (supervisor-cli-result-output result)))
          ;; runlevel3.target row should show reached, not pending
          (should (string-match "runlevel3\\.target.*reached" output)))))))

(ert-deftest supervisor-test-cli-target-status-alias-shows-canonical-state ()
  "Target-status for alias shows convergence from canonical target."
  (supervisor-test-with-unit-files
      '(("sleep 1" :id "svc-a" :wanted-by ("multi-user.target"))
        (nil :id "basic.target" :type target)
        (nil :id "multi-user.target" :type target)
        (nil :id "runlevel3.target" :type target)
        (nil :id "default.target" :type target))
    (let ((supervisor--current-plan t)
          (supervisor--processes (make-hash-table :test 'equal))
          (supervisor--entry-state (make-hash-table :test 'equal))
          (supervisor--failed (make-hash-table :test 'equal))
          (supervisor--oneshot-completed (make-hash-table :test 'equal))
          (supervisor--remain-active (make-hash-table :test 'equal))
          (supervisor--manually-stopped (make-hash-table :test 'equal))
          (supervisor--mask-override (make-hash-table :test 'equal))
          (supervisor--target-convergence (make-hash-table :test 'equal))
          (supervisor--target-convergence-reasons
           (make-hash-table :test 'equal))
          (supervisor-default-target-link "multi-user.target")
          (supervisor--default-target-link-override nil))
      (puthash "multi-user.target" 'reached supervisor--target-convergence)
      (let ((result (supervisor--cli-dispatch
                     '("target-status" "runlevel3.target"))))
        (should (= supervisor-cli-exit-success
                    (supervisor-cli-result-exitcode result)))
        (let ((output (supervisor-cli-result-output result)))
          (should (string-match "reached" output))
          ;; Should list members from canonical target
          (should (string-match "svc-a" output)))))))

(ert-deftest supervisor-test-cli-explain-target-alias-shows-canonical-state ()
  "Explain-target for alias shows convergence from canonical target."
  (supervisor-test-with-unit-files
      '(("sleep 1" :id "svc-a" :required-by ("multi-user.target"))
        (nil :id "basic.target" :type target)
        (nil :id "multi-user.target" :type target)
        (nil :id "runlevel3.target" :type target)
        (nil :id "default.target" :type target))
    (let ((supervisor--current-plan t)
          (supervisor--processes (make-hash-table :test 'equal))
          (supervisor--entry-state (make-hash-table :test 'equal))
          (supervisor--failed (make-hash-table :test 'equal))
          (supervisor--oneshot-completed (make-hash-table :test 'equal))
          (supervisor--remain-active (make-hash-table :test 'equal))
          (supervisor--manually-stopped (make-hash-table :test 'equal))
          (supervisor--mask-override (make-hash-table :test 'equal))
          (supervisor--target-convergence (make-hash-table :test 'equal))
          (supervisor--target-convergence-reasons
           (make-hash-table :test 'equal))
          (supervisor-default-target-link "multi-user.target")
          (supervisor--default-target-link-override nil))
      (puthash "multi-user.target" 'reached supervisor--target-convergence)
      (let ((result (supervisor--cli-dispatch
                     '("explain-target" "runlevel3.target"))))
        (should (= supervisor-cli-exit-success
                    (supervisor-cli-result-exitcode result)))
        (let ((output (supervisor-cli-result-output result)))
          (should (string-match "reached" output))
          (should (string-match "healthy" output)))))))

(ert-deftest supervisor-test-cli-explain-target-json-resolved-link-key ()
  "Explain-target JSON for alias uses `resolved-link' key, not `resolved'."
  (supervisor-test-with-unit-files
      '((nil :id "basic.target" :type target)
        (nil :id "multi-user.target" :type target)
        (nil :id "runlevel3.target" :type target)
        (nil :id "default.target" :type target))
    (let ((supervisor--current-plan t)
          (supervisor--processes (make-hash-table :test 'equal))
          (supervisor--entry-state (make-hash-table :test 'equal))
          (supervisor--failed (make-hash-table :test 'equal))
          (supervisor--oneshot-completed (make-hash-table :test 'equal))
          (supervisor--remain-active (make-hash-table :test 'equal))
          (supervisor--manually-stopped (make-hash-table :test 'equal))
          (supervisor--mask-override (make-hash-table :test 'equal))
          (supervisor--target-convergence nil)
          (supervisor--target-convergence-reasons nil)
          (supervisor-default-target-link "multi-user.target")
          (supervisor--default-target-link-override nil))
      (let ((result (supervisor--cli-dispatch
                     '("--json" "explain-target" "runlevel3.target"))))
        (should (= supervisor-cli-exit-success
                    (supervisor-cli-result-exitcode result)))
        (let ((json (json-read-from-string
                     (supervisor-cli-result-output result))))
          (should (alist-get 'resolved-link json))
          (should-not (alist-get 'resolved json)))))))

(ert-deftest supervisor-test-dashboard-alias-target-shows-canonical-convergence ()
  "Dashboard entry for alias target shows convergence from canonical."
  (let* ((conv-hash (make-hash-table :test 'equal))
         (supervisor--target-convergence conv-hash)
         (supervisor--target-convergence-reasons
          (make-hash-table :test 'equal))
         (snapshot (supervisor-snapshot--create
                    :process-alive (make-hash-table :test 'equal)
                    :process-pids (make-hash-table :test 'equal)
                    :failed (make-hash-table :test 'equal)
                    :oneshot-exit (make-hash-table :test 'equal)
                    :entry-state (make-hash-table :test 'equal)
                    :invalid (make-hash-table :test 'equal)
                    :enabled-override (make-hash-table :test 'equal)
                    :restart-override (make-hash-table :test 'equal)
                    :logging-override (make-hash-table :test 'equal)
                    :mask-override (make-hash-table :test 'equal)
                    :manually-started (make-hash-table :test 'equal)
                    :manually-stopped (make-hash-table :test 'equal)
                    :remain-active (make-hash-table :test 'equal)
                    :timestamp (float-time))))
    ;; Convergence stored under canonical ID
    (puthash "multi-user.target" 'reached conv-hash)
    ;; Query via alias ID
    (let ((vec (supervisor--make-dashboard-entry
                "runlevel3.target" 'target nil t nil nil snapshot)))
      ;; TARGET column (index 2) should show reached
      (should (equal "reached"
                     (substring-no-properties (aref vec 2)))))))

(ert-deftest supervisor-test-dashboard-detail-alias-shows-canonical-convergence ()
  "Detail panel for alias target shows convergence from canonical."
  (let* ((supervisor--target-convergence (make-hash-table :test 'equal))
         (supervisor--target-convergence-reasons
          (make-hash-table :test 'equal))
         (supervisor--target-members (make-hash-table :test 'equal))
         (supervisor--processes (make-hash-table :test 'equal))
         (supervisor--failed (make-hash-table :test 'equal))
         (supervisor--oneshot-completed (make-hash-table :test 'equal))
         (supervisor--entry-state (make-hash-table :test 'equal))
         (supervisor--enabled-override (make-hash-table :test 'equal))
         (supervisor--restart-override (make-hash-table :test 'equal))
         (supervisor--logging (make-hash-table :test 'equal))
         (supervisor--mask-override (make-hash-table :test 'equal))
         (supervisor--remain-active (make-hash-table :test 'equal))
         (supervisor--manually-stopped (make-hash-table :test 'equal))
         (supervisor--start-times (make-hash-table :test 'equal))
         (supervisor--ready-times (make-hash-table :test 'equal))
         (supervisor--restart-times (make-hash-table :test 'equal))
         (supervisor--restart-timers (make-hash-table :test 'equal))
         (supervisor--logging-override (make-hash-table :test 'equal))
         (supervisor--last-exit-info (make-hash-table :test 'equal))
         (supervisor--spawn-failure-reason (make-hash-table :test 'equal))
         ;; 39-element target entry for runlevel3.target (alias)
         (entry (list "runlevel3.target" nil 0 t nil nil nil nil
                      'target nil nil nil nil nil nil
                      nil nil nil nil nil nil
                      nil nil nil nil nil nil nil nil nil nil
                      nil nil
                      nil nil nil nil nil nil)))
    ;; Store convergence under canonical ID
    (puthash "multi-user.target" 'reached supervisor--target-convergence)
    (puthash "multi-user.target" '("all healthy")
             supervisor--target-convergence-reasons)
    (puthash "multi-user.target" '(:requires ("svc-a") :wants ("svc-b"))
             supervisor--target-members)
    (cl-letf (((symbol-function 'supervisor--unit-file-path)
               (lambda (_id) nil))
              ((symbol-function 'supervisor--telemetry-log-tail)
               (lambda (_id &optional _lines) nil)))
      (supervisor--describe-entry-detail "runlevel3.target" entry)
      (let ((info-buf (get-buffer "*supervisor-info*")))
        (unwind-protect
            (progn
              (should info-buf)
              (let ((output (with-current-buffer info-buf
                              (buffer-string))))
                (should (string-match-p "Converge: reached" output))
                (should (string-match-p "Req-mem: svc-a" output))
                (should (string-match-p "Want-mem: svc-b" output))))
          (when info-buf (kill-buffer info-buf)))))))

;;; Regression Tests: Convergence, Status, and Target Guards

(ert-deftest supervisor-test-convergence-survives-dag-cleanup ()
  "Target convergence state persists after DAG cleanup."
  (let ((supervisor--target-convergence (make-hash-table :test 'equal))
        (supervisor--target-convergence-reasons (make-hash-table :test 'equal))
        (supervisor--target-converging nil)
        (supervisor--target-member-reverse nil)
        (supervisor--target-members (make-hash-table :test 'equal))
        (supervisor--dag-in-degree nil)
        (supervisor--dag-dependents nil)
        (supervisor--dag-entries nil)
        (supervisor--dag-blocking nil)
        (supervisor--dag-started nil)
        (supervisor--dag-ready nil)
        (supervisor--dag-timeout-timers nil)
        (supervisor--dag-delay-timers nil)
        (supervisor--dag-id-to-index nil)
        (supervisor--dag-complete-callback nil)
        (supervisor--dag-timeout-timer nil)
        (supervisor--dag-pending-starts nil)
        (supervisor--dag-active-starts 0))
    (puthash "basic.target" 'reached supervisor--target-convergence)
    (puthash "multi.target" 'degraded supervisor--target-convergence)
    (puthash "multi.target" '("svc: failed") supervisor--target-convergence-reasons)
    (supervisor--dag-cleanup)
    ;; Convergence state must survive
    (should (eq 'reached (gethash "basic.target" supervisor--target-convergence)))
    (should (eq 'degraded (gethash "multi.target" supervisor--target-convergence)))
    (should (equal '("svc: failed")
                   (gethash "multi.target" supervisor--target-convergence-reasons)))
    ;; DAG temporaries must be cleared
    (should (null supervisor--target-converging))
    (should (null supervisor--target-member-reverse))))

(ert-deftest supervisor-test-disabled-oneshot-status ()
  "Disabled oneshot entries show status=disabled, not pending."
  (let ((supervisor--processes (make-hash-table :test 'equal))
        (supervisor--failed (make-hash-table :test 'equal))
        (supervisor--oneshot-completed (make-hash-table :test 'equal))
        (supervisor--remain-active (make-hash-table :test 'equal))
        (supervisor--manually-stopped (make-hash-table :test 'equal))
        (supervisor--mask-override (make-hash-table :test 'equal))
        (supervisor--entry-state (make-hash-table :test 'equal))
        (supervisor--target-convergence nil)
        (supervisor--current-plan nil))
    (puthash "setup-x" 'disabled supervisor--entry-state)
    (let ((result (supervisor--compute-entry-status "setup-x" 'oneshot)))
      (should (equal "disabled" (car result))))))

(ert-deftest supervisor-test-disabled-simple-status ()
  "Disabled simple entries show status=disabled, not stopped."
  (let ((supervisor--processes (make-hash-table :test 'equal))
        (supervisor--failed (make-hash-table :test 'equal))
        (supervisor--oneshot-completed (make-hash-table :test 'equal))
        (supervisor--remain-active (make-hash-table :test 'equal))
        (supervisor--manually-stopped (make-hash-table :test 'equal))
        (supervisor--mask-override (make-hash-table :test 'equal))
        (supervisor--entry-state (make-hash-table :test 'equal))
        (supervisor--target-convergence nil)
        (supervisor--current-plan nil))
    (puthash "svc" 'disabled supervisor--entry-state)
    (let ((result (supervisor--compute-entry-status "svc" 'simple)))
      (should (equal "disabled" (car result))))))

(ert-deftest supervisor-test-default-target-alias-mirrors-link ()
  "Status of default.target mirrors its resolved link convergence."
  (let ((supervisor--processes (make-hash-table :test 'equal))
        (supervisor--failed (make-hash-table :test 'equal))
        (supervisor--oneshot-completed (make-hash-table :test 'equal))
        (supervisor--remain-active (make-hash-table :test 'equal))
        (supervisor--manually-stopped (make-hash-table :test 'equal))
        (supervisor--mask-override (make-hash-table :test 'equal))
        (supervisor--entry-state (make-hash-table :test 'equal))
        (supervisor--target-convergence (make-hash-table :test 'equal))
        (supervisor--current-plan nil)
        (supervisor-default-target-link "graphical.target")
        (supervisor--default-target-link-override nil))
    (puthash "graphical.target" 'reached supervisor--target-convergence)
    (let ((result (supervisor--compute-entry-status "default.target" 'target)))
      (should (equal "reached" (car result))))))

(ert-deftest supervisor-test-unreachable-status-outside-closure ()
  "Entries outside the activation closure show unreachable status."
  (let* ((supervisor--processes (make-hash-table :test 'equal))
         (supervisor--failed (make-hash-table :test 'equal))
         (supervisor--oneshot-completed (make-hash-table :test 'equal))
         (supervisor--remain-active (make-hash-table :test 'equal))
         (supervisor--manually-stopped (make-hash-table :test 'equal))
         (supervisor--mask-override (make-hash-table :test 'equal))
         (supervisor--entry-state (make-hash-table :test 'equal))
         (supervisor--target-convergence nil)
         (closure (make-hash-table :test 'equal))
         (supervisor--current-plan
          (supervisor-plan--create
           :entries nil :by-target nil
           :deps (make-hash-table :test 'equal)
           :requires-deps (make-hash-table :test 'equal)
           :dependents (make-hash-table :test 'equal)
           :invalid (make-hash-table :test 'equal)
           :cycle-fallback-ids (make-hash-table :test 'equal)
           :order-index (make-hash-table :test 'equal)
           :meta nil
           :activation-closure closure)))
    ;; "inside" is in the closure
    (puthash "inside" t closure)
    ;; "outside" is not in the closure
    (let ((result (supervisor--compute-entry-status "outside" 'simple)))
      (should (equal "unreachable" (car result))))
    ;; "inside" should show normal status (stopped since not running)
    (let ((result (supervisor--compute-entry-status "inside" 'simple)))
      (should (equal "stopped" (car result))))))

(ert-deftest supervisor-test-health-counts-disabled-not-pending ()
  "Health counts put disabled entries in :disabled, not :pending."
  (let ((supervisor--processes (make-hash-table :test 'equal))
        (supervisor--failed (make-hash-table :test 'equal))
        (supervisor--oneshot-completed (make-hash-table :test 'equal))
        (supervisor--remain-active (make-hash-table :test 'equal))
        (supervisor--mask-override (make-hash-table :test 'equal))
        (supervisor--invalid (make-hash-table :test 'equal))
        (supervisor--entry-state (make-hash-table :test 'equal)))
    (puthash "setup-a" 'disabled supervisor--entry-state)
    (let ((counts (supervisor--health-counts
                   nil
                   '(("true" :id "setup-a" :type oneshot)))))
      (should (= 0 (plist-get counts :pending)))
      (should (= 1 (plist-get counts :disabled))))))

(ert-deftest supervisor-test-health-counts-skips-targets ()
  "Health counts do not count target entries."
  (let ((supervisor--processes (make-hash-table :test 'equal))
        (supervisor--failed (make-hash-table :test 'equal))
        (supervisor--oneshot-completed (make-hash-table :test 'equal))
        (supervisor--remain-active (make-hash-table :test 'equal))
        (supervisor--mask-override (make-hash-table :test 'equal))
        (supervisor--invalid (make-hash-table :test 'equal))
        (supervisor--entry-state (make-hash-table :test 'equal)))
    (let ((counts (supervisor--health-counts
                   nil
                   '((nil :id "basic.target" :type target)
                     ("sleep 300" :id "svc" :type simple)))))
      ;; Only svc should be counted (as pending since not running)
      (should (= 1 (plist-get counts :pending)))
      (should (= 0 (plist-get counts :running))))))

(ert-deftest supervisor-test-manual-start-rejects-target ()
  "Manual start of a target returns error."
  (supervisor-test-with-unit-files
      '((nil :id "basic.target" :type target)
        (nil :id "default.target" :type target))
    (let ((supervisor-default-target-link "basic.target")
          (supervisor--default-target-link-override nil)
          (supervisor--invalid (make-hash-table :test 'equal))
          (supervisor--processes (make-hash-table :test 'equal))
          (supervisor--remain-active (make-hash-table :test 'equal)))
      (let ((result (supervisor--manual-start "basic.target")))
        (should (eq 'error (plist-get result :status)))
        (should (string-match "target" (plist-get result :reason)))))))

(ert-deftest supervisor-test-manual-stop-rejects-target ()
  "Manual stop of a target returns error."
  (supervisor-test-with-unit-files
      '((nil :id "basic.target" :type target)
        (nil :id "default.target" :type target))
    (let ((supervisor-default-target-link "basic.target")
          (supervisor--default-target-link-override nil)
          (supervisor--processes (make-hash-table :test 'equal))
          (supervisor--remain-active (make-hash-table :test 'equal)))
      (let ((result (supervisor--manual-stop "basic.target")))
        (should (eq 'error (plist-get result :status)))
        (should (string-match "target" (plist-get result :reason)))))))

(ert-deftest supervisor-test-policy-set-restart-rejects-target ()
  "Restart policy not applicable to target entries."
  (supervisor-test-with-unit-files
      '((nil :id "basic.target" :type target)
        (nil :id "default.target" :type target))
    (let ((supervisor-default-target-link "basic.target")
          (supervisor--default-target-link-override nil)
          (supervisor--invalid (make-hash-table :test 'equal))
          (supervisor--enabled-override (make-hash-table :test 'equal))
          (supervisor--restart-override (make-hash-table :test 'equal))
          (supervisor--logging (make-hash-table :test 'equal))
          (supervisor--mask-override (make-hash-table :test 'equal))
          (supervisor--overrides-loaded-p t))
      (let ((result (supervisor--policy-set-restart "basic.target" 'always)))
        (should (eq 'error (plist-get result :status)))
        (should (string-match "target" (plist-get result :message)))))))

(ert-deftest supervisor-test-policy-set-logging-rejects-target ()
  "Logging not applicable to target entries."
  (supervisor-test-with-unit-files
      '((nil :id "basic.target" :type target)
        (nil :id "default.target" :type target))
    (let ((supervisor-default-target-link "basic.target")
          (supervisor--default-target-link-override nil)
          (supervisor--invalid (make-hash-table :test 'equal))
          (supervisor--enabled-override (make-hash-table :test 'equal))
          (supervisor--restart-override (make-hash-table :test 'equal))
          (supervisor--logging (make-hash-table :test 'equal))
          (supervisor--mask-override (make-hash-table :test 'equal))
          (supervisor--overrides-loaded-p t))
      (let ((result (supervisor--policy-set-logging "basic.target" t)))
        (should (eq 'error (plist-get result :status)))
        (should (string-match "target" (plist-get result :message)))))))

(ert-deftest supervisor-test-cli-cat-rejects-target ()
  "CLI cat rejects target units."
  (supervisor-test-with-unit-files
      '((nil :id "basic.target" :type target)
        (nil :id "default.target" :type target))
    (let ((supervisor-default-target-link "basic.target")
          (supervisor--default-target-link-override nil))
      (let ((result (supervisor--cli-dispatch '("cat" "basic.target"))))
        (should (/= supervisor-cli-exit-success
                     (supervisor-cli-result-exitcode result)))
        (should (string-match "target"
                              (supervisor-cli-result-output result)))))))

(ert-deftest supervisor-test-cli-logs-rejects-target ()
  "CLI logs rejects target units."
  (supervisor-test-with-unit-files
      '((nil :id "basic.target" :type target)
        (nil :id "default.target" :type target))
    (let ((supervisor-default-target-link "basic.target")
          (supervisor--default-target-link-override nil))
      (let ((result (supervisor--cli-dispatch '("logs" "basic.target"))))
        (should (/= supervisor-cli-exit-success
                     (supervisor-cli-result-exitcode result)))
        (should (string-match "target"
                              (supervisor-cli-result-output result)))))))

;;;; Sandbox (bubblewrap) Integration Tests

(ert-deftest supervisor-test-sandbox-parse-profile ()
  "Parse entry extracts sandbox-profile as symbol."
  (let ((entry (supervisor--parse-entry
                '("sleep 300" :id "svc" :sandbox-profile strict))))
    (should (= (length entry) 39))
    (should (eq (supervisor-entry-sandbox-profile entry) 'strict))))

(ert-deftest supervisor-test-sandbox-parse-profile-string ()
  "Parse entry converts string sandbox-profile to symbol."
  (let ((entry (supervisor--parse-entry
                '("sleep 300" :id "svc" :sandbox-profile "service"))))
    (should (eq (supervisor-entry-sandbox-profile entry) 'service))))

(ert-deftest supervisor-test-sandbox-parse-network ()
  "Parse entry extracts sandbox-network as symbol."
  (let ((entry (supervisor--parse-entry
                '("sleep 300" :id "svc" :sandbox-network isolated))))
    (should (eq (supervisor-entry-sandbox-network entry) 'isolated))))

(ert-deftest supervisor-test-sandbox-parse-ro-bind ()
  "Parse entry extracts and deduplicates sandbox-ro-bind."
  (let ((entry (supervisor--parse-entry
                '("sleep 300" :id "svc"
                  :sandbox-ro-bind ("/opt" "/usr" "/opt")))))
    (should (equal (supervisor-entry-sandbox-ro-bind entry)
                   '("/opt" "/usr")))))

(ert-deftest supervisor-test-sandbox-parse-rw-bind ()
  "Parse entry extracts sandbox-rw-bind."
  (let ((entry (supervisor--parse-entry
                '("sleep 300" :id "svc"
                  :sandbox-rw-bind ("/var/lib/app")))))
    (should (equal (supervisor-entry-sandbox-rw-bind entry)
                   '("/var/lib/app")))))

(ert-deftest supervisor-test-sandbox-parse-tmpfs ()
  "Parse entry extracts sandbox-tmpfs."
  (let ((entry (supervisor--parse-entry
                '("sleep 300" :id "svc" :sandbox-tmpfs ("/tmp")))))
    (should (equal (supervisor-entry-sandbox-tmpfs entry)
                   '("/tmp")))))

(ert-deftest supervisor-test-sandbox-parse-raw-args ()
  "Parse entry extracts sandbox-raw-args."
  (let ((entry (supervisor--parse-entry
                '("sleep 300" :id "svc"
                  :sandbox-raw-args ("--cap-add" "CAP_NET_RAW")))))
    (should (equal (supervisor-entry-sandbox-raw-args entry)
                   '("--cap-add" "CAP_NET_RAW")))))

(ert-deftest supervisor-test-sandbox-parse-none-defaults ()
  "Parse entry defaults sandbox fields to nil."
  (let ((entry (supervisor--parse-entry '("sleep 300" :id "svc"))))
    (should-not (supervisor-entry-sandbox-profile entry))
    (should-not (supervisor-entry-sandbox-network entry))
    (should-not (supervisor-entry-sandbox-ro-bind entry))
    (should-not (supervisor-entry-sandbox-rw-bind entry))
    (should-not (supervisor-entry-sandbox-tmpfs entry))
    (should-not (supervisor-entry-sandbox-raw-args entry))))

(ert-deftest supervisor-test-sandbox-requesting-p-profile ()
  "Sandbox-requesting-p returns t when profile is not none."
  (let ((entry (supervisor--parse-entry
                '("sleep 300" :id "svc" :sandbox-profile strict))))
    (should (supervisor--sandbox-requesting-p entry))))

(ert-deftest supervisor-test-sandbox-requesting-p-none ()
  "Sandbox-requesting-p returns nil for profile none with no knobs."
  (let ((entry (supervisor--parse-entry
                '("sleep 300" :id "svc" :sandbox-profile none))))
    (should-not (supervisor--sandbox-requesting-p entry))))

(ert-deftest supervisor-test-sandbox-requesting-p-knob-only ()
  "Sandbox-requesting-p returns t when knobs set without profile."
  (let ((entry (supervisor--parse-entry
                '("sleep 300" :id "svc"
                  :sandbox-network isolated))))
    (should (supervisor--sandbox-requesting-p entry))))

(ert-deftest supervisor-test-sandbox-requesting-p-no-sandbox ()
  "Sandbox-requesting-p returns nil for non-sandbox entry."
  (let ((entry (supervisor--parse-entry '("sleep 300" :id "svc"))))
    (should-not (supervisor--sandbox-requesting-p entry))))

;; Validation tests

(ert-deftest supervisor-test-sandbox-validate-profile-valid ()
  "Valid sandbox profiles pass validation."
  (cl-letf (((symbol-function 'executable-find)
             (lambda (name) (when (equal name "bwrap") "/usr/bin/bwrap"))))
    (dolist (profile '(none strict service desktop))
      (should-not (supervisor--validate-entry
                   `("cmd" :id "svc" :sandbox-profile ,profile))))))

(ert-deftest supervisor-test-sandbox-validate-profile-invalid ()
  "Invalid sandbox profile is rejected."
  (let ((reason (supervisor--validate-entry
                 '("cmd" :id "svc" :sandbox-profile bogus))))
    (should (string-match-p ":sandbox-profile must be one of" reason))))

(ert-deftest supervisor-test-sandbox-validate-network-valid ()
  "Valid network modes pass validation."
  (cl-letf (((symbol-function 'executable-find)
             (lambda (name) (when (equal name "bwrap") "/usr/bin/bwrap"))))
    (dolist (mode '(shared isolated))
      (should-not (supervisor--validate-entry
                   `("cmd" :id "svc" :sandbox-network ,mode))))))

(ert-deftest supervisor-test-sandbox-validate-network-invalid ()
  "Invalid network mode is rejected."
  (let ((reason (supervisor--validate-entry
                 '("cmd" :id "svc" :sandbox-network bogus))))
    (should (string-match-p ":sandbox-network must be one of" reason))))

(ert-deftest supervisor-test-sandbox-validate-path-absolute ()
  "Relative paths in bind lists are rejected."
  (let ((reason (supervisor--validate-entry
                 '("cmd" :id "svc" :sandbox-ro-bind ("relative/path")))))
    (should (string-match-p "paths must be absolute" reason))))

(ert-deftest supervisor-test-sandbox-validate-path-empty ()
  "Empty paths in bind lists are rejected."
  (let ((reason (supervisor--validate-entry
                 '("cmd" :id "svc" :sandbox-rw-bind ("")))))
    (should (string-match-p "must not contain empty paths" reason))))

(ert-deftest supervisor-test-sandbox-validate-path-forbidden ()
  "Forbidden paths in bind lists are rejected."
  (let ((reason (supervisor--validate-entry
                 '("cmd" :id "svc" :sandbox-tmpfs ("/proc")))))
    (should (string-match-p "must not include forbidden path" reason))))

(ert-deftest supervisor-test-sandbox-validate-path-forbidden-dev ()
  "Forbidden /dev path in bind lists is rejected."
  (let ((reason (supervisor--validate-entry
                 '("cmd" :id "svc" :sandbox-ro-bind ("/dev")))))
    (should (string-match-p "must not include forbidden path" reason))))

(ert-deftest supervisor-test-sandbox-validate-path-forbidden-trailing-slash ()
  "Forbidden paths with trailing slash are rejected."
  (let ((reason (supervisor--validate-entry
                 '("cmd" :id "svc" :sandbox-tmpfs ("/proc/")))))
    (should (string-match-p "must not include forbidden path" reason))))

(ert-deftest supervisor-test-sandbox-validate-path-forbidden-dev-trailing-slash ()
  "Forbidden /dev/ path with trailing slash is rejected."
  (let ((reason (supervisor--validate-entry
                 '("cmd" :id "svc" :sandbox-ro-bind ("/dev/")))))
    (should (string-match-p "must not include forbidden path" reason))))

(ert-deftest supervisor-test-sandbox-validate-path-forbidden-proc-dot-segment ()
  "Forbidden /proc/. dot-segment alias is rejected."
  (let ((reason (supervisor--validate-entry
                 '("cmd" :id "svc" :sandbox-tmpfs ("/proc/.")))))
    (should (string-match-p "must not include forbidden path" reason))))

(ert-deftest supervisor-test-sandbox-validate-path-forbidden-dev-dot-segment ()
  "Forbidden /dev/. dot-segment alias is rejected."
  (let ((reason (supervisor--validate-entry
                 '("cmd" :id "svc" :sandbox-ro-bind ("/dev/.")))))
    (should (string-match-p "must not include forbidden path" reason))))

(ert-deftest supervisor-test-sandbox-validate-path-valid ()
  "Valid absolute paths pass validation."
  (cl-letf (((symbol-function 'executable-find)
             (lambda (name) (when (equal name "bwrap") "/usr/bin/bwrap"))))
    (should-not (supervisor--validate-entry
                 '("cmd" :id "svc" :sandbox-ro-bind ("/tmp"))))))

(ert-deftest supervisor-test-sandbox-validate-bind-source-nonexistent ()
  "Non-existent source path in ro-bind is rejected."
  (let ((reason (supervisor--validate-entry
                 '("cmd" :id "svc" :sandbox-ro-bind
                   ("/definitely/does/not/exist/supervisor-test")))))
    (should (string-match-p "source path does not exist" reason))))

(ert-deftest supervisor-test-sandbox-validate-rw-bind-source-nonexistent ()
  "Non-existent source path in rw-bind is rejected."
  (let ((reason (supervisor--validate-entry
                 '("cmd" :id "svc" :sandbox-rw-bind
                   ("/definitely/does/not/exist/supervisor-test")))))
    (should (string-match-p "source path does not exist" reason))))

(ert-deftest supervisor-test-sandbox-validate-tmpfs-no-existence-check ()
  "Tmpfs paths do not require source existence."
  (cl-letf (((symbol-function 'executable-find)
             (lambda (name) (when (equal name "bwrap") "/usr/bin/bwrap"))))
    (should-not (supervisor--validate-entry
                 '("cmd" :id "svc" :sandbox-tmpfs
                   ("/definitely/does/not/exist/supervisor-test"))))))

(ert-deftest supervisor-test-sandbox-validate-bind-source-string-nonexistent ()
  "Non-existent source path as string in ro-bind is rejected."
  (let ((reason (supervisor--validate-entry
                 '("cmd" :id "svc" :sandbox-ro-bind
                   "/definitely/does/not/exist/supervisor-test"))))
    (should (string-match-p "source path does not exist" reason))))

(ert-deftest supervisor-test-sandbox-validate-path-invalid-type ()
  "Non-string path list is rejected."
  (let ((reason (supervisor--validate-entry
                 '("cmd" :id "svc" :sandbox-rw-bind (42)))))
    (should (string-match-p "must be a string or list of absolute" reason))))

(ert-deftest supervisor-test-sandbox-validate-raw-args-gate-off ()
  "Raw args rejected when gate is off."
  (let ((supervisor-sandbox-allow-raw-bwrap nil))
    (let ((reason (supervisor--validate-entry
                   '("cmd" :id "svc"
                     :sandbox-raw-args ("--cap-add" "CAP_NET_RAW")))))
      (should (string-match-p "requires supervisor-sandbox-allow-raw-bwrap" reason)))))

(ert-deftest supervisor-test-sandbox-validate-raw-args-gate-on ()
  "Raw args accepted when gate is on."
  (let ((supervisor-sandbox-allow-raw-bwrap t))
    (cl-letf (((symbol-function 'executable-find)
               (lambda (name) (when (equal name "bwrap") "/usr/bin/bwrap"))))
      (should-not (supervisor--validate-entry
                   '("cmd" :id "svc"
                     :sandbox-raw-args ("--cap-add" "CAP_NET_RAW")))))))

(ert-deftest supervisor-test-sandbox-validate-raw-args-shape ()
  "Raw args must be list of strings."
  (let ((supervisor-sandbox-allow-raw-bwrap t))
    (let ((reason (supervisor--validate-entry
                   '("cmd" :id "svc" :sandbox-raw-args (42)))))
      (should (string-match-p "must be a list of strings" reason)))))

(ert-deftest supervisor-test-sandbox-validate-raw-args-share-net-conflicts-isolated ()
  "Raw --share-net conflicts with explicit :sandbox-network isolated."
  (let ((supervisor-sandbox-allow-raw-bwrap t))
    (let ((reason (supervisor--validate-entry
                   '("cmd" :id "svc"
                     :sandbox-profile strict
                     :sandbox-network isolated
                     :sandbox-raw-args ("--share-net")))))
      (should (string-match-p "\"--share-net\" conflicts with effective network isolated"
                              reason)))))

(ert-deftest supervisor-test-sandbox-validate-raw-args-unshare-net-conflicts-shared ()
  "Raw --unshare-net conflicts with explicit :sandbox-network shared."
  (let ((supervisor-sandbox-allow-raw-bwrap t))
    (let ((reason (supervisor--validate-entry
                   '("cmd" :id "svc"
                     :sandbox-profile service
                     :sandbox-network shared
                     :sandbox-raw-args ("--unshare-net")))))
      (should (string-match-p "\"--unshare-net\" conflicts with effective network shared"
                              reason)))))

(ert-deftest supervisor-test-sandbox-validate-raw-args-share-net-conflicts-strict-default ()
  "Raw --share-net conflicts with strict profile default (isolated)."
  (let ((supervisor-sandbox-allow-raw-bwrap t))
    (let ((reason (supervisor--validate-entry
                   '("cmd" :id "svc"
                     :sandbox-profile strict
                     :sandbox-raw-args ("--share-net")))))
      (should (string-match-p "\"--share-net\" conflicts with effective network isolated"
                              reason)))))

(ert-deftest supervisor-test-sandbox-validate-raw-args-unshare-net-conflicts-service-default ()
  "Raw --unshare-net conflicts with service profile default (shared)."
  (let ((supervisor-sandbox-allow-raw-bwrap t))
    (let ((reason (supervisor--validate-entry
                   '("cmd" :id "svc"
                     :sandbox-profile service
                     :sandbox-raw-args ("--unshare-net")))))
      (should (string-match-p "\"--unshare-net\" conflicts with effective network shared"
                              reason)))))

(ert-deftest supervisor-test-sandbox-validate-raw-args-unshare-all-conflicts ()
  "Raw --unshare-all conflicts with profile-managed namespace setup."
  (let ((supervisor-sandbox-allow-raw-bwrap t))
    (let ((reason (supervisor--validate-entry
                   '("cmd" :id "svc"
                     :sandbox-profile service
                     :sandbox-raw-args ("--unshare-all")))))
      (should (string-match-p "\"--unshare-all\" conflicts with profile-managed"
                              reason)))))

(ert-deftest supervisor-test-sandbox-validate-raw-args-die-with-parent-conflicts ()
  "Raw --die-with-parent conflicts with profile-managed setup."
  (let ((supervisor-sandbox-allow-raw-bwrap t))
    (let ((reason (supervisor--validate-entry
                   '("cmd" :id "svc"
                     :sandbox-profile strict
                     :sandbox-raw-args ("--die-with-parent")))))
      (should (string-match-p "\"--die-with-parent\" conflicts with profile-managed"
                              reason)))))

(ert-deftest supervisor-test-sandbox-validate-raw-args-proc-conflicts ()
  "Raw --proc conflicts with profile-managed mount setup."
  (let ((supervisor-sandbox-allow-raw-bwrap t))
    (let ((reason (supervisor--validate-entry
                   '("cmd" :id "svc"
                     :sandbox-profile service
                     :sandbox-raw-args ("--proc")))))
      (should (string-match-p "\"--proc\" conflicts with profile-managed"
                              reason)))))

(ert-deftest supervisor-test-sandbox-validate-raw-args-safe-arg-accepted ()
  "Non-conflicting raw args like --cap-add pass validation."
  (let ((supervisor-sandbox-allow-raw-bwrap t))
    (cl-letf (((symbol-function 'executable-find)
               (lambda (name) (when (equal name "bwrap") "/usr/bin/bwrap"))))
      (should-not (supervisor--validate-entry
                   '("cmd" :id "svc"
                     :sandbox-profile service
                     :sandbox-raw-args ("--cap-add" "CAP_NET_RAW")))))))

(ert-deftest supervisor-test-sandbox-validate-target-rejects ()
  "Sandbox keys are rejected for target type."
  (let ((reason (supervisor--validate-entry
                 '(nil :id "app.target" :type target
                       :sandbox-profile strict))))
    (should (string-match-p ":sandbox-profile is invalid for :type target"
                            reason))))

(ert-deftest supervisor-test-sandbox-validate-non-linux ()
  "Sandbox-requesting units on non-Linux are rejected."
  (cl-letf (((symbol-value 'system-type) 'darwin))
    (let ((reason (supervisor--validate-entry
                   '("cmd" :id "svc" :sandbox-profile strict))))
      (should (string-match-p "only supported on GNU/Linux" reason)))))

(ert-deftest supervisor-test-sandbox-validate-missing-bwrap ()
  "Sandbox-requesting units without bwrap are rejected."
  (cl-letf (((symbol-function 'executable-find)
             (lambda (name)
               (unless (equal name "bwrap")
                 (executable-find name)))))
    (let ((reason (supervisor--validate-entry
                   '("cmd" :id "svc" :sandbox-profile strict))))
      (should (string-match-p "bwrap.*not found" reason)))))

(ert-deftest supervisor-test-sandbox-validate-non-sandbox-ignores-bwrap ()
  "Non-sandbox units validate fine without bwrap."
  (cl-letf (((symbol-function 'executable-find)
             (lambda (name)
               (unless (equal name "bwrap")
                 (executable-find name)))))
    (should-not (supervisor--validate-entry '("cmd" :id "svc")))))

(ert-deftest supervisor-test-sandbox-mixed-plan-missing-bwrap ()
  "Mixed plan invalidates sandbox entry and keeps non-sandbox entry valid.
Build a plan with one sandbox-requesting and one non-sandbox entry while
bwrap is missing.  The sandbox entry must land in the invalid hash with
a bwrap-related reason, while the non-sandbox entry must be in the valid
entries list and eligible for DAG startup."
  (cl-letf (((symbol-function 'executable-find)
             (lambda (name)
               (unless (equal name "bwrap")
                 (executable-find name)))))
    (let* ((programs '(("sleep 300" :id "sandboxed-svc"
                         :sandbox-profile strict)
                       ("sleep 300" :id "plain-svc")))
           (warnings nil))
      ;; Capture warnings emitted by supervisor--log
      (cl-letf (((symbol-function 'message)
                 (lambda (fmt &rest args)
                   (push (apply #'format fmt args) warnings))))
        (let ((plan (supervisor--build-plan programs)))
          ;; Sandbox-requesting entry must be invalid
          (should (gethash "sandboxed-svc"
                           (supervisor-plan-invalid plan)))
          (should (string-match-p
                   "bwrap"
                   (gethash "sandboxed-svc"
                            (supervisor-plan-invalid plan))))
          ;; Non-sandbox entry must be valid
          (should (cl-find "plain-svc"
                           (supervisor-plan-entries plan)
                           :key #'supervisor-entry-id
                           :test #'equal))
          (should-not (gethash "plain-svc"
                               (supervisor-plan-invalid plan)))
          ;; Warning must have been emitted for the sandbox entry
          (should (cl-some (lambda (w)
                             (and (string-match-p "INVALID" w)
                                  (string-match-p "sandboxed-svc" w)))
                           warnings)))))))

(ert-deftest supervisor-test-sandbox-nil-bind-key-presence-requesting ()
  "Entry with :sandbox-ro-bind nil is sandbox-requesting at validation.
Per plan contract, key presence (not truthy value) triggers sandbox-request
detection in validation.  Validation uses plist-member and rejects when
bwrap is missing.  Runtime uses truthy checks on parsed tuples (where nil
and absent are indistinguishable) and correctly does not apply sandbox."
  (cl-letf (((symbol-function 'executable-find)
             (lambda (name)
               (unless (equal name "bwrap")
                 (executable-find name)))))
    ;; Validation detects key presence: sandbox-requesting, rejected for bwrap
    (let ((reason (supervisor--validate-entry
                   '("cmd" :id "svc" :sandbox-ro-bind nil))))
      (should (string-match-p "bwrap" reason)))
    ;; Runtime detection uses truthy checks on parsed tuple: not requesting
    ;; (harmless -- validation already gated entry acceptance)
    (let ((entry (supervisor--parse-entry
                  '("cmd" :id "svc" :sandbox-ro-bind nil))))
      (should-not (supervisor--sandbox-requesting-p entry)))))

;; Profile registry and command builder tests

(ert-deftest supervisor-test-sandbox-profile-none-no-argv ()
  "Profile none produces no argv."
  (should-not (supervisor--sandbox-profile-args 'none)))

(ert-deftest supervisor-test-sandbox-profile-strict-deterministic ()
  "Profile strict produces deterministic argv."
  (let ((args (supervisor--sandbox-profile-args 'strict)))
    (should (member "--unshare-all" args))
    (should (member "--die-with-parent" args))
    (should (member "--ro-bind" args))))

(ert-deftest supervisor-test-sandbox-profile-service-deterministic ()
  "Profile service produces deterministic argv."
  (let ((args (supervisor--sandbox-profile-args 'service)))
    (should (member "--die-with-parent" args))
    (should (member "--unshare-pid" args))
    (should (member "--unshare-ipc" args))
    (should (member "--ro-bind" args))
    ;; Service does NOT unshare-all (unlike strict)
    (should-not (member "--unshare-all" args))))

(ert-deftest supervisor-test-sandbox-profile-desktop-deterministic ()
  "Profile desktop produces deterministic argv."
  (let ((args (supervisor--sandbox-profile-args 'desktop)))
    (should (member "--die-with-parent" args))
    (should (member "--unshare-pid" args))
    (should (member "--ro-bind" args))
    ;; Desktop binds X11 socket for graphical access
    (should (member "/tmp/.X11-unix" args))
    ;; Desktop does NOT unshare-all (unlike strict)
    (should-not (member "--unshare-all" args))))

(ert-deftest supervisor-test-sandbox-profile-service-shared-network ()
  "Profile service defaults to shared network."
  (should (eq (supervisor--sandbox-profile-default-network 'service)
              'shared)))

(ert-deftest supervisor-test-sandbox-profile-desktop-shared-network ()
  "Profile desktop defaults to shared network."
  (should (eq (supervisor--sandbox-profile-default-network 'desktop)
              'shared)))

(ert-deftest supervisor-test-sandbox-profile-strict-isolated-network ()
  "Profile strict defaults to isolated network."
  (should (eq (supervisor--sandbox-profile-default-network 'strict)
              'isolated)))

(ert-deftest supervisor-test-sandbox-build-argv-none ()
  "Build-argv returns nil for non-sandbox entry."
  (let ((entry (supervisor--parse-entry '("sleep 300" :id "svc"))))
    (should-not (supervisor--sandbox-build-argv entry))))

(ert-deftest supervisor-test-sandbox-build-argv-strict ()
  "Build-argv returns bwrap wrapper for strict profile."
  (let ((entry (supervisor--parse-entry
                '("sleep 300" :id "svc" :sandbox-profile strict))))
    (cl-letf (((symbol-function 'executable-find)
               (lambda (_name) "/usr/bin/bwrap")))
      (let ((argv (supervisor--sandbox-build-argv entry)))
        (should argv)
        (should (equal (car argv) "/usr/bin/bwrap"))
        (should (member "--unshare-all" argv))
        (should (member "--unshare-net" argv))
        (should (equal (car (last argv)) "--"))))))

(ert-deftest supervisor-test-sandbox-build-argv-network-override ()
  "Build-argv respects network override for strict profile.
Strict uses --unshare-all which includes network isolation.
Override to shared must emit --share-net to restore networking."
  (let ((entry (supervisor--parse-entry
                '("sleep 300" :id "svc"
                  :sandbox-profile strict
                  :sandbox-network shared))))
    (cl-letf (((symbol-function 'executable-find)
               (lambda (_name) "/usr/bin/bwrap")))
      (let ((argv (supervisor--sandbox-build-argv entry)))
        ;; --share-net must be present to counter --unshare-all
        (should (member "--share-net" argv))
        ;; --unshare-net must NOT be added
        (should-not (member "--unshare-net" argv))))))

(ert-deftest supervisor-test-sandbox-build-argv-service-shared-no-share-net ()
  "Service profile with shared network does not emit --share-net.
Only profiles using --unshare-all need --share-net to restore networking."
  (let ((entry (supervisor--parse-entry
                '("sleep 300" :id "svc"
                  :sandbox-profile service
                  :sandbox-network shared))))
    (cl-letf (((symbol-function 'executable-find)
               (lambda (_name) "/usr/bin/bwrap")))
      (let ((argv (supervisor--sandbox-build-argv entry)))
        ;; service does not use --unshare-all, so no --share-net needed
        (should-not (member "--share-net" argv))
        (should-not (member "--unshare-net" argv))))))

(ert-deftest supervisor-test-sandbox-build-argv-desktop ()
  "Build-argv for desktop profile produces deterministic argv.
Desktop uses per-namespace unshare args, shared network by default,
and includes X11 and XDG runtime dir binds."
  (let ((entry (supervisor--parse-entry
                '("sleep 300" :id "svc"
                  :sandbox-profile desktop))))
    (cl-letf (((symbol-function 'executable-find)
               (lambda (_name) "/usr/bin/bwrap")))
      (let ((argv (supervisor--sandbox-build-argv entry)))
        (should (equal "/usr/bin/bwrap" (car argv)))
        (should (member "--unshare-pid" argv))
        (should (member "--unshare-ipc" argv))
        (should (member "--unshare-uts" argv))
        (should (member "--die-with-parent" argv))
        ;; Desktop has shared network by default -- no unshare-net
        (should-not (member "--unshare-net" argv))
        ;; X11 socket bind
        (should (member "/tmp/.X11-unix" argv))
        ;; Separator at end
        (should (equal "--" (car (last argv))))))))

(ert-deftest supervisor-test-sandbox-build-argv-ro-bind ()
  "Build-argv appends read-only bind mounts."
  (let ((entry (supervisor--parse-entry
                '("sleep 300" :id "svc"
                  :sandbox-profile service
                  :sandbox-ro-bind ("/opt/data")))))
    (cl-letf (((symbol-function 'executable-find)
               (lambda (_name) "/usr/bin/bwrap")))
      (let ((argv (supervisor--sandbox-build-argv entry)))
        ;; Find the custom ro-bind (profile already has ro-bind / /)
        (let ((pos (cl-position "/opt/data" argv :test #'equal)))
          (should pos)
          (should (equal (nth (1- pos) argv) "--ro-bind")))))))

(ert-deftest supervisor-test-sandbox-build-argv-rw-bind ()
  "Build-argv appends read-write bind mounts."
  (let ((entry (supervisor--parse-entry
                '("sleep 300" :id "svc"
                  :sandbox-profile service
                  :sandbox-rw-bind ("/var/lib/app")))))
    (cl-letf (((symbol-function 'executable-find)
               (lambda (_name) "/usr/bin/bwrap")))
      (let ((argv (supervisor--sandbox-build-argv entry)))
        (let ((pos (cl-position "/var/lib/app" argv :test #'equal)))
          (should pos)
          (should (equal (nth (1- pos) argv) "--bind")))))))

(ert-deftest supervisor-test-sandbox-build-argv-tmpfs ()
  "Build-argv appends tmpfs mounts."
  (let ((entry (supervisor--parse-entry
                '("sleep 300" :id "svc"
                  :sandbox-profile service
                  :sandbox-tmpfs ("/run/scratch")))))
    (cl-letf (((symbol-function 'executable-find)
               (lambda (_name) "/usr/bin/bwrap")))
      (let ((argv (supervisor--sandbox-build-argv entry)))
        (let ((pos (cl-position "/run/scratch" argv :test #'equal)))
          (should pos)
          (should (equal (nth (1- pos) argv) "--tmpfs")))))))

(ert-deftest supervisor-test-sandbox-build-argv-raw-args ()
  "Build-argv appends raw args."
  (let ((supervisor-sandbox-allow-raw-bwrap t))
    (let ((entry (supervisor--parse-entry
                  '("sleep 300" :id "svc"
                    :sandbox-profile service
                    :sandbox-raw-args ("--cap-add" "CAP_NET_RAW")))))
      (cl-letf (((symbol-function 'executable-find)
                 (lambda (_name) "/usr/bin/bwrap")))
        (let ((argv (supervisor--sandbox-build-argv entry)))
          (should (member "--cap-add" argv))
          (should (member "CAP_NET_RAW" argv)))))))

;; Launch command integration tests

(ert-deftest supervisor-test-sandbox-build-launch-no-sandbox ()
  "Build-launch-command without sandbox produces normal argv."
  (let ((args (supervisor--build-launch-command "sleep 300")))
    (should (equal args '("sleep" "300")))))

(ert-deftest supervisor-test-sandbox-build-launch-with-sandbox ()
  "Build-launch-command with sandbox prepends bwrap."
  (let ((entry (supervisor--parse-entry
                '("sleep 300" :id "svc" :sandbox-profile service))))
    (cl-letf (((symbol-function 'executable-find)
               (lambda (_name) "/usr/bin/bwrap")))
      (let ((args (supervisor--build-launch-command "sleep 300" nil nil
                                                    entry)))
        (should (equal (car args) "/usr/bin/bwrap"))
        ;; Should end with -- sleep 300
        (let ((sep-pos (cl-position "--" args :test #'equal :from-end t)))
          (should sep-pos)
          (should (equal (nth (+ sep-pos 1) args) "/usr/bin/bwrap")))))))

(ert-deftest supervisor-test-sandbox-build-launch-runas-then-bwrap ()
  "Build-launch-command with identity + sandbox uses correct order."
  (let ((entry (supervisor--parse-entry
                '("sleep 300" :id "svc" :sandbox-profile service))))
    (cl-letf (((symbol-function 'executable-find)
               (lambda (_name) "/usr/bin/bwrap")))
      (let ((args (supervisor--build-launch-command "sleep 300" "alice" nil
                                                    entry)))
        ;; First element should be runas helper
        (should (equal (car args) supervisor-runas-command))
        ;; Should contain --user alice
        (should (member "--user" args))
        (should (member "alice" args))
        ;; bwrap should appear after the first -- separator (runas --)
        (let* ((first-sep (cl-position "--" args :test #'equal))
               (after-sep (nth (1+ first-sep) args)))
          (should (equal after-sep "/usr/bin/bwrap")))))))

(ert-deftest supervisor-test-sandbox-build-launch-resolves-service-exe ()
  "Build-launch-command resolves service executable under runas + bwrap.
The service binary must be resolved to an absolute path via executable-find
even when both identity wrapper and sandbox wrapper are active."
  (let ((entry (supervisor--parse-entry
                '("sleep 300" :id "svc" :sandbox-profile service))))
    (cl-letf (((symbol-function 'executable-find)
               (lambda (name)
                 (cond ((equal name "bwrap") "/usr/bin/bwrap")
                       ((equal name "sleep") "/usr/bin/sleep")
                       (t nil)))))
      (let ((args (supervisor--build-launch-command "sleep 300" "alice" nil
                                                    entry)))
        ;; Runas is first
        (should (equal (car args) supervisor-runas-command))
        ;; bwrap appears after runas -- separator
        (let ((first-sep (cl-position "--" args :test #'equal)))
          (should first-sep)
          (should (equal (nth (1+ first-sep) args) "/usr/bin/bwrap")))
        ;; Service executable is resolved to absolute path after bwrap --
        (let ((last-sep (cl-position "--" args :test #'equal :from-end t)))
          (should last-sep)
          (should (equal (nth (1+ last-sep) args) "/usr/bin/sleep"))
          (should (equal (nth (+ last-sep 2) args) "300")))))))

;; Service struct roundtrip tests

(ert-deftest supervisor-test-sandbox-service-roundtrip ()
  "Service-to-entry conversion preserves sandbox fields."
  (let* ((svc (supervisor-service--create
               :id "svc" :command "cmd"
               :sandbox-profile 'strict
               :sandbox-network 'isolated
               :sandbox-ro-bind '("/opt")
               :sandbox-rw-bind '("/var")
               :sandbox-tmpfs '("/tmp/work")
               :sandbox-raw-args '("--cap-add" "CAP_NET_RAW")))
         (entry (supervisor-service-to-entry svc)))
    (should (= (length entry) 39))
    (should (eq (supervisor-entry-sandbox-profile entry) 'strict))
    (should (eq (supervisor-entry-sandbox-network entry) 'isolated))
    (should (equal (supervisor-entry-sandbox-ro-bind entry) '("/opt")))
    (should (equal (supervisor-entry-sandbox-rw-bind entry) '("/var")))
    (should (equal (supervisor-entry-sandbox-tmpfs entry) '("/tmp/work")))
    (should (equal (supervisor-entry-sandbox-raw-args entry)
                   '("--cap-add" "CAP_NET_RAW")))))

;; Non-regression test

(ert-deftest supervisor-test-sandbox-non-sandbox-unchanged ()
  "Non-sandbox entry launch behavior is unchanged."
  (let ((entry (supervisor--parse-entry '("sleep 300" :id "svc"))))
    (should-not (supervisor--sandbox-requesting-p entry))
    ;; Build-launch-command with nil sandbox-entry is identical to no sandbox
    (let ((with (supervisor--build-launch-command "sleep 300" nil nil entry))
          (without (supervisor--build-launch-command "sleep 300" nil nil nil)))
      (should (equal with without)))))

(provide 'supervisor-test)
;;; supervisor-test.el ends here
