[[https://github.com/cypherpunk2001/supervisor.el/actions/workflows/ci.yml][https://github.com/cypherpunk2001/supervisor.el/actions/workflows/ci.yml/badge.svg]]

* supervisor.el Handbook

*A real service supervisor for Emacs.*

~supervisor.el~ is an Emacs Lisp-based service supervisor.  It follows a
familiar systemd-like interface (service types, dependencies, restart
policies) adapted for Emacs.  ~M-x supervisor~ is the main interface:
start, stop, inspect, and manage everything from inside Emacs.

** Features (at a glance)

- *Dashboard*: ~M-x supervisor~ -- live view with lifecycle actions, policy
  changes, dependency inspection, and log viewing.
- *Target-based startup*: systemd-style targets with DAG ordering
  (~:after~, ~:before~), pull-in (~:requires~, ~:wants~), and membership
  (~:wanted-by~, ~:required-by~).
- *Service types*: long-running ~simple~ services and run-once ~oneshot~ tasks
  with configurable restart policies.
- *Persistent overrides*: enable/disable, mask/unmask, restart-policy, and
  logging overrides persist across restarts.
- *Authority-tier unit files*: shipped defaults overridden by higher-precedence
  user tiers, with daemon-reload support.
- *CLI*: ~sbin/supervisorctl~ for scripting and remote use (human and JSON).
- *Timers*: calendar and relative timers for oneshot, simple, and target units
  with persistent catch-up semantics.
- *Logging*: external log writers plus rotate/prune tooling for bounded growth.
- *Sandbox*: optional bubblewrap integration with curated profiles for process
  isolation (Linux only).

** Requirements

- Emacs 28.1 or later
- For CLI: ~emacsclient~, ~base64~, and ~sed~ in your ~PATH~
- For bundled ~libexec~ helpers: a C compiler in ~PATH~ (typically ~cc~,
  ~clang~, or ~gcc~)

** Handbook Overview

This document is the complete reference. Run ~M-x supervisor-handbook~ to open
it in Emacs at any time.

The [[#quick-start][Quick Start]] below gets you running immediately. The rest of the handbook
provides detailed reference material:

- [[#service-definition][Service Definition]] - all unit-file keywords for defining services
- [[#unit-files-modular-configuration][Unit Files]] - authority roots, precedence, and unit-file management
- [[#startup-and-lifecycle-model][Startup and Lifecycle Model]] - targets, dependencies, and restarts
- [[#runtime-overrides-and-reconciliation][Runtime Overrides]] - enabling, disabling, and policy changes at runtime
- [[#timer-subsystem-handbook][Timer Subsystem]] - scheduled unit execution (oneshot, simple, target)
- [[#dashboard-handbook-m-x-supervisor][Dashboard]] - the interactive UI
- [[#cli-handbook-sbinsupervisorctl][CLI]] - terminal control with ~supervisorctl~
- [[#events-and-hooks][Events and Hooks]] - programmatic integration
- [[#customization-reference][Customization Reference]] - all variables and faces
- [[#command-reference][Command Reference]] - every interactive command
- [[#service-management-systems-comparison][Systems Comparison]] - supervisor vs systemd vs runit vs s6

* Quick Start
:PROPERTIES:
:CUSTOM_ID: quick-start
:END:

#+begin_src emacs-lisp
(add-to-list 'load-path "~/repos/supervisor.el")
(require 'supervisor)

;; Use supervisor-stop-now for immediate SIGKILL - ensures clean X session exit
(add-hook 'kill-emacs-hook #'supervisor-stop-now)

;; Don't ask about running processes on exit - supervisor handles cleanup
(setq confirm-kill-processes nil)

;; Ensure timer subsystem is enabled (default is enabled)
(supervisor-timer-subsystem-mode 1)

;; Start supervisor and config watcher
(supervisor-mode 1)
#+end_src

Services are defined as individual unit files in your authority roots (default
=~/.config/supervisor.el/=).  For example:

#+begin_src emacs-lisp
;; ~/.config/supervisor.el/xhost.el
(:id "xhost"
 :command "xhost +SI:localuser:$USER"
 :type oneshot
 :required-by ("basic.target")
 :tags (x-setup))
#+end_src

#+begin_src emacs-lisp
;; ~/.config/supervisor.el/nm-applet.el
(:id "nm-applet"
 :command "nm-applet"
 :type simple
 :wanted-by ("graphical.target")
 :delay 3
 :restart t
 :tags (applet tray))
#+end_src

With the above configuration running, ~sbin/supervisorctl status~ shows:

#+begin_example
$ sbin/supervisorctl status
ID               TYPE     TARGET               ENABLED  STATUS     RESTART  LOG   PID     REASON
----------------------------------------------------------------------------------------------------
xhost            oneshot  graphical.target     yes      done       n/a      yes   -       -
nm-applet        simple   graphical.target     yes      running    always   yes   1396    -
#+end_example

~M-x supervisor~ opens an interactive dashboard for managing services:

#+CAPTION: Supervisor dashboard
[[file:doc/dashboard.png]]

Each service gets its own ~.el~ file in an authority root.  See
[[#unit-files-modular-configuration][Unit Files]] for the full authority-root model, precedence rules, and
all available keywords.

** Understanding the Dashboard View
:PROPERTIES:
:CUSTOM_ID: understanding-the-dashboard
:END:

When you first run ~M-x supervisor~, you will see a mix of target statuses that
might look surprising.  Some targets show *reached*, others show *unreachable*,
and you might wonder if something is broken.  It is not -- this is how the
target system works.

*** Why some targets are "reached"

At startup, supervisor picks a root target (by default ~graphical.target~) and
walks its dependency chain to figure out what needs to start.  The built-in
target hierarchy is:

#+begin_example
basic.target
  ^  (required by)
multi-user.target
  ^  (required by)
graphical.target   <-- startup root
#+end_example

All three are in the startup path, so they activate, their member services
start, and the targets converge to *reached*.  ~default.target~ also shows
reached because it resolves to ~graphical.target~ under the hood.

*** Why some targets are "unreachable"

Targets like ~rescue.target~, ~shutdown.target~, ~poweroff.target~, and
~reboot.target~ are *not* in ~graphical.target~'s dependency chain.  Nothing
pulls them in during a normal boot, so they sit outside the activation closure.

Supervisor shows these as *unreachable* -- meaning "not part of the current
startup transaction."  This is expected.  These targets only activate when you
explicitly request them with ~isolate~ or ~init~.

*** Why runlevel aliases follow their canonical target

Each ~runlevelN.target~ is an alias that resolves to a canonical target before
any status lookup:

| Alias | Resolves to | In normal boot? | Status |
|-------+-------------+-----------------+--------|
| ~runlevel2.target~ | ~multi-user.target~ | yes | reached |
| ~runlevel3.target~ | ~multi-user.target~ | yes | reached |
| ~runlevel4.target~ | ~multi-user.target~ | yes | reached |
| ~runlevel5.target~ | ~graphical.target~ | yes | reached |
| ~runlevel0.target~ | ~poweroff.target~ | no | unreachable |
| ~runlevel1.target~ | ~rescue.target~ | no | unreachable |
| ~runlevel6.target~ | ~reboot.target~ | no | unreachable |

Runlevels 2 through 5 show *reached* because their canonical targets
(~multi-user.target~ and ~graphical.target~) are in the startup path and
converged.  Runlevels 0, 1, and 6 show *unreachable* because their canonical
targets (~poweroff.target~, ~rescue.target~, ~reboot.target~) were never pulled
into the startup transaction.

*** Reading a default dashboard

Below is a representative view of what ~M-x supervisor~ shows after a default
graphical boot with two user services (~ssh-agent~ and ~emacs-server~) and the
timer subsystem enabled.

**** Services section

#+begin_example
── Services  TYPE     TARGET               ENABLED  STATUS      RESTART   LOG   PID     REASON
ssh-agent    simple   multi-user.target    yes      running     always    yes   84210
emacs-server simple   graphical.target     yes      running     always    yes   84215
logrotate    oneshot  -                    yes      unreachable n/a       yes   -       pending
log-prune    oneshot  -                    yes      unreachable n/a       yes   -       pending
basic.target          target               ...      reached     n/a       -     -
multi-user.target     target               ...      reached     n/a       -     -
graphical.target      target               ...      reached     n/a       -     -
default.target        target               ...      reached     n/a       -     -
rescue.target         target               ...      unreachable n/a       -     -
shutdown.target       target               ...      unreachable n/a       -     -
poweroff.target       target               ...      unreachable n/a       -     -
reboot.target         target               ...      unreachable n/a       -     -
runlevel0.target      target               ...      unreachable n/a       -     -
runlevel1.target      target               ...      unreachable n/a       -     -
runlevel2.target      target               ...      reached     n/a       -     -
runlevel3.target      target               ...      reached     n/a       -     -
runlevel4.target      target               ...      reached     n/a       -     -
runlevel5.target      target               ...      reached     n/a       -     -
runlevel6.target      target               ...      unreachable n/a       -     -
#+end_example

What each group means:

- *Your services* (~ssh-agent~, ~emacs-server~) -- running, owned by their
  respective targets.  These are the units you defined.
- *logrotate and log-prune* -- built-in maintenance oneshots.  They show
  *unreachable* because no target in the startup path pulls them in.  They are
  not broken -- they activate only when their timers fire (see below).  The
  ~pending~ reason means they have not run yet.
- *Startup targets* (~basic.target~ through ~default.target~) -- all *reached*
  because they are in ~graphical.target~'s dependency chain and all their
  members started successfully.
- *Transition targets* (~rescue.target~, ~shutdown.target~, ~poweroff.target~,
  ~reboot.target~) -- all *unreachable* because they are not part of the
  current startup transaction.  They activate only on ~init~ or ~isolate~.
- *Runlevel aliases* (~runlevel0.target~ through ~runlevel6.target~) -- each
  mirrors the status of its canonical target.  Runlevels 2 through 5 show
  reached; 0, 1, 6 show unreachable.

**** Timers section

#+begin_example
── Timers          TARGET      ENABLED  LAST-RUN  NEXT-RUN  EXIT  REASON  TYPE     RESULT
logrotate-daily    logrotate   yes      -         +23h      -     -       oneshot  -
log-prune-daily    log-prune   yes      -         +23h      -     -       oneshot  -
#+end_example

Timers trigger their target oneshot on a schedule.  In a fresh session:

- *LAST-RUN* is ~-~ because neither timer has fired yet.
- *NEXT-RUN* shows the time until the next trigger (e.g., ~+23h~).
- *EXIT*, *REASON*, and *RESULT* are all empty until the first run completes.

After the first trigger, these columns fill in with the exit code, completion
reason, and pass/fail result of the last oneshot run.

*** Quick reference for target statuses

| Status | Meaning |
|--------+---------|
| reached | Target's required members all started successfully. |
| degraded | Target converged, but one or more members failed. |
| converging | Target is still waiting for members to start. |
| pending | Target is in the startup path but has not begun converging yet. |
| unreachable | Target is not part of the current startup transaction. |
| masked | Target was explicitly masked by the operator. |

* Service Definition (Unit-File Keywords)
:PROPERTIES:
:CUSTOM_ID: service-definition
:END:

Each unit file is a single plist expression with ~:id~ required.
~:command~ is required for non-target units and invalid for ~:type target~.

** Entry Keywords

| Keyword | Type | Default | Notes |
| ~:id~ | string | *(required)* | Unit ID (non-empty string) |
| ~:command~ | string or ~nil~ | *(required for non-target types)* | Command to execute; must be omitted for ~:type target~ |
| ~:type~ | symbol | ~simple~ | ~simple~, ~oneshot~, or ~target~ |
| ~:delay~ | non-negative number | ~0~ | Delays spawn in seconds |
| ~:after~ | string or list of strings | ~nil~ | Ordering dependency |
| ~:requires~ | string or list of strings | ~nil~ | Requirement + ordering dependency |
| ~:enabled~ | boolean | ~t~ | Enable/disable service |
| ~:disabled~ | boolean | ~nil~ | Inverse form of ~:enabled~ |
| ~:restart~ | boolean or policy symbol | ~always~ | For ~simple~ only; accepts ~t/nil~ or ~always/no/on-success/on-failure~ |
| ~:no-restart~ | boolean | ~nil~ | Inverse form of ~:restart~ (~t~ means policy ~no~) |
| ~:logging~ | boolean | ~t~ | Per-process log capture |
| ~:stdout-log-file~ | string or ~nil~ | ~nil~ | Optional stdout log path override |
| ~:stderr-log-file~ | string or ~nil~ | ~nil~ | Optional stderr log path override; defaults to stdout target |
| ~:oneshot-blocking~ | boolean | ~supervisor-oneshot-default-blocking~ | For ~oneshot~ only |
| ~:oneshot-async~ | boolean | ~nil~ | Inverse of ~:oneshot-blocking~ |
| ~:oneshot-timeout~ | number or ~nil~ | ~supervisor-oneshot-timeout~ | For ~oneshot~ only |
| ~:tags~ | symbol, string, or list | ~nil~ | Dashboard tag filtering |
| ~:working-directory~ | string | ~nil~ | Process working directory |
| ~:environment~ | alist of ~(KEY . VALUE)~ | ~nil~ | Environment variables |
| ~:environment-file~ | string or list of strings | ~nil~ | Environment file path(s) |
| ~:exec-stop~ | string or list of strings | ~nil~ | Custom stop command(s), ~simple~ only |
| ~:exec-reload~ | string or list of strings | ~nil~ | Custom reload command(s), ~simple~ only |
| ~:restart-sec~ | non-negative number | ~nil~ | Per-unit restart delay, ~simple~ only |
| ~:description~ | string | ~nil~ | Human-readable description, metadata only |
| ~:documentation~ | string or list of strings | ~nil~ | Documentation URIs/paths, metadata only |
| ~:before~ | string or list of strings | ~nil~ | Inverse ordering, see below |
| ~:wants~ | string or list of strings | ~nil~ | Soft dependency, see below |
| ~:kill-signal~ | symbol or string | ~SIGTERM~ | Graceful stop signal for this unit |
| ~:kill-mode~ | symbol or string | ~process~ | ~process~ or ~mixed~, see Stop Semantics |
| ~:remain-after-exit~ | boolean | ~nil~ | ~oneshot~ only: latch active on success |
| ~:success-exit-status~ | int, signal symbol/string, or list | ~nil~ | ~simple~ only: extra clean exit criteria |
| ~:user~ | string, integer, or ~nil~ | ~nil~ | Run-as user (requires root, trusted unit source) |
| ~:group~ | string, integer, or ~nil~ | ~nil~ | Run-as group (requires root, trusted unit source) |
| ~:wanted-by~ | string or list of strings | ~nil~ | Soft membership in target units |
| ~:required-by~ | string or list of strings | ~nil~ | Required membership in target units |
| ~:sandbox-profile~ | symbol | ~nil~ | ~none~, ~strict~, ~service~, or ~desktop~ (Linux only) |
| ~:sandbox-network~ | symbol | profile default | ~shared~ or ~isolated~ |
| ~:sandbox-ro-bind~ | list of absolute path strings | ~nil~ | Read-only bind mounts inside sandbox |
| ~:sandbox-rw-bind~ | list of absolute path strings | ~nil~ | Read-write bind mounts inside sandbox |
| ~:sandbox-tmpfs~ | list of absolute path strings | ~nil~ | Tmpfs mounts inside sandbox |
| ~:sandbox-raw-args~ | list of strings | ~nil~ | Raw bwrap arguments (expert gate required) |

** Validation Rules

Validation is performed by unit-file validation
(~supervisor--validate-unit-file-plist~) plus
~supervisor--validate-entry~ during plan building.

- Malformed plist structures are rejected (non-proper lists, odd number of
  elements).
- Unknown keywords are rejected.
- Duplicate plist keys are rejected.
- Unit files require ~:id~.  ~:command~ is required for non-target entries and
  rejected for ~:type target~.
- ~:id~ must be a non-empty string containing only ~A-Z~, ~a-z~, ~0-9~, ~.~,
  ~_~, ~:~, ~@~, and ~-~.
- ~:command~, when present, must be a non-empty, non-whitespace-only string.
- ~:type~ must be symbol ~simple~, ~oneshot~, or ~target~.
- ~:stage~ is removed and rejected.  Use ~:wanted-by~ and ~:required-by~ for
  target membership.
- ~:delay~ must be non-negative number.
- ~:restart~, when provided, must be ~t/nil~ or one of
  ~always/no/on-success/on-failure~.
- ~:oneshot-timeout~ must be a positive number or ~nil~.
- Boolean flag keys (~:enabled~, ~:disabled~, ~:logging~, ~:no-restart~,
  ~:oneshot-blocking~, ~:oneshot-async~) must be exactly ~t~ or ~nil~.
- ~:stdout-log-file~ and ~:stderr-log-file~ must be non-empty strings or ~nil~.
- Mutually exclusive pairs are rejected: ~:enabled~ with ~:disabled~, ~:restart~
  with ~:no-restart~, and ~:oneshot-blocking~ with ~:oneshot-async~.
- ~:restart-sec~ with a disabled restart policy (~:no-restart t~, ~:restart no~,
  or ~:restart nil~) is rejected as contradictory.
- Type restrictions are enforced: ~oneshot~ rejects ~:restart~ and
  ~:no-restart~; ~simple~ rejects ~:oneshot-blocking~, ~:oneshot-async~, and
  ~:oneshot-timeout~.  ~oneshot~ rejects ~:exec-stop~, ~:exec-reload~, and
  ~:restart-sec~ (simple-only keys).
- ~:tags~ must be a symbol, string, or proper list of symbols/strings.  Empty
  strings and ~nil~ elements within the list are rejected.
- ~:after~, ~:requires~, ~:before~, and ~:wants~ must be string or proper list
  of strings.  Empty or whitespace-only dependency IDs are rejected.
  Self-referencing the entry's own ID is rejected.
- ~:wanted-by~ and ~:required-by~ must be string or proper list of strings.
  Referenced IDs must exist and be ~:type target~.
- ~:working-directory~ must be a string or ~nil~.
- ~:environment~ must be an alist of ~(KEY . VALUE)~ string pairs.  Keys must
  match ~[A-Za-z_][A-Za-z0-9_]*~.  Duplicate keys are rejected.
- ~:environment-file~ must be a string, proper list of strings, or ~nil~.
- ~:exec-stop~ and ~:exec-reload~ must be a string, proper list of strings, or
  ~nil~.  Empty or whitespace-only command strings within are rejected.
- ~:restart-sec~ must be a non-negative number or ~nil~.
- ~:description~ must be a string or ~nil~.
- ~:documentation~ must be a string, proper list of strings, or ~nil~.
- ~:kill-signal~ must be a recognized signal name (e.g., ~SIGTERM~, ~SIGINT~).
- ~:kill-mode~ must be symbol ~process~ or ~mixed~.
- ~:remain-after-exit~ must be boolean; rejected for ~simple~ type.
- ~:success-exit-status~ items must be integers (0--255) or recognized signal
  names; rejected for ~oneshot~ type.
- ~:user~ and ~:group~ must be a string, integer, or ~nil~.  Identity
  requirements (root privileges, trust gate) are enforced at launch time, not
  during validation.  See [[#security][Security]] for details.
- ~:sandbox-profile~ must be one of ~none~, ~strict~, ~service~, or ~desktop~.
- ~:sandbox-network~ must be ~shared~ or ~isolated~.
- ~:sandbox-ro-bind~, ~:sandbox-rw-bind~, and ~:sandbox-tmpfs~ must be strings
  or proper lists of absolute path strings.  Empty paths and forbidden
  destinations (~/proc~, ~/dev~) are rejected.  Duplicate paths are
  deduplicated (first occurrence wins).  Bind sources (~:sandbox-ro-bind~ and
  ~:sandbox-rw-bind~) must exist on disk; ~:sandbox-tmpfs~ destinations do
  not require existence (bwrap creates them).
- ~:sandbox-raw-args~ must be a list of strings.  Rejected unless
  ~supervisor-sandbox-allow-raw-bwrap~ is non-nil.  Raw args that conflict
  with the effective network mode or duplicate profile-managed setup are
  rejected (see [[#sandbox-expert-raw-mode][Expert Raw Mode]]).
- Sandbox keys are rejected for ~:type target~.
- Units requesting sandbox (any sandbox key present or profile not ~none~) on
  non-Linux hosts are rejected.
- Units requesting sandbox without =bwrap= (bubblewrap) installed are rejected.

Invalid entries are skipped at start and shown as ~invalid~ in dashboard
and CLI status/validate output.

** ID Resolution and Duplicate Handling

ID resolution for string entries uses the basename of the first command token
(after ~split-string-and-unquote~).

Duplicate IDs are deterministic:

- First valid occurrence wins.
- Later duplicates are skipped with warning.

** Dependency Semantics: ~:after~, ~:requires~, ~:before~, ~:wants~

- ~:after~: ordering only.
- ~:requires~: pull-in + ordering.
- ~:before~: inverse ordering (~A :before B~ is equivalent to ~B :after A~).
- ~:wants~: soft dependency with ordering preference.

Planner rules:

- Dependencies are global (no stage partitioning).
- ~:before~ is inverted into ~:after~ edges before sorting.
- Missing ~:after~ and ~:before~ refs are dropped with warning.
- Missing ~:wants~ refs are dropped.
- Missing ~:requires~ refs are dropped for non-target units; for target units,
  missing ~:requires~ makes the target invalid.
- Topological sort uses stable source order as tie-break.
- Cycle fallback clears ~:after~, ~:requires~, and ~:wants~ edges for cycle
  participants and falls back to deterministic source order.

~:wants~ soft dependency semantics:

- A wanted unit that is missing, disabled, masked, or fails to start does not
  block the wanting unit.
- ~:wants~ does not force-start disabled units.

** Internal Normalized Shape

Valid entries are normalized to schema v1 tuple form:

#+begin_src elisp
(id cmd delay enabled-p restart-policy logging-p
    stdout-log-file stderr-log-file
    type stage after
    oneshot-blocking oneshot-timeout tags requires
    working-directory environment environment-file
    exec-stop exec-reload restart-sec
    description documentation before wants
    kill-signal kill-mode remain-after-exit success-exit-status
    user group wanted-by required-by
    sandbox-profile sandbox-network sandbox-ro-bind sandbox-rw-bind
    sandbox-tmpfs sandbox-raw-args)
#+end_src

Accessor functions (~supervisor-entry-id~, ~supervisor-entry-command~, etc.) are
the canonical way to read entry fields.
The internal ~stage~ slot is retained for compatibility and is currently fixed
to ~stage3~ for user-defined entries.

** Validation and Dry-Run Commands

~M-x supervisor-verify~:

- validates services
- validates timers when timer module is available
- populates invalid hashes for dashboard/CLI visibility
- opens ~*supervisor-verify*~ report buffer

~M-x supervisor-dry-run~:

- builds plan without starting processes
- prints resolved target closure and dependency metadata
- prints timer validation summary when timers are configured
- opens ~*supervisor-dry-run*~ report buffer

* Unit Files (Modular Configuration)
:PROPERTIES:
:CUSTOM_ID: unit-files-modular-configuration
:END:

Services are defined as individual unit files.  Each unit file is a single ~.el~
file containing one plist expression.

** Authority Roots (Cascading Resolution)

Unit files are loaded from a configurable list of authority roots, searched in
order from lowest to highest precedence.  When the same unit ID exists in
multiple roots, the highest-precedence root wins completely (no key-level
merge).  Non-existent roots are silently skipped.

#+begin_src emacs-lisp
(setq supervisor-unit-authority-path
      '("/usr/lib/supervisor.el/"    ; Tier 1: vendor (lowest precedence)
        "/etc/supervisor.el/"        ; Tier 2: system admin
        "~/.config/supervisor.el/")) ; Tier 3: user (highest precedence)
#+end_src

The default three-tier layout mirrors systemd's resolution order.  You can add,
remove, or reorder roots to suit your environment.

Unit files found across all active roots are resolved at startup using the
precedence rules described below.

** Unit File Format

Each file contains a single plist:

#+begin_src emacs-lisp
;; ~/.config/supervisor.el/nm-applet.el
(:id "nm-applet"
 :command "nm-applet"
 :type simple
 :wanted-by ("graphical.target")
 :restart t)
#+end_src

Required keys:

- ~:id~ (non-empty string)
- ~:command~ (string, for non-target units)

All other keys are optional.  See [[#service-definition][Service Definition]] for
the complete key list and constraints.

** Unit File Best Practices (Data-Only Declarations)

Unit files are Lisp syntax, but they should be treated as static data
declarations, not mini programs, so validation stays reliable, behavior stays
reproducible, and unit loading stays deterministic.

Recommended:

- Keep values literal and explicit.
- Put conditional logic in wrapper scripts or the service program itself.
- Keep runtime behavior reproducible across machines and restarts.

Discouraged:

- Embedding logic in unit declarations (~if~, ~when~, filesystem checks,
  environment-dependent branching, or read-time evaluation tricks).

Good example (declarative):

#+begin_src emacs-lisp
(:id "backup"
 :command "/usr/local/bin/backup-runner --mode=incremental"
 :type oneshot
 :wanted-by ("multi-user.target")
 :enabled t
 :logging t)
#+end_src

Bad example (logic in declaration):

#+begin_src emacs-lisp
;; Discouraged: dynamic branching in unit data.
;; Keep this kind of logic in a script/program, not the unit file.
(:id "backup"
 :command (if (file-exists-p "/mnt/backup")
              "/usr/local/bin/backup-runner --mode=incremental"
            "/usr/local/bin/backup-runner --mode=local")
 :type oneshot
 :wanted-by ("multi-user.target"))
#+end_src

** Precedence and Merge Semantics

Within each authority root, unit files (~*.el~) are scanned in alphabetical order.
Roots are resolved in the order listed in ~supervisor-unit-authority-path~ (low to
high precedence).  When the same unit ID appears in multiple roots, the
highest-precedence root wins completely -- no per-key merge is performed.

- Same root, duplicate IDs: first file wins, later duplicates are skipped with
  warning.
- Cross-root, same ID: highest-precedence root wins, lower-precedence entries
  are shadowed.
- ID absent from all roots: not loaded (use ~edit ID~ to create a new unit),
  except default log maintenance IDs (~logrotate~, ~log-prune~) when
  ~supervisor-seed-default-maintenance-units~ is enabled.

*** Override Example

A vendor root provides a default service:

#+begin_src emacs-lisp
;; /usr/lib/supervisor.el/polkit.el  (Tier 1, vendor)
(:id "polkit"
 :command "/usr/lib/polkit-gnome/polkit-gnome-authentication-agent-1"
 :type simple
 :wanted-by ("multi-user.target"))
#+end_src

A user root overrides it with different target membership and logging:

#+begin_src emacs-lisp
;; ~/.config/supervisor.el/polkit.el  (Tier 3, user)
(:id "polkit"
 :command "/usr/lib/polkit-gnome/polkit-gnome-authentication-agent-1"
 :type simple
 :wanted-by ("graphical.target")
 :logging t)
#+end_src

The user definition wins entirely.  The vendor definition is shadowed.

*** Invalid Authority Root Example

If an authority root does not exist, it is silently skipped.  This means a
misconfigured path does not cause an error -- it simply contributes no units:

#+begin_src emacs-lisp
(setq supervisor-unit-authority-path
      '("/nonexistent/root/"          ; Silently skipped (does not exist)
        "/etc/supervisor.el/"         ; Active if exists
        "~/.config/supervisor.el/"))  ; Active if exists
#+end_src

*** Invalid Winner Blocks Fallback Example

If the highest-tier unit file for an ID is invalid, it blocks fallback to a
valid lower-tier unit for the same ID.  This prevents surprising behavior where
a broken override silently reverts to the vendor default:

#+begin_src emacs-lisp
;; /usr/lib/supervisor.el/backup.el  (Tier 1, vendor -- valid)
(:id "backup"
 :command "/usr/bin/backup-agent"
 :type simple
 :wanted-by ("multi-user.target"))
#+end_src

#+begin_src emacs-lisp
;; ~/.config/supervisor.el/backup.el  (Tier 3, user -- INVALID: missing :command)
(:id "backup"
 :type simple)
#+end_src

Result: ~backup~ appears as ~invalid~ in the dashboard and CLI.  The vendor
definition is *not* used as a fallback -- the invalid higher-tier winner blocks it.
Fix the user unit file or delete it to unblock the vendor definition.

** Validation

Unit files are validated at load time:

- Unknown keywords are rejected.
- Missing ~:id~ is rejected.
- ~:command~ is required for non-target entries and rejected for target entries.
- ~:id~ must be a non-empty string; ~:command~ must be a string when present.
- File path is included in validation error messages.
- Invalid unit files are skipped and logged.
- Invalid unit files appear in the dashboard and CLI with ~invalid~ status.

** Editing Unit Files

From the dashboard, press ~i e~ on any service row to open its unit file for
editing.  If the file does not exist, a scaffold template is created with the
service ID and common configuration keys commented out.

On save, the unit file is validated automatically and results are reported in
the minibuffer.  A minor mode (~supervisor-edit-mode~) is activated with
convenient return bindings: press ~q~ to return to the ~*supervisor*~
dashboard (prompts to save if modified), or ~C-c C-q~ to save and return
unconditionally.  Killing the buffer also returns to the dashboard.

From the CLI:

#+begin_src sh
supervisorctl edit nm-applet
#+end_src

This resolves the unit file path and launches ~$VISUAL~ or ~$EDITOR~.  If the
file does not exist, a scaffold is created first.  If neither ~$VISUAL~ nor
~$EDITOR~ is set, an error is returned with the unit file path for manual
editing.

** Viewing Unit Files

From the dashboard, press ~c~ on a service row to view its unit file in
read-only mode (~view-mode~).  Press ~q~ to return.

From the CLI:

#+begin_src sh
supervisorctl cat nm-applet
#+end_src

This outputs the raw unit file content.  Returns an error if the file does not
exist.  With ~--json~, returns ~{"path": "...", "content": "..."}~.

** Adding a New Service

*** Step 1: Create the unit file

Create a file in your highest-precedence authority root (default
=~/.config/supervisor.el/=).  The filename should be ~ID.el~ (e.g.,
~nm-applet.el~):

#+begin_src emacs-lisp
;; ~/.config/supervisor.el/nm-applet.el
(:id "nm-applet"
 :command "nm-applet"
 :type simple
 :wanted-by ("graphical.target")
 :restart t)
#+end_src

Or press ~i e~ in the dashboard to scaffold a unit file interactively.

*** Step 2: Reload

Run ~supervisorctl daemon-reload~ to pick up the new unit file.

* Startup and Lifecycle Model
:PROPERTIES:
:CUSTOM_ID: startup-and-lifecycle-model
:END:

** Activation Root and Closure

Startup begins from a resolved root target:

- ~supervisor-default-target~ selects the startup root.
- If it is ~default.target~, supervisor resolves
  ~supervisor-default-target-link~ first.
- Alias targets (for example ~runlevel5.target~) are resolved to canonical
  targets before activation.

The root must exist and be ~:type target~.  Supervisor then computes an
activation closure:

- Target units pull in their own ~:requires~ and ~:wants~.
- Target units also pull in inverse membership edges contributed by service
  ~:required-by~ and ~:wanted-by~ declarations.
- Service units pull in their own ~:requires~ and ~:wants~.

Only units in this closure are activated during startup.  Units outside the
closure -- including both service and target units -- are shown as ~unreachable~
in status surfaces.  This applies to all unit types:

- Service and oneshot units outside the closure show ~unreachable~.
- Target units outside the closure show ~unreachable~ (not ~pending~).
- Alias targets (e.g., ~runlevel3.target~) resolve to their canonical target
  before checking closure membership, so an alias shows ~reached~ when its
  canonical target has converged, and ~unreachable~ when the canonical target is
  not in the closure.

In a normal ~graphical.target~ boot, transition targets such as ~rescue.target~,
~shutdown.target~, ~poweroff.target~, and ~reboot.target~ are not in the
activation closure and display as ~unreachable~.  This is expected -- these
targets activate only when explicitly requested via ~isolate~ or ~init~.

** Async DAG Scheduler Semantics

Scheduling is a global DAG over the activation closure (no stage partitioning).

- In-degree 0 entries are eligible to start.
- Dependents unlock when prerequisites become ready.
- Disabled entries are marked ready immediately.
- Start failures mark ready immediately (do not block graph).
- Optional ~supervisor-max-concurrent-starts~ limits active spawn attempts.

Ready semantics:

- ~simple~: ready when process spawns.
- ~oneshot~: ready on exit (success/failure) or timeout.
- ~target~: ready when required members converge (reached/degraded).

Startup completion requires all of:

- all entries started/skipped/failed-to-spawn,
- no pending delay timers,
- no pending blocking oneshots,
- no targets still converging.

** Lifecycle State Machine

Per-entry runtime state is tracked in ~supervisor--entry-state~.

States:

- ~pending~
- ~waiting-on-deps~
- ~delayed~
- ~disabled~
- ~started~
- ~failed-to-spawn~
- ~startup-timeout~

~invalid~ is a surfaced status (from validation hash tables), not a lifecycle FSM
state in ~supervisor--entry-state~.

Invalid transitions signal errors unless forced by internal maintenance paths.

** Process Spawn and Command Execution

Processes are created via ~make-process~.

- Command arguments are parsed by ~split-string-and-unquote~.
- No implicit shell is used.
- Use explicit shell (~sh -c ...~) when shell semantics are required (for
  example pipelines ~cmd1 | cmd2~, redirects ~> file~, or shell expansion like
  ~$HOME~).

** Restart and Crash Loop Policy (~simple~)

Restart behavior is controlled by effective restart policy
(config + runtime override).  The four restart policies are:

| Policy | Behavior |
|--------+----------|
| ~no~ | Never auto-restart |
| ~on-success~ | Restart only on clean exit (exit 0 or clean signal) |
| ~on-failure~ | Restart only on non-clean exit |
| ~always~ | Restart regardless of exit type |

Clean exit means exit code 0, or a signal in ~SIGHUP~, ~SIGINT~,
~SIGPIPE~, ~SIGTERM~.  The ~:success-exit-status~ keyword extends this
set with additional numeric exit codes and/or signal names per unit.
For example, ~:success-exit-status (42 SIGUSR1)~ treats exit code 42
and ~SIGUSR1~ as clean exits for restart-policy evaluation.

Set the policy at runtime from the dashboard policy menu (~p r~, explicit
selection) or via CLI: ~supervisorctl restart-policy always myservice~.

Crash-loop protection:

- Delay: ~supervisor-restart-delay~ (overridden per-unit by ~:restart-sec~)
- Window: ~supervisor-restart-window~ seconds
- Threshold: ~supervisor-max-restarts~
- On crash-loop threshold, service is marked failed (~dead~) and restart stops.

~oneshot~ services are not auto-restarted.

** Per-Unit Restart Delay (~:restart-sec~)

Set ~:restart-sec~ to override ~supervisor-restart-delay~ for a single unit.
A value of ~0~ means immediate retry.  If ~nil~ (the default), the global
delay applies.  ~simple~ only.

** Working Directory (~:working-directory~)

Set ~:working-directory~ to a path string.  The process starts with that
directory as its working directory.

- ="~"= and =~/...= are expanded to the home directory.
- Relative paths are resolved against the directory containing the
  authoritative unit file for that unit.
- If the resolved directory does not exist, the process fails to start.

** Environment Variables (~:environment~, ~:environment-file~)

Effective environment build order:

1. Start from inherited ~process-environment~.
2. Apply ~:environment-file~ entries in list order.
3. Apply ~:environment~ pairs in list order.
4. Later assignment for the same key overrides earlier assignment.

~:environment~ is an alist of ~(KEY . VALUE)~ string pairs:

#+begin_src emacs-lisp
:environment (("APP_ENV" . "prod")
              ("LOG_LEVEL" . "info"))
#+end_src

~:environment-file~ is a path (or list of paths) to files containing
~KEY=VALUE~ lines:

- Blank lines and lines starting with ~#~ or ~;~ are ignored.
- Optional ~export ~ prefix is accepted and stripped.
- Key must match ~[A-Za-z_][A-Za-z0-9_]*~.
- Invalid lines produce logged warnings with file:line context (non-fatal).
- Relative paths are resolved against the authoritative unit file directory.
- Leading ~-~ in a path means a missing file is silently ignored; without it,
  a missing file is an error that prevents the process from starting.

** Reload Semantics (~:exec-reload~)

When a running ~simple~ unit has ~:exec-reload~ commands, reloading it
(~supervisorctl reload ID~, dashboard ~l u~) runs the reload commands
sequentially without stopping or restarting the process.  Each command
has a per-command timeout of ~supervisor-shutdown-timeout~ seconds.

- If reload commands succeed, the unit reports ~reloaded~.
- If any reload command fails, the unit reports an error and the process
  continues running.
- If ~:exec-reload~ is ~nil~, reload falls back to the default behavior
  (stop the process, start with new config).

** Oneshot Exit Encoding

For oneshot completion tracking (~supervisor--oneshot-completed~):

- normal exit stores exit code (~0~, ~1~, ...)
- signal death stores negative signal number (~SIGKILL~ -> ~-9~)

This is used by status/reporting and timer retry eligibility.

** Comparison with systemd Oneshot Semantics

Supervisor oneshot services are modeled after systemd's ~Type=oneshot~
services, but the mapping is not one-to-one.

| Supervisor | systemd | Notes |
|------------+---------+-------|
| ~:type oneshot~ | ~Type=oneshot~ | Run-to-completion services |
| ~:oneshot-blocking t~ | ~Type=oneshot~ (inherent) | Blocking is inherent to ~Type=oneshot~; ordering deps wait for exit |
| ~:oneshot-async t~ | No direct equivalent | Process runs without blocking dependency progression |
| ~:oneshot-timeout 30~ | ~TimeoutStartSec=30~ | Kill the process if it hasn't exited in time |
| No restart for oneshot | ~Restart=~ partially valid | systemd allows ~Restart=on-failure~ etc. for oneshot; supervisor forbids all restart for oneshot |
| ~:working-directory~ | ~WorkingDirectory=~ | Process working directory |
| ~:environment~ | ~Environment=~ | Key-value pairs as alist |
| ~:environment-file~ | ~EnvironmentFile=~ | Paths to env files; ~-~ prefix = optional |
| ~:exec-stop~ | ~ExecStop=~ | Custom stop commands (~simple~ only) |
| ~:exec-reload~ | ~ExecReload=~ | Custom reload commands (~simple~ only) |
| ~:restart-sec~ | ~RestartSec=~ | Per-unit restart delay (~simple~ only) |
| ~:description~ | ~Description=~ | Human-readable description |
| ~:documentation~ | ~Documentation=~ | Documentation URIs/paths |
| ~:before~ | ~Before=~ | Inverse ordering dependency |
| ~:wants~ | ~Wants=~ | Soft dependency |
| ~:kill-signal~ | ~KillSignal=~ | Graceful stop signal |
| ~:kill-mode~ | ~KillMode=~ | ~process~ or ~mixed~ (no ~control-group~ or ~none~) |
| ~:remain-after-exit~ | ~RemainAfterExit=~ | Latch active status on success (~oneshot~ only) |
| ~:success-exit-status~ | ~SuccessExitStatus=~ | Extra clean exit criteria (~simple~ only) |

Key differences:

- *Blocking is the default.*  Supervisor oneshots block dependency progression by
  default (~supervisor-oneshot-default-blocking~ is ~t~).  In systemd,
  blocking is inherent to ~Type=oneshot~: ordered dependencies wait
  for the oneshot process to exit before starting.
  ~RemainAfterExit=~ controls whether the unit stays in "active" state
  after exit, not whether it blocks ordering.
- *Restart policy.*  Supervisor forbids all restart policies for
  oneshot services.  systemd permits ~Restart=on-failure~,
  ~on-abnormal~, ~on-abort~, and ~on-watchdog~ for ~Type=oneshot~
  (restarting on non-clean exit), but disallows ~always~ and
  ~on-success~.
- *Timeout default.*  Supervisor defaults to ~supervisor-oneshot-timeout~
  (30 seconds).  systemd disables the startup timeout for oneshot by
  default (~TimeoutStartSec=infinity~), relying on the administrator
  to set explicit limits.
- *RemainAfterExit.*  Supervisor supports ~:remain-after-exit t~ for
  oneshot units.  If the process exits with code 0, the unit status
  latches to ~active~ until explicitly stopped.  Non-zero exit still
  results in ~failed~ status.  ~stop~ on an active latched unit
  transitions it to ~stopped~.  ~start~ on an active unit is a no-op.
  ~restart~ re-runs the oneshot.
- *Target model and closure.*  Both systems sequence oneshots with dependency
  ordering.  Supervisor activation is root-target closure based
  (~:required-by~/~:wanted-by~ + ~:requires~/~:wants~), then globally
  topologically ordered.

** Stop Semantics

Per-unit stop (~supervisorctl stop ID~, dashboard ~l t~):

1. If the unit has ~:exec-stop~ commands, they run sequentially with the unit's
   effective working directory and environment.  Each command has a per-command
   timeout of ~supervisor-shutdown-timeout~ seconds.
2. After stop commands complete (or fail), the process is terminated via signal.
   The signal used is the unit's ~:kill-signal~ (default ~SIGTERM~).
3. Stop commands failing does not abort the shutdown path.

~supervisor-stop~ (async graceful):

1. Runs ~:exec-stop~ command chains for applicable simple units.
2. Sends each unit's ~:kill-signal~ (default ~SIGTERM~) to remaining live
   processes.
3. After ~supervisor-shutdown-timeout~, sends ~SIGKILL~ to survivors.
   For units with ~:kill-mode mixed~, ~SIGKILL~ is also sent to discovered
   descendant processes of the main process.

~supervisor-stop-now~ (sync hard stop):

- sends immediate ~SIGKILL~
- waits up to ~0.5s~ for process death
- does not run ~:exec-stop~ commands
- intended for ~kill-emacs-hook~

~:kill-signal~:

- Overrides the default graceful stop signal (~SIGTERM~) for this unit.
- Accepts signal name symbols (e.g., ~SIGQUIT~, ~SIGUSR1~).
- Short forms like ~QUIT~ are normalized to ~SIGQUIT~.
- Applies to stop, restart, and shutdown paths.

~:kill-mode~:

- ~process~ (default): signal only the main supervised process.
- ~mixed~: send the graceful ~:kill-signal~ to the main process first; on
  timeout, send ~SIGKILL~ to both the main process and its discovered
  descendants.
- Descendant discovery uses ~list-system-processes~ and ~process-attributes~
  (PID-tree traversal).  If OS/process metadata is unavailable, a warning is
  logged and behavior falls back to ~process~ mode.

* Runtime Overrides and Reconciliation
:PROPERTIES:
:CUSTOM_ID: runtime-overrides-and-reconciliation
:END:

** Runtime Overrides

Four override tables are supported:

- mask override (~supervisor--mask-override~)
- enabled override (~supervisor--enabled-override~)
- restart override (~supervisor--restart-override~)
- logging override (~supervisor--logging~)

Effective value resolution for enabled state:

- if masked, always disabled (highest precedence),
- else explicit enabled override if present,
- otherwise config default.

Enable/disable semantics follow the systemctl model:

- ~enable ID~: unit should start on next ~supervisor-start~.  Persisted as
  override.
- ~disable ID~: unit should NOT start automatically.  Persisted.
- ~start ID~ on a disabled unit: starts it this session only.  Does not
  change enabled state.  Only mask blocks manual start.

** Persistence of Overrides

Overrides are persisted in ~supervisor-overrides-file~.

- Saved with atomic write (temp file + rename)
- Loaded on ~supervisor-start~
- Corrupt file is logged and preserved

Interactive helpers:

- ~M-x supervisor-overrides-load~
- ~M-x supervisor-overrides-save~
- ~M-x supervisor-overrides-clear~

All dashboard policy commands (~enable~, ~disable~, ~mask~, ~unmask~,
~set-restart-policy~, ~set-logging~) persist overrides immediately via
~supervisor--save-overrides~, matching the CLI behaviour.

* Target System
:PROPERTIES:
:CUSTOM_ID: target-system-handbook
:END:

Supervisor uses systemd-style targets for startup ordering and runtime
isolation.  Targets are dependency-only units (no command) whose IDs
end in ~.target~.

** Built-in Targets

Canonical built-in targets (lowest authority, user overrides win):

| Target | Requires | Description |
|--------+----------+-------------|
| ~basic.target~ | (none) | Basic system initialization |
| ~multi-user.target~ | ~basic.target~ | Multi-user services |
| ~graphical.target~ | ~multi-user.target~ | Graphical session |
| ~default.target~ | (none) | Startup root (alias resolved via ~supervisor-default-target-link~) |
| ~rescue.target~ | ~basic.target~ | Single-user rescue mode |
| ~shutdown.target~ | (none) | Shutdown synchronization barrier |
| ~poweroff.target~ | ~shutdown.target~ | Power-off target |
| ~reboot.target~ | ~shutdown.target~ | Reboot target |

** SysV Init Runlevel Compatibility

Supervisor maps SysV numeric runlevels to targets using systemd mapping
semantics.  The mapping is fixed and not configurable:

| Runlevel | Target | Description |
|----------+--------+-------------|
| 0 | ~poweroff.target~ | Halt/power off |
| 1 | ~rescue.target~ | Single-user / rescue |
| 2 | ~multi-user.target~ | Multi-user (no NFS) |
| 3 | ~multi-user.target~ | Multi-user (full) |
| 4 | ~multi-user.target~ | Reserved / multi-user |
| 5 | ~graphical.target~ | Graphical session |
| 6 | ~reboot.target~ | Reboot |

Use ~init N~ or ~telinit N~ to switch runlevels at runtime.  Both
commands map the numeric runlevel to the corresponding target and
execute an ~isolate~ transaction (stops entries not in the new target
closure, starts entries in the closure).

Runlevels 0 and 6 are destructive transitions and require
confirmation.  In interactive Emacs, a ~y-or-n-p~ prompt is shown.
In batch mode or JSON output, ~--yes~ is required.
Runlevels 1-5 do not require confirmation.

~init N~ is transaction-scoped and does NOT persist default target
changes.  Use ~set-default TARGET~ to persist a default target
override.

** Alias Targets

Alias targets provide alternate names for canonical targets.  They
resolve to the canonical target before graph expansion.  The built-in
runlevel aliases are:

| Alias | Resolves to |
|-------+-------------|
| ~runlevel0.target~ | ~poweroff.target~ |
| ~runlevel1.target~ | ~rescue.target~ |
| ~runlevel2.target~ | ~multi-user.target~ |
| ~runlevel3.target~ | ~multi-user.target~ |
| ~runlevel4.target~ | ~multi-user.target~ |
| ~runlevel5.target~ | ~graphical.target~ |
| ~runlevel6.target~ | ~reboot.target~ |

Alias resolution is immutable.  User units cannot redefine
~runlevelN.target~ alias mappings.

~set-default~ accepts alias targets but always persists the resolved
canonical target ID.  ~list-targets~ shows the ~KIND~ column
(~canonical~ or ~alias~) and resolved link for alias targets.

** Timer Denylist for Init-Transition Targets

Timer targets that represent init transitions are not timer-eligible.
The timer validation denylist includes:

- ~rescue.target~, ~shutdown.target~, ~poweroff.target~, ~reboot.target~
- ~runlevel0.target~ through ~runlevel6.target~

Timers targeting these IDs are rejected during validation with a
reason of the form =:target 'ID' is an init-transition target and is
not timer-eligible= and excluded from the scheduler.

* Timer Subsystem
:PROPERTIES:
:CUSTOM_ID: timer-subsystem-handbook
:END:

Timer subsystem lives in ~supervisor-timer.el~ and is enabled by default.
Both ~supervisor-mode~ and ~supervisor-timer-subsystem-mode~ must be
active for timers to run.

To disable:

#+begin_src emacs-lisp
(supervisor-timer-subsystem-mode -1)
#+end_src

Disabling the timer subsystem disables all timer-driven scheduling,
including ~logrotate-daily~ and ~log-prune-daily~.  It does not disable
normal unit startup.

** Timer Configuration (~supervisor-timers~)

Each timer is a plist.

Required keys:

- ~:id~ (non-empty string)
- ~:target~ (non-empty string; must resolve to a ~oneshot~, ~simple~, or ~target~ unit)

Trigger keys (at least one required):

- ~:on-calendar~
- ~:on-startup-sec~
- ~:on-unit-active-sec~

Optional keys:

- ~:enabled~ (boolean, default ~t~)
- ~:persistent~ (boolean, default ~t~)

#+begin_src emacs-lisp
(setq supervisor-timers
      '((:id "daily-backup"
         :target "backup-oneshot"       ;; oneshot target
         :on-calendar (:hour 3 :minute 0)
         :persistent t)
        (:id "warm-cache"
         :target "cache-prime"          ;; simple service
         :on-startup-sec 45)
        (:id "sync-loop"
         :target "sync-oneshot"         ;; oneshot target
         :on-unit-active-sec 300)
        (:id "nightly-converge"
         :target "multi-user.target"    ;; target unit
         :on-calendar (:hour 2 :minute 30))))
#+end_src

** Calendar Trigger Format

~:on-calendar~ accepts either:

- single plist, or
- list of plists (earliest next match wins)

Allowed fields:

- ~:minute~ (0..59)
- ~:hour~ (0..23)
- ~:day-of-month~ (1..31)
- ~:month~ (1..12)
- ~:day-of-week~ (0..6)

Field values:

- integer
- non-empty list of integers
- ~*~ wildcard

Semantics:

- next run is computed strictly after current time
- day-by-day search with bounded horizon (28-year coverage for full leap-day +
  weekday combinations)
- DST gaps are handled by validating encoded/decoded wall clock fields

** Trigger Semantics

~:on-startup-sec~:

- positive integer seconds after scheduler startup
- fires once per supervisor session

~:on-unit-active-sec~:

- positive integer seconds after last successful target execution
- anchor is type-specific:
  - ~oneshot~: anchored at last successful completion timestamp
  - ~simple~: anchored at last successful activation timestamp (spawn
    success or ~already-active~ no-op)
  - ~target~: anchored at last successful convergence timestamp
    (~reached~ or ~already-reached~ no-op)

Combined timers:

- scheduler chooses earliest due trigger among configured trigger types

** Overlap, Disable, and Missing-Target Behavior

When due:

- Disabled timer -> skipped, miss reason ~disabled~
- Active target oneshot -> skipped, miss reason ~overlap~
- Already-running simple service -> success no-op, reason ~already-active~
- Converging target unit -> skipped, miss reason ~target-converging~
- Disabled target unit -> skipped, miss reason ~disabled-target~
- Masked target unit -> skipped, miss reason ~masked-target~
- Missing target entry -> failure recorded, reason ~target-not-found~

Miss metadata is stored in timer state.

** Retry Policy

Configured by ~supervisor-timer-retry-intervals~ (default ~'(30 120 600)~).

- Retryable failures for oneshot targets: positive exit codes only
- Retryable failures for simple targets: spawn failures
- Retryable failures for target units: degraded convergence outcome
- Non-retryable: signal deaths (negative stored exit codes), nil, zero, overlap
  skips
- Retry budget resets on fresh scheduled runs

** Catch-up Policy

Configured by:

- ~:persistent~ per timer (default ~t~)
- ~supervisor-timer-catch-up-limit~ in seconds (default 24h)

On scheduler start, persistent timers may trigger catch-up runs for missed
schedules within the configured window.

** Timer Persistence

Timer runtime state file: ~supervisor-timer-state-file~.

- Atomic writes (temp + rename)
- Schema versioned
- Newer incompatible schema versions are rejected
- Stale timer IDs are pruned when scheduler starts

Persisted keys include:

- ~:last-run-at~
- ~:last-success-at~
- ~:last-failure-at~
- ~:last-exit~
- ~:last-missed-at~
- ~:last-miss-reason~
- ~:last-result~ (~success~, ~failure~, or ~skip~)
- ~:last-result-reason~ (type-specific reason symbol or nil; e.g.
  ~already-active~, ~already-reached~, ~overlap~, ~spawn-failed~,
  ~target-reached~, ~target-degraded~, ~target-not-converged~,
  ~convergence-unknown~, ~target-converging~, ~target-not-found~,
  ~disabled~, ~disabled-target~, ~masked-target~)
- ~:last-target-type~ (~oneshot~, ~simple~, or ~target~)

Transient keys (for example ~:next-run-at~, retry bookkeeping, startup-consumed
state) are recomputed each session.

State is saved on every trigger, completion, and scheduler stop.

** Timer Scheduler Lifecycle

- Started after startup completion
- Stopped on ~supervisor-stop~, ~supervisor-stop-now~, and when timer mode is disabled
- Uses ~run-at-time~ scheduling (no polling loop)

** Timer Visibility Surfaces

Dashboard:

- Timer section is shown when ~supervisor-dashboard-show-timers~ is non-nil.
- Target and tag filters apply only to the service section; the timer section
  is always visible when ~supervisor-dashboard-show-timers~ is non-nil.
- When the timer subsystem is disabled, the timer section renders with
  an explicit "(disabled)" label and no interactive timer actions.
- When no timers are configured, the section shows "no timers configured".

CLI:

- ~supervisorctl list-timers~ shows timer runtime/invalid definitions.
- If subsystem is gated off, command returns explicit disabled status.

* Dashboard (~M-x supervisor~)
:PROPERTIES:
:CUSTOM_ID: dashboard-handbook-m-x-supervisor
:END:

Dashboard buffer: ~*supervisor*~, major mode ~supervisor-dashboard-mode~
(derived from ~tabulated-list-mode~).

** Service Columns

- ~ID~
- ~Type~
- ~Target~
- ~Enabled~
- ~Status~
- ~Restart~
- ~Log~
- ~PID~
- ~Reason~

** Service Status Values

- ~running~
- ~active~ (oneshot with ~:remain-after-exit~ exited successfully)
- ~done~
- ~failed~
- ~dead~
- ~pending~
- ~stopped~
- ~masked~
- ~invalid~

~active~ means a ~:remain-after-exit~ oneshot exited with code 0 and is
latched active until explicitly stopped.
~masked~ means the entry has been explicitly masked and is always disabled.
~invalid~ means configuration/validation failure, not a runtime FSM state.

** Service Reason Values

- ~masked~
- ~disabled~
- ~delayed~
- ~waiting-on-deps~
- ~failed-to-spawn~
- ~startup-timeout~
- ~crash-loop~

** Timer Rows in Dashboard

Timer rows appear in a dedicated section below services with their own
column layout: ~ID~, ~TARGET~, ~ENABLED~, ~LAST-RUN~, ~NEXT-RUN~,
~EXIT~, ~REASON~, ~TYPE~, ~RESULT~.  This matches the columns of ~supervisorctl list-timers~.

Timer rows support interactive timer actions via the ~y~ submenu.
Service-only commands (lifecycle, policy, inspect) reject timer rows
with the message: "Not available for timer rows: use timer actions
(y or ? -> Timers)".

The first body row is a services section header:
~── Services  TYPE  TARGET  ENABLED  STATUS  RESTART  LOG  PID  REASON~.
Service rows follow under this section.

Service counters (~run/done/pend/fail/inv~) are shown in the Emacs
header line.  These counters are service-only and do not include timer rows.

Timer rows do not use service ~STATUS~/~REASON~ semantics.  They show
timer-specific runtime fields:

- ~LAST-RUN~: relative time since the most recent trigger (or ~-~)
- ~NEXT-RUN~: relative time until next scheduled trigger (or ~-~)
- ~EXIT~: last target exit code (or ~-~)
- ~REASON~: last result reason symbol (or ~-~)
- ~TYPE~: target type (~oneshot~, ~simple~, ~target~, or ~-~)
- ~RESULT~: last execution result (~success~, ~failure~, ~skip~, or ~-~)

** Dashboard Keymap

The dashboard uses a Magit-style nested menu model.  Top-level keys handle
navigation, filtering, and system controls.  Service actions are grouped into
three submenus (lifecycle, policy, inspect) accessed by a prefix key followed
by a second key.  Timer actions use the ~y~ prefix.

*** Top-Level Keys

| Key | Function |
| ~f~ | Cycle target filter (all -> targetA -> targetB -> ...) |
| ~F~ | Cycle tag filter |
| ~g~ | Refresh dashboard |
| ~G~ | Toggle auto-refresh (live monitoring) |
| ~t~ | Open ~proced~ (system process list) |
| ~T~ | Toggle proced auto-update mode |
| ~l~ | Open *Lifecycle* submenu (service rows only) |
| ~p~ | Open *Policy* submenu (service rows only) |
| ~i~ | Open *Inspect* submenu (service rows only) |
| ~y~ | Open *Timers* submenu (timer rows only) |
| ~?~ | Open transient action menu |
| ~h~ | Open dashboard help buffer |
| ~q~ | Quit dashboard |

*** Lifecycle (~l~)

| Key | Function |
| ~s~ | Start process |
| ~t~ | Stop process (graceful, suppresses restart) |
| ~r~ | Restart process (stop + start) |
| ~k~ | Kill process (send signal, restart policy unchanged) |
| ~u~ | Reload unit (re-read config and restart) |
| ~f~ | Reset failed state |

*** Policy (~p~)

Policy actions are explicit verbs (not blind toggles).

| Key | Function |
| ~e~ | Enable entry |
| ~d~ | Disable entry |
| ~m~ | Mask entry (always disabled) |
| ~u~ | Unmask entry |
| ~r~ | Set restart policy (via selection) |
| ~l~ | Set logging (via selection) |

*** Inspect (~i~)

All inspect actions are read-only.

| Key | Function |
| ~i~ | Show entry details (~C-u~ for status legend) |
| ~d~ | Show dependencies for entry |
| ~g~ | Show dependency graph |
| ~b~ | Blame: startup timing sorted by duration |
| ~l~ | View log file |
| ~c~ | View unit file (read-only) |
| ~e~ | Edit unit file (create scaffold if missing) |
| ~m~ | Show target members (target rows only) |

*** Timers (~y~)

Timer actions operate on timer rows only.  Service rows reject these
actions.

| Key | Function |
| ~t~ | Trigger timer now (manual reason) |
| ~i~ | Show timer details (schedule, state, retry info) |
| ~j~ | Jump to target service row |
| ~r~ | Reset timer runtime state and recompute next run |
| ~g~ | Refresh timer section |

Timer actions are also available via the ~?~ transient menu under
the "Timers" group.

Limitations in this version:

- ~cat~ and ~edit~ are not available for timer definitions (timers do
  not have unit files).
- Timer enable/disable policy overrides are not yet supported.

*** Notes

- Separator rows reject service actions.
- Timer rows reject service-only commands (lifecycle, policy, inspect).
- Service rows reject timer-only commands.
- ~?~ requires the ~transient~ package.
- Full ID is echoed in minibuffer when current row ID exceeds table width.
- *Stop vs Kill*: ~l t~ (stop) gracefully terminates and suppresses
  auto-restart; ~l k~ (kill) sends a signal without changing restart policy.
  Use ~l s~ to start a stopped service again.
- *Restart*: ~l r~ performs a stop-then-start cycle for service rows.

** Mode Interaction and Buffer-Local State

- ~supervisor-mode~ is the parent global mode; enabling it runs
  ~supervisor-start~, disabling it runs ~supervisor-stop~.
- ~supervisor-timer-subsystem-mode~ is a global gate for the timer subsystem
  and only becomes active when ~supervisor-mode~ is also enabled.
- ~supervisor-dashboard-mode~ is the major mode for ~*supervisor*~ and can be
  opened independently of whether supervision is currently running.
- Dashboard filters are buffer-local:
  ~supervisor--dashboard-target-filter~ and ~supervisor--dashboard-tag-filter~.
- Dashboard auto-refresh timer (~supervisor--auto-refresh-timer~) is buffer-local
  and defaults to off until toggled with ~G~ / ~M-x supervisor-dashboard-toggle-auto-refresh~.

** Dashboard Faces

All dashboard faces are in customization group ~supervisor~:

| Face | Used for |
| ~supervisor-status-running~ | Status ~running~ |
| ~supervisor-status-done~ | Status ~done~ |
| ~supervisor-status-failed~ | Status ~failed~ |
| ~supervisor-status-dead~ | Status ~dead~ |
| ~supervisor-status-invalid~ | Status ~invalid~ |
| ~supervisor-status-pending~ | Status ~pending~ |
| ~supervisor-status-stopped~ | Status ~stopped~ |
| ~supervisor-type-simple~ | Type ~simple~ |
| ~supervisor-type-oneshot~ | Type ~oneshot~ |
| ~supervisor-type-timer~ | Type ~timer~ rows |
| ~supervisor-stage-1~ | Compatibility face (currently unused) |
| ~supervisor-stage-2~ | Compatibility face (currently unused) |
| ~supervisor-stage-3~ | Compatibility face (currently unused) |
| ~supervisor-stage-4~ | Compatibility face (currently unused) |
| ~supervisor-enabled-yes~ | Enabled column (~yes~) |
| ~supervisor-enabled-no~ | Enabled column (~no~) |
| ~supervisor-reason~ | Reason column values |
| ~supervisor-stage-separator~ | Section header/separator rows |

* CLI (~sbin/supervisorctl~)
:PROPERTIES:
:CUSTOM_ID: cli-handbook-sbinsupervisorctl
:END:

The shell wrapper is transport-only; behavior is implemented in
~supervisor-cli.el~ dispatchers.

Requires the Emacs server to be running:

#+begin_src emacs-lisp
(require 'server)
(unless (server-running-p) (server-start))
#+end_src

** Wrapper Syntax

#+begin_src bash
sbin/supervisorctl [WRAPPER-OPTIONS] COMMAND [COMMAND-ARGS]
#+end_src

** Wrapper Options

| Option | Notes |
| ~--help~, ~-h~ | Show wrapper help |
| ~--json~ | Request JSON output from CLI dispatcher |
| ~--socket NAME~, ~--socket-name NAME~, ~-s NAME~ | Use specific local socket |
| ~--server-file PATH~, ~-f PATH~ | Use server file transport |
| ~--timeout N~, ~-t N~ | Pass wait timeout to ~emacsclient -w~ |

Wrapper transport rules:

- ~--socket~ and ~--server-file~ are mutually exclusive.
- ~--server-file~ emits a TCP transport warning.

Wrapper/dispatcher usage behavior:

- Wrapper ~--help~ prints wrapper option help.
- Calling ~supervisorctl~ with no command prints dispatcher usage text and
  command list.

** CLI Commands

Systemctl-compatible commands:

- ~status [ID...]~ (detail with IDs, overview without)
- ~list-units [ID...]~ (overview table)
- ~show ID~ (all properties of a unit)
- ~start [--target TARGET] [-- ID...]~
- ~stop [-- ID...]~
- ~restart [-- ID...]~
- ~enable [--] ID...~
- ~disable [--] ID...~
- ~mask [--] ID...~ (always disabled, overrides enable)
- ~unmask [--] ID...~
- ~kill [--signal SIG] [--] ID~
- ~is-active ID~ (exit 0 if running or latched active, 3 if not, 4 if unknown)
- ~is-enabled ID~ (exit 0 if enabled, 1 if disabled/masked, 4 if unknown)
- ~is-failed ID~ (exit 0 if failed/dead, 1 if not failed, 4 if unknown)
- ~daemon-reload~ (reload unit definitions from disk)
- ~reload [--] ID...~ (hot-reload specific units)
- ~cat ID~ (display raw unit file content)
- ~edit ID~ (edit unit file; creates scaffold if missing)
- ~list-dependencies [ID]~
- ~list-timers~

Target commands:

- ~list-targets~ (list all target units with convergence state and alias/canonical kind)
- ~target-status TARGET~ (show convergence, member lists, alias resolution)
- ~explain-target TARGET~ (root-cause chain for target state)
- ~isolate --yes TARGET~ (switch to target, transaction-scoped, does not persist)
- ~get-default~ (show effective default target)
- ~set-default TARGET~ (persist default target; aliases resolved to canonical)
- ~init [--yes] N~ (switch to runlevel 0-6; maps to systemd-style target)
- ~telinit [--yes] N~ (alias for ~init~)

Supervisor-specific commands:

- ~verify~
- ~reset-failed [--] [ID...]~ (with IDs: reset those; without: reset all)
- ~restart-policy (no|on-success|on-failure|always) [--] ID...~
- ~logging (on|off) [--] ID...~
- ~blame~
- ~logs [--tail N] [--] ID~
- ~ping~
- ~version~

Use ~--~ before IDs that start with ~-~ for commands that accept positional
IDs.

** Command Notes

~status~:

- with IDs: detailed per-unit output for valid units, invalid detail for
  misconfigured units, and "could not be found" for truly missing IDs; non-zero
  exit only when IDs are truly missing (not just invalid)
- without IDs: overview table (delegates to ~list-units~)

~verify~:

- returns exit code ~4~ if service or timer validation errors exist
- returns both service and timer invalid sets

~reset-failed~:

- with IDs: reset failed state for those entries
- without IDs: reset all failed entries
- clears crash-loop tracking so entries can be restarted

~start~, ~stop~, ~restart~:

- with IDs: operate on those IDs
- with no IDs: operate on whole supervisor (~start~, ~stop~, ~stop+start~)
- ~start --target TARGET~: start full supervisor from TARGET for that invocation
  only (cannot be combined with specific IDs)
- ~start~ on a disabled unit: succeeds (session-only, no override change).
  Only masked units are blocked from manual start.

~list-dependencies~:

- no ID: full edge list
- with ID: after/requires/blocks for that ID

~list-timers~:

- explicit disabled response when ~supervisor-timer-subsystem-mode~ is off
- works even when ~supervisor-mode~ is off (shows configured timer definitions)

~cat~:

- requires exactly one ID argument
- outputs raw file content from the authoritative unit file (resolved via
  ~supervisor-unit-authority-path~)
- error if file does not exist
- JSON: ~{"path": "...", "content": "..."}~

~edit~:

- requires exactly one ID argument
- resolves path via authority roots; new files are created in the
  highest-precedence active root
- creates scaffold template if unit file does not exist
- reports the authority root and tier in human output and JSON
- non-interactive: launches ~$VISUAL~ or ~$EDITOR~
- JSON: ~{"path": "...", "root": "...", "tier": N, "created": true/false}~

~daemon-reload~:

- no arguments
- re-reads unit files from all authority roots and rebuilds the internal plan
- does NOT start, stop, or restart anything; runtime state is untouched
- after daemon-reload, the next ~start~ or ~reload~ operates on the refreshed
  plan
- JSON: ~{"reloaded": true, "entries": N, "invalid": N}~
- available in dashboard transient menu under "System" group (~X~)

~reload~:

- requires at least one ID argument
- hot-reloads specific units: re-reads config and applies changes per unit
- running simple process: stop gracefully, then start with new definition
  (action: ~reloaded~)
- not running: update stored definition only; next start uses new config
  (action: ~updated~)
- masked unit: skip with warning (action: ~skipped (masked)~)
- unknown ID: error (action: ~error: not found~)
- does NOT affect other units (operates only on the specified IDs)
- exit 0 if all units succeed, exit 1 if any unit has an error
- human output: one line per ID showing ~ID: action~
- JSON: ~{"results": [{"id": "x", "action": "reloaded"}, ...]}~
- available in dashboard transient menu under "System" group (~u~)

~is-active~, ~is-enabled~, ~is-failed~:

- require exactly one ID argument
- use strict systemctl-compatible exit codes (not boolean 0/1)
- human output prints the status/state string followed by newline
- ~is-active~: exit 0 if running or latched active, exit 3 if not active,
  exit 4 if no such unit
- ~is-enabled~: exit 0 if enabled, exit 1 if disabled or masked, exit 4 if no
  such unit; output distinguishes "enabled", "disabled", and "masked" states
- ~is-failed~: exit 0 if status is "dead" or "failed", exit 1 if not failed,
  exit 4 if no such unit
- JSON: ~{"id": "...", "<predicate>": true/false, "status": "..."}~
  (~is-enabled~ uses ~"state"~ instead of ~"status"~)

** Output Formats

Human format is default.

~--json~ returns stable object structures per command (for example status,
verify, list-dependencies, list-timers).

Status JSON top-level keys (~status~ without IDs / ~list-units~):

- ~entries~ (array)
- ~invalid~ (array)

Status JSON top-level keys (~status ID...~):

- ~entries~ (array, valid unit detail)
- ~invalid~ (array, invalid configured units with reason)
- ~not_found~ (array, truly missing IDs)

Per-entry status JSON object keys (~entries~ array):

- ~id~, ~type~, ~stage~, ~enabled~, ~status~, ~restart~, ~logging~, ~pid~,
  ~reason~, ~delay~, ~after~, ~requires~
- ~start_time~, ~ready_time~, ~duration~, ~unit_file~, ~authority_tier~
- ~working_directory~, ~environment~, ~environment_file~, ~exec_stop~,
  ~exec_reload~, ~restart_sec~, ~user~, ~group~
- ~sandbox_enabled~, ~sandbox_profile~, ~sandbox_network~
- ~uptime~, ~restart_count~, ~last_exit~, ~next_restart_eta~, ~metrics~,
  ~process_tree~
- ~description~, ~documentation~, ~log_tail~

Sandbox JSON field notes:

- ~sandbox_enabled~ is ~true~ when sandbox is requested, otherwise ~false~.
- ~sandbox_profile~ is always present as one of ~"none"~, ~"strict"~,
  ~"service"~, or ~"desktop"~.
- ~sandbox_network~ is always present as effective mode (~"shared"~ or
  ~"isolated"~), including profile defaults when no explicit network override
  is set.

Timer JSON top-level keys:

- ~timers~ (array)
- ~invalid~ (array)

Per-timer JSON object keys:

- ~id~, ~target~, ~enabled~, ~persistent~
- ~on_calendar~, ~on_startup_sec~, ~on_unit_active_sec~
- ~last_run_at~, ~last_success_at~, ~last_failure_at~
- ~last_exit~, ~next_run_at~, ~retry_at~
- ~last_miss_at~, ~miss_reason~
- ~last_result~ (~"success"~, ~"failure"~, ~"skip"~, or ~null~)
- ~last_result_reason~ (reason symbol string or ~null~)
- ~target_type~ (~"oneshot"~, ~"simple"~, ~"target"~, or ~null~)

Validation JSON top-level keys:

- ~services~ with ~valid~, ~invalid~, ~errors~
- ~timers~ with ~valid~, ~invalid~, ~errors~

Error JSON shape (for argument/runtime errors):

- ~error~ (boolean)
- ~message~ (string)
- ~exitcode~ (integer)

Empty collections are encoded as arrays (not ~null~).

** Exit Codes

| Code | Meaning |
| ~0~ | Success |
| ~1~ | Runtime failure (also: ~is-enabled~ disabled/masked, ~is-failed~ not failed) |
| ~2~ | Invalid arguments |
| ~3~ | ~is-active~: unit exists but not active (systemctl parity) |
| ~4~ | ~is-*~: no such unit; also: ~verify~ validation failed |
| ~69~ | Emacs server unavailable (EX_UNAVAILABLE) |

* Events and Hooks
:PROPERTIES:
:CUSTOM_ID: events-and-hooks
:END:

** Unified Event Hook

~supervisor-event-hook~ receives one plist per event:

- ~:type~ (symbol)
- ~:ts~ (float timestamp)
- ~:id~ (string or ~nil~)
- ~:stage~ (symbol or ~nil~; currently emitted as ~nil~)
- ~:data~ (plist)

Event types:

- ~startup-begin~
- ~startup-complete~
- ~process-started~
- ~process-ready~
- ~process-exit~
- ~process-failed~
- ~cleanup~
- ~timer-trigger~
- ~timer-overlap~
- ~timer-success~
- ~timer-failure~
- ~target-reached~
- ~target-degraded~

~startup-begin~ and ~startup-complete~ are currently defined event symbols but
are not emitted by runtime paths in this release.

** Minibuffer Notifications

By default, supervisor does not show minibuffer messages for process failures
or non-zero exits. Use an event hook if you want immediate notification:

#+begin_src emacs-lisp
(add-hook 'supervisor-event-hook
          (lambda (event)
            (pcase (plist-get event :type)
              ('process-failed
               (message "Supervisor: FAILED to start %s" (plist-get event :id)))
              ('process-exit
               (let ((code (plist-get (plist-get event :data) :code)))
                 (unless (eq code 0)
                   (message "Supervisor: %s exited with code %s"
                            (plist-get event :id) code)))))))
#+end_src

This is optional. You can also check the dashboard or logs.

* Persistence and Files
:PROPERTIES:
:CUSTOM_ID: persistence-and-files
:END:

** Log Files

- Supervisor-level log file (optional):
- ~<supervisor-log-directory>/supervisor.log~ (controlled by ~supervisor-log-to-file~)
- Per-process logs:
- ~<supervisor-log-directory>/log-<id>.log~ by default (controlled per service
  logging policy)

By default, each unit merges stdout and stderr into the same per-process
log file.  Units can override stream targets with ~:stdout-log-file~ and
~:stderr-log-file~.  If both resolve to the same path, streams remain merged.
If they differ, supervisor writes stdout and stderr via separate logd writers.
These stream overrides are literal file paths; use writable paths and ensure
the target directories exist.

Example split stream configuration:

#+begin_src emacs-lisp
(:id "example-svc"
 :command "/usr/bin/example"
 :stdout-log-file "~/.config/supervisor/log/example-svc.out.log"
 :stderr-log-file "~/.config/supervisor/log/example-svc.err.log")
#+end_src

Log files are managed by external ~supervisor-logd~ writer processes.
Each writer enforces a per-file size cap (~supervisor-logd-max-file-size~)
and rotates locally when the limit is reached.

The default ~supervisor-log-directory~ is user-local
(~(expand-file-name "supervisor" user-emacs-directory)~), so userland setups
work without requiring write access to ~/var/log~.

If ~supervisor-log-directory~ is configured to an unwritable location,
supervisor automatically falls back to the same user-local default path.
If neither location is writable, file logging is skipped and services
still run.

Bundled helpers can be built from Emacs with
~M-x supervisor-build-libexec-helpers~.  Startup can prompt or auto-build
missing/stale helpers via ~supervisor-libexec-build-on-startup~.

~supervisor-logd~ and ~supervisor-runas~ are deliberately narrow helper
executables.  ~supervisor-logd~ handles continuous append/rotate I/O outside
the Emacs Lisp scheduler loop, and ~supervisor-runas~ performs privileged
identity transitions (~setuid/setgid/initgroups~) when units request
~:user~ / ~:group~.

*** Scheduled Rotation

The ~sbin/supervisor-logrotate~ script provides scheduled rotation and
pruning of log files.  It rotates active log files by renaming them with
a timestamp suffix (~YYYYMMDD-HHMMSS~), optionally signals logd writers
to reopen their files, and prunes old rotated files by age.

#+begin_example
sbin/supervisor-logrotate --log-dir /path/to/logs --keep-days 14
#+end_example

Options:
- ~--log-dir DIR~ (required) -- the log directory to operate on
- ~--keep-days N~ (default: 14) -- prune rotated files older than N days
- ~--signal-reopen~ -- send SIGHUP to logd writers after rotation
- ~--pid-dir DIR~ (default: same as ~--log-dir~) -- directory for writer
  PID file discovery
- ~--dry-run~ -- print actions without executing
- ~--help~ -- show usage

Script output behavior:
- progress/action lines are written to stdout
- warnings and errors are written to stderr

A typical cron entry for daily rotation:

#+begin_example
0 3 * * * /path/to/supervisor-logrotate --log-dir /path/to/supervisor-log-directory --signal-reopen
#+end_example

*** Global Pruning

The ~sbin/supervisor-log-prune~ script enforces a hard cap on the total
size of the log directory.  It deletes the oldest rotated files first
until the directory is at or below the cap.  Active log files
(~log-<id>.log~, ~supervisor.log~) are never deleted.

#+begin_example
sbin/supervisor-log-prune --log-dir /path/to/logs --max-total-bytes 1073741824
#+end_example

Options:
- ~--log-dir DIR~ (required) -- the log directory to operate on
- ~--max-total-bytes N~ (default: 1073741824, i.e. 1 GiB) -- hard cap on
  total directory size in bytes
- ~--lock-file PATH~ (default: ~<log-dir>/.prune.lock~) -- exclusive lock
  file path to prevent concurrent prune races
- ~--protect-id ID~ (repeatable) -- never delete ~log-<ID>.log~; use this
  for services whose ID contains a timestamp pattern (e.g.
  ~svc.20250101-120000~) to prevent their active log from being
  misidentified as rotated
- ~--dry-run~ -- print actions without executing
- ~--help~ -- show usage

Script output behavior:
- progress/action lines are written to stdout
- warnings and errors are written to stderr

The script uses ~flock~ for exclusive locking.  If another prune instance
is already running, the script prints a lock-busy skip message and exits 0
without taking action.

Active logs whose service ID contains a timestamp pattern (e.g.
~svc.20250101-120000~) are unconditionally protected.  A file matching
the rotated-file naming pattern is only deleted when the script can
confirm it is genuinely rotated.  Confirmation requires at least one of:

1. *Parent-exists guard* -- the parent active log exists in the
   directory (e.g. ~log-svc.log~ confirms ~log-svc.20250101-120000.log~
   is a rotated child of service ~svc~).
2. *Sibling guard* -- multiple rotated files share the same parent name,
   confirming they are rotated children of a now-removed service (e.g.
   ~log-svc.20240101-120000.log~ and ~log-svc.20240201-120000.log~ both
   map to parent ~log-svc.log~, confirming each other).
3. *Children guard* -- the file has its own rotated children, confirming
   it as an active parent (protects the file from deletion).
4. *Open-file guard* -- when ~fuser~ is available, files currently held
   open by a process (e.g. the logd writer) are never deleted.

A lone file with no parent, no siblings, and no children is preserved
because it could be an active log for a timestamp-like service ID.
The ~--protect-id~ flag provides additional explicit protection.

A typical cron entry for periodic pruning (e.g. hourly):

#+begin_example
0 * * * * /path/to/supervisor-log-prune --log-dir /path/to/supervisor-log-directory --max-total-bytes 1073741824
#+end_example

*** Integrated Maintenance

Three paths keep log growth bounded end-to-end:

1. *logd path* -- each logd writer rotates its own file when the
   per-file size cap is reached, then triggers the prune script
   (throttled by ~supervisor-logd-prune-min-interval~ seconds) to keep
   the directory within the total size cap.

2. *Daily automatic path* -- a built-in ~logrotate~ oneshot unit and
   a built-in ~log-prune~ oneshot unit are scheduled by separate timers:
   ~logrotate-daily~ at 03:00 and ~log-prune-daily~ at 03:05.
   This runs automatically when the timer subsystem is enabled
   (the default).  The rotate unit uses ~--signal-reopen~, so log writers
   reopen after rotation.

3. *Manual path* -- ~M-x supervisor-run-log-maintenance~ runs the
   full maintenance sequence asynchronously: rotate all active logs,
   signal writers to reopen, then prune.

Built-in ~logrotate~ and ~log-prune~ units are inert fallback
definitions -- they do not declare ~:wanted-by~ and are not activated
during startup.  They exist solely so that the built-in timers
~logrotate-daily~ and ~log-prune-daily~ can find the target entry at
runtime.  When ~supervisor-seed-default-maintenance-units~ is enabled
(the default), the first startup seeds unit files for these IDs into
the highest-precedence authority root.

A user-created unit file with ~:id "logrotate"~ overrides the built-in
entry, and a user-created unit file with ~:id "log-prune"~ overrides
that built-in entry.  Similarly, user timers with IDs
~logrotate-daily~ or ~log-prune-daily~ in ~supervisor-timers~ override
the built-in timer schedules.

Seeded unit files are write-once: once created, they are never
overwritten by supervisor.  This means improvements to default
commands will not propagate to already-seeded units.  To pick up
updated defaults, delete the seeded unit file and call
~supervisor-daemon-reload~ (or restart supervisor) -- the seeder will
create a fresh file with current defaults.

Seeding respects runtime overrides: if a maintenance unit is masked
(via ~supervisorctl mask~) or disabled (via ~supervisorctl disable~),
its unit file will not be re-seeded after deletion.

To disable automatic daily maintenance, either disable the timer
subsystem entirely:

#+begin_src emacs-lisp
(supervisor-timer-subsystem-mode -1)
#+end_src

Or override the built-in timer with a disabled one:

#+begin_src emacs-lisp
(setq supervisor-timers
      '((:id "logrotate-daily" :target "logrotate"
         :on-calendar (:hour 3 :minute 0) :enabled nil)
        (:id "log-prune-daily" :target "log-prune"
         :on-calendar (:hour 3 :minute 5) :enabled nil)))
#+end_src

All paths use the same lock file (~<log-dir>/.prune.lock~) for prune
coordination, so concurrent invocations are safe.

Relevant customization variables:

| Variable | Default | Purpose |
|----------+---------+---------|
| ~supervisor-logd-max-file-size~ | 50 MiB | Per-file size cap before logd rotates locally |
| ~supervisor-log-prune-max-total-bytes~ | 1 GiB | Hard cap on total log directory size |
| ~supervisor-logd-prune-min-interval~ | 60 s | Minimum seconds between logd-triggered prune calls |
| ~supervisor-logrotate-keep-days~ | 14 | Days to keep rotated files (scheduled path) |

** Logging Semantics

~supervisor--log~ emits levels:

- ~error~ and ~warning~ are always shown in minibuffer/log output.
- ~info~ is shown when ~supervisor-verbose~ is non-nil.
- When ~supervisor-log-to-file~ is non-nil, all levels are written to
  ~supervisor.log~ regardless of ~supervisor-verbose~.

** Overrides File

- Path: ~supervisor-overrides-file~
- Default: ~${XDG_CONFIG_HOME}/supervisor/overrides.eld~ if ~XDG_CONFIG_HOME~
  is set, otherwise =~/.config/supervisor/overrides.eld=
- Format: schema-versioned Elisp data

** Timer State File

- Path: ~supervisor-timer-state-file~
- Default: ~${XDG_STATE_HOME}/supervisor/timer-state.eld~ if ~XDG_STATE_HOME~ is
  set, otherwise =~/.local/state/supervisor/timer-state.eld=
- Active only when timer subsystem is active

* Customization Reference
:PROPERTIES:
:CUSTOM_ID: customization-reference
:END:

All user options (defcustom) are listed below.

** Core Options

| Variable | Default | Purpose |
| ~supervisor-timers~ | ~nil~ | Timer definition list |
| ~supervisor-log-directory~ | ~(expand-file-name "supervisor" user-emacs-directory)~ | Log directory |
| ~supervisor-restart-delay~ | ~2~ | Restart delay (seconds) |
| ~supervisor-max-restarts~ | ~3~ | Crash-loop threshold |
| ~supervisor-restart-window~ | ~60~ | Crash-loop time window (seconds) |
| ~supervisor-shutdown-timeout~ | ~3~ | Graceful shutdown timeout |
| ~supervisor-oneshot-default-blocking~ | ~t~ | Default oneshot blocking behavior |
| ~supervisor-oneshot-timeout~ | ~30~ | Default oneshot timeout |
| ~supervisor-startup-timeout~ | ~nil~ | Startup timeout before force-complete (~nil~ means disabled) |
| ~supervisor-max-concurrent-starts~ | ~nil~ | Max concurrent startup spawn attempts |
| ~supervisor-default-target~ | ~"default.target"~ | Startup target to activate |
| ~supervisor-default-target-link~ | ~"graphical.target"~ | Alias target that ~default.target~ resolves to |
| ~supervisor-verbose~ | ~nil~ | Show info-level messages |
| ~supervisor-log-to-file~ | ~nil~ | Write supervisor events to file |
| ~supervisor-watch-config~ | ~nil~ | Config file watch and auto-reload |
| ~supervisor-overrides-file~ | ~(XDG_CONFIG_HOME or ~/.config)/supervisor/overrides.eld~ | Override persistence path |
| ~supervisor-logd-command~ | ~libexec/supervisor-logd~ (relative to package) | Per-service log writer helper path |
| ~supervisor-logrotate-command~ | ~sbin/supervisor-logrotate~ (relative to package) | Log rotation script path |
| ~supervisor-log-prune-command~ | ~sbin/supervisor-log-prune~ (relative to package) | Global log prune script path |
| ~supervisor-logrotate-keep-days~ | ~14~ | Days to keep rotated log files |
| ~supervisor-logd-max-file-size~ | ~52428800~ (50 MiB) | Per-file size cap for log writer |
| ~supervisor-log-prune-max-total-bytes~ | ~1073741824~ (1 GiB) | Total log directory size cap |
| ~supervisor-logd-prune-min-interval~ | ~60~ | Throttle interval for logd-triggered prune (seconds) |
| ~supervisor-logd-pid-directory~ | ~nil~ (falls back to effective log directory) | Writer PID file directory |
| ~supervisor-libexec-build-on-startup~ | ~prompt~ | Build bundled helper binaries on startup (~prompt/automatic/never~) |
| ~supervisor-libexec-compiler-candidates~ | ~("cc" "clang" "gcc")~ | Candidate compiler commands, checked in order |
| ~supervisor-libexec-cflags~ | ~("-Wall" "-Wextra" "-Werror" "-pedantic" "-std=c99" "-O2")~ | C flags used when building bundled helpers |
| ~supervisor-sandbox-allow-raw-bwrap~ | ~nil~ | Enable raw bwrap arguments (~:sandbox-raw-args~) |

** Unit-File Options

| Variable | Default | Purpose |
| ~supervisor-unit-authority-path~ | ~'("/usr/lib/supervisor.el/" "/etc/supervisor.el/" "~/.config/supervisor.el/")~ | Authority roots (low to high precedence) |
| ~supervisor-unit-directory~ | ~(XDG_CONFIG_HOME or ~/.config)/supervisor/units/~ | Legacy unit directory (deprecated; use ~supervisor-unit-authority-path~) |
| ~supervisor-seed-default-maintenance-units~ | ~t~ | Auto-seed default ~logrotate~ / ~log-prune~ unit files when missing |

** Timer Options

| Variable | Default | Purpose |
| ~supervisor-timer-state-file~ | ~(XDG_STATE_HOME or ~/.local/state)/supervisor/timer-state.eld~ | Timer state persistence path |
| ~supervisor-timer-retry-intervals~ | ~'(30 120 600)~ | Retry schedule |
| ~supervisor-timer-catch-up-limit~ | ~(* 24 60 60)~ | Catch-up lookback window |

** Dashboard Options

| Variable | Default | Purpose |
| ~supervisor-dashboard-show-header-hints~ | ~nil~ | Reserved compatibility option (currently no effect); use ~h~ for key help |
| ~supervisor-dashboard-show-timers~ | ~t~ | Show timer section |
| ~supervisor-auto-refresh-interval~ | ~2~ | Auto-refresh cadence |

* Command Reference
:PROPERTIES:
:CUSTOM_ID: command-reference
:END:

** Interactive Emacs Commands

| Command | Purpose |
| ~M-x supervisor-mode~ | Global supervisor mode (start/stop + file watch) |
| ~M-x supervisor-timer-subsystem-mode~ | Toggle timer subsystem gate |
| ~M-x supervisor-start~ | Build plan and start target-closure DAG scheduler |
| ~M-x supervisor-stop~ | Async graceful stop |
| ~M-x supervisor-stop-now~ | Sync hard stop |
| ~M-x supervisor-run-log-maintenance~ | Run rotate, reopen, and prune immediately |
| ~M-x supervisor-build-libexec-helpers~ | Compile missing/stale bundled libexec helpers |
| ~M-x supervisor-verify~ | Verify config without start |
| ~M-x supervisor-dry-run~ | Show execution plan without start |
| ~M-x supervisor-migrate-config~ | Emit canonical schema v1 config |
| ~M-x supervisor-overrides-load~ | Load overrides from disk |
| ~M-x supervisor-overrides-save~ | Save overrides to disk |
| ~M-x supervisor-overrides-clear~ | Clear overrides in memory + file |
| ~M-x supervisor~ | Open dashboard |
| ~M-x supervisor-handbook~ | Open README.org handbook (read-only) |

** Dashboard Interactive Commands

| Command | Purpose |
| ~M-x supervisor-dashboard-lifecycle~ | Open lifecycle submenu |
| ~M-x supervisor-dashboard-policy~ | Open policy submenu |
| ~M-x supervisor-dashboard-inspect~ | Open inspect submenu |
| ~M-x supervisor-dashboard-refresh~ | Refresh dashboard buffer |
| ~M-x supervisor-dashboard-cycle-filter~ | Cycle target filter |
| ~M-x supervisor-dashboard-cycle-tag-filter~ | Cycle tag filter |
| ~M-x supervisor-dashboard-toggle-auto-refresh~ | Toggle auto-refresh |
| ~M-x supervisor-dashboard-quit~ | Quit dashboard |
| ~M-x supervisor-dashboard-start~ | Start selected service |
| ~M-x supervisor-dashboard-stop~ | Stop selected service (graceful, suppresses restart) |
| ~M-x supervisor-dashboard-restart~ | Restart selected service (stop + start) |
| ~M-x supervisor-dashboard-kill~ | Kill selected service (send signal, restart unchanged) |
| ~M-x supervisor-dashboard-kill-force~ | Kill selected service (no confirm) |
| ~M-x supervisor-dashboard-reset-failed~ | Reset failed state |
| ~M-x supervisor-dashboard-reload-unit~ | Hot-reload unit at point |
| ~M-x supervisor-dashboard-enable~ | Enable entry (explicit) |
| ~M-x supervisor-dashboard-disable~ | Disable entry (explicit) |
| ~M-x supervisor-dashboard-mask~ | Mask entry (always disabled) |
| ~M-x supervisor-dashboard-unmask~ | Unmask entry |
| ~M-x supervisor-dashboard-set-restart-policy~ | Set restart policy (selection) |
| ~M-x supervisor-dashboard-set-logging~ | Set logging (selection) |
| ~M-x supervisor-dashboard-describe-entry~ | Describe selected row |
| ~M-x supervisor-dashboard-show-deps~ | Show selected service deps |
| ~M-x supervisor-dashboard-show-graph~ | Show full dependency graph |
| ~M-x supervisor-dashboard-blame~ | Show startup timing view |
| ~M-x supervisor-dashboard-target-members~ | Show required/wanted members for target at point |
| ~M-x supervisor-dashboard-view-log~ | Open selected service log |
| ~M-x supervisor-dashboard-cat~ | View unit file (read-only) |
| ~M-x supervisor-dashboard-edit~ | Edit unit file (scaffold if missing) |
| ~M-x supervisor-dashboard-timer-actions~ | Open timer submenu |
| ~M-x supervisor-dashboard-timer-trigger~ | Trigger selected timer now |
| ~M-x supervisor-dashboard-timer-info~ | Show selected timer details |
| ~M-x supervisor-dashboard-timer-jump~ | Jump to selected timer target service |
| ~M-x supervisor-dashboard-timer-reset~ | Reset selected timer runtime state |
| ~M-x supervisor-dashboard-timer-refresh~ | Refresh timer section |
| ~M-x supervisor-dashboard-help~ | Open dashboard help |
| ~M-x supervisor-dashboard-menu-open~ | Open transient menu |

** Unit Edit Buffer Commands

| Command | Purpose |
| ~M-x supervisor-edit-finish~ | Save unit file and return to dashboard |
| ~M-x supervisor-edit-quit~ | Prompt-save if modified and return to dashboard |

* Indexes
:PROPERTIES:
:CUSTOM_ID: indexes
:END:

This is a topical index for targeted lookup of less-obvious behavior.

** Topical Index

- Async oneshots (~:oneshot-async~, ~:oneshot-blocking~): [[#service-definition][Service Definition]], [[#startup-and-lifecycle-model][Startup and Lifecycle Model]]
- Cat unit file (~cat~, ~i c~ in dashboard): [[#unit-files-modular-configuration][Unit Files]]
- Blocking oneshot timeout (~:oneshot-timeout~, ~supervisor-oneshot-timeout~): [[#service-definition][Service Definition]], [[#startup-and-lifecycle-model][Startup and Lifecycle Model]], [[#customization-reference][Customization Reference]]
- Command parsing (no implicit shell, use ~sh -c~ when needed): [[#startup-and-lifecycle-model][Startup and Lifecycle Model]]
- Config file watch and debounce (~supervisor-watch-config~): [[#persistence-and-files][Persistence and Files]], [[#customization-reference][Customization Reference]]
- Crash-loop detection (~supervisor-max-restarts~, ~supervisor-restart-window~): [[#startup-and-lifecycle-model][Startup and Lifecycle Model]], [[#customization-reference][Customization Reference]]
- Cycle fallback behavior for dependencies: [[#service-definition][Service Definition]], [[#startup-and-lifecycle-model][Startup and Lifecycle Model]]
- Dashboard filtering (target/tag): [[#dashboard-handbook-m-x-supervisor][Dashboard (~M-x supervisor~)]]
- Disabled unit manual start (session-only, systemctl model): [[#runtime-overrides-and-reconciliation][Runtime Overrides and Reconciliation]]
- Dashboard live updates (~supervisor-auto-refresh-interval~): [[#dashboard-handbook-m-x-supervisor][Dashboard (~M-x supervisor~)]], [[#customization-reference][Customization Reference]]
- Dashboard mode/filter state (buffer-local target/tag/auto-refresh): [[#dashboard-handbook-m-x-supervisor][Dashboard (~M-x supervisor~)]]
- Dashboard visual customization (status/type/separator faces): [[#dashboard-handbook-m-x-supervisor][Dashboard (~M-x supervisor~)]]
- Dependency semantics split (~:after~ vs ~:requires~): [[#service-definition][Service Definition]]
- Edit unit file (~edit~, ~i e~ in dashboard, scaffold template): [[#unit-files-modular-configuration][Unit Files]]
- Event API (~supervisor-event-hook~ and event types): [[#events-and-hooks][Events and Hooks]]
- Exit code semantics for oneshots (signals stored negative): [[#startup-and-lifecycle-model][Startup and Lifecycle Model]]
- Graceful vs hard stop (~supervisor-stop~ vs ~supervisor-stop-now~): [[#startup-and-lifecycle-model][Startup and Lifecycle Model]], [[#command-reference][Command Reference]]
- Hyphen-prefixed IDs in CLI (use ~--~ separator): [[#cli-handbook-sbinsupervisorctl][CLI (~sbin/supervisorctl~)]]
- JSON contracts (status/verify/list-timers + error shape): [[#cli-handbook-sbinsupervisorctl][CLI (~sbin/supervisorctl~)]]
- Log rotation and log file paths: [[#persistence-and-files][Persistence and Files]], [[#customization-reference][Customization Reference]]
- Logging pipeline (~supervisor--log~, ~supervisor-verbose~, ~supervisor-log-to-file~): [[#persistence-and-files][Persistence and Files]], [[#customization-reference][Customization Reference]]
- Manual stop behavior and restart suppression: [[#startup-and-lifecycle-model][Startup and Lifecycle Model]], [[#runtime-overrides-and-reconciliation][Runtime Overrides and Reconciliation]]
- Mask/unmask (~mask~, ~unmask~, ~m~ in dashboard): [[#runtime-overrides-and-reconciliation][Runtime Overrides and Reconciliation]]
- Max concurrent startup spawn attempts (~supervisor-max-concurrent-starts~): [[#startup-and-lifecycle-model][Startup and Lifecycle Model]], [[#customization-reference][Customization Reference]]
- Adding a new service (~edit~, scaffold template): [[#unit-files-modular-configuration][Unit Files]]
- Override precedence (runtime override vs config default): [[#runtime-overrides-and-reconciliation][Runtime Overrides and Reconciliation]]
- Override persistence (~supervisor-overrides-file~): [[#runtime-overrides-and-reconciliation][Runtime Overrides and Reconciliation]], [[#persistence-and-files][Persistence and Files]]
- Reload unit (~reload~, ~u~ in dashboard): [[#cli-handbook-sbinsupervisorctl][CLI (~sbin/supervisorctl~)]]
- Reset failed state (~reset-failed~, ~F~ in dashboard): [[#cli-handbook-sbinsupervisorctl][CLI (~sbin/supervisorctl~)]], [[#dashboard-handbook-m-x-supervisor][Dashboard (~M-x supervisor~)]]
- Manager targeting (caller identity, ~emacsclient~ discovery): [[#security][Security]]
- Process sandbox (bubblewrap profiles, knobs, raw mode): [[#sandbox][Process Sandbox (bubblewrap)]]
- Privilege-drop trust gate (~:user~, ~:group~, root-owned unit files): [[#security][Security]]
- Privilege-drop troubleshooting (identity errors, trust gate failures): [[#privilege-drop-troubleshooting][Privilege-Drop Troubleshooting]]
- Security boundary (~emacsclient --eval~, server socket trust): [[#security][Security]]
- Wrapper help vs no-command usage text: [[#cli-handbook-sbinsupervisorctl][CLI (~sbin/supervisorctl~)]]
- Startup timeout force-complete (~supervisor-startup-timeout~): [[#startup-and-lifecycle-model][Startup and Lifecycle Model]], [[#customization-reference][Customization Reference]]
- Mutator inventory and classification (explicit verb / unit-definition): [[#service-management-systems-comparison][Service Management Systems Comparison]]
- Systemd example conversions (unit file to supervisor config): [[#service-management-systems-comparison][Service Management Systems Comparison]]
- Systemd feature support matrix: [[#service-management-systems-comparison][Service Management Systems Comparison]]
- Systemd oneshot comparison (~:oneshot-blocking~, ~:oneshot-timeout~ mapping): [[#startup-and-lifecycle-model][Startup and Lifecycle Model]]
- Timer catch-up window (~supervisor-timer-catch-up-limit~, ~:persistent~): [[#timer-subsystem-handbook][Timer Subsystem]], [[#customization-reference][Customization Reference]]
- Timer disabled/gated behavior (~supervisor-timer-subsystem-mode~ + parent mode): [[#timer-subsystem-handbook][Timer Subsystem]], [[#command-reference][Command Reference]]
- Timer miss reasons (~overlap~, ~disabled~, ~disabled-target~, ~masked-target~, ~target-not-found~): [[#timer-subsystem-handbook][Timer Subsystem]], [[#dashboard-handbook-m-x-supervisor][Dashboard (~M-x supervisor~)]]
- Timer retry policy (~supervisor-timer-retry-intervals~, signal non-retry): [[#timer-subsystem-handbook][Timer Subsystem]], [[#customization-reference][Customization Reference]]
- Timer state persistence and schema compatibility (~supervisor-timer-state-file~): [[#timer-subsystem-handbook][Timer Subsystem]], [[#persistence-and-files][Persistence and Files]]
- Unit file scaffold template (created by ~edit~ on missing file): [[#unit-files-modular-configuration][Unit Files]]
- Unit file validate-on-save (after-save-hook in edited buffers): [[#unit-files-modular-configuration][Unit Files]]

* Security
:PROPERTIES:
:CUSTOM_ID: security
:END:

** Manager Targeting

~supervisorctl~ uses ~emacsclient --eval~.  Which manager instance it reaches
is determined entirely by the standard ~emacsclient~ server-discovery
mechanism, which in turn depends on the caller's OS identity:

- Each user's Emacs server listens on a socket in that user's runtime
  directory (e.g., ~/run/user/UID/emacs~).
- ~emacsclient~ finds the socket belonging to the *caller's* uid.
- There is no supervisor-level routing: manager selection = caller identity.

Operational patterns:

| Goal | Invocation |
| Manage your own services | ~supervisorctl status~ |
| Manage a root-owned manager | ~sudo supervisorctl status~ |
| Manage another user's manager | ~sudo -u alice supervisorctl status~ |

The ~--socket~ and ~--server-file~ wrapper options override discovery when
multiple servers coexist under one uid.

~:user~ and ~:group~ on a unit affect the *spawned process* identity, not
which manager is targeted.

Explicit ~--system~ / ~--user~ scope flags (analogous to ~systemctl --user~)
are deferred to future planning; the current model relies on caller identity
for manager selection.

** Transport Security

~supervisorctl~ uses ~emacsclient --eval~.  Any principal that can connect to
your Emacs server can execute code as your Emacs user.

Security boundary: your Emacs server socket/server-file access controls.

Practical guidance:

- Prefer local socket transport.
- Use ~--server-file~ only when you intentionally operate server-file/TCP mode.
- Keep server auth/socket directories private (owner-only permissions).

** Privilege-Drop Trust Gate

When a unit specifies ~:user~ or ~:group~, two runtime checks are enforced at
launch time (both initial startup and reload/restart):

1. *Root requirement.*  The manager must be running as root (euid 0).  A
   non-root manager that encounters ~:user~ or ~:group~ will fail the spawn
   with reason ~identity change requires root (user=... group=...)~.

2. *Trust gate.*  When running as root, the unit file must pass ownership and
   permission checks before identity change is allowed:
   - The unit must originate from a file on disk (not inline legacy config).
   - The file must be owned by root (uid 0).
   - The file must not be world-writable.
   Failure produces reason ~unit source not trusted (user=... group=...)~.

These are runtime spawn rejections, not validation errors.  The unit passes
validation normally; the service appears with status ~stopped~ and a
~failed-to-spawn~ reason containing identity context.  This prevents
unprivileged users from escalating through writable unit files.

** Process Sandbox (bubblewrap)
:PROPERTIES:
:CUSTOM_ID: sandbox
:END:

supervisor.el provides optional process sandboxing via [[https://github.com/containers/bubblewrap][bubblewrap]] (=bwrap=).
Sandboxing is Linux-only, opt-in, and disabled by default.

*** Overview

Sandbox is configured per-unit via ~:sandbox-profile~ and optional knob
overrides.  The feature model is profile-first:

1. Select a curated built-in profile.
2. Optionally override network mode and bind mounts.
3. For advanced use, enable the global expert gate for raw arguments.

bubblewrap is an optional dependency.  Units without sandbox settings launch
exactly as before.  Units requesting sandbox without =bwrap= installed are
rejected at validation time with an explicit reason -- they never fall back to
unsandboxed execution.

*** Profiles

| Profile | Namespaces | Filesystem | Network | Use case |
|---------+------------+------------+---------+----------|
| ~none~ | (no sandbox) | (no sandbox) | (no sandbox) | Default -- no wrapper |
| ~strict~ | All (--unshare-all) | Read-only root, tmpfs /tmp | Isolated | Batch jobs, build tasks |
| ~service~ | PID, IPC, UTS | Read-only root, tmpfs /tmp | Shared | Network daemons |
| ~desktop~ | PID, IPC, UTS | Read-only root, tmpfs /tmp, XDG_RUNTIME_DIR, X11 socket | Shared | Desktop userland apps |

*** Safe Knobs

These per-unit overrides adjust the effective sandbox without bypassing the
profile model:

- ~:sandbox-network~ -- Force ~shared~ or ~isolated~ network mode, overriding
  the profile default.
- ~:sandbox-ro-bind~ -- Add read-only bind mounts inside the sandbox.
- ~:sandbox-rw-bind~ -- Add read-write bind mounts inside the sandbox.
- ~:sandbox-tmpfs~ -- Add tmpfs mounts inside the sandbox.

Path validation rules:

- All paths must be absolute.
- Empty paths are rejected.
- ~/proc~ and ~/dev~ are forbidden destinations (profiles handle these).
  Equivalent spellings (trailing slashes, dot segments) are canonicalized
  before the check.
- ~:sandbox-ro-bind~ and ~:sandbox-rw-bind~ sources must exist on disk.
  ~:sandbox-tmpfs~ destinations do not require existence (bwrap creates them).
- Duplicate paths are deduplicated (first occurrence wins).

*** Expert Raw Mode
:PROPERTIES:
:CUSTOM_ID: sandbox-expert-raw-mode
:END:

~:sandbox-raw-args~ allows passing arbitrary bwrap arguments.  This key is
rejected at validation time unless the global gate is enabled:

#+begin_src emacs-lisp
(setq supervisor-sandbox-allow-raw-bwrap t)
#+end_src

When enabled, the raw arguments are appended after profile and knob arguments.
Expert mode is unsupported on non-Linux and rejected.

Even with the gate enabled, conflicting or unsafe raw arguments are rejected:

- ~--share-net~ is rejected when the effective network mode is ~isolated~
  (explicit ~:sandbox-network isolated~ or profile default such as ~strict~).
- ~--unshare-net~ is rejected when the effective network mode is ~shared~
  (explicit ~:sandbox-network shared~ or profile default such as ~service~).
- ~--unshare-all~, ~--die-with-parent~, ~--proc~, and ~--dev~ are rejected
  because all profiles already emit these arguments and duplication causes
  undefined bwrap behavior.

*** Status Surfaces

Sandbox status is surfaced in CLI and dashboard detail views:

- CLI human detail (~status ID~ / ~show ID~) includes:
  - ~Sandbox: PROFILE (network MODE)~ (only when sandbox is requested)
- CLI JSON entry objects include:
  - ~sandbox_enabled~ (boolean)
  - ~sandbox_profile~ (~"none"~, ~"strict"~, ~"service"~, or ~"desktop"~)
  - ~sandbox_network~ (~"shared"~ or ~"isolated"~)
- Dashboard inspect detail (~i i~) includes:
  - ~Sandbox: PROFILE (network MODE)~ (only when sandbox is requested)

*** Launch Order

When both identity drop (~:user~ / ~:group~) and sandbox are configured, the
launch wrapper ordering is fixed:

#+begin_example
supervisor-runas -> bwrap -> service executable
#+end_example

The runas helper drops to the target identity, then bwrap creates the sandbox
namespace, then the service runs inside.

*** Unit File Example

#+begin_src emacs-lisp
;; ~/.config/supervisor/units/myapp.el
(:id "myapp"
 :command "/usr/bin/myapp --serve"
 :sandbox-profile service
 :sandbox-network shared
 :sandbox-rw-bind ("/var/lib/myapp")
 :description "My application (sandboxed)")
#+end_src

*** Troubleshooting

- *"sandbox is only supported on GNU/Linux"* -- bubblewrap uses Linux
  namespaces.  Non-Linux hosts cannot use sandbox features.
- *"sandbox requires bwrap (bubblewrap) but bwrap is not found in PATH"* --
  Install bubblewrap (e.g., =apt install bubblewrap=).
- *":sandbox-raw-args requires supervisor-sandbox-allow-raw-bwrap"* -- Set
  the global gate variable before loading units.

* Service Management Systems Comparison
:PROPERTIES:
:CUSTOM_ID: service-management-systems-comparison
:END:

** Feature Support Matrix

Where behavior diverges across systems, parenthetical notes explain.

| Feature | systemd | runit | s6 | supervisor |
|---------+---------+-------+----+------------|
| *Init System (PID 1)* | | | | |
| Can run as PID 1 | yes (systemd is PID 1) | yes (runit-init, 3-stage boot) | yes (s6-linux-init, separate package) | no (needs sinit-style shim as PID 1, may run as PID 2+) |
| *Process Supervision* | | | | |
| Restart crashed daemons | yes | yes | yes | yes |
| Restart policies (always/on-failure/on-success/no) | yes (6 modes) | no (always or never) | no (always or never) | yes (4 modes) |
| Restart backoff / graduated delay | yes (v254 RestartSteps) | no | no | yes (restart-sec per unit) |
| Crash-loop detection | yes (StartLimitBurst) | no | no | yes (supervisor--failed) |
| Configurable kill signal | yes (KillSignal) | yes (control/ scripts) | yes (down-signal file) | yes (kill-signal) |
| Kill mode (cgroup/process/mixed) | yes (KillMode) | no (process only) | no (process only) | yes (kill-mode, process/mixed) |
| Exec-stop custom shutdown | yes (ExecStop) | yes (finish script) | yes (finish script) | yes (exec-stop) |
| Exec-reload custom reload | yes (ExecReload) | no | no | yes (exec-reload) |
| *Service Types* | | | | |
| Long-running daemons | yes (Type=simple) | yes | yes (longruns) | yes (type simple) |
| Oneshot run-to-completion | yes (Type=oneshot) | partial (sv once, no dedicated type) | yes (s6-rc oneshot) | yes (type oneshot) |
| Forking/double-fork PID tracking | yes (Type=forking) | no | no | no |
| D-Bus readiness type | yes (Type=dbus) | no | no | no |
| Notify readiness protocol | yes (Type=notify, sd_notify) | no | yes (notification-fd, no library needed) | no |
| Remain-after-exit | yes (RemainAfterExit) | no | no | yes (remain-after-exit) |
| Success-exit-status override | yes (SuccessExitStatus) | no | no | yes (success-exit-status) |
| *Dependencies and Ordering* | | | | |
| Explicit dependency declarations | yes (Requires/Wants/BindsTo) | no | yes (s6-rc dependencies) | yes (requires/wants) |
| Ordering declarations | yes (Before/After) | no (manual in run scripts) | yes (s6-rc ordering) | yes (before/after) |
| Topological sort with cycle detection | yes | no | yes | yes (DAG with cycle fallback) |
| Parallel startup respecting ordering | yes | yes (all parallel, no ordering) | yes | yes (DAG in-degree scheduling) |
| Conflict declarations | yes (Conflicts) | no | no | no |
| Conditional activation | yes (ConditionXxx) | no | no | no |
| *Targets / Runlevels* | | | | |
| Named synchronization barriers | yes (targets) | partial (runlevels as dirs) | yes (s6-rc bundles) | yes (targets) |
| Runlevel/target switching at runtime | yes (isolate) | yes (runsvchdir) | yes (s6-rc -u/-d bundles) | yes (isolate, init, telinit) |
| *Activation Mechanisms* | | | | |
| Socket activation | yes (centralized, fd passing) | no | partial (s6-ipcserver/s6-tcpserver, composable not centralized) | no |
| Timer activation | yes (OnCalendar, monotonic) | no | no | yes (on-calendar, on-startup-sec, on-unit-active-sec) |
| Path activation (inotify) | yes (.path units) | no | no (ftrig is FIFO-based, not inotify) | no |
| D-Bus activation | yes | no | no | no |
| Device activation | yes (.device from udev) | no | no | no |
| *Logging* | | | | |
| Integrated logging daemon | yes (journald, structured binary) | yes (svlogd, plain text) | yes (s6-log, plain text) | yes (supervisor-logd, plain text) |
| Per-service log capture | yes (journal tags by unit) | yes (service/log/run pipe) | yes (servicedir/log pipe) | yes (per-id log files) |
| Log rotation | yes (journal size/time) | yes (svlogd built-in) | yes (s6-log built-in) | yes (supervisor-logrotate) |
| Log pruning | yes (journald vacuum) | no (manual) | no (manual) | yes (supervisor-log-prune) |
| Structured/indexed log queries | yes (journalctl field filtering) | no | no | no |
| Network log shipping | yes (journal-remote/upload) | partial (svlogd UDP) | no | no |
| *Resource Control* | | | | |
| Cgroup integration | yes (native, per-unit cgroup) | no | no | no |
| CPU/memory/IO limits | yes (CPUQuota, MemoryMax, etc.) | no | no | no |
| Task limits | yes (TasksMax) | no | no | no |
| Resource accounting | yes (CPUAccounting, etc.) | no | no | no |
| Resource limits (ulimit-style) | yes (LimitNOFILE, etc.) | yes (chpst) | yes (s6-softlimit) | no |
| *Sandboxing* | | | | |
| Namespace isolation | yes (PrivateTmp, PrivateNetwork, etc.) | no | no | yes (bubblewrap profiles) |
| Seccomp syscall filtering | yes (SystemCallFilter) | no | no | no |
| Capability restriction | yes (CapabilityBoundingSet) | no | no | no |
| Filesystem protection | yes (ProtectSystem, ReadOnlyPaths) | no | no | yes (sandbox-ro-bind, sandbox-rw-bind) |
| Dynamic user allocation | yes (DynamicUser) | no | no | no |
| Security audit scoring | yes (systemd-analyze security) | no | no | no |
| Sandbox profiles | partial (systemd-analyze security) | no | no | yes (none, strict, service, desktop) |
| *Environment and Execution Context* | | | | |
| Environment variables | yes (Environment, EnvironmentFile) | partial (chpst -e envdir) | yes (s6-envdir) | yes (environment, environment-file) |
| Working directory | yes (WorkingDirectory) | yes (set in run script) | yes (set in run script) | yes (working-directory) |
| User/group execution | yes (User, Group) | yes (chpst -u) | yes (s6-setuidgid) | yes (user, group fields) |
| Supplementary groups | yes (SupplementaryGroups) | yes (chpst -u uid:gid:gid) | yes (s6-applyuidgid) | no |
| *Enable / Disable / Mask* | | | | |
| Enable/disable services | yes (systemctl enable/disable) | yes (symlink in/out of rundir) | yes (s6-rc enable/disable) | yes (enabled/disabled, runtime overrides) |
| Mask (force-prevent start) | yes (systemctl mask) | no | no | yes (mask-override) |
| Persistent runtime overrides | partial (enable/disable persist, runtime overrides do not) | yes (symlinks persist) | yes (compiled db persists) | yes (overrides.eld atomic file) |
| Preset defaults | yes (systemd.preset files) | no | no | no |
| Drop-in override fragments | yes (unit.d/*.conf) | no | no | no |
| *Template / Instance Services* | | | | |
| Template units with instances | yes (unit@.service, %i specifier) | no | yes (s6-instance-maker) | no |
| *Watchdog* | | | | |
| Service heartbeat watchdog | yes (WatchdogSec, sd_notify WATCHDOG=1) | no | no | no |
| Hardware watchdog | yes (RuntimeWatchdogSec) | no | no | no |
| *UI and Observability* | | | | |
| Interactive dashboard | no (third-party cockpit) | no | no | yes (supervisor-dashboard-mode) |
| CLI status/control | yes (systemctl) | yes (sv) | yes (s6-rc, s6-svc) | yes (supervisorctl) |
| JSON output mode | yes (systemctl --output=json) | no | no | yes (supervisorctl --json) |
| *Boot Loader* | | | | |
| UEFI boot manager | yes (systemd-boot) | no | no | no |
| Unified Kernel Images | yes (ukify, sd-stub) | no | no | no |
| TPM2 measured boot | yes (pcrlock, pcrextend, measure) | no | no | no |
| *Networking* | | | | |
| Network configuration | yes (networkd) | no | no | no |
| DNS resolver/cache | yes (resolved) | no | no | no |
| NTP client | yes (timesyncd) | no | no | no |
| *Container / VM Management* | | | | |
| OS containers | yes (nspawn) | no | no | no |
| VM spawning | yes (vmspawn) | no | no | no |
| Machine registration | yes (machined) | no | no | no |
| Portable services | yes (portabled) | no | no | no |
| System extensions | yes (sysext, confext) | no | no | no |
| *Home / User / Identity* | | | | |
| Encrypted home dirs | yes (homed) | no | no | no |
| Declarative system users | yes (sysusers) | no | no | no |
| User record multiplexer | yes (userdb) | no | no | no |
| Hostname/locale daemons | yes (hostnamed, localed) | no | no | no |
| *Storage / Filesystem* | | | | |
| LUKS/dm-crypt setup | yes (cryptsetup, cryptenroll) | no | no | no |
| dm-verity/dm-integrity | yes (veritysetup, integritysetup) | no | no | no |
| Declarative partitioning | yes (repart) | no | no | no |
| Disk image inspection | yes (dissect) | no | no | no |
| *Credentials / Secrets* | | | | |
| Encrypted service credentials | yes (systemd-creds, TPM2-sealed) | no | no | no |
| *OOM / Core Dumps* | | | | |
| Userspace OOM killer | yes (oomd, PSI-based) | no | no | no |
| Core dump capture/management | yes (coredump, coredumpctl) | no | no | no |
| *Power Management* | | | | |
| Suspend/hibernate/hybrid | yes (systemd-sleep) | no | no | no |
| Inhibitor locks | yes (systemd-inhibit) | no | no | no |
| Soft reboot (userspace only) | yes (systemd-soft-reboot) | no | no | no |
| *Misc* | | | | |
| Transient units from CLI | yes (systemd-run) | no | no | no |
| Boot performance analysis | yes (systemd-analyze blame/plot/critical-chain) | no | no | no |
| Virtualization detection | yes (systemd-detect-virt) | no | no | no |
| sudo replacement | yes (run0, v256+) | no | no | no |
| Config override delta view | yes (systemd-delta) | no | no | no |
| Unit file validation | yes (systemd-analyze verify) | no | no | yes (entry whitelist validation) |

** Example Conversions: systemd to supervisor

The examples below are strict do-the-same-thing translations.
Each supervisor unit includes ~:command~ in the plist, because unit files
in these examples are non-target units (where ~:command~ is required).

*** Translation Rules Used in Examples

| systemd directive | supervisor key | Notes |
|-------------------+----------------+-------|
| ~Description=~ | ~:description~ | Same intent |
| ~Type=simple~ | ~:type simple~ | Same process model |
| ~Type=oneshot~ | ~:type oneshot~ | Same run-to-completion model |
| ~ExecStart=...~ | ~:command \"...\"~ | Required in supervisor unit files |
| ~Restart=...~ | ~:restart ...~ | Same policy names for supported values |
| ~RestartSec=...~ | ~:restart-sec ...~ | Restart delay |
| ~WorkingDirectory=...~ | ~:working-directory ...~ | Same intent |
| ~After=...~ | ~:after (...)~ | Use supervisor IDs (for example, ~database~ not ~database.service~) |
| ~Requires=...~ | ~:requires (...)~ | Hard dependency + ordering |
| ~Environment=K=V~ | ~:environment ((\"K\" . \"V\"))~ | Alist form |
| ~ExecStop=...~ | ~:exec-stop \"...\"~ | Stop command |
| ~KillSignal=...~ | ~:kill-signal ...~ | Signal symbol |
| ~RemainAfterExit=yes~ | ~:remain-after-exit t~ | Oneshot active latch |
| ~User=~/~Group=~ | ~:user~ / ~:group~ | Requires root manager + trusted unit file |
| ~WantedBy=multi-user.target~ | ~:wanted-by (\"multi-user.target\")~ + ~:enabled t~ | Target membership |

*** Example 1: Simple Daemon

systemd unit:

#+begin_example
[Unit]
Description=My Background Service
After=network-ready.service

[Service]
Type=simple
ExecStart=/usr/bin/my-daemon --config /etc/my-daemon.conf
Restart=on-failure
RestartSec=5
WorkingDirectory=/var/lib/my-daemon

[Install]
WantedBy=multi-user.target
#+end_example

supervisor unit file (~my-daemon.el~):

#+begin_src emacs-lisp
(:id "my-daemon"
 :command "/usr/bin/my-daemon --config /etc/my-daemon.conf"
 :description "My Background Service"
 :type simple
 :wanted-by ("multi-user.target")
 :after ("network-ready")
 :restart on-failure
 :restart-sec 5
 :working-directory "/var/lib/my-daemon"
 :enabled t)
#+end_src

*** Example 2: Oneshot Setup Script

systemd unit:

#+begin_example
[Unit]
Description=Create runtime directories

[Service]
Type=oneshot
ExecStart=/usr/bin/mkdir -p /run/myapp
RemainAfterExit=yes

[Install]
WantedBy=multi-user.target
#+end_example

supervisor unit file (~setup-dirs.el~):

#+begin_src emacs-lisp
(:id "setup-dirs"
 :command "/usr/bin/mkdir -p /run/myapp"
 :description "Create runtime directories"
 :type oneshot
 :wanted-by ("multi-user.target")
 :remain-after-exit t
 :enabled t)
#+end_src

*** Example 3: Service with Dependencies and Environment

systemd unit:

#+begin_example
[Unit]
Description=Web Application
After=database.service
Requires=database.service

[Service]
Type=simple
ExecStart=/usr/bin/node /opt/webapp/server.js
Environment=NODE_ENV=production
Environment=PORT=3000
Restart=always
ExecStop=/usr/bin/pkill -TERM -f /opt/webapp/server.js
KillSignal=SIGTERM

[Install]
WantedBy=multi-user.target
#+end_example

supervisor unit file (~webapp.el~):

#+begin_src emacs-lisp
(:id "webapp"
 :command "/usr/bin/node /opt/webapp/server.js"
 :description "Web Application"
 :type simple
 :wanted-by ("multi-user.target")
 :after ("database")
 :requires ("database")
 :environment (("NODE_ENV" . "production")
               ("PORT" . "3000"))
 :restart always
 :exec-stop "/usr/bin/pkill -TERM -f /opt/webapp/server.js"
 :kill-signal SIGTERM
 :enabled t)
#+end_src

*** Example 4: Service with Privilege Drop

systemd unit:

#+begin_example
[Unit]
Description=Web server

[Service]
Type=simple
ExecStart=/usr/bin/nginx -g "daemon off;"
User=www-data
Group=www-data
Restart=on-failure

[Install]
WantedBy=multi-user.target
#+end_example

supervisor unit file (~nginx.el~), placed in a root-owned unit directory:

#+begin_src emacs-lisp
(:id "nginx"
 :command "/usr/bin/nginx -g \"daemon off;\""
 :description "Web server"
 :type simple
 :wanted-by ("multi-user.target")
 :restart on-failure
 :user "www-data"
 :group "www-data"
 :enabled t)
#+end_src

Requirements: the Emacs manager must run as root, and the unit file must be
owned by root and not world-writable.

** Privilege-Drop Troubleshooting
:PROPERTIES:
:CUSTOM_ID: privilege-drop-troubleshooting
:END:

*** "identity change requires root (user=... group=...)"

The manager is not running as root.  ~:user~ and ~:group~ require the Emacs
process to have euid 0 so that the ~supervisor-runas~ helper can call
~setuid/setgid~.

Resolution: start Emacs (and its server) as root, or remove the ~:user~ /
~:group~ keys from the unit file.

*** "unit source not trusted (user=... group=...)"

The manager is root but the unit file failed the trust gate.  Common causes:

- The unit file is not owned by root.  Fix: ~sudo chown root:root unit.el~.
- The unit file is world-writable.  Fix: ~sudo chmod o-w unit.el~.
- The unit was defined inline in ~supervisor-programs~ rather than in a unit
  file.  Inline definitions have no verifiable file ownership; move the
  definition to a root-owned unit file.

*** "executable not found"

When ~:user~ or ~:group~ is set, the command is launched through the
~supervisor-runas~ helper (at ~libexec/supervisor-runas~).  This error means
either the helper itself or the target executable could not be found.  Verify
that ~supervisor-runas-command~ points to the compiled helper and that the
target program path is absolute (the helper uses ~execv~ without PATH search).

** Mutator Inventory and Classification

Every state-mutating entry point across all modules, classified by
semantic category.  Classification key:

- *Explicit verb*: user-invoked command that performs exactly one named
  operation on a named target.
- *Unit-definition mutation*: re-reads or modifies the on-disk unit
  definition; state changes are a side-effect of the new definition.
- *Implicit (sentinel)*: triggered automatically by a process exit
  event; not directly user-invoked.
- *Implicit (scheduler)*: triggered automatically by the staging engine
  during startup sequencing; not directly user-invoked.
- *UI-local state*: mutates dashboard-local or display state only
  (buffer-local variables, timers); does not change service runtime
  state.

No toggle/cycle mutators for service policy remain.  Legacy toggle
commands (~toggle-restart~, ~toggle-enabled~, ~toggle-mask~,
~toggle-logging~) were removed in favour of explicit verb replacements.

*** Core Engine (~supervisor-core.el~)

Public entry points that change runtime state:

| Function | Category | State mutated |
|----------+----------+---------------|
| ~supervisor-start~ | Explicit verb | Clears all runtime state, loads overrides, builds plan, starts target-closure DAG scheduler |
| ~supervisor-stop~ | Explicit verb | Sends graceful stop to all processes (async) |
| ~supervisor-stop-now~ | Explicit verb | Sends hard stop to all processes (sync, for ~kill-emacs-hook~) |
| ~supervisor-daemon-reload~ | Unit-definition mutation | Re-reads unit files, refreshes invalid hash |
| ~supervisor-overrides-load~ | Explicit verb | Reads override hash tables from ~supervisor-overrides-file~ |
| ~supervisor-overrides-save~ | Explicit verb | Writes override hash tables to ~supervisor-overrides-file~ |
| ~supervisor-overrides-clear~ | Explicit verb | Clears all override hash tables and deletes file |

Private helpers called by CLI and dashboard (not direct entry points):

| Function | Category | State mutated |
|----------+----------+---------------|
| ~supervisor--manual-start~ | Explicit verb | Clears failed/stopped flags, spawns process, records ~manually-started~ |
| ~supervisor--manual-stop~ | Explicit verb | Stops process, records ~manually-stopped~, clears ~remain-active~ latch |
| ~supervisor--manual-kill~ | Explicit verb | Sends signal to process, restart policy unchanged |
| ~supervisor--reset-failed~ | Explicit verb | Clears ~failed~, ~oneshot-completed~, ~restart-times~ for target |
| ~supervisor--reload-unit~ | Unit-definition mutation | Re-reads unit file, stops/starts if running, clears stale state |
| ~supervisor--policy-enable~ | Explicit verb | Sets/clears ~enabled-override~ with config normalization |
| ~supervisor--policy-disable~ | Explicit verb | Sets/clears ~enabled-override~ with config normalization |
| ~supervisor--policy-mask~ | Explicit verb | Sets ~mask-override~ |
| ~supervisor--policy-unmask~ | Explicit verb | Clears ~mask-override~ |
| ~supervisor--policy-set-restart~ | Explicit verb | Sets/clears ~restart-override~ with config normalization, cancels timer on ~no~ |
| ~supervisor--policy-set-logging~ | Explicit verb | Sets/clears ~logging~ with config normalization |
| ~supervisor--save-overrides~ | Implicit (scheduler) | Writes override hash tables to ~supervisor-overrides-file~ (called by policy commands) |
| ~supervisor--check-crash-loop~ | Implicit (sentinel) | Records restart timestamp; marks ~failed~ if threshold exceeded |
| ~supervisor--make-process-sentinel~ | Implicit (sentinel) | On exit: removes from ~processes~, records ~last-exit-info~, handles oneshot completion, schedules restart |
| ~supervisor--start-process~ | Implicit (scheduler) | Inserts into ~processes~, clears ~manually-stopped~, records ~start-times~ |
| ~supervisor--handle-oneshot-exit~ | Implicit (sentinel) | Records ~oneshot-completed~ exit code, sets ~remain-active~ latch |
| ~supervisor--transition-state~ | Implicit (scheduler) | Updates ~entry-state~ FSM |
| ~supervisor--reconcile~ | Implicit (daemon-reload) | Diffs running vs desired state, stops/starts as needed |

*** CLI (~supervisor-cli.el~)

All CLI subcommand handlers.  Each dispatches to a core helper.

| Subcommand | Function | Category | Core call | Persists |
|------------+----------+----------+-----------+----------|
| ~start~ | ~supervisor--cli-cmd-start~ | Explicit verb | ~supervisor--manual-start~ | No |
| ~stop~ | ~supervisor--cli-cmd-stop~ | Explicit verb | ~supervisor--manual-stop~ / ~supervisor-stop~ | No |
| ~restart~ | ~supervisor--cli-cmd-restart~ | Explicit verb | ~supervisor--manual-stop~ + ~supervisor--manual-start~ | No |
| ~kill~ | ~supervisor--cli-cmd-kill~ | Explicit verb | ~supervisor--manual-kill~ | No |
| ~enable~ | ~supervisor--cli-cmd-enable~ | Explicit verb | ~supervisor--policy-enable~ + ~save-overrides~ | Yes |
| ~disable~ | ~supervisor--cli-cmd-disable~ | Explicit verb | ~supervisor--policy-disable~ + ~save-overrides~ | Yes |
| ~mask~ | ~supervisor--cli-cmd-mask~ | Explicit verb | ~supervisor--policy-mask~ + ~save-overrides~ | Yes |
| ~unmask~ | ~supervisor--cli-cmd-unmask~ | Explicit verb | ~supervisor--policy-unmask~ + ~save-overrides~ | Yes |
| ~restart-policy~ | ~supervisor--cli-cmd-restart-policy~ | Explicit verb | ~supervisor--policy-set-restart~ + ~save-overrides~ | Yes |
| ~logging~ | ~supervisor--cli-cmd-logging~ | Explicit verb | ~supervisor--policy-set-logging~ + ~save-overrides~ | Yes |
| ~reset-failed~ | ~supervisor--cli-cmd-reset-failed~ | Explicit verb | ~supervisor--reset-failed~ | No |
| ~reload~ | ~supervisor--cli-cmd-reload~ | Unit-definition mutation | ~supervisor--reload-unit~ | No |
| ~daemon-reload~ | ~supervisor--cli-cmd-daemon-reload~ | Unit-definition mutation | ~supervisor-daemon-reload~ | No |

*** Dashboard (~supervisor-dashboard.el~)

All interactive dashboard commands that change state.

| Command | Category | Core call | Persists |
|---------+----------+-----------+----------|
| ~supervisor-dashboard-start~ | Explicit verb | ~supervisor--manual-start~ | No |
| ~supervisor-dashboard-stop~ | Explicit verb | ~supervisor--manual-stop~ | No |
| ~supervisor-dashboard-restart~ | Explicit verb | ~supervisor--manual-stop~ + ~supervisor--manual-start~ | No |
| ~supervisor-dashboard-kill~ | Explicit verb | ~supervisor--manual-kill~ | No |
| ~supervisor-dashboard-kill-force~ | Explicit verb | ~supervisor--manual-kill~ (no confirm) | No |
| ~supervisor-dashboard-reset-failed~ | Explicit verb | ~supervisor--reset-failed~ | No |
| ~supervisor-dashboard-enable~ | Explicit verb | ~supervisor--policy-enable~ + ~save-overrides~ | Yes |
| ~supervisor-dashboard-disable~ | Explicit verb | ~supervisor--policy-disable~ + ~save-overrides~ | Yes |
| ~supervisor-dashboard-mask~ | Explicit verb | ~supervisor--policy-mask~ + ~save-overrides~ | Yes |
| ~supervisor-dashboard-unmask~ | Explicit verb | ~supervisor--policy-unmask~ + ~save-overrides~ | Yes |
| ~supervisor-dashboard-set-restart-policy~ | Explicit verb | ~supervisor--policy-set-restart~ + ~save-overrides~ | Yes |
| ~supervisor-dashboard-set-logging~ | Explicit verb | ~supervisor--policy-set-logging~ + ~save-overrides~ | Yes |
| ~supervisor-dashboard-reload-unit~ | Unit-definition mutation | ~supervisor--reload-unit~ | No |
| ~supervisor-dashboard-daemon-reload~ | Unit-definition mutation | ~supervisor-daemon-reload~ | No |
| ~supervisor-dashboard-cycle-filter~ | UI-local state | Sets buffer-local ~supervisor--dashboard-target-filter~ | No |
| ~supervisor-dashboard-cycle-tag-filter~ | UI-local state | Sets buffer-local ~supervisor--dashboard-tag-filter~ | No |
| ~supervisor-dashboard-toggle-auto-refresh~ | UI-local state | Creates/cancels buffer-local auto-refresh timer | No |
| ~supervisor-dashboard-toggle-proced-auto-update~ | UI-local state | Toggles ~proced-auto-update-flag~ | No |

*** CLI / Dashboard Parity

Every CLI mutator has a dashboard counterpart with identical semantics.

| Operation | CLI | Dashboard | Same core path |
|-----------+-----+-----------+----------------|
| Start | ~start ID~ | ~l s~ | ~supervisor--manual-start~ |
| Stop | ~stop ID~ | ~l t~ | ~supervisor--manual-stop~ |
| Restart | ~restart ID~ | ~l r~ | stop + start |
| Kill | ~kill ID~ | ~l k~ | ~supervisor--manual-kill~ |
| Reset failed | ~reset-failed ID~ | ~l f~ | ~supervisor--reset-failed~ |
| Enable | ~enable ID~ | ~p e~ | ~supervisor--policy-enable~ |
| Disable | ~disable ID~ | ~p d~ | ~supervisor--policy-disable~ |
| Mask | ~mask ID~ | ~p m~ | ~supervisor--policy-mask~ |
| Unmask | ~unmask ID~ | ~p u~ | ~supervisor--policy-unmask~ |
| Restart policy | ~restart-policy ID POLICY~ | ~p r~ | ~supervisor--policy-set-restart~ |
| Logging | ~logging ID on\vert{}off~ | ~p l~ | ~supervisor--policy-set-logging~ |
| Reload unit | ~reload ID~ | ~l u~ | ~supervisor--reload-unit~ |
| Daemon reload | ~daemon-reload~ | ~X~ (transient) | ~supervisor-daemon-reload~ |

All policy mutations (enable/disable/mask/unmask/restart-policy/logging)
route through shared core policy mutators (~supervisor--policy-*~) that
validate entry existence, reject invalid entries, normalize overrides
against config defaults, and return a status plist.  Both CLI and
dashboard call ~supervisor--save-overrides~ after the core mutator
applies the change.

* Development
:PROPERTIES:
:CUSTOM_ID: development
:END:

#+begin_src bash
make check
make lint
make test
make test-one TEST=supervisor-test-parse-string-entry
#+end_src

Interactive load:

#+begin_src bash
emacs -Q -l supervisor.el
#+end_src

* License
:PROPERTIES:
:CUSTOM_ID: license
:END:

GPL-3.0-or-later. See ~LICENSE~.
