[[https://github.com/cypherpunk2001/supervisor.el/actions/workflows/ci.yml][https://github.com/cypherpunk2001/supervisor.el/actions/workflows/ci.yml/badge.svg]]

* supervisor.el Handbook

*A process supervisor for Emacs.*

~supervisor.el~ aims to be robust enough to serve as PID 2, but not
init. In practice, it is best suited for userland: managing desktop sessions
under window managers like EXWM, or running inside
long-lived daemonized Emacs instances that need to manage child processes or
automate tasks with timers.

Define your services in Elisp, organize them into startup stages, declare
dependencies between them, and let supervisor handle the rest. When something
crashes, it restarts. When you log out, everything stops cleanly.

** Features

- *Staged startup*: Services start in four stages (stage1 through stage4), so
  your X session setup runs before your system tray, and your tray runs before
  the applets that need it.

- *Dependencies*: Control start order with ~:after~, or pull in requirements
  with ~:requires~.

- *Two service types*: Long-running daemons (~simple~) that restart on crash,
  and run-once scripts (~oneshot~) for initialization commands.

- *Crash recovery*: Simple services automatically restart when they die.
  Crash-looping services are marked failed after repeated crashes.

- *Interactive dashboard*: ~M-x supervisor~ opens a live view where you can
  start, stop, restart, enable, and disable services with single keystrokes.

- *CLI control*: The included ~sbin/supervisorctl~ script lets you manage
  services from any terminal, even remotely via SSH.

- *Scheduled tasks*: An experimental timer subsystem can run oneshots on cron-like
  schedules.

** Requirements

- Emacs 28.1 or later
- Optional: ~transient~ package for the dashboard help menu (~?~ key)
- For CLI: ~emacsclient~, ~base64~, and ~sed~ in your ~PATH~

** Handbook Overview

This document is the complete reference. Run ~M-x supervisor-handbook~ to open
it in Emacs at any time.

The [[#quick-start][Quick Start]] below gets you running immediately. The rest of the handbook
provides detailed reference material:

- [[#service-definition-handbook-supervisor-programs][Service Definition]] - all the options for defining services
- [[#unit-files-modular-configuration][Unit Files]] - modular one-file-per-unit configuration
- [[#startup-and-lifecycle-model][Startup and Lifecycle Model]] - how stages, dependencies, and restarts work
- [[#runtime-overrides-and-reconciliation][Runtime Overrides]] - enabling, disabling, and policy changes at runtime
- [[#timer-subsystem-handbook-experimental][Timer Subsystem]] - scheduled oneshot execution (experimental)
- [[#dashboard-handbook-m-x-supervisor][Dashboard]] - the interactive UI
- [[#cli-handbook-sbinsupervisorctl][CLI]] - terminal control with ~supervisorctl~
- [[#events-and-hooks][Events and Hooks]] - programmatic integration
- [[#customization-reference][Customization Reference]] - all variables and faces
- [[#command-reference][Command Reference]] - every interactive command

* Quick Start
:PROPERTIES:
:CUSTOM_ID: quick-start
:END:

#+begin_src emacs-lisp
(add-to-list 'load-path "~/repos/supervisor.el")
(require 'supervisor)

(setq supervisor-programs
      `(;; Stage 1: X session setup (oneshots)
        ;; Use backtick+comma for Elisp expansion instead of sh -c for shell expansion
        (,(format "xhost +SI:localuser:%s" (user-login-name))
         :type oneshot :id "xhost" :stage stage1 :tags (x-setup))
        (,(format "xrdb -merge %s" (expand-file-name "~/.Xresources"))
         :type oneshot :id "xrdb" :stage stage1 :after "xhost" :tags (x-setup))
        ("xsetroot -cursor_name left_ptr" :type oneshot :id "xsetroot" :stage stage1
         :tags (x-setup))
        ("xset r rate 200 60" :type oneshot :id "xset-repeat" :stage stage1
         :tags (x-setup))
        ("xset -dpms" :type oneshot :id "xset-dpms" :stage stage1
         :tags (x-setup))
        ("xset s off" :type oneshot :id "xset-s" :stage stage1
         :tags (x-setup))
        ("xinput set-prop \"Kingsis Peripherals ZOWIE Gaming mouse\" \"libinput Accel Profile Enabled\" 0 1"
         :type oneshot :id "xinput-mouse" :stage stage1 :tags (x-setup))
        ("redshift -P -O 2500"
         :type oneshot :id "redshift" :stage stage1 :tags (x-setup))

        ;; Stage 2: system agents
        ("/usr/lib/polkit-gnome/polkit-gnome-authentication-agent-1"
         :type simple :id "polkit" :stage stage2 :restart t :tags (system))

        ;; Stage 3: tray applets (delay for EXWM systray init)
        ("nm-applet" :type simple :stage stage3 :delay 3 :restart t :tags (applet tray))

        ;; Stage 4: more tray applets
        ("blueman-applet" :type simple :stage stage4 :delay 3 :restart t :tags (applet tray))
        ("pasystray" :type simple :stage stage4 :delay 3 :restart t :tags (applet tray))))

;; Use supervisor-stop-now for immediate SIGKILL - ensures clean X session exit
(add-hook 'kill-emacs-hook #'supervisor-stop-now)

;; Don't ask about running processes on exit - supervisor handles cleanup
(setq confirm-kill-processes nil)

;; Start supervisor
(supervisor-start)
#+end_src

With the above configuration running, ~sbin/supervisorctl status~ shows:

#+begin_example
$ sbin/supervisorctl status
ID               TYPE     STAGE    ENABLED  STATUS     RESTART  LOG   PID     REASON
----------------------------------------------------------------------------------------------------
xhost            oneshot  stage1   yes      done       n/a      yes   -       -
xrdb             oneshot  stage1   yes      done       n/a      yes   -       -
xsetroot         oneshot  stage1   yes      done       n/a      yes   -       -
xset-repeat      oneshot  stage1   yes      done       n/a      yes   -       -
xset-dpms        oneshot  stage1   yes      done       n/a      yes   -       -
xset-s           oneshot  stage1   yes      done       n/a      yes   -       -
xinput-mouse     oneshot  stage1   yes      done       n/a      yes   -       -
redshift         oneshot  stage1   yes      done       n/a      yes   -       -
polkit           simple   stage2   yes      running    yes      yes   1280    -
nm-applet        simple   stage3   yes      running    yes      yes   1396    -
blueman-applet   simple   stage4   yes      running    yes      yes   1927    -
pasystray        simple   stage4   yes      running    yes      yes   1442    -
#+end_example

~M-x supervisor~ opens an interactive dashboard for managing services:

#+CAPTION: Supervisor dashboard
[[file:doc/dashboard.png]]

As your setup grows, consider [[#unit-files-modular-configuration][unit files]] as an alternative to the
monolithic ~supervisor-programs~ list---each service gets its own ~.el~ file
under ~~/.config/supervisor/units/~.

* Service Definition (~supervisor-programs~)
:PROPERTIES:
:CUSTOM_ID: service-definition-handbook-supervisor-programs
:END:

~supervisor-programs~ is a list of entries.

Entry forms:

- Command string: ~"nm-applet"~
- Command + plist: ~("nm-applet" :id "nm" :stage stage3 ...)~

** Entry Keywords

| Keyword | Type | Default | Notes |
| ~:id~ | string | basename of executable token | Must be string if provided |
| ~:type~ | symbol | ~simple~ | ~simple~ or ~oneshot~ |
| ~:stage~ | symbol | ~stage3~ | ~stage1~, ~stage2~, ~stage3~, ~stage4~ |
| ~:delay~ | non-negative number | ~0~ | Delays spawn in seconds |
| ~:after~ | string or list of strings | ~nil~ | Ordering dependency (same stage) |
| ~:requires~ | string or list of strings | ~nil~ | Requirement + ordering dependency (same stage) |
| ~:enabled~ | boolean | ~t~ | Enable/disable service |
| ~:disabled~ | boolean | ~nil~ | Inverse form of ~:enabled~ |
| ~:restart~ | boolean | ~t~ | For ~simple~ only |
| ~:no-restart~ | boolean | ~nil~ | Inverse form of ~:restart~ |
| ~:logging~ | boolean | ~t~ | Per-process log capture |
| ~:oneshot-wait~ | boolean | ~supervisor-oneshot-default-wait~ | For ~oneshot~ only |
| ~:async~ | boolean | ~nil~ | Alias for non-blocking oneshot (~not :oneshot-wait~) |
| ~:oneshot-timeout~ | number or ~nil~ | ~supervisor-oneshot-timeout~ | For ~oneshot~ only |
| ~:tags~ | symbol, string, or list | ~nil~ | Dashboard tag filtering |

** Validation Rules

Validation is performed by ~supervisor--validate-entry~ and plan building.

- Unknown keywords are rejected.
- ~:id~ must be a string when present.
- ~:type~ must be symbol ~simple~ or ~oneshot~.
- ~:stage~ must be symbol ~stage1..stage4~.
- ~:delay~ must be non-negative number.
- ~:oneshot-timeout~ must be number or ~nil~.
- ~:after~ and ~:requires~ must be string or proper list of strings.
- Mutually exclusive pairs are rejected: ~:enabled~ with ~:disabled~, ~:restart~
  with ~:no-restart~, and ~:oneshot-wait~ with ~:async~.
- Type restrictions are enforced: ~oneshot~ rejects ~:restart~ and
  ~:no-restart~; ~simple~ rejects ~:oneshot-wait~, ~:async~, and
  ~:oneshot-timeout~.

Invalid entries are skipped at start and shown as ~invalid~ in dashboard
and CLI status/validate output.

** ID Resolution and Duplicate Handling

ID resolution for string entries uses the basename of the first command token
(after ~split-string-and-unquote~).

Duplicate IDs are deterministic:

- First valid occurrence wins.
- Later duplicates are skipped with warning.

** Dependency Semantics: ~:after~ vs ~:requires~

- ~:after~: ordering only.
- ~:requires~: pull-in + ordering.

Planner rules:

- Both are constrained to same-stage dependencies.
- Cross-stage ~:after~ is ignored with warning.
- Cross-stage ~:requires~ is an error (entry invalid).
- Missing dependencies are ignored with warning.
- Topological sort uses stable list order as tie-break.
- Cycle fallback clears dependency edges for affected stage and falls back to
  deterministic list order.

** Internal Normalized Shape

Valid entries are normalized to schema v1 tuple form:

#+begin_src elisp
(id cmd delay enabled-p restart-p logging-p type stage after
    oneshot-wait oneshot-timeout tags requires)
#+end_src

Accessor functions (~supervisor-entry-id~, ~supervisor-entry-command~, etc.) are
the canonical way to read entry fields.

** Validation and Dry-Run Commands

~M-x supervisor-validate~:

- validates services
- validates timers when timer module is available
- populates invalid hashes for dashboard/CLI visibility
- opens ~*supervisor-validate*~ report buffer

~M-x supervisor-dry-run~:

- builds plan without starting processes
- prints stage order and resolved dependency metadata
- prints timer validation summary when timers are configured
- opens ~*supervisor-dry-run*~ report buffer

* Unit Files (Modular Configuration)
:PROPERTIES:
:CUSTOM_ID: unit-files-modular-configuration
:END:

In addition to the monolithic ~supervisor-programs~ list, services can be defined
as individual unit files.  Each unit file is a single ~.el~ file containing one
plist expression.

** Enabling Unit Files

#+begin_src emacs-lisp
(setq supervisor-use-unit-files t)
#+end_src

When enabled, unit files are loaded from ~supervisor-unit-directory~ and merged
with ~supervisor-programs~.  Unit-file entries take precedence on ID collision.

** Unit File Format

Each file contains a single plist:

#+begin_src emacs-lisp
;; ~/.config/supervisor/units/nm-applet.el
(:id "nm-applet"
 :command "nm-applet"
 :type simple
 :stage stage3
 :restart t)
#+end_src

Required keys:

- ~:id~ (non-empty string)
- ~:command~ (string, the shell command)

All other keys from ~supervisor-programs~ entry plists are supported (~:type~,
~:stage~, ~:delay~, ~:after~, ~:requires~, ~:enabled~, ~:disabled~, ~:restart~,
~:no-restart~, ~:logging~, ~:oneshot-wait~, ~:async~, ~:oneshot-timeout~,
~:tags~).

** Unit File Best Practices (Data-Only Declarations)

Unit files are Lisp syntax, but they should be treated as static data
declarations, not mini programs, so validation stays reliable, behavior stays
reproducible, and unit loading stays deterministic.

Recommended:

- Keep values literal and explicit.
- Put conditional logic in wrapper scripts or the service program itself.
- Keep runtime behavior reproducible across machines and restarts.

Discouraged:

- Embedding logic in unit declarations (~if~, ~when~, filesystem checks,
  environment-dependent branching, or read-time evaluation tricks).

Good example (declarative):

#+begin_src emacs-lisp
(:id "backup"
 :command "/usr/local/bin/backup-runner --mode=incremental"
 :type oneshot
 :stage stage4
 :enabled t
 :logging t)
#+end_src

Bad example (logic in declaration):

#+begin_src emacs-lisp
;; Discouraged: dynamic branching in unit data.
;; Keep this kind of logic in a script/program, not the unit file.
(:id "backup"
 :command (if (file-exists-p "/mnt/backup")
              "/usr/local/bin/backup-runner --mode=incremental"
            "/usr/local/bin/backup-runner --mode=local")
 :type oneshot
 :stage stage4)
#+end_src

** Unit Directory

Default: ~$XDG_CONFIG_HOME/supervisor/units/~ or ~~/.config/supervisor/units/~.

Configure with ~supervisor-unit-directory~.

** Merge Semantics

- Unit files are scanned in alphabetical order.
- Duplicate IDs within unit files: first file wins, later duplicates are skipped
  with warning.
- ID collision between unit file and ~supervisor-programs~: unit file wins, legacy
  entry is dropped with informational log.

** Validation

Unit files are validated at load time:

- Unknown keywords are rejected.
- Missing ~:id~ or ~:command~ is rejected.
- ~:id~ must be a non-empty string; ~:command~ must be a string.
- File path is included in validation error messages.
- Invalid unit files are skipped and logged.
- Invalid unit files appear in the dashboard and CLI with ~invalid~ status.

** Editing Unit Files

From the dashboard, press ~E~ on any service row to open its unit file for
editing.  If the file does not exist, a scaffold template is created with the
service ID and common configuration keys commented out.

On save, the unit file is validated automatically and results are reported in
the minibuffer.  A minor mode (~supervisor-edit-mode~) is activated with
convenient return bindings: press ~q~ to return to the ~*supervisor*~
dashboard (prompts to save if modified), or ~C-c C-q~ to save and return
unconditionally.  Killing the buffer also returns to the dashboard.

From the CLI:

#+begin_src sh
supervisorctl edit nm-applet
#+end_src

This resolves the unit file path and launches ~$VISUAL~ or ~$EDITOR~.  If the
file does not exist, a scaffold is created first.  If neither ~$VISUAL~ nor
~$EDITOR~ is set, an error is returned with the unit file path for manual
editing.

** Viewing Unit Files

From the dashboard, press ~c~ on a service row to view its unit file in
read-only mode (~view-mode~).  Press ~q~ to return.

From the CLI:

#+begin_src sh
supervisorctl cat nm-applet
#+end_src

This outputs the raw unit file content.  Returns an error if the file does not
exist.  With ~--json~, returns ~{"path": "...", "content": "..."}~.

** Migrating to Unit Files
:PROPERTIES:
:CUSTOM_ID: migrating-to-unit-files
:END:

You can migrate from the monolithic ~supervisor-programs~ list to individual
unit files.  Both formats can coexist: ~supervisor-programs~ entries and unit
files are merged at startup, with unit files taking precedence on ID collision.

*** Step 1: Normalize your configuration

Run ~M-x supervisor-migrate-config~ to display your current ~supervisor-programs~
in canonical schema v1 form.  This normalizes all entries, drops any that are
invalid or duplicated, and emits a clean ~supervisor-programs~ definition.
Review the output to understand what each entry looks like in plist form.

*** Step 2: Enable unit files

#+begin_src emacs-lisp
(setq supervisor-use-unit-files t)
#+end_src

*** Step 3: Create unit files

For each service you want to extract, create a file in your unit directory
(default ~~/.config/supervisor/units/~).  The filename should be ~ID.el~ by
convention (e.g., ~nm-applet.el~).  Each file contains a single plist:

#+begin_src emacs-lisp
;; ~/.config/supervisor/units/nm-applet.el
(:id "nm-applet"
 :command "nm-applet"
 :type simple
 :stage stage3
 :restart t)
#+end_src

You can also press ~E~ in the dashboard to scaffold a unit file for any service.

*** Step 4: Remove migrated entries from ~supervisor-programs~

After creating a unit file for a service, remove its entry from
~supervisor-programs~.  The unit file version takes over.  You can migrate
gradually---services not yet extracted remain in ~supervisor-programs~.

*** Step 5: Reload

Run ~supervisorctl daemon-reload~ to pick up the new configuration.

* Startup and Lifecycle Model
:PROPERTIES:
:CUSTOM_ID: startup-and-lifecycle-model
:END:

** Stages and Ordering

Stage order is fixed:

- ~stage1~
- ~stage2~
- ~stage3~
- ~stage4~

Stages execute sequentially; entries inside a stage execute in dependency order,
with parallelism allowed where dependencies permit.

** Async DAG Scheduler Semantics

Within a stage:

- In-degree 0 entries are eligible to start.
- Dependents unlock when prerequisites become ready.
- Disabled entries are marked ready immediately.
- Start failures mark ready immediately (do not block graph).
- Optional ~supervisor-max-concurrent-starts~ limits active spawn attempts.

Ready semantics:

- ~simple~: ready when process spawns.
- ~oneshot~: ready on exit (success/failure) or timeout.

Stage completion requires all of:

- all entries started/skipped/failed-to-spawn,
- no pending delay timers,
- no pending blocking oneshots.

** Lifecycle State Machine

Per-entry runtime state is tracked in ~supervisor--entry-state~.

States:

- ~stage-not-started~
- ~waiting-on-deps~
- ~delayed~
- ~disabled~
- ~started~
- ~failed-to-spawn~
- ~stage-timeout~

~invalid~ is a surfaced status (from validation hash tables), not a lifecycle FSM
state in ~supervisor--entry-state~.

Invalid transitions signal errors unless forced by internal maintenance paths.

** Process Spawn and Command Execution

Processes are created via ~make-process~.

- Command arguments are parsed by ~split-string-and-unquote~.
- No implicit shell is used.
- Use explicit shell (~sh -c ...~) when shell semantics are required (for
  example pipelines ~cmd1 | cmd2~, redirects ~> file~, or shell expansion like
  ~$HOME~).

** Restart and Crash Loop Policy (~simple~)

Restart behavior is controlled by effective restart policy
(config + runtime override).  The four restart policies are:

| Policy | Behavior |
|--------+----------|
| ~no~ | Never auto-restart |
| ~on-success~ | Restart only on clean exit (exit 0 or clean signal) |
| ~on-failure~ | Restart only on non-clean exit |
| ~always~ | Restart regardless of exit type |

Clean exit means exit code 0, or a signal in ~SIGHUP~, ~SIGINT~,
~SIGPIPE~, ~SIGTERM~.

Set the policy at runtime with ~r~ in the dashboard (cycles through all
four) or via CLI: ~supervisorctl restart-policy always myservice~.

Crash-loop protection:

- Delay: ~supervisor-restart-delay~
- Window: ~supervisor-restart-window~ seconds
- Threshold: ~supervisor-max-restarts~
- On crash-loop threshold, service is marked failed (~dead~) and restart stops.

~oneshot~ services are not auto-restarted.

** Oneshot Exit Encoding

For oneshot completion tracking (~supervisor--oneshot-completed~):

- normal exit stores exit code (~0~, ~1~, ...)
- signal death stores negative signal number (~SIGKILL~ -> ~-9~)

This is used by status/reporting and timer retry eligibility.

** Stop Semantics

~supervisor-stop~ (async graceful):

- sends ~SIGTERM~
- waits asynchronously for exits
- after ~supervisor-shutdown-timeout~, sends ~SIGKILL~ to survivors

~supervisor-stop-now~ (sync hard stop):

- sends immediate ~SIGKILL~
- waits up to ~0.5s~ for process death
- intended for ~kill-emacs-hook~

* Runtime Overrides and Reconciliation
:PROPERTIES:
:CUSTOM_ID: runtime-overrides-and-reconciliation
:END:

** Runtime Overrides

Four override tables are supported:

- mask override (~supervisor--mask-override~)
- enabled override (~supervisor--enabled-override~)
- restart override (~supervisor--restart-override~)
- logging override (~supervisor--logging~)

Effective value resolution for enabled state:

- if masked, always disabled (highest precedence),
- else explicit enabled override if present,
- otherwise config default.

Enable/disable semantics follow the systemctl model:

- ~enable ID~: unit should start on next ~supervisor-start~.  Persisted as
  override.
- ~disable ID~: unit should NOT start automatically.  Persisted.
- ~start ID~ on a disabled unit: starts it this session only.  Does not
  change enabled state.  Only mask blocks manual start.

** Persistence of Overrides

Overrides are persisted in ~supervisor-overrides-file~.

- Saved with atomic write (temp file + rename)
- Loaded on ~supervisor-start~
- Corrupt file is logged and preserved

Interactive helpers:

- ~M-x supervisor-overrides-load~
- ~M-x supervisor-overrides-save~
- ~M-x supervisor-overrides-clear~

Dashboard toggles for enabled/restart/mask persist immediately.
Dashboard logging toggle updates runtime state; use explicit save command (or CLI
logging command) when you want persistence written immediately. In other words:
dashboard logging toggle does not auto-save, but CLI ~logging on|off ...~ does.

* Timer Subsystem (Experimental)
:PROPERTIES:
:CUSTOM_ID: timer-subsystem-handbook-experimental
:END:

Timer subsystem lives in ~supervisor-timer.el~ and is disabled by default.

To enable:

#+begin_src emacs-lisp
(supervisor-mode 1)
(supervisor-timer-subsystem-mode 1)
#+end_src

Both modes must be active for timers to run.

** Timer Configuration (~supervisor-timers~)

Each timer is a plist.

Required keys:

- ~:id~ (non-empty string)
- ~:target~ (non-empty string; must resolve to a ~oneshot~ service)

Trigger keys (at least one required):

- ~:on-calendar~
- ~:on-startup-sec~
- ~:on-unit-active-sec~

Optional keys:

- ~:enabled~ (boolean, default ~t~)
- ~:persistent~ (boolean, default ~t~)

#+begin_src emacs-lisp
(setq supervisor-timers
      '((:id "daily-backup"
         :target "backup-oneshot"
         :on-calendar (:hour 3 :minute 0)
         :persistent t)
        (:id "warm-cache"
         :target "cache-prime"
         :on-startup-sec 45)
        (:id "sync-loop"
         :target "sync-oneshot"
         :on-unit-active-sec 300)))
#+end_src

** Calendar Trigger Format

~:on-calendar~ accepts either:

- single plist, or
- list of plists (earliest next match wins)

Allowed fields:

- ~:minute~ (0..59)
- ~:hour~ (0..23)
- ~:day-of-month~ (1..31)
- ~:month~ (1..12)
- ~:day-of-week~ (0..6)

Field values:

- integer
- non-empty list of integers
- ~*~ wildcard

Semantics:

- next run is computed strictly after current time
- day-by-day search with bounded horizon (28-year coverage for full leap-day +
  weekday combinations)
- DST gaps are handled by validating encoded/decoded wall clock fields

** Trigger Semantics

~:on-startup-sec~:

- positive integer seconds after scheduler startup
- fires once per supervisor session

~:on-unit-active-sec~:

- positive integer seconds after last successful target completion

Combined timers:

- scheduler chooses earliest due trigger among configured trigger types

** Overlap, Disable, and Missing-Target Behavior

When due:

- Disabled timer -> skipped, miss reason ~disabled~
- Active target oneshot -> skipped, miss reason ~overlap~
- Disabled target service -> skipped, miss reason ~disabled-target~
- Missing target entry -> warning, no trigger

Miss metadata is stored in timer state.

** Retry Policy

Configured by ~supervisor-timer-retry-intervals~ (default ~'(30 120 600)~).

- Retryable failures: positive exit codes only
- Non-retryable: signal deaths (negative stored exit codes), nil, and zero
- Retry budget resets on fresh scheduled runs

** Catch-up Policy

Configured by:

- ~:persistent~ per timer (default ~t~)
- ~supervisor-timer-catch-up-limit~ in seconds (default 24h)

On scheduler start, persistent timers may trigger catch-up runs for missed
schedules within the configured window.

** Timer Persistence

Timer runtime state file: ~supervisor-timer-state-file~.

- Atomic writes (temp + rename)
- Schema versioned
- Newer incompatible schema versions are rejected
- Stale timer IDs are pruned when scheduler starts

Persisted keys include:

- ~:last-run-at~
- ~:last-success-at~
- ~:last-failure-at~
- ~:last-exit~
- ~:last-missed-at~
- ~:last-miss-reason~

Transient keys (for example ~:next-run-at~, retry bookkeeping, startup-consumed
state) are recomputed each session.

** Timer Scheduler Lifecycle

- Started after all service stages complete
- Stopped on ~supervisor-stop~, ~supervisor-stop-now~, and when timer mode is disabled
- Uses ~run-at-time~ scheduling (no polling loop)

** Timer Visibility Surfaces

Dashboard:

- Timer section is shown only when
- ~supervisor-dashboard-show-timers~ is non-nil
- timer subsystem is active
- no stage filter is active
- there are timer rows or invalid timer definitions

CLI:

- ~supervisorctl list-timers~ shows timer runtime/invalid definitions
- If subsystem is gated off, command returns explicit disabled status

* Dashboard (~M-x supervisor~)
:PROPERTIES:
:CUSTOM_ID: dashboard-handbook-m-x-supervisor
:END:

Dashboard buffer: ~*supervisor*~, major mode ~supervisor-dashboard-mode~
(derived from ~tabulated-list-mode~).

** Service Columns

- ~ID~
- ~Type~
- ~Stage~
- ~Enabled~
- ~Status~
- ~Restart~
- ~Log~
- ~PID~
- ~Reason~

** Service Status Values

- ~running~
- ~done~
- ~failed~
- ~dead~
- ~pending~
- ~stopped~
- ~masked~
- ~invalid~

~masked~ means the entry has been explicitly masked and is always disabled.
~invalid~ means configuration/validation failure, not a runtime FSM state.

** Service Reason Values

- ~masked~
- ~disabled~
- ~delayed~
- ~waiting-on-deps~
- ~stage-not-started~
- ~failed-to-spawn~
- ~stage-timeout~
- ~crash-loop~

** Timer Rows in Dashboard

Timer rows are informational and use timer runtime state.

Timer row status values:

- ~active~ (target currently running)
- ~done~ (last exit ~0~)
- ~failed~ (last exit non-zero)
- ~pending~ (no completion yet)

Timer reason column shows either:

- ~missed: <reason>~, or
- ~next: <relative time>~

** Dashboard Keymap

| Key | Function |
| ~e~ | Toggle enabled override |
| ~m~ | Toggle mask (masked entries are always disabled) |
| ~f~ | Cycle stage filter |
| ~t~ | Cycle tag filter |
| ~s~ | Start selected service |
| ~x~ | Stop selected service (graceful, suppresses restart) |
| ~R~ | Restart selected service (stop + start) |
| ~k~ | Kill selected service (send signal, restart policy unchanged) |
| ~K~ | Kill selected service (force, no confirmation) |
| ~r~ | Cycle restart policy (no/on-success/on-failure/always) |
| ~l~ | Toggle logging override |
| ~L~ | Open selected service log file |
| ~c~ | View unit file (read-only) |
| ~E~ | Edit unit file (create scaffold if missing) |
| ~p~ | Open ~proced~ |
| ~P~ | Toggle proced auto-update |
| ~d~ | Show dependencies for selected service |
| ~D~ | Show full dependency graph |
| ~B~ | Show startup blame timings |
| ~g~ | Refresh dashboard |
| ~G~ | Toggle auto-refresh |
| ~?~ | Open transient action menu |
| ~i~ | Describe row (~C-u i~ shows status legend) |
| ~h~ | Open dashboard help buffer |
| ~q~ | Quit dashboard |

Notes:

- Separator rows reject service actions.
- ~?~ requires the ~transient~ package.
- Full ID is echoed in minibuffer when current row ID exceeds table width.
- *Stop vs Kill*: ~x~ (stop) gracefully terminates and suppresses auto-restart;
  ~k~ (kill) sends a signal without changing restart policy.  Use ~s~ to start a
  stopped service again.
- *Restart*: ~R~ performs a stop-then-start cycle.  Only for ~simple~ entries.

** Mode Interaction and Buffer-Local State

- ~supervisor-mode~ is the parent global mode; enabling it runs
  ~supervisor-start~, disabling it runs ~supervisor-stop~.
- ~supervisor-timer-subsystem-mode~ is an experimental global gate and only
  becomes active when ~supervisor-mode~ is also enabled.
- ~supervisor-dashboard-mode~ is the major mode for ~*supervisor*~ and can be
  opened independently of whether supervision is currently running.
- Dashboard filters are buffer-local:
  ~supervisor--dashboard-stage-filter~ and ~supervisor--dashboard-tag-filter~.
- Dashboard auto-refresh timer (~supervisor--auto-refresh-timer~) is buffer-local
  and defaults to off until toggled with ~G~ / ~M-x supervisor-dashboard-toggle-auto-refresh~.

** Dashboard Faces

All dashboard faces are in customization group ~supervisor~:

| Face | Used for |
| ~supervisor-status-running~ | Status ~running~ |
| ~supervisor-status-done~ | Status ~done~ |
| ~supervisor-status-failed~ | Status ~failed~ |
| ~supervisor-status-dead~ | Status ~dead~ |
| ~supervisor-status-invalid~ | Status ~invalid~ |
| ~supervisor-status-pending~ | Status ~pending~ |
| ~supervisor-status-stopped~ | Status ~stopped~ |
| ~supervisor-type-simple~ | Type ~simple~ |
| ~supervisor-type-oneshot~ | Type ~oneshot~ |
| ~supervisor-type-timer~ | Type ~timer~ rows |
| ~supervisor-stage-1~ | Stage column ~stage1~ |
| ~supervisor-stage-2~ | Stage column ~stage2~ |
| ~supervisor-stage-3~ | Stage column ~stage3~ |
| ~supervisor-stage-4~ | Stage column ~stage4~ |
| ~supervisor-enabled-yes~ | Enabled column (~yes~) |
| ~supervisor-enabled-no~ | Enabled column (~no~) |
| ~supervisor-reason~ | Reason column values |
| ~supervisor-stage-separator~ | Stage separator rows |

* CLI (~sbin/supervisorctl~)
:PROPERTIES:
:CUSTOM_ID: cli-handbook-sbinsupervisorctl
:END:

The shell wrapper is transport-only; behavior is implemented in
~supervisor-cli.el~ dispatchers.

Requires the Emacs server to be running:

#+begin_src emacs-lisp
(require 'server)
(unless (server-running-p) (server-start))
#+end_src

** Wrapper Syntax

#+begin_src bash
sbin/supervisorctl [WRAPPER-OPTIONS] COMMAND [COMMAND-ARGS]
#+end_src

** Wrapper Options

| Option | Notes |
| ~--help~, ~-h~ | Show wrapper help |
| ~--json~ | Request JSON output from CLI dispatcher |
| ~--socket NAME~, ~--socket-name NAME~, ~-s NAME~ | Use specific local socket |
| ~--server-file PATH~, ~-f PATH~ | Use server file transport |
| ~--timeout N~, ~-t N~ | Pass wait timeout to ~emacsclient -w~ |

Wrapper transport rules:

- ~--socket~ and ~--server-file~ are mutually exclusive.
- ~--server-file~ emits a TCP transport warning.

Wrapper/dispatcher usage behavior:

- Wrapper ~--help~ prints wrapper option help.
- Calling ~supervisorctl~ with no command prints dispatcher usage text and
  command list.

** CLI Commands

Systemctl-compatible commands:

- ~status [ID...]~ (detail with IDs, overview without)
- ~list-units [ID...]~ (overview table)
- ~show ID~ (all properties of a unit)
- ~start [-- ID...]~
- ~stop [-- ID...]~
- ~restart [-- ID...]~
- ~enable [--] ID...~
- ~disable [--] ID...~
- ~mask [--] ID...~ (always disabled, overrides enable)
- ~unmask [--] ID...~
- ~kill [--signal SIG] [--] ID~
- ~is-active ID~ (exit 0 if running, 3 if not active, 4 if unknown)
- ~is-enabled ID~ (exit 0 if enabled, 1 if disabled/masked, 4 if unknown)
- ~is-failed ID~ (exit 0 if failed/dead, 1 if not failed, 4 if unknown)
- ~daemon-reload~ (reload unit definitions from disk)
- ~reload [--] ID...~ (hot-reload specific units)
- ~cat ID~ (display raw unit file content)
- ~edit ID~ (edit unit file; creates scaffold if missing)
- ~list-dependencies [ID]~
- ~list-timers~

Supervisor-specific commands:

- ~validate~
- ~restart-policy (no|on-success|on-failure|always) [--] ID...~
- ~logging (on|off) [--] ID...~
- ~blame~
- ~logs [--tail N] [--] ID~
- ~ping~
- ~version~

Use ~--~ before IDs that start with ~-~ for commands that accept positional
IDs.

** Command Notes

~status~:

- with IDs: detailed per-unit output for valid units, invalid detail for
  misconfigured units, and "could not be found" for truly missing IDs; non-zero
  exit only when IDs are truly missing (not just invalid)
- without IDs: overview table (delegates to ~list-units~)

~validate~:

- returns exit code ~4~ if service or timer validation errors exist
- returns both service and timer invalid sets

~start~, ~stop~, ~restart~:

- with IDs: operate on those IDs
- with no IDs: operate on whole supervisor (~start~, ~stop~, ~stop+start~)
- ~start~ on a disabled unit: succeeds (session-only, no override change).
  Only masked units are blocked from manual start.

~list-dependencies~:

- no ID: full edge list
- with ID: after/requires/blocks for that ID

~list-timers~:

- explicit disabled response when timer subsystem is gated off

~cat~:

- requires exactly one ID argument
- outputs raw file content from ~supervisor-unit-directory~/ID.el
- error if file does not exist
- JSON: ~{"path": "...", "content": "..."}~

~edit~:

- requires exactly one ID argument
- creates scaffold template if unit file does not exist
- non-interactive: launches ~$VISUAL~ or ~$EDITOR~
- JSON: ~{"path": "...", "created": true/false}~

~daemon-reload~:

- no arguments
- re-reads ~supervisor-programs~ and unit files (when ~supervisor-use-unit-files~
  is non-nil), rebuilds the internal plan
- does NOT start, stop, or restart anything; runtime state is untouched
- after daemon-reload, the next ~start~ or ~reload~ operates on the refreshed
  plan
- JSON: ~{"reloaded": true, "entries": N, "invalid": N}~
- available in dashboard transient menu under "System" group (~X~)

~reload~:

- requires at least one ID argument
- hot-reloads specific units: re-reads config and applies changes per unit
- running simple process: stop gracefully, then start with new definition
  (action: ~reloaded~)
- not running: update stored definition only; next start uses new config
  (action: ~updated~)
- masked unit: skip with warning (action: ~skipped (masked)~)
- unknown ID: error (action: ~error: not found~)
- does NOT affect other units (operates only on the specified IDs)
- exit 0 if all units succeed, exit 1 if any unit has an error
- human output: one line per ID showing ~ID: action~
- JSON: ~{"results": [{"id": "x", "action": "reloaded"}, ...]}~
- available in dashboard transient menu under "System" group (~u~)

~is-active~, ~is-enabled~, ~is-failed~:

- require exactly one ID argument
- use strict systemctl-compatible exit codes (not boolean 0/1)
- human output prints the status/state string followed by newline
- ~is-active~: exit 0 if running, exit 3 if not active, exit 4 if no such unit
- ~is-enabled~: exit 0 if enabled, exit 1 if disabled or masked, exit 4 if no
  such unit; output distinguishes "enabled", "disabled", and "masked" states
- ~is-failed~: exit 0 if status is "dead" or "failed", exit 1 if not failed,
  exit 4 if no such unit
- JSON: ~{"id": "...", "<predicate>": true/false, "status": "..."}~
  (~is-enabled~ uses ~"state"~ instead of ~"status"~)

** Output Formats

Human format is default.

~--json~ returns stable object structures per command (for example status,
validate, list-dependencies, list-timers).

Status JSON top-level keys (~status~ without IDs / ~list-units~):

- ~entries~ (array)
- ~invalid~ (array)

Status JSON top-level keys (~status ID...~):

- ~entries~ (array, valid unit detail)
- ~invalid~ (array, invalid configured units with reason)
- ~not_found~ (array, truly missing IDs)

Timer JSON top-level keys:

- ~timers~ (array)
- ~invalid~ (array)

Validation JSON top-level keys:

- ~services~ with ~valid~, ~invalid~, ~errors~
- ~timers~ with ~valid~, ~invalid~, ~errors~

Error JSON shape (for argument/runtime errors):

- ~error~ (boolean)
- ~message~ (string)
- ~exitcode~ (integer)

Empty collections are encoded as arrays (not ~null~).

** Exit Codes

| Code | Meaning |
| ~0~ | Success |
| ~1~ | Runtime failure (also: ~is-enabled~ disabled/masked, ~is-failed~ not failed) |
| ~2~ | Invalid arguments |
| ~3~ | ~is-active~: unit exists but not active (systemctl parity) |
| ~4~ | ~is-*~: no such unit; also: ~validate~ validation failed |
| ~69~ | Emacs server unavailable (EX_UNAVAILABLE) |

* Events and Hooks
:PROPERTIES:
:CUSTOM_ID: events-and-hooks
:END:

** Unified Event Hook

~supervisor-event-hook~ receives one plist per event:

- ~:type~ (symbol)
- ~:ts~ (float timestamp)
- ~:id~ (string or ~nil~)
- ~:stage~ (symbol or ~nil~)
- ~:data~ (plist)

Event types:

- ~stage-start~
- ~stage-complete~
- ~process-started~
- ~process-ready~
- ~process-exit~
- ~process-failed~
- ~cleanup~
- ~timer-trigger~
- ~timer-overlap~
- ~timer-success~
- ~timer-failure~

** Minibuffer Notifications

By default, supervisor does not show minibuffer messages for process failures
or non-zero exits. Use an event hook if you want immediate notification:

#+begin_src emacs-lisp
(add-hook 'supervisor-event-hook
          (lambda (event)
            (pcase (plist-get event :type)
              ('process-failed
               (message "Supervisor: FAILED to start %s" (plist-get event :id)))
              ('process-exit
               (let ((code (plist-get (plist-get event :data) :code)))
                 (unless (eq code 0)
                   (message "Supervisor: %s exited with code %s"
                            (plist-get event :id) code)))))))
#+end_src

This is optional. You can also check the dashboard or logs.

* Persistence and Files
:PROPERTIES:
:CUSTOM_ID: persistence-and-files
:END:

** Log Files

- Supervisor-level log file (optional):
- ~<supervisor-log-directory>/supervisor.log~ (controlled by ~supervisor-log-to-file~)
- Per-process logs:
- ~<supervisor-log-directory>/log-<id>.log~ (controlled per service logging policy)

Existing ~log-*.log~ files are rotated on ~supervisor-start~.

** Logging Semantics

~supervisor--log~ emits levels:

- ~error~ and ~warning~ are always shown in minibuffer/log output.
- ~info~ is shown when ~supervisor-verbose~ is non-nil.
- When ~supervisor-log-to-file~ is non-nil, all levels are written to
  ~supervisor.log~ regardless of ~supervisor-verbose~.

** Overrides File

- Path: ~supervisor-overrides-file~
- Default: ~${XDG_STATE_HOME}/supervisor/overrides.eld~ if ~XDG_STATE_HOME~ is
  set, otherwise ~~/.local/state/supervisor/overrides.eld~
- Format: schema-versioned Elisp data

** Timer State File

- Path: ~supervisor-timer-state-file~
- Default: ~${XDG_STATE_HOME}/supervisor/timer-state.eld~ if ~XDG_STATE_HOME~ is
  set, otherwise ~~/.local/state/supervisor/timer-state.eld~
- Active only when timer subsystem is active

* Customization Reference
:PROPERTIES:
:CUSTOM_ID: customization-reference
:END:

All user options (defcustom) are listed below.

** Core Options

| Variable | Default | Purpose |
| ~supervisor-programs~ | ~nil~ | Service definition list |
| ~supervisor-timers~ | ~nil~ | Timer definition list |
| ~supervisor-log-directory~ | ~(expand-file-name "supervisor" user-emacs-directory)~ | Log directory |
| ~supervisor-restart-delay~ | ~2~ | Restart delay (seconds) |
| ~supervisor-max-restarts~ | ~3~ | Crash-loop threshold |
| ~supervisor-restart-window~ | ~60~ | Crash-loop time window (seconds) |
| ~supervisor-shutdown-timeout~ | ~3~ | Graceful shutdown timeout |
| ~supervisor-oneshot-default-wait~ | ~t~ | Default oneshot blocking behavior |
| ~supervisor-oneshot-timeout~ | ~30~ | Default oneshot timeout |
| ~supervisor-stage-timeout~ | ~nil~ | Per-stage timeout (~nil~ means disabled) |
| ~supervisor-max-concurrent-starts~ | ~nil~ | Max concurrent stage spawns |
| ~supervisor-verbose~ | ~nil~ | Show info-level messages |
| ~supervisor-log-to-file~ | ~nil~ | Write supervisor events to file |
| ~supervisor-watch-config~ | ~nil~ | Config file watch and auto-reload |
| ~supervisor-overrides-file~ | ~(XDG_STATE_HOME or ~/.local/state)/supervisor/overrides.eld~ | Override persistence path |

** Unit-File Options

| Variable | Default | Purpose |
| ~supervisor-use-unit-files~ | ~nil~ | Enable unit-file loading and merge |
| ~supervisor-unit-directory~ | ~(XDG_CONFIG_HOME or ~/.config)/supervisor/units/~ | Unit files directory |

** Timer Options

| Variable | Default | Purpose |
| ~supervisor-timer-state-file~ | ~(XDG_STATE_HOME or ~/.local/state)/supervisor/timer-state.eld~ | Timer state persistence path |
| ~supervisor-timer-retry-intervals~ | ~'(30 120 600)~ | Retry schedule |
| ~supervisor-timer-catch-up-limit~ | ~(* 24 60 60)~ | Catch-up lookback window |

** Dashboard Options

| Variable | Default | Purpose |
| ~supervisor-stage-descriptions~ | ~((stage1 . "X Setup") (stage2 . "System") (stage3 . "Services") (stage4 . "Applets"))~ | Stage labels |
| ~supervisor-dashboard-group-by-stage~ | ~t~ | Group rows by stage |
| ~supervisor-dashboard-show-header-hints~ | ~nil~ | Show header key hint line |
| ~supervisor-dashboard-show-timers~ | ~t~ | Show timer section |
| ~supervisor-auto-refresh-interval~ | ~2~ | Auto-refresh cadence |

* Command Reference
:PROPERTIES:
:CUSTOM_ID: command-reference
:END:

** Interactive Emacs Commands

| Command | Purpose |
| ~M-x supervisor-mode~ | Global supervisor mode (start/stop + file watch) |
| ~M-x supervisor-timer-subsystem-mode~ | Toggle experimental timer subsystem gate |
| ~M-x supervisor-start~ | Build plan and start staged scheduler |
| ~M-x supervisor-stop~ | Async graceful stop |
| ~M-x supervisor-stop-now~ | Sync hard stop |
| ~M-x supervisor-validate~ | Validate config without start |
| ~M-x supervisor-dry-run~ | Show execution plan without start |
| ~M-x supervisor-migrate-config~ | Emit canonical schema v1 config |
| ~M-x supervisor-overrides-load~ | Load overrides from disk |
| ~M-x supervisor-overrides-save~ | Save overrides to disk |
| ~M-x supervisor-overrides-clear~ | Clear overrides in memory + file |
| ~M-x supervisor~ | Open dashboard |
| ~M-x supervisor-handbook~ | Open README.org handbook (read-only) |

** Dashboard Interactive Commands

| Command | Purpose |
| ~M-x supervisor-dashboard-refresh~ | Refresh dashboard buffer |
| ~M-x supervisor-dashboard-cycle-filter~ | Cycle stage filter |
| ~M-x supervisor-dashboard-cycle-tag-filter~ | Cycle tag filter |
| ~M-x supervisor-dashboard-describe-entry~ | Describe selected row |
| ~M-x supervisor-dashboard-help~ | Open dashboard help |
| ~M-x supervisor-dashboard-toggle-auto-refresh~ | Toggle auto-refresh |
| ~M-x supervisor-dashboard-quit~ | Quit dashboard |
| ~M-x supervisor-dashboard-toggle-restart~ | Cycle restart policy (no/on-success/on-failure/always) |
| ~M-x supervisor-dashboard-toggle-enabled~ | Toggle enabled override |
| ~M-x supervisor-dashboard-toggle-mask~ | Toggle mask (always disabled) |
| ~M-x supervisor-dashboard-start~ | Start selected service |
| ~M-x supervisor-dashboard-stop~ | Stop selected service (graceful, suppresses restart) |
| ~M-x supervisor-dashboard-restart~ | Restart selected service (stop + start) |
| ~M-x supervisor-dashboard-kill~ | Kill selected service (send signal, restart unchanged) |
| ~M-x supervisor-dashboard-kill-force~ | Kill selected service (no confirm) |
| ~M-x supervisor-dashboard-toggle-logging~ | Toggle logging override |
| ~M-x supervisor-dashboard-view-log~ | Open selected service log |
| ~M-x supervisor-dashboard-cat~ | View unit file (read-only) |
| ~M-x supervisor-dashboard-edit~ | Edit unit file (scaffold if missing) |
| ~M-x supervisor-dashboard-reload-unit~ | Hot-reload unit at point |
| ~M-x supervisor-dashboard-toggle-proced-auto-update~ | Toggle proced auto-update |
| ~M-x supervisor-dashboard-show-deps~ | Show selected service deps |
| ~M-x supervisor-dashboard-blame~ | Show startup timing view |
| ~M-x supervisor-dashboard-show-graph~ | Show full dependency graph |
| ~M-x supervisor-dashboard-menu-open~ | Open transient menu |

* Indexes
:PROPERTIES:
:CUSTOM_ID: indexes
:END:

This is a topical index for targeted lookup of less-obvious behavior.

** Topical Index

- Async oneshots (~:async~, ~:oneshot-wait~): [[#service-definition-handbook-supervisor-programs][Service Definition]], [[#startup-and-lifecycle-model][Startup and Lifecycle Model]]
- Cat unit file (~cat~, ~c~ in dashboard): [[#unit-files-modular-configuration][Unit Files]]
- Blocking oneshot timeout (~:oneshot-timeout~, ~supervisor-oneshot-timeout~): [[#service-definition-handbook-supervisor-programs][Service Definition]], [[#startup-and-lifecycle-model][Startup and Lifecycle Model]], [[#customization-reference][Customization Reference]]
- Command parsing (no implicit shell, use ~sh -c~ when needed): [[#startup-and-lifecycle-model][Startup and Lifecycle Model]]
- Config file watch and debounce (~supervisor-watch-config~): [[#persistence-and-files][Persistence and Files]], [[#customization-reference][Customization Reference]]
- Crash-loop detection (~supervisor-max-restarts~, ~supervisor-restart-window~): [[#startup-and-lifecycle-model][Startup and Lifecycle Model]], [[#customization-reference][Customization Reference]]
- Cycle fallback behavior for dependencies: [[#service-definition-handbook-supervisor-programs][Service Definition]], [[#startup-and-lifecycle-model][Startup and Lifecycle Model]]
- Dashboard filtering (stage/tag): [[#dashboard-handbook-m-x-supervisor][Dashboard (~M-x supervisor~)]]
- Disabled unit manual start (session-only, systemctl model): [[#runtime-overrides-and-reconciliation][Runtime Overrides and Reconciliation]]
- Dashboard live updates (~supervisor-auto-refresh-interval~): [[#dashboard-handbook-m-x-supervisor][Dashboard (~M-x supervisor~)]], [[#customization-reference][Customization Reference]]
- Dashboard mode/filter state (buffer-local stage/tag/auto-refresh): [[#dashboard-handbook-m-x-supervisor][Dashboard (~M-x supervisor~)]]
- Dashboard visual customization (status/type/stage faces): [[#dashboard-handbook-m-x-supervisor][Dashboard (~M-x supervisor~)]]
- Dependency semantics split (~:after~ vs ~:requires~): [[#service-definition-handbook-supervisor-programs][Service Definition]]
- Edit unit file (~edit~, ~E~ in dashboard, scaffold template): [[#unit-files-modular-configuration][Unit Files]]
- Event API (~supervisor-event-hook~ and event types): [[#events-and-hooks][Events and Hooks]]
- Exit code semantics for oneshots (signals stored negative): [[#startup-and-lifecycle-model][Startup and Lifecycle Model]]
- Graceful vs hard stop (~supervisor-stop~ vs ~supervisor-stop-now~): [[#startup-and-lifecycle-model][Startup and Lifecycle Model]], [[#command-reference][Command Reference]]
- Hyphen-prefixed IDs in CLI (use ~--~ separator): [[#cli-handbook-sbinsupervisorctl][CLI (~sbin/supervisorctl~)]]
- JSON contracts (status/validate/list-timers + error shape): [[#cli-handbook-sbinsupervisorctl][CLI (~sbin/supervisorctl~)]]
- Log rotation and log file paths: [[#persistence-and-files][Persistence and Files]], [[#customization-reference][Customization Reference]]
- Logging pipeline (~supervisor--log~, ~supervisor-verbose~, ~supervisor-log-to-file~): [[#persistence-and-files][Persistence and Files]], [[#customization-reference][Customization Reference]]
- Manual stop behavior and restart suppression: [[#startup-and-lifecycle-model][Startup and Lifecycle Model]], [[#runtime-overrides-and-reconciliation][Runtime Overrides and Reconciliation]]
- Mask/unmask (~mask~, ~unmask~, ~m~ in dashboard): [[#runtime-overrides-and-reconciliation][Runtime Overrides and Reconciliation]]
- Max concurrent stage starts (~supervisor-max-concurrent-starts~): [[#startup-and-lifecycle-model][Startup and Lifecycle Model]], [[#customization-reference][Customization Reference]]
- Migration from ~supervisor-programs~ to unit files (~supervisor-migrate-config~): [[#migrating-to-unit-files][Migrating to Unit Files]]
- Override precedence (runtime override vs config default): [[#runtime-overrides-and-reconciliation][Runtime Overrides and Reconciliation]]
- Override persistence (~supervisor-overrides-file~): [[#runtime-overrides-and-reconciliation][Runtime Overrides and Reconciliation]], [[#persistence-and-files][Persistence and Files]]
- Reload unit (~reload~, ~u~ in dashboard): [[#cli-handbook-sbinsupervisorctl][CLI (~sbin/supervisorctl~)]]
- Security boundary (~emacsclient --eval~, server socket trust): [[#security][Security]]
- Wrapper help vs no-command usage text: [[#cli-handbook-sbinsupervisorctl][CLI (~sbin/supervisorctl~)]]
- Stage timeout force-complete (~supervisor-stage-timeout~): [[#startup-and-lifecycle-model][Startup and Lifecycle Model]], [[#customization-reference][Customization Reference]]
- Timer catch-up window (~supervisor-timer-catch-up-limit~, ~:persistent~): [[#timer-subsystem-handbook-experimental][Timer Subsystem (Experimental)]], [[#customization-reference][Customization Reference]]
- Timer disabled/gated behavior (~supervisor-timer-subsystem-mode~ + parent mode): [[#timer-subsystem-handbook-experimental][Timer Subsystem (Experimental)]], [[#command-reference][Command Reference]]
- Timer miss reasons (~overlap~, ~disabled~, ~disabled-target~): [[#timer-subsystem-handbook-experimental][Timer Subsystem (Experimental)]], [[#dashboard-handbook-m-x-supervisor][Dashboard (~M-x supervisor~)]]
- Timer retry policy (~supervisor-timer-retry-intervals~, signal non-retry): [[#timer-subsystem-handbook-experimental][Timer Subsystem (Experimental)]], [[#customization-reference][Customization Reference]]
- Timer state persistence and schema compatibility (~supervisor-timer-state-file~): [[#timer-subsystem-handbook-experimental][Timer Subsystem (Experimental)]], [[#persistence-and-files][Persistence and Files]]
- Unit file scaffold template (created by ~edit~ on missing file): [[#unit-files-modular-configuration][Unit Files]]
- Unit file validate-on-save (after-save-hook in edited buffers): [[#unit-files-modular-configuration][Unit Files]]

* Security
:PROPERTIES:
:CUSTOM_ID: security
:END:

~supervisorctl~ uses ~emacsclient --eval~. Any principal that can connect to
your Emacs server can execute code as your Emacs user.

Security boundary: your Emacs server socket/server-file access controls.

Practical guidance:

- Prefer local socket transport.
- Use ~--server-file~ only when you intentionally operate server-file/TCP mode.
- Keep server auth/socket directories private (owner-only permissions).

* Development
:PROPERTIES:
:CUSTOM_ID: development
:END:

#+begin_src bash
make check
make lint
make test
make test-one TEST=supervisor-test-parse-string-entry
#+end_src

Interactive load:

#+begin_src bash
emacs -Q -l supervisor.el
#+end_src

* License
:PROPERTIES:
:CUSTOM_ID: license
:END:

GPL-3.0-or-later. See ~LICENSE~.
