[[https://github.com/cypherpunk2001/supervisor.el/actions/workflows/ci.yml][https://github.com/cypherpunk2001/supervisor.el/actions/workflows/ci.yml/badge.svg]]

* supervisor.el Handbook

*A process supervisor for Emacs.*

~supervisor.el~ aims to be robust enough to serve as PID 2, but not
init. In practice, it is best suited for userland: managing desktop sessions
under window managers like EXWM, or running inside
long-lived daemonized Emacs instances that need to manage child processes or
automate tasks with timers.

Define your services in Elisp, organize them into startup stages, declare
dependencies between them, and let supervisor handle the rest. When something
crashes, it restarts. When you log out, everything stops cleanly.

** Features

- *Staged startup*: Services start in four stages (stage1 through stage4), so
  your X session setup runs before your system tray, and your tray runs before
  the applets that need it.

- *Dependencies*: Control start order with ~:after~, or pull in requirements
  with ~:requires~.

- *Two service types*: Long-running daemons (~simple~) that restart on crash,
  and run-once scripts (~oneshot~) for initialization commands.

- *Crash recovery*: Simple services automatically restart when they die.
  Crash-looping services are marked failed after repeated crashes.

- *Interactive dashboard*: ~M-x supervisor~ opens a live view where you can
  start, stop, restart, enable, and disable services with single keystrokes.

- *CLI control*: The included ~sbin/supervisorctl~ script lets you manage
  services from any terminal, even remotely via SSH.

- *Scheduled tasks*: An experimental timer subsystem can run oneshots on cron-like
  schedules.

** Requirements

- Emacs 28.1 or later
- Optional: ~transient~ package for the dashboard help menu (~?~ key)
- For CLI: ~emacsclient~, ~base64~, and ~sed~ in your ~PATH~

** Handbook Overview

This document is the complete reference. Run ~M-x supervisor-handbook~ to open
it in Emacs at any time.

The [[#quick-start][Quick Start]] below gets you running immediately. The rest of the handbook
provides detailed reference material:

- [[#service-definition][Service Definition]] - all unit-file keywords for defining services
- [[#unit-files-modular-configuration][Unit Files]] - authority roots, precedence, and unit-file management
- [[#startup-and-lifecycle-model][Startup and Lifecycle Model]] - how stages, dependencies, and restarts work
- [[#runtime-overrides-and-reconciliation][Runtime Overrides]] - enabling, disabling, and policy changes at runtime
- [[#timer-subsystem-handbook-experimental][Timer Subsystem]] - scheduled oneshot execution (experimental)
- [[#dashboard-handbook-m-x-supervisor][Dashboard]] - the interactive UI
- [[#cli-handbook-sbinsupervisorctl][CLI]] - terminal control with ~supervisorctl~
- [[#events-and-hooks][Events and Hooks]] - programmatic integration
- [[#customization-reference][Customization Reference]] - all variables and faces
- [[#command-reference][Command Reference]] - every interactive command
- [[#service-management-comparison][Systems Comparison]] - supervisor vs systemd vs runit
- [[#unplanned-systemd-directives][Unplanned Directives]] - systemd features not implemented

* Quick Start
:PROPERTIES:
:CUSTOM_ID: quick-start
:END:

#+begin_src emacs-lisp
(add-to-list 'load-path "~/repos/supervisor.el")
(require 'supervisor)

;; Use supervisor-stop-now for immediate SIGKILL - ensures clean X session exit
(add-hook 'kill-emacs-hook #'supervisor-stop-now)

;; Don't ask about running processes on exit - supervisor handles cleanup
(setq confirm-kill-processes nil)

;; Start supervisor
(supervisor-start)
#+end_src

Services are defined as individual unit files in your authority roots (default
~~/.config/supervisor.el/~).  For example:

#+begin_src emacs-lisp
;; ~/.config/supervisor.el/xhost.el
(:id "xhost"
 :command "xhost +SI:localuser:$USER"
 :type oneshot
 :stage stage1
 :tags (x-setup))
#+end_src

#+begin_src emacs-lisp
;; ~/.config/supervisor.el/nm-applet.el
(:id "nm-applet"
 :command "nm-applet"
 :type simple
 :stage stage3
 :delay 3
 :restart t
 :tags (applet tray))
#+end_src

With the above configuration running, ~sbin/supervisorctl status~ shows:

#+begin_example
$ sbin/supervisorctl status
ID               TYPE     STAGE    ENABLED  STATUS     RESTART  LOG   PID     REASON
----------------------------------------------------------------------------------------------------
xhost            oneshot  stage1   yes      done       n/a      yes   -       -
xrdb             oneshot  stage1   yes      done       n/a      yes   -       -
xsetroot         oneshot  stage1   yes      done       n/a      yes   -       -
xset-repeat      oneshot  stage1   yes      done       n/a      yes   -       -
xset-dpms        oneshot  stage1   yes      done       n/a      yes   -       -
xset-s           oneshot  stage1   yes      done       n/a      yes   -       -
xinput-mouse     oneshot  stage1   yes      done       n/a      yes   -       -
redshift         oneshot  stage1   yes      done       n/a      yes   -       -
polkit           simple   stage2   yes      running    yes      yes   1280    -
nm-applet        simple   stage3   yes      running    yes      yes   1396    -
blueman-applet   simple   stage4   yes      running    yes      yes   1927    -
pasystray        simple   stage4   yes      running    yes      yes   1442    -
#+end_example

~M-x supervisor~ opens an interactive dashboard for managing services:

#+CAPTION: Supervisor dashboard
[[file:doc/dashboard.png]]

Each service gets its own ~.el~ file in an authority root.  See
[[#unit-files-modular-configuration][Unit Files]] for the full authority-root model, precedence rules, and
all available keywords.

* Service Definition (Unit-File Keywords)
:PROPERTIES:
:CUSTOM_ID: service-definition
:END:

Each unit file is a single plist expression with ~:id~ and ~:command~ required.

** Entry Keywords

| Keyword | Type | Default | Notes |
| ~:id~ | string | *(required)* | Unit ID (non-empty string) |
| ~:command~ | string | *(required)* | Command to execute |
| ~:type~ | symbol | ~simple~ | ~simple~ or ~oneshot~ |
| ~:stage~ | symbol | ~stage3~ | ~stage1~, ~stage2~, ~stage3~, ~stage4~ |
| ~:delay~ | non-negative number | ~0~ | Delays spawn in seconds |
| ~:after~ | string or list of strings | ~nil~ | Ordering dependency (same stage) |
| ~:requires~ | string or list of strings | ~nil~ | Requirement + ordering dependency (same stage) |
| ~:enabled~ | boolean | ~t~ | Enable/disable service |
| ~:disabled~ | boolean | ~nil~ | Inverse form of ~:enabled~ |
| ~:restart~ | boolean or policy symbol | ~always~ | For ~simple~ only; accepts ~t~/~nil~ or ~always~/~no~/~on-success~/~on-failure~ |
| ~:no-restart~ | boolean | ~nil~ | Inverse form of ~:restart~ (~t~ means policy ~no~) |
| ~:logging~ | boolean | ~t~ | Per-process log capture |
| ~:oneshot-blocking~ | boolean | ~supervisor-oneshot-default-blocking~ | For ~oneshot~ only |
| ~:oneshot-async~ | boolean | ~nil~ | Inverse of ~:oneshot-blocking~ |
| ~:oneshot-timeout~ | number or ~nil~ | ~supervisor-oneshot-timeout~ | For ~oneshot~ only |
| ~:tags~ | symbol, string, or list | ~nil~ | Dashboard tag filtering |
| ~:working-directory~ | string | ~nil~ | Process working directory |
| ~:environment~ | alist of ~(KEY . VALUE)~ | ~nil~ | Environment variables |
| ~:environment-file~ | string or list of strings | ~nil~ | Environment file path(s) |
| ~:exec-stop~ | string or list of strings | ~nil~ | Custom stop command(s), ~simple~ only |
| ~:exec-reload~ | string or list of strings | ~nil~ | Custom reload command(s), ~simple~ only |
| ~:restart-sec~ | non-negative number | ~nil~ | Per-unit restart delay, ~simple~ only |
| ~:description~ | string | ~nil~ | Human-readable description, metadata only |
| ~:documentation~ | string or list of strings | ~nil~ | Documentation URIs/paths, metadata only |
| ~:before~ | string or list of strings | ~nil~ | Inverse ordering (same stage), see below |
| ~:wants~ | string or list of strings | ~nil~ | Soft dependency (same stage), see below |
| ~:kill-signal~ | symbol or string | ~SIGTERM~ | Graceful stop signal for this unit |
| ~:kill-mode~ | symbol or string | ~process~ | ~process~ or ~mixed~, see Stop Semantics |
| ~:remain-after-exit~ | boolean | ~nil~ | ~oneshot~ only: latch active on success |
| ~:success-exit-status~ | int, signal symbol/string, or list | ~nil~ | ~simple~ only: extra clean exit criteria |
| ~:user~ | string, integer, or ~nil~ | ~nil~ | Run-as user (requires root, trusted unit source) |
| ~:group~ | string, integer, or ~nil~ | ~nil~ | Run-as group (requires root, trusted unit source) |

** Validation Rules

Validation is performed by unit-file validation
(~supervisor--validate-unit-file-plist~) plus
~supervisor--validate-entry~ during plan building.

- Malformed plist structures are rejected (non-proper lists, odd number of
  elements).
- Unknown keywords are rejected.
- Duplicate plist keys are rejected.
- Unit files require both ~:id~ and ~:command~.
- ~:id~ must be a non-empty string containing only ~A-Z~, ~a-z~, ~0-9~, ~.~,
  ~_~, ~:~, ~@~, and ~-~.
- ~:command~ must be a non-empty, non-whitespace-only string.
- ~:type~ must be symbol ~simple~ or ~oneshot~.
- ~:stage~ must be symbol ~stage1..stage4~.
- ~:delay~ must be non-negative number.
- ~:restart~, when provided, must be ~t~/~nil~ or one of
  ~always~/~no~/~on-success~/~on-failure~.
- ~:oneshot-timeout~ must be a positive number or ~nil~.
- Boolean flag keys (~:enabled~, ~:disabled~, ~:logging~, ~:no-restart~,
  ~:oneshot-blocking~, ~:oneshot-async~) must be exactly ~t~ or ~nil~.
- Mutually exclusive pairs are rejected: ~:enabled~ with ~:disabled~, ~:restart~
  with ~:no-restart~, and ~:oneshot-blocking~ with ~:oneshot-async~.
- ~:restart-sec~ with a disabled restart policy (~:no-restart t~, ~:restart no~,
  or ~:restart nil~) is rejected as contradictory.
- Type restrictions are enforced: ~oneshot~ rejects ~:restart~ and
  ~:no-restart~; ~simple~ rejects ~:oneshot-blocking~, ~:oneshot-async~, and
  ~:oneshot-timeout~.  ~oneshot~ rejects ~:exec-stop~, ~:exec-reload~, and
  ~:restart-sec~ (simple-only keys).
- ~:tags~ must be a symbol, string, or proper list of symbols/strings.  Empty
  strings and ~nil~ elements within the list are rejected.
- ~:after~, ~:requires~, ~:before~, and ~:wants~ must be string or proper list
  of strings.  Empty or whitespace-only dependency IDs are rejected.
  Self-referencing the entry's own ID is rejected.
- ~:working-directory~ must be a string or ~nil~.
- ~:environment~ must be an alist of ~(KEY . VALUE)~ string pairs.  Keys must
  match ~[A-Za-z_][A-Za-z0-9_]*~.  Duplicate keys are rejected.
- ~:environment-file~ must be a string, proper list of strings, or ~nil~.
- ~:exec-stop~ and ~:exec-reload~ must be a string, proper list of strings, or
  ~nil~.  Empty or whitespace-only command strings within are rejected.
- ~:restart-sec~ must be a non-negative number or ~nil~.
- ~:description~ must be a string or ~nil~.
- ~:documentation~ must be a string, proper list of strings, or ~nil~.
- ~:kill-signal~ must be a recognized signal name (e.g., ~SIGTERM~, ~SIGINT~).
- ~:kill-mode~ must be symbol ~process~ or ~mixed~.
- ~:remain-after-exit~ must be boolean; rejected for ~simple~ type.
- ~:success-exit-status~ items must be integers (0--255) or recognized signal
  names; rejected for ~oneshot~ type.
- ~:user~ and ~:group~ must be a string, integer, or ~nil~.  At startup the
  manager must be running as root (euid 0) when either key is set; non-root
  managers reject the unit as invalid.  The unit file must also pass the trust
  gate: it must exist on disk, be owned by root, and not be world-writable.

Invalid entries are skipped at start and shown as ~invalid~ in dashboard
and CLI status/validate output.

** ID Resolution and Duplicate Handling

ID resolution for string entries uses the basename of the first command token
(after ~split-string-and-unquote~).

Duplicate IDs are deterministic:

- First valid occurrence wins.
- Later duplicates are skipped with warning.

** Dependency Semantics: ~:after~, ~:requires~, ~:before~, ~:wants~

- ~:after~: ordering only.
- ~:requires~: pull-in + ordering.
- ~:before~: inverse ordering (~A :before B~ is equivalent to ~B :after A~).
- ~:wants~: soft dependency with ordering preference.

Planner rules:

- All four are constrained to same-stage dependencies.
- Cross-stage ~:after~ and ~:before~ are ignored with warning.
- Cross-stage ~:requires~ is an error (entry invalid).
- Cross-stage ~:wants~ is ignored with warning.
- Missing ~:after~, ~:before~, and ~:wants~ targets are silently dropped.
- Missing ~:requires~ targets are ignored with warning.
- Topological sort uses stable list order as tie-break.
- Cycle fallback clears dependency edges for affected stage and falls back to
  deterministic list order.  ~:before~ and ~:wants~ edges participate in cycle
  detection.

~:wants~ soft dependency semantics:

- A wanted unit that is missing, disabled, masked, or fails to start does not
  block the wanting unit.
- ~:wants~ does not force-start disabled units.

** Internal Normalized Shape

Valid entries are normalized to schema v1 tuple form:

#+begin_src elisp
(id cmd delay enabled-p restart-policy logging-p type stage after
    oneshot-blocking oneshot-timeout tags requires
    working-directory environment environment-file
    exec-stop exec-reload restart-sec
    description documentation before wants
    kill-signal kill-mode remain-after-exit success-exit-status)
#+end_src

Accessor functions (~supervisor-entry-id~, ~supervisor-entry-command~, etc.) are
the canonical way to read entry fields.

** Validation and Dry-Run Commands

~M-x supervisor-verify~:

- validates services
- validates timers when timer module is available
- populates invalid hashes for dashboard/CLI visibility
- opens ~*supervisor-verify*~ report buffer

~M-x supervisor-dry-run~:

- builds plan without starting processes
- prints stage order and resolved dependency metadata
- prints timer validation summary when timers are configured
- opens ~*supervisor-dry-run*~ report buffer

* Unit Files (Modular Configuration)
:PROPERTIES:
:CUSTOM_ID: unit-files-modular-configuration
:END:

Services are defined as individual unit files.  Each unit file is a single ~.el~
file containing one plist expression.

** Authority Roots (Cascading Resolution)

Unit files are loaded from a configurable list of authority roots, searched in
order from lowest to highest precedence.  When the same unit ID exists in
multiple roots, the highest-precedence root wins completely (no key-level
merge).  Non-existent roots are silently skipped.

#+begin_src emacs-lisp
(setq supervisor-unit-authority-path
      '("/usr/lib/supervisor.el/"    ; Tier 1: vendor (lowest precedence)
        "/etc/supervisor.el/"        ; Tier 2: system admin
        "~/.config/supervisor.el/")) ; Tier 3: user (highest precedence)
#+end_src

The default three-tier layout mirrors systemd's resolution order.  You can add,
remove, or reorder roots to suit your environment.

Unit files found across all active roots are resolved at startup using the
precedence rules described below.

** Unit File Format

Each file contains a single plist:

#+begin_src emacs-lisp
;; ~/.config/supervisor.el/nm-applet.el
(:id "nm-applet"
 :command "nm-applet"
 :type simple
 :stage stage3
 :restart t)
#+end_src

Required keys:

- ~:id~ (non-empty string)
- ~:command~ (string, the shell command)

All other keys are optional (~:type~, ~:stage~, ~:delay~, ~:after~, ~:requires~,
~:enabled~, ~:disabled~, ~:restart~, ~:no-restart~, ~:logging~,
~:oneshot-blocking~, ~:oneshot-async~, ~:oneshot-timeout~, ~:tags~,
~:working-directory~, ~:environment~, ~:environment-file~, ~:exec-stop~,
~:exec-reload~, ~:restart-sec~, ~:description~, ~:documentation~, ~:before~,
~:wants~, ~:kill-signal~, ~:kill-mode~, ~:remain-after-exit~,
~:success-exit-status~).

** Unit File Best Practices (Data-Only Declarations)

Unit files are Lisp syntax, but they should be treated as static data
declarations, not mini programs, so validation stays reliable, behavior stays
reproducible, and unit loading stays deterministic.

Recommended:

- Keep values literal and explicit.
- Put conditional logic in wrapper scripts or the service program itself.
- Keep runtime behavior reproducible across machines and restarts.

Discouraged:

- Embedding logic in unit declarations (~if~, ~when~, filesystem checks,
  environment-dependent branching, or read-time evaluation tricks).

Good example (declarative):

#+begin_src emacs-lisp
(:id "backup"
 :command "/usr/local/bin/backup-runner --mode=incremental"
 :type oneshot
 :stage stage4
 :enabled t
 :logging t)
#+end_src

Bad example (logic in declaration):

#+begin_src emacs-lisp
;; Discouraged: dynamic branching in unit data.
;; Keep this kind of logic in a script/program, not the unit file.
(:id "backup"
 :command (if (file-exists-p "/mnt/backup")
              "/usr/local/bin/backup-runner --mode=incremental"
            "/usr/local/bin/backup-runner --mode=local")
 :type oneshot
 :stage stage4)
#+end_src

** Precedence and Merge Semantics

Within each authority root, unit files (~*.el~) are scanned in alphabetical order.
Roots are resolved in the order listed in ~supervisor-unit-authority-path~ (low to
high precedence).  When the same unit ID appears in multiple roots, the
highest-precedence root wins completely---no per-key merge is performed.

- Same root, duplicate IDs: first file wins, later duplicates are skipped with
  warning.
- Cross-root, same ID: highest-precedence root wins, lower-precedence entries
  are shadowed.
- ID absent from all roots: not loaded (use ~edit ID~ to create a new unit).

*** Override Example

A vendor root provides a default service:

#+begin_src emacs-lisp
;; /usr/lib/supervisor.el/polkit.el  (Tier 1, vendor)
(:id "polkit"
 :command "/usr/lib/polkit-gnome/polkit-gnome-authentication-agent-1"
 :type simple
 :stage stage2)
#+end_src

A user root overrides it with a different stage and logging:

#+begin_src emacs-lisp
;; ~/.config/supervisor.el/polkit.el  (Tier 3, user)
(:id "polkit"
 :command "/usr/lib/polkit-gnome/polkit-gnome-authentication-agent-1"
 :type simple
 :stage stage3
 :logging t)
#+end_src

The user definition wins entirely.  The vendor definition is shadowed.

*** Invalid Authority Root Example

If an authority root does not exist, it is silently skipped.  This means a
misconfigured path does not cause an error---it simply contributes no units:

#+begin_src emacs-lisp
(setq supervisor-unit-authority-path
      '("/nonexistent/root/"          ; Silently skipped (does not exist)
        "/etc/supervisor.el/"         ; Active if exists
        "~/.config/supervisor.el/"))  ; Active if exists
#+end_src

*** Invalid Winner Blocks Fallback Example

If the highest-tier unit file for an ID is invalid, it blocks fallback to a
valid lower-tier unit for the same ID.  This prevents surprising behavior where
a broken override silently reverts to the vendor default:

#+begin_src emacs-lisp
;; /usr/lib/supervisor.el/backup.el  (Tier 1, vendor — valid)
(:id "backup"
 :command "/usr/bin/backup-agent"
 :type simple
 :stage stage3)
#+end_src

#+begin_src emacs-lisp
;; ~/.config/supervisor.el/backup.el  (Tier 3, user — INVALID: missing :command)
(:id "backup"
 :type simple)
#+end_src

Result: ~backup~ appears as ~invalid~ in the dashboard and CLI.  The vendor
definition is *not* used as a fallback---the invalid higher-tier winner blocks it.
Fix the user unit file or delete it to unblock the vendor definition.

** Validation

Unit files are validated at load time:

- Unknown keywords are rejected.
- Missing ~:id~ or ~:command~ is rejected.
- ~:id~ must be a non-empty string; ~:command~ must be a string.
- File path is included in validation error messages.
- Invalid unit files are skipped and logged.
- Invalid unit files appear in the dashboard and CLI with ~invalid~ status.

** Editing Unit Files

From the dashboard, press ~E~ on any service row to open its unit file for
editing.  If the file does not exist, a scaffold template is created with the
service ID and common configuration keys commented out.

On save, the unit file is validated automatically and results are reported in
the minibuffer.  A minor mode (~supervisor-edit-mode~) is activated with
convenient return bindings: press ~q~ to return to the ~*supervisor*~
dashboard (prompts to save if modified), or ~C-c C-q~ to save and return
unconditionally.  Killing the buffer also returns to the dashboard.

From the CLI:

#+begin_src sh
supervisorctl edit nm-applet
#+end_src

This resolves the unit file path and launches ~$VISUAL~ or ~$EDITOR~.  If the
file does not exist, a scaffold is created first.  If neither ~$VISUAL~ nor
~$EDITOR~ is set, an error is returned with the unit file path for manual
editing.

** Viewing Unit Files

From the dashboard, press ~c~ on a service row to view its unit file in
read-only mode (~view-mode~).  Press ~q~ to return.

From the CLI:

#+begin_src sh
supervisorctl cat nm-applet
#+end_src

This outputs the raw unit file content.  Returns an error if the file does not
exist.  With ~--json~, returns ~{"path": "...", "content": "..."}~.

** Adding a New Service

*** Step 1: Create the unit file

Create a file in your highest-precedence authority root (default
~~/.config/supervisor.el/~).  The filename should be ~ID.el~ (e.g.,
~nm-applet.el~):

#+begin_src emacs-lisp
;; ~/.config/supervisor.el/nm-applet.el
(:id "nm-applet"
 :command "nm-applet"
 :type simple
 :stage stage3
 :restart t)
#+end_src

Or press ~E~ in the dashboard to scaffold a unit file interactively.

*** Step 2: Reload

Run ~supervisorctl daemon-reload~ to pick up the new unit file.

* Startup and Lifecycle Model
:PROPERTIES:
:CUSTOM_ID: startup-and-lifecycle-model
:END:

** Stages and Ordering

Stage order is fixed:

- ~stage1~
- ~stage2~
- ~stage3~
- ~stage4~

Stages execute sequentially; entries inside a stage execute in dependency order,
with parallelism allowed where dependencies permit.

** Async DAG Scheduler Semantics

Within a stage:

- In-degree 0 entries are eligible to start.
- Dependents unlock when prerequisites become ready.
- Disabled entries are marked ready immediately.
- Start failures mark ready immediately (do not block graph).
- Optional ~supervisor-max-concurrent-starts~ limits active spawn attempts.

Ready semantics:

- ~simple~: ready when process spawns.
- ~oneshot~: ready on exit (success/failure) or timeout.

Stage completion requires all of:

- all entries started/skipped/failed-to-spawn,
- no pending delay timers,
- no pending blocking oneshots.

** Lifecycle State Machine

Per-entry runtime state is tracked in ~supervisor--entry-state~.

States:

- ~stage-not-started~
- ~waiting-on-deps~
- ~delayed~
- ~disabled~
- ~started~
- ~failed-to-spawn~
- ~stage-timeout~

~invalid~ is a surfaced status (from validation hash tables), not a lifecycle FSM
state in ~supervisor--entry-state~.

Invalid transitions signal errors unless forced by internal maintenance paths.

** Process Spawn and Command Execution

Processes are created via ~make-process~.

- Command arguments are parsed by ~split-string-and-unquote~.
- No implicit shell is used.
- Use explicit shell (~sh -c ...~) when shell semantics are required (for
  example pipelines ~cmd1 | cmd2~, redirects ~> file~, or shell expansion like
  ~$HOME~).

** Restart and Crash Loop Policy (~simple~)

Restart behavior is controlled by effective restart policy
(config + runtime override).  The four restart policies are:

| Policy | Behavior |
|--------+----------|
| ~no~ | Never auto-restart |
| ~on-success~ | Restart only on clean exit (exit 0 or clean signal) |
| ~on-failure~ | Restart only on non-clean exit |
| ~always~ | Restart regardless of exit type |

Clean exit means exit code 0, or a signal in ~SIGHUP~, ~SIGINT~,
~SIGPIPE~, ~SIGTERM~.  The ~:success-exit-status~ keyword extends this
set with additional numeric exit codes and/or signal names per unit.
For example, ~:success-exit-status (42 SIGUSR1)~ treats exit code 42
and ~SIGUSR1~ as clean exits for restart-policy evaluation.

Set the policy at runtime with ~r~ in the dashboard (cycles through all
four) or via CLI: ~supervisorctl restart-policy always myservice~.

Crash-loop protection:

- Delay: ~supervisor-restart-delay~ (overridden per-unit by ~:restart-sec~)
- Window: ~supervisor-restart-window~ seconds
- Threshold: ~supervisor-max-restarts~
- On crash-loop threshold, service is marked failed (~dead~) and restart stops.

~oneshot~ services are not auto-restarted.

** Per-Unit Restart Delay (~:restart-sec~)

Set ~:restart-sec~ to override ~supervisor-restart-delay~ for a single unit.
A value of ~0~ means immediate retry.  If ~nil~ (the default), the global
delay applies.  ~simple~ only.

** Working Directory (~:working-directory~)

Set ~:working-directory~ to a path string.  The process starts with that
directory as its working directory.

- ~"~"~ and ~~/...~ are expanded to the home directory.
- Relative paths are resolved against the directory containing the
  authoritative unit file for that unit.
- If the resolved directory does not exist, the process fails to start.

** Environment Variables (~:environment~, ~:environment-file~)

Effective environment build order:

1. Start from inherited ~process-environment~.
2. Apply ~:environment-file~ entries in list order.
3. Apply ~:environment~ pairs in list order.
4. Later assignment for the same key overrides earlier assignment.

~:environment~ is an alist of ~(KEY . VALUE)~ string pairs:

#+begin_src emacs-lisp
:environment (("APP_ENV" . "prod")
              ("LOG_LEVEL" . "info"))
#+end_src

~:environment-file~ is a path (or list of paths) to files containing
~KEY=VALUE~ lines:

- Blank lines and lines starting with ~#~ or ~;~ are ignored.
- Optional ~export ~ prefix is accepted and stripped.
- Key must match ~[A-Za-z_][A-Za-z0-9_]*~.
- Invalid lines produce logged warnings with file:line context (non-fatal).
- Relative paths are resolved against the authoritative unit file directory.
- Leading ~-~ in a path means a missing file is silently ignored; without it,
  a missing file is an error that prevents the process from starting.

** Reload Semantics (~:exec-reload~)

When a running ~simple~ unit has ~:exec-reload~ commands, reloading it
(~supervisorctl reload ID~, dashboard ~l u~) runs the reload commands
sequentially without stopping or restarting the process.  Each command
has a per-command timeout of ~supervisor-shutdown-timeout~ seconds.

- If reload commands succeed, the unit reports ~reloaded~.
- If any reload command fails, the unit reports an error and the process
  continues running.
- If ~:exec-reload~ is ~nil~, reload falls back to the default behavior
  (stop the process, start with new config).

** Oneshot Exit Encoding

For oneshot completion tracking (~supervisor--oneshot-completed~):

- normal exit stores exit code (~0~, ~1~, ...)
- signal death stores negative signal number (~SIGKILL~ -> ~-9~)

This is used by status/reporting and timer retry eligibility.

** Comparison with systemd Oneshot Semantics

Supervisor oneshot services are modeled after systemd's ~Type=oneshot~
services, but the mapping is not one-to-one.

| Supervisor | systemd | Notes |
|------------+---------+-------|
| ~:type oneshot~ | ~Type=oneshot~ | Run-to-completion services |
| ~:oneshot-blocking t~ | ~Type=oneshot~ (inherent) | Blocking is inherent to ~Type=oneshot~; ordering deps wait for exit |
| ~:oneshot-async t~ | No direct equivalent | Process runs without blocking stage advancement |
| ~:oneshot-timeout 30~ | ~TimeoutStartSec=30~ | Kill the process if it hasn't exited in time |
| No restart for oneshot | ~Restart=~ partially valid | systemd allows ~Restart=on-failure~ etc. for oneshot; supervisor forbids all restart for oneshot |
| ~:working-directory~ | ~WorkingDirectory=~ | Process working directory |
| ~:environment~ | ~Environment=~ | Key-value pairs as alist |
| ~:environment-file~ | ~EnvironmentFile=~ | Paths to env files; ~-~ prefix = optional |
| ~:exec-stop~ | ~ExecStop=~ | Custom stop commands (~simple~ only) |
| ~:exec-reload~ | ~ExecReload=~ | Custom reload commands (~simple~ only) |
| ~:restart-sec~ | ~RestartSec=~ | Per-unit restart delay (~simple~ only) |
| ~:description~ | ~Description=~ | Human-readable description |
| ~:documentation~ | ~Documentation=~ | Documentation URIs/paths |
| ~:before~ | ~Before=~ | Inverse ordering dependency |
| ~:wants~ | ~Wants=~ | Soft dependency |
| ~:kill-signal~ | ~KillSignal=~ | Graceful stop signal |
| ~:kill-mode~ | ~KillMode=~ | ~process~ or ~mixed~ (no ~control-group~ or ~none~) |
| ~:remain-after-exit~ | ~RemainAfterExit=~ | Latch active status on success (~oneshot~ only) |
| ~:success-exit-status~ | ~SuccessExitStatus=~ | Extra clean exit criteria (~simple~ only) |

Key differences:

- *Blocking is the default.*  Supervisor oneshots block their stage by
  default (~supervisor-oneshot-default-blocking~ is ~t~).  In systemd,
  blocking is inherent to ~Type=oneshot~: ordered dependencies wait
  for the oneshot process to exit before starting.
  ~RemainAfterExit=~ controls whether the unit stays in "active" state
  after exit, not whether it blocks ordering.
- *Restart policy.*  Supervisor forbids all restart policies for
  oneshot services.  systemd permits ~Restart=on-failure~,
  ~on-abnormal~, ~on-abort~, and ~on-watchdog~ for ~Type=oneshot~
  (restarting on non-clean exit), but disallows ~always~ and
  ~on-success~.
- *Timeout default.*  Supervisor defaults to ~supervisor-oneshot-timeout~
  (30 seconds).  systemd disables the startup timeout for oneshot by
  default (~TimeoutStartSec=infinity~), relying on the administrator
  to set explicit limits.
- *RemainAfterExit.*  Supervisor supports ~:remain-after-exit t~ for
  oneshot units.  If the process exits with code 0, the unit status
  latches to ~active~ until explicitly stopped.  Non-zero exit still
  results in ~failed~ status.  ~stop~ on an active latched unit
  transitions it to ~stopped~.  ~start~ on an active unit is a no-op.
  ~restart~ re-runs the oneshot.
- *Stage model vs dependency model.*  systemd uses target units and
  ordering dependencies to sequence oneshots.  Supervisor uses a fixed
  four-stage model (~stage1~ through ~stage4~) with ~:after~ and
  ~:requires~ for intra-stage ordering.

** Stop Semantics

Per-unit stop (~supervisorctl stop ID~, dashboard ~l t~):

1. If the unit has ~:exec-stop~ commands, they run sequentially with the unit's
   effective working directory and environment.  Each command has a per-command
   timeout of ~supervisor-shutdown-timeout~ seconds.
2. After stop commands complete (or fail), the process is terminated via signal.
   The signal used is the unit's ~:kill-signal~ (default ~SIGTERM~).
3. Stop commands failing does not abort the shutdown path.

~supervisor-stop~ (async graceful):

1. Runs ~:exec-stop~ command chains for applicable simple units.
2. Sends each unit's ~:kill-signal~ (default ~SIGTERM~) to remaining live
   processes.
3. After ~supervisor-shutdown-timeout~, sends ~SIGKILL~ to survivors.
   For units with ~:kill-mode mixed~, ~SIGKILL~ is also sent to discovered
   descendant processes of the main process.

~supervisor-stop-now~ (sync hard stop):

- sends immediate ~SIGKILL~
- waits up to ~0.5s~ for process death
- does not run ~:exec-stop~ commands
- intended for ~kill-emacs-hook~

~:kill-signal~:

- Overrides the default graceful stop signal (~SIGTERM~) for this unit.
- Accepts signal name symbols (e.g., ~SIGQUIT~, ~SIGUSR1~).
- Short forms like ~QUIT~ are normalized to ~SIGQUIT~.
- Applies to stop, restart, and shutdown paths.

~:kill-mode~:

- ~process~ (default): signal only the main supervised process.
- ~mixed~: send the graceful ~:kill-signal~ to the main process first; on
  timeout, send ~SIGKILL~ to both the main process and its discovered
  descendants.
- Descendant discovery uses ~list-system-processes~ and ~process-attributes~
  (PID-tree traversal).  If OS/process metadata is unavailable, a warning is
  logged and behavior falls back to ~process~ mode.

* Runtime Overrides and Reconciliation
:PROPERTIES:
:CUSTOM_ID: runtime-overrides-and-reconciliation
:END:

** Runtime Overrides

Four override tables are supported:

- mask override (~supervisor--mask-override~)
- enabled override (~supervisor--enabled-override~)
- restart override (~supervisor--restart-override~)
- logging override (~supervisor--logging~)

Effective value resolution for enabled state:

- if masked, always disabled (highest precedence),
- else explicit enabled override if present,
- otherwise config default.

Enable/disable semantics follow the systemctl model:

- ~enable ID~: unit should start on next ~supervisor-start~.  Persisted as
  override.
- ~disable ID~: unit should NOT start automatically.  Persisted.
- ~start ID~ on a disabled unit: starts it this session only.  Does not
  change enabled state.  Only mask blocks manual start.

** Persistence of Overrides

Overrides are persisted in ~supervisor-overrides-file~.

- Saved with atomic write (temp file + rename)
- Loaded on ~supervisor-start~
- Corrupt file is logged and preserved

Interactive helpers:

- ~M-x supervisor-overrides-load~
- ~M-x supervisor-overrides-save~
- ~M-x supervisor-overrides-clear~

All dashboard policy commands (~enable~, ~disable~, ~mask~, ~unmask~,
~set-restart-policy~, ~set-logging~) persist overrides immediately via
~supervisor--save-overrides~, matching the CLI behaviour.

* Timer Subsystem (Experimental)
:PROPERTIES:
:CUSTOM_ID: timer-subsystem-handbook-experimental
:END:

Timer subsystem lives in ~supervisor-timer.el~ and is disabled by default.

To enable:

#+begin_src emacs-lisp
(supervisor-mode 1)
(supervisor-timer-subsystem-mode 1)
#+end_src

Both modes must be active for timers to run.

** Timer Configuration (~supervisor-timers~)

Each timer is a plist.

Required keys:

- ~:id~ (non-empty string)
- ~:target~ (non-empty string; must resolve to a ~oneshot~ service)

Trigger keys (at least one required):

- ~:on-calendar~
- ~:on-startup-sec~
- ~:on-unit-active-sec~

Optional keys:

- ~:enabled~ (boolean, default ~t~)
- ~:persistent~ (boolean, default ~t~)

#+begin_src emacs-lisp
(setq supervisor-timers
      '((:id "daily-backup"
         :target "backup-oneshot"
         :on-calendar (:hour 3 :minute 0)
         :persistent t)
        (:id "warm-cache"
         :target "cache-prime"
         :on-startup-sec 45)
        (:id "sync-loop"
         :target "sync-oneshot"
         :on-unit-active-sec 300)))
#+end_src

** Calendar Trigger Format

~:on-calendar~ accepts either:

- single plist, or
- list of plists (earliest next match wins)

Allowed fields:

- ~:minute~ (0..59)
- ~:hour~ (0..23)
- ~:day-of-month~ (1..31)
- ~:month~ (1..12)
- ~:day-of-week~ (0..6)

Field values:

- integer
- non-empty list of integers
- ~*~ wildcard

Semantics:

- next run is computed strictly after current time
- day-by-day search with bounded horizon (28-year coverage for full leap-day +
  weekday combinations)
- DST gaps are handled by validating encoded/decoded wall clock fields

** Trigger Semantics

~:on-startup-sec~:

- positive integer seconds after scheduler startup
- fires once per supervisor session

~:on-unit-active-sec~:

- positive integer seconds after last successful target completion

Combined timers:

- scheduler chooses earliest due trigger among configured trigger types

** Overlap, Disable, and Missing-Target Behavior

When due:

- Disabled timer -> skipped, miss reason ~disabled~
- Active target oneshot -> skipped, miss reason ~overlap~
- Disabled target service -> skipped, miss reason ~disabled-target~
- Missing target entry -> warning, no trigger

Miss metadata is stored in timer state.

** Retry Policy

Configured by ~supervisor-timer-retry-intervals~ (default ~'(30 120 600)~).

- Retryable failures: positive exit codes only
- Non-retryable: signal deaths (negative stored exit codes), nil, and zero
- Retry budget resets on fresh scheduled runs

** Catch-up Policy

Configured by:

- ~:persistent~ per timer (default ~t~)
- ~supervisor-timer-catch-up-limit~ in seconds (default 24h)

On scheduler start, persistent timers may trigger catch-up runs for missed
schedules within the configured window.

** Timer Persistence

Timer runtime state file: ~supervisor-timer-state-file~.

- Atomic writes (temp + rename)
- Schema versioned
- Newer incompatible schema versions are rejected
- Stale timer IDs are pruned when scheduler starts

Persisted keys include:

- ~:last-run-at~
- ~:last-success-at~
- ~:last-failure-at~
- ~:last-exit~
- ~:last-missed-at~
- ~:last-miss-reason~

Transient keys (for example ~:next-run-at~, retry bookkeeping, startup-consumed
state) are recomputed each session.

** Timer Scheduler Lifecycle

- Started after all service stages complete
- Stopped on ~supervisor-stop~, ~supervisor-stop-now~, and when timer mode is disabled
- Uses ~run-at-time~ scheduling (no polling loop)

** Timer Visibility Surfaces

Dashboard:

- Timer section is shown only when
- ~supervisor-dashboard-show-timers~ is non-nil
- timer subsystem is active
- no stage filter is active
- there are timer rows or invalid timer definitions

CLI:

- ~supervisorctl list-timers~ shows timer runtime/invalid definitions
- If subsystem is gated off, command returns explicit disabled status

* Dashboard (~M-x supervisor~)
:PROPERTIES:
:CUSTOM_ID: dashboard-handbook-m-x-supervisor
:END:

Dashboard buffer: ~*supervisor*~, major mode ~supervisor-dashboard-mode~
(derived from ~tabulated-list-mode~).

** Service Columns

- ~ID~
- ~Type~
- ~Stage~
- ~Enabled~
- ~Status~
- ~Restart~
- ~Log~
- ~PID~
- ~Reason~

** Service Status Values

- ~running~
- ~active~ (oneshot with ~:remain-after-exit~ exited successfully)
- ~done~
- ~failed~
- ~dead~
- ~pending~
- ~stopped~
- ~masked~
- ~invalid~

~active~ means a ~:remain-after-exit~ oneshot exited with code 0 and is
latched active until explicitly stopped.
~masked~ means the entry has been explicitly masked and is always disabled.
~invalid~ means configuration/validation failure, not a runtime FSM state.

** Service Reason Values

- ~masked~
- ~disabled~
- ~delayed~
- ~waiting-on-deps~
- ~stage-not-started~
- ~failed-to-spawn~
- ~stage-timeout~
- ~crash-loop~

** Timer Rows in Dashboard

Timer rows are informational and use timer runtime state.

Timer row status values:

- ~active~ (target currently running)
- ~done~ (last exit ~0~)
- ~failed~ (last exit non-zero)
- ~pending~ (no completion yet)

Timer reason column shows either:

- ~missed: <reason>~, or
- ~next: <relative time>~

** Dashboard Keymap

The dashboard uses a Magit-style nested menu model.  Top-level keys handle
navigation, filtering, and system controls.  Actions are grouped into three
submenus accessed by a prefix key followed by a second key.

*** Top-Level Keys

| Key | Function |
| ~f~ | Cycle stage filter (all -> stage1 -> stage2 -> ...) |
| ~F~ | Cycle tag filter |
| ~g~ | Refresh dashboard |
| ~G~ | Toggle auto-refresh (live monitoring) |
| ~t~ | Open ~proced~ (system process list) |
| ~T~ | Toggle proced auto-update mode |
| ~l~ | Open *Lifecycle* submenu |
| ~p~ | Open *Policy* submenu |
| ~i~ | Open *Inspect* submenu |
| ~?~ | Open transient action menu |
| ~h~ | Open dashboard help buffer |
| ~q~ | Quit dashboard |

*** Lifecycle (~l~)

| Key | Function |
| ~s~ | Start process |
| ~t~ | Stop process (graceful, suppresses restart) |
| ~r~ | Restart process (stop + start) |
| ~k~ | Kill process (send signal, restart policy unchanged) |
| ~u~ | Reload unit (re-read config and restart) |
| ~f~ | Reset failed state |

*** Policy (~p~)

Policy actions are explicit verbs (not blind toggles).

| Key | Function |
| ~e~ | Enable entry |
| ~d~ | Disable entry |
| ~m~ | Mask entry (always disabled) |
| ~u~ | Unmask entry |
| ~r~ | Set restart policy (via selection) |
| ~l~ | Set logging (via selection) |

*** Inspect (~i~)

All inspect actions are read-only.

| Key | Function |
| ~i~ | Show entry details (~C-u~ for status legend) |
| ~d~ | Show dependencies for entry |
| ~g~ | Show dependency graph |
| ~b~ | Blame: startup timing sorted by duration |
| ~l~ | View log file |
| ~c~ | View unit file (read-only) |
| ~e~ | Edit unit file (create scaffold if missing) |

*** Notes

- Separator rows reject service actions.
- ~?~ requires the ~transient~ package.
- Full ID is echoed in minibuffer when current row ID exceeds table width.
- *Stop vs Kill*: ~l t~ (stop) gracefully terminates and suppresses
  auto-restart; ~l k~ (kill) sends a signal without changing restart policy.
  Use ~l s~ to start a stopped service again.
- *Restart*: ~l r~ performs a stop-then-start cycle.  Only for ~simple~
  entries.

** Mode Interaction and Buffer-Local State

- ~supervisor-mode~ is the parent global mode; enabling it runs
  ~supervisor-start~, disabling it runs ~supervisor-stop~.
- ~supervisor-timer-subsystem-mode~ is an experimental global gate and only
  becomes active when ~supervisor-mode~ is also enabled.
- ~supervisor-dashboard-mode~ is the major mode for ~*supervisor*~ and can be
  opened independently of whether supervision is currently running.
- Dashboard filters are buffer-local:
  ~supervisor--dashboard-stage-filter~ and ~supervisor--dashboard-tag-filter~.
- Dashboard auto-refresh timer (~supervisor--auto-refresh-timer~) is buffer-local
  and defaults to off until toggled with ~G~ / ~M-x supervisor-dashboard-toggle-auto-refresh~.

** Dashboard Faces

All dashboard faces are in customization group ~supervisor~:

| Face | Used for |
| ~supervisor-status-running~ | Status ~running~ |
| ~supervisor-status-done~ | Status ~done~ |
| ~supervisor-status-failed~ | Status ~failed~ |
| ~supervisor-status-dead~ | Status ~dead~ |
| ~supervisor-status-invalid~ | Status ~invalid~ |
| ~supervisor-status-pending~ | Status ~pending~ |
| ~supervisor-status-stopped~ | Status ~stopped~ |
| ~supervisor-type-simple~ | Type ~simple~ |
| ~supervisor-type-oneshot~ | Type ~oneshot~ |
| ~supervisor-type-timer~ | Type ~timer~ rows |
| ~supervisor-stage-1~ | Stage column ~stage1~ |
| ~supervisor-stage-2~ | Stage column ~stage2~ |
| ~supervisor-stage-3~ | Stage column ~stage3~ |
| ~supervisor-stage-4~ | Stage column ~stage4~ |
| ~supervisor-enabled-yes~ | Enabled column (~yes~) |
| ~supervisor-enabled-no~ | Enabled column (~no~) |
| ~supervisor-reason~ | Reason column values |
| ~supervisor-stage-separator~ | Stage separator rows |

* CLI (~sbin/supervisorctl~)
:PROPERTIES:
:CUSTOM_ID: cli-handbook-sbinsupervisorctl
:END:

The shell wrapper is transport-only; behavior is implemented in
~supervisor-cli.el~ dispatchers.

Requires the Emacs server to be running:

#+begin_src emacs-lisp
(require 'server)
(unless (server-running-p) (server-start))
#+end_src

** Wrapper Syntax

#+begin_src bash
sbin/supervisorctl [WRAPPER-OPTIONS] COMMAND [COMMAND-ARGS]
#+end_src

** Wrapper Options

| Option | Notes |
| ~--help~, ~-h~ | Show wrapper help |
| ~--json~ | Request JSON output from CLI dispatcher |
| ~--socket NAME~, ~--socket-name NAME~, ~-s NAME~ | Use specific local socket |
| ~--server-file PATH~, ~-f PATH~ | Use server file transport |
| ~--timeout N~, ~-t N~ | Pass wait timeout to ~emacsclient -w~ |

Wrapper transport rules:

- ~--socket~ and ~--server-file~ are mutually exclusive.
- ~--server-file~ emits a TCP transport warning.

Wrapper/dispatcher usage behavior:

- Wrapper ~--help~ prints wrapper option help.
- Calling ~supervisorctl~ with no command prints dispatcher usage text and
  command list.

** CLI Commands

Systemctl-compatible commands:

- ~status [ID...]~ (detail with IDs, overview without)
- ~list-units [ID...]~ (overview table)
- ~show ID~ (all properties of a unit)
- ~start [-- ID...]~
- ~stop [-- ID...]~
- ~restart [-- ID...]~
- ~enable [--] ID...~
- ~disable [--] ID...~
- ~mask [--] ID...~ (always disabled, overrides enable)
- ~unmask [--] ID...~
- ~kill [--signal SIG] [--] ID~
- ~is-active ID~ (exit 0 if running or latched active, 3 if not, 4 if unknown)
- ~is-enabled ID~ (exit 0 if enabled, 1 if disabled/masked, 4 if unknown)
- ~is-failed ID~ (exit 0 if failed/dead, 1 if not failed, 4 if unknown)
- ~daemon-reload~ (reload unit definitions from disk)
- ~reload [--] ID...~ (hot-reload specific units)
- ~cat ID~ (display raw unit file content)
- ~edit ID~ (edit unit file; creates scaffold if missing)
- ~list-dependencies [ID]~
- ~list-timers~

Supervisor-specific commands:

- ~verify~
- ~reset-failed [--] [ID...]~ (with IDs: reset those; without: reset all)
- ~restart-policy (no|on-success|on-failure|always) [--] ID...~
- ~logging (on|off) [--] ID...~
- ~blame~
- ~logs [--tail N] [--] ID~
- ~ping~
- ~version~

Use ~--~ before IDs that start with ~-~ for commands that accept positional
IDs.

** Command Notes

~status~:

- with IDs: detailed per-unit output for valid units, invalid detail for
  misconfigured units, and "could not be found" for truly missing IDs; non-zero
  exit only when IDs are truly missing (not just invalid)
- without IDs: overview table (delegates to ~list-units~)

~verify~:

- returns exit code ~4~ if service or timer validation errors exist
- returns both service and timer invalid sets

~reset-failed~:

- with IDs: reset failed state for those entries
- without IDs: reset all failed entries
- clears crash-loop tracking so entries can be restarted

~start~, ~stop~, ~restart~:

- with IDs: operate on those IDs
- with no IDs: operate on whole supervisor (~start~, ~stop~, ~stop+start~)
- ~start~ on a disabled unit: succeeds (session-only, no override change).
  Only masked units are blocked from manual start.

~list-dependencies~:

- no ID: full edge list
- with ID: after/requires/blocks for that ID

~list-timers~:

- explicit disabled response when timer subsystem is gated off

~cat~:

- requires exactly one ID argument
- outputs raw file content from the authoritative unit file (resolved via
  ~supervisor-unit-authority-path~)
- error if file does not exist
- JSON: ~{"path": "...", "content": "..."}~

~edit~:

- requires exactly one ID argument
- resolves path via authority roots; new files are created in the
  highest-precedence active root
- creates scaffold template if unit file does not exist
- reports the authority root and tier in human output and JSON
- non-interactive: launches ~$VISUAL~ or ~$EDITOR~
- JSON: ~{"path": "...", "root": "...", "tier": N, "created": true/false}~

~daemon-reload~:

- no arguments
- re-reads unit files from all authority roots and rebuilds the internal plan
- does NOT start, stop, or restart anything; runtime state is untouched
- after daemon-reload, the next ~start~ or ~reload~ operates on the refreshed
  plan
- JSON: ~{"reloaded": true, "entries": N, "invalid": N}~
- available in dashboard transient menu under "System" group (~X~)

~reload~:

- requires at least one ID argument
- hot-reloads specific units: re-reads config and applies changes per unit
- running simple process: stop gracefully, then start with new definition
  (action: ~reloaded~)
- not running: update stored definition only; next start uses new config
  (action: ~updated~)
- masked unit: skip with warning (action: ~skipped (masked)~)
- unknown ID: error (action: ~error: not found~)
- does NOT affect other units (operates only on the specified IDs)
- exit 0 if all units succeed, exit 1 if any unit has an error
- human output: one line per ID showing ~ID: action~
- JSON: ~{"results": [{"id": "x", "action": "reloaded"}, ...]}~
- available in dashboard transient menu under "System" group (~u~)

~is-active~, ~is-enabled~, ~is-failed~:

- require exactly one ID argument
- use strict systemctl-compatible exit codes (not boolean 0/1)
- human output prints the status/state string followed by newline
- ~is-active~: exit 0 if running or latched active, exit 3 if not active,
  exit 4 if no such unit
- ~is-enabled~: exit 0 if enabled, exit 1 if disabled or masked, exit 4 if no
  such unit; output distinguishes "enabled", "disabled", and "masked" states
- ~is-failed~: exit 0 if status is "dead" or "failed", exit 1 if not failed,
  exit 4 if no such unit
- JSON: ~{"id": "...", "<predicate>": true/false, "status": "..."}~
  (~is-enabled~ uses ~"state"~ instead of ~"status"~)

** Output Formats

Human format is default.

~--json~ returns stable object structures per command (for example status,
verify, list-dependencies, list-timers).

Status JSON top-level keys (~status~ without IDs / ~list-units~):

- ~entries~ (array)
- ~invalid~ (array)

Status JSON top-level keys (~status ID...~):

- ~entries~ (array, valid unit detail)
- ~invalid~ (array, invalid configured units with reason)
- ~not_found~ (array, truly missing IDs)

Timer JSON top-level keys:

- ~timers~ (array)
- ~invalid~ (array)

Validation JSON top-level keys:

- ~services~ with ~valid~, ~invalid~, ~errors~
- ~timers~ with ~valid~, ~invalid~, ~errors~

Error JSON shape (for argument/runtime errors):

- ~error~ (boolean)
- ~message~ (string)
- ~exitcode~ (integer)

Empty collections are encoded as arrays (not ~null~).

** Exit Codes

| Code | Meaning |
| ~0~ | Success |
| ~1~ | Runtime failure (also: ~is-enabled~ disabled/masked, ~is-failed~ not failed) |
| ~2~ | Invalid arguments |
| ~3~ | ~is-active~: unit exists but not active (systemctl parity) |
| ~4~ | ~is-*~: no such unit; also: ~verify~ validation failed |
| ~69~ | Emacs server unavailable (EX_UNAVAILABLE) |

* Events and Hooks
:PROPERTIES:
:CUSTOM_ID: events-and-hooks
:END:

** Unified Event Hook

~supervisor-event-hook~ receives one plist per event:

- ~:type~ (symbol)
- ~:ts~ (float timestamp)
- ~:id~ (string or ~nil~)
- ~:stage~ (symbol or ~nil~)
- ~:data~ (plist)

Event types:

- ~stage-start~
- ~stage-complete~
- ~process-started~
- ~process-ready~
- ~process-exit~
- ~process-failed~
- ~cleanup~
- ~timer-trigger~
- ~timer-overlap~
- ~timer-success~
- ~timer-failure~

** Minibuffer Notifications

By default, supervisor does not show minibuffer messages for process failures
or non-zero exits. Use an event hook if you want immediate notification:

#+begin_src emacs-lisp
(add-hook 'supervisor-event-hook
          (lambda (event)
            (pcase (plist-get event :type)
              ('process-failed
               (message "Supervisor: FAILED to start %s" (plist-get event :id)))
              ('process-exit
               (let ((code (plist-get (plist-get event :data) :code)))
                 (unless (eq code 0)
                   (message "Supervisor: %s exited with code %s"
                            (plist-get event :id) code)))))))
#+end_src

This is optional. You can also check the dashboard or logs.

* Persistence and Files
:PROPERTIES:
:CUSTOM_ID: persistence-and-files
:END:

** Log Files

- Supervisor-level log file (optional):
- ~<supervisor-log-directory>/supervisor.log~ (controlled by ~supervisor-log-to-file~)
- Per-process logs:
- ~<supervisor-log-directory>/log-<id>.log~ (controlled per service logging policy)

Existing ~log-*.log~ files are rotated on ~supervisor-start~.

** Logging Semantics

~supervisor--log~ emits levels:

- ~error~ and ~warning~ are always shown in minibuffer/log output.
- ~info~ is shown when ~supervisor-verbose~ is non-nil.
- When ~supervisor-log-to-file~ is non-nil, all levels are written to
  ~supervisor.log~ regardless of ~supervisor-verbose~.

** Overrides File

- Path: ~supervisor-overrides-file~
- Default: ~${XDG_STATE_HOME}/supervisor/overrides.eld~ if ~XDG_STATE_HOME~ is
  set, otherwise ~~/.local/state/supervisor/overrides.eld~
- Format: schema-versioned Elisp data

** Timer State File

- Path: ~supervisor-timer-state-file~
- Default: ~${XDG_STATE_HOME}/supervisor/timer-state.eld~ if ~XDG_STATE_HOME~ is
  set, otherwise ~~/.local/state/supervisor/timer-state.eld~
- Active only when timer subsystem is active

* Customization Reference
:PROPERTIES:
:CUSTOM_ID: customization-reference
:END:

All user options (defcustom) are listed below.

** Core Options

| Variable | Default | Purpose |
| ~supervisor-timers~ | ~nil~ | Timer definition list |
| ~supervisor-log-directory~ | ~(expand-file-name "supervisor" user-emacs-directory)~ | Log directory |
| ~supervisor-restart-delay~ | ~2~ | Restart delay (seconds) |
| ~supervisor-max-restarts~ | ~3~ | Crash-loop threshold |
| ~supervisor-restart-window~ | ~60~ | Crash-loop time window (seconds) |
| ~supervisor-shutdown-timeout~ | ~3~ | Graceful shutdown timeout |
| ~supervisor-oneshot-default-blocking~ | ~t~ | Default oneshot blocking behavior |
| ~supervisor-oneshot-timeout~ | ~30~ | Default oneshot timeout |
| ~supervisor-stage-timeout~ | ~nil~ | Per-stage timeout (~nil~ means disabled) |
| ~supervisor-max-concurrent-starts~ | ~nil~ | Max concurrent stage spawns |
| ~supervisor-verbose~ | ~nil~ | Show info-level messages |
| ~supervisor-log-to-file~ | ~nil~ | Write supervisor events to file |
| ~supervisor-watch-config~ | ~nil~ | Config file watch and auto-reload |
| ~supervisor-overrides-file~ | ~(XDG_STATE_HOME or ~/.local/state)/supervisor/overrides.eld~ | Override persistence path |

** Unit-File Options

| Variable | Default | Purpose |
| ~supervisor-unit-authority-path~ | ~'("/usr/lib/supervisor.el/" "/etc/supervisor.el/" "~/.config/supervisor.el/")~ | Authority roots (low to high precedence) |
| ~supervisor-unit-directory~ | ~(XDG_CONFIG_HOME or ~/.config)/supervisor/units/~ | Legacy unit directory (deprecated; use ~supervisor-unit-authority-path~) |

** Timer Options

| Variable | Default | Purpose |
| ~supervisor-timer-state-file~ | ~(XDG_STATE_HOME or ~/.local/state)/supervisor/timer-state.eld~ | Timer state persistence path |
| ~supervisor-timer-retry-intervals~ | ~'(30 120 600)~ | Retry schedule |
| ~supervisor-timer-catch-up-limit~ | ~(* 24 60 60)~ | Catch-up lookback window |

** Dashboard Options

| Variable | Default | Purpose |
| ~supervisor-stage-descriptions~ | ~((stage1 . "X Setup") (stage2 . "System") (stage3 . "Services") (stage4 . "Applets"))~ | Stage labels |
| ~supervisor-dashboard-group-by-stage~ | ~t~ | Group rows by stage |
| ~supervisor-dashboard-show-header-hints~ | ~nil~ | Show header key hint line |
| ~supervisor-dashboard-show-timers~ | ~t~ | Show timer section |
| ~supervisor-auto-refresh-interval~ | ~2~ | Auto-refresh cadence |

* Command Reference
:PROPERTIES:
:CUSTOM_ID: command-reference
:END:

** Interactive Emacs Commands

| Command | Purpose |
| ~M-x supervisor-mode~ | Global supervisor mode (start/stop + file watch) |
| ~M-x supervisor-timer-subsystem-mode~ | Toggle experimental timer subsystem gate |
| ~M-x supervisor-start~ | Build plan and start staged scheduler |
| ~M-x supervisor-stop~ | Async graceful stop |
| ~M-x supervisor-stop-now~ | Sync hard stop |
| ~M-x supervisor-verify~ | Verify config without start |
| ~M-x supervisor-dry-run~ | Show execution plan without start |
| ~M-x supervisor-migrate-config~ | Emit canonical schema v1 config |
| ~M-x supervisor-overrides-load~ | Load overrides from disk |
| ~M-x supervisor-overrides-save~ | Save overrides to disk |
| ~M-x supervisor-overrides-clear~ | Clear overrides in memory + file |
| ~M-x supervisor~ | Open dashboard |
| ~M-x supervisor-handbook~ | Open README.org handbook (read-only) |

** Dashboard Interactive Commands

| Command | Purpose |
| ~M-x supervisor-dashboard-lifecycle~ | Open lifecycle submenu |
| ~M-x supervisor-dashboard-policy~ | Open policy submenu |
| ~M-x supervisor-dashboard-inspect~ | Open inspect submenu |
| ~M-x supervisor-dashboard-refresh~ | Refresh dashboard buffer |
| ~M-x supervisor-dashboard-cycle-filter~ | Cycle stage filter |
| ~M-x supervisor-dashboard-cycle-tag-filter~ | Cycle tag filter |
| ~M-x supervisor-dashboard-toggle-auto-refresh~ | Toggle auto-refresh |
| ~M-x supervisor-dashboard-quit~ | Quit dashboard |
| ~M-x supervisor-dashboard-start~ | Start selected service |
| ~M-x supervisor-dashboard-stop~ | Stop selected service (graceful, suppresses restart) |
| ~M-x supervisor-dashboard-restart~ | Restart selected service (stop + start) |
| ~M-x supervisor-dashboard-kill~ | Kill selected service (send signal, restart unchanged) |
| ~M-x supervisor-dashboard-kill-force~ | Kill selected service (no confirm) |
| ~M-x supervisor-dashboard-reset-failed~ | Reset failed state |
| ~M-x supervisor-dashboard-reload-unit~ | Hot-reload unit at point |
| ~M-x supervisor-dashboard-enable~ | Enable entry (explicit) |
| ~M-x supervisor-dashboard-disable~ | Disable entry (explicit) |
| ~M-x supervisor-dashboard-mask~ | Mask entry (always disabled) |
| ~M-x supervisor-dashboard-unmask~ | Unmask entry |
| ~M-x supervisor-dashboard-set-restart-policy~ | Set restart policy (selection) |
| ~M-x supervisor-dashboard-set-logging~ | Set logging (selection) |
| ~M-x supervisor-dashboard-describe-entry~ | Describe selected row |
| ~M-x supervisor-dashboard-show-deps~ | Show selected service deps |
| ~M-x supervisor-dashboard-show-graph~ | Show full dependency graph |
| ~M-x supervisor-dashboard-blame~ | Show startup timing view |
| ~M-x supervisor-dashboard-view-log~ | Open selected service log |
| ~M-x supervisor-dashboard-cat~ | View unit file (read-only) |
| ~M-x supervisor-dashboard-edit~ | Edit unit file (scaffold if missing) |
| ~M-x supervisor-dashboard-help~ | Open dashboard help |
| ~M-x supervisor-dashboard-menu-open~ | Open transient menu |

* Indexes
:PROPERTIES:
:CUSTOM_ID: indexes
:END:

This is a topical index for targeted lookup of less-obvious behavior.

** Topical Index

- Async oneshots (~:oneshot-async~, ~:oneshot-blocking~): [[#service-definition][Service Definition]], [[#startup-and-lifecycle-model][Startup and Lifecycle Model]]
- Cat unit file (~cat~, ~i c~ in dashboard): [[#unit-files-modular-configuration][Unit Files]]
- Blocking oneshot timeout (~:oneshot-timeout~, ~supervisor-oneshot-timeout~): [[#service-definition][Service Definition]], [[#startup-and-lifecycle-model][Startup and Lifecycle Model]], [[#customization-reference][Customization Reference]]
- Command parsing (no implicit shell, use ~sh -c~ when needed): [[#startup-and-lifecycle-model][Startup and Lifecycle Model]]
- Config file watch and debounce (~supervisor-watch-config~): [[#persistence-and-files][Persistence and Files]], [[#customization-reference][Customization Reference]]
- Crash-loop detection (~supervisor-max-restarts~, ~supervisor-restart-window~): [[#startup-and-lifecycle-model][Startup and Lifecycle Model]], [[#customization-reference][Customization Reference]]
- Cycle fallback behavior for dependencies: [[#service-definition][Service Definition]], [[#startup-and-lifecycle-model][Startup and Lifecycle Model]]
- Dashboard filtering (stage/tag): [[#dashboard-handbook-m-x-supervisor][Dashboard (~M-x supervisor~)]]
- Disabled unit manual start (session-only, systemctl model): [[#runtime-overrides-and-reconciliation][Runtime Overrides and Reconciliation]]
- Dashboard live updates (~supervisor-auto-refresh-interval~): [[#dashboard-handbook-m-x-supervisor][Dashboard (~M-x supervisor~)]], [[#customization-reference][Customization Reference]]
- Dashboard mode/filter state (buffer-local stage/tag/auto-refresh): [[#dashboard-handbook-m-x-supervisor][Dashboard (~M-x supervisor~)]]
- Dashboard visual customization (status/type/stage faces): [[#dashboard-handbook-m-x-supervisor][Dashboard (~M-x supervisor~)]]
- Dependency semantics split (~:after~ vs ~:requires~): [[#service-definition][Service Definition]]
- Edit unit file (~edit~, ~i e~ in dashboard, scaffold template): [[#unit-files-modular-configuration][Unit Files]]
- Event API (~supervisor-event-hook~ and event types): [[#events-and-hooks][Events and Hooks]]
- Exit code semantics for oneshots (signals stored negative): [[#startup-and-lifecycle-model][Startup and Lifecycle Model]]
- Graceful vs hard stop (~supervisor-stop~ vs ~supervisor-stop-now~): [[#startup-and-lifecycle-model][Startup and Lifecycle Model]], [[#command-reference][Command Reference]]
- Hyphen-prefixed IDs in CLI (use ~--~ separator): [[#cli-handbook-sbinsupervisorctl][CLI (~sbin/supervisorctl~)]]
- JSON contracts (status/verify/list-timers + error shape): [[#cli-handbook-sbinsupervisorctl][CLI (~sbin/supervisorctl~)]]
- Log rotation and log file paths: [[#persistence-and-files][Persistence and Files]], [[#customization-reference][Customization Reference]]
- Logging pipeline (~supervisor--log~, ~supervisor-verbose~, ~supervisor-log-to-file~): [[#persistence-and-files][Persistence and Files]], [[#customization-reference][Customization Reference]]
- Manual stop behavior and restart suppression: [[#startup-and-lifecycle-model][Startup and Lifecycle Model]], [[#runtime-overrides-and-reconciliation][Runtime Overrides and Reconciliation]]
- Mask/unmask (~mask~, ~unmask~, ~m~ in dashboard): [[#runtime-overrides-and-reconciliation][Runtime Overrides and Reconciliation]]
- Max concurrent stage starts (~supervisor-max-concurrent-starts~): [[#startup-and-lifecycle-model][Startup and Lifecycle Model]], [[#customization-reference][Customization Reference]]
- Adding a new service (~edit~, scaffold template): [[#unit-files-modular-configuration][Unit Files]]
- Override precedence (runtime override vs config default): [[#runtime-overrides-and-reconciliation][Runtime Overrides and Reconciliation]]
- Override persistence (~supervisor-overrides-file~): [[#runtime-overrides-and-reconciliation][Runtime Overrides and Reconciliation]], [[#persistence-and-files][Persistence and Files]]
- Reload unit (~reload~, ~u~ in dashboard): [[#cli-handbook-sbinsupervisorctl][CLI (~sbin/supervisorctl~)]]
- Reset failed state (~reset-failed~, ~F~ in dashboard): [[#cli-handbook-sbinsupervisorctl][CLI (~sbin/supervisorctl~)]], [[#dashboard-handbook-m-x-supervisor][Dashboard (~M-x supervisor~)]]
- Manager targeting (caller identity, ~emacsclient~ discovery): [[#security][Security]]
- Privilege-drop trust gate (~:user~, ~:group~, root-owned unit files): [[#security][Security]]
- Security boundary (~emacsclient --eval~, server socket trust): [[#security][Security]]
- Wrapper help vs no-command usage text: [[#cli-handbook-sbinsupervisorctl][CLI (~sbin/supervisorctl~)]]
- Stage timeout force-complete (~supervisor-stage-timeout~): [[#startup-and-lifecycle-model][Startup and Lifecycle Model]], [[#customization-reference][Customization Reference]]
- Mutator inventory and classification (explicit verb / unit-definition): [[#service-management-comparison][Service Management Systems Comparison]]
- Stage model comparison (supervisor vs systemd targets vs runit stages): [[#service-management-comparison][Service Management Systems Comparison]]
- Systemd command mapping (supervisorctl vs systemctl vs sv): [[#service-management-comparison][Service Management Systems Comparison]]
- Systemd example conversions (unit file to supervisor config): [[#service-management-comparison][Service Management Systems Comparison]]
- Systemd feature support matrix: [[#service-management-comparison][Service Management Systems Comparison]]
- Systemd oneshot comparison (~:oneshot-blocking~, ~:oneshot-timeout~ mapping): [[#startup-and-lifecycle-model][Startup and Lifecycle Model]]
- Timer catch-up window (~supervisor-timer-catch-up-limit~, ~:persistent~): [[#timer-subsystem-handbook-experimental][Timer Subsystem (Experimental)]], [[#customization-reference][Customization Reference]]
- Timer disabled/gated behavior (~supervisor-timer-subsystem-mode~ + parent mode): [[#timer-subsystem-handbook-experimental][Timer Subsystem (Experimental)]], [[#command-reference][Command Reference]]
- Timer miss reasons (~overlap~, ~disabled~, ~disabled-target~): [[#timer-subsystem-handbook-experimental][Timer Subsystem (Experimental)]], [[#dashboard-handbook-m-x-supervisor][Dashboard (~M-x supervisor~)]]
- Timer retry policy (~supervisor-timer-retry-intervals~, signal non-retry): [[#timer-subsystem-handbook-experimental][Timer Subsystem (Experimental)]], [[#customization-reference][Customization Reference]]
- Timer state persistence and schema compatibility (~supervisor-timer-state-file~): [[#timer-subsystem-handbook-experimental][Timer Subsystem (Experimental)]], [[#persistence-and-files][Persistence and Files]]
- Unit file scaffold template (created by ~edit~ on missing file): [[#unit-files-modular-configuration][Unit Files]]
- Unit file validate-on-save (after-save-hook in edited buffers): [[#unit-files-modular-configuration][Unit Files]]

* Security
:PROPERTIES:
:CUSTOM_ID: security
:END:

** Manager Targeting

~supervisorctl~ uses ~emacsclient --eval~.  Which manager instance it reaches
is determined entirely by the standard ~emacsclient~ server-discovery
mechanism, which in turn depends on the caller's OS identity:

- Each user's Emacs server listens on a socket in that user's runtime
  directory (e.g., ~/run/user/UID/emacs~).
- ~emacsclient~ finds the socket belonging to the *caller's* uid.
- There is no supervisor-level routing: manager selection = caller identity.

Operational patterns:

| Goal | Invocation |
| Manage your own services | ~supervisorctl status~ |
| Manage a root-owned manager | ~sudo supervisorctl status~ |
| Manage another user's manager | ~sudo -u alice supervisorctl status~ |

The ~--socket~ and ~--server-file~ wrapper options override discovery when
multiple servers coexist under one uid.

~:user~ and ~:group~ on a unit affect the *spawned process* identity, not
which manager is targeted.

Explicit ~--system~ / ~--user~ scope flags (analogous to ~systemctl --user~)
are deferred to future planning; the current model relies on caller identity
for manager selection.

** Transport Security

~supervisorctl~ uses ~emacsclient --eval~.  Any principal that can connect to
your Emacs server can execute code as your Emacs user.

Security boundary: your Emacs server socket/server-file access controls.

Practical guidance:

- Prefer local socket transport.
- Use ~--server-file~ only when you intentionally operate server-file/TCP mode.
- Keep server auth/socket directories private (owner-only permissions).

** Privilege-Drop Trust Gate

When the manager runs as root and a unit specifies ~:user~ or ~:group~, the
unit file must pass a trust gate before the process is launched:

- The unit must originate from a file on disk (not inline legacy config).
- The file must be owned by root (uid 0).
- The file must not be world-writable.

Units that fail the trust gate are rejected at startup with an ~invalid~
status and a diagnostic reason.  This prevents unprivileged users from
escalating through writable unit files.

* Service Management Systems Comparison
:PROPERTIES:
:CUSTOM_ID: service-management-comparison
:END:

This section provides explicit comparison between supervisor's design and
other service management systems, covering architectural decisions,
terminology mapping, and feature coverage.

** Stage Model vs Targets vs runlevels

Service management systems use different models for grouping and ordering
service startup.

| Concept | supervisor | systemd | runit |
|---------+------------+---------+-------|
| Grouping | 4 fixed stages (~stage1~--~stage4~) | Targets (arbitrary DAG nodes) | 3 stages (~1~--~3~) |
| Ordering within group | ~:after~, ~:requires~ (intra-stage) | ~After=~, ~Requires=~ (global) | Alphabetical within ~/etc/sv/~ |
| Cross-group ordering | Stages run sequentially | ~After=~ across targets | Stages run sequentially |
| Adding new groups | Not supported (4 stages fixed) | Create new ~.target~ unit | Not supported (3 stages fixed) |
| Conditional membership | ~:stage~ keyword on unit | ~WantedBy=~, ~RequiredBy=~ | Symlink presence |
| Default parallelism | Concurrent within stage | Concurrent globally | Sequential per stage |

*** Supervisor Stage Model

Supervisor uses a fixed four-stage pipeline: ~stage1~ through ~stage4~.
Stages execute sequentially: all entries in ~stage1~ must complete (spawn
for simple, exit for blocking oneshot) before ~stage2~ begins.  Within each
stage, entries run concurrently, subject to ~:after~ and ~:requires~
ordering edges.

This model is simple and predictable.  The fixed number of stages means
startup ordering is easy to reason about at a glance: lower stage number
runs first, and dependencies within a stage are explicit.  The trade-off
is less flexibility than a full DAG model: you cannot create arbitrary
grouping points or conditional activation paths.

*** systemd Target Model

systemd uses target units as synchronization points in a directed acyclic
graph.  Any unit can declare ~WantedBy=~ or ~RequiredBy=~ a target, and
targets themselves can depend on other targets.  This provides maximum
flexibility but requires understanding the full dependency graph to predict
startup order.

*** runit Stage Model

runit uses three stages: stage 1 (one-time init), stage 2 (service
supervision), and stage 3 (shutdown).  Stage 1 runs a single script
(~/etc/runit/1~) to completion.  Stage 2 starts ~runsvdir~ which
supervises all services in ~/etc/sv/~ concurrently.  Stage 3 runs a
shutdown script.  Within stage 2, all services start simultaneously with
no ordering mechanism beyond filesystem-level hacks.

*** Recommendation

The four-stage model is appropriate for supervisor's use case: a userland
process manager within Emacs.  The fixed stages provide sufficient
sequencing (setup, system, services, applets) without the complexity of a
full target graph.  The ~:after~ and ~:requires~ edges within stages
handle fine-grained ordering where needed.

** Command Mapping: supervisor vs systemd vs runit

| Operation | supervisor CLI | systemd | runit |
|-----------+----------------+---------+-------|
| Start | ~supervisorctl start ID~ | ~systemctl start ID~ | ~sv start ID~ |
| Stop | ~supervisorctl stop ID~ | ~systemctl stop ID~ | ~sv stop ID~ |
| Restart | ~supervisorctl restart ID~ | ~systemctl restart ID~ | ~sv restart ID~ |
| Kill | ~supervisorctl kill ID~ | ~systemctl kill ID~ | ~sv kill ID~ |
| Enable | ~supervisorctl enable ID~ | ~systemctl enable ID~ | ~ln -s /etc/sv/ID /var/service/~ |
| Disable | ~supervisorctl disable ID~ | ~systemctl disable ID~ | ~rm /var/service/ID~ |
| Mask | ~supervisorctl mask ID~ | ~systemctl mask ID~ | (no equivalent) |
| Reload config | ~supervisorctl reload ID~ | ~systemctl reload ID~ | ~sv hup ID~ |
| Reload all | ~supervisorctl daemon-reload~ | ~systemctl daemon-reload~ | (automatic via ~runsvdir~) |
| Status | ~supervisorctl status ID~ | ~systemctl status ID~ | ~sv status ID~ |
| List all | ~supervisorctl status~ | ~systemctl list-units~ | ~sv status /var/service/*~ |
| Reset failed | ~supervisorctl reset-failed ID~ | ~systemctl reset-failed ID~ | (no equivalent) |
| Set policy | ~supervisorctl restart-policy always ID~ | (edit unit file) | (no equivalent) |
| Set logging | ~supervisorctl logging on ID~ | (edit unit file) | Logging is automatic |

** Feature Support Matrix

| Feature | supervisor | systemd | Notes |
|---------+------------+---------+-------|
| Process supervision | Supported | Supported | Core functionality |
| Restart on crash | Supported | Supported | ~:restart~ / ~Restart=~ |
| Restart policies | Supported | Supported | ~always~, ~on-success~, ~on-failure~, ~no~ |
| Restart backoff | Supported | Supported | ~:restart-sec~ / ~RestartSec=~ |
| Oneshot services | Supported | Supported | ~:type oneshot~ / ~Type=oneshot~ |
| Dependency ordering | Supported | Supported | ~:after~ / ~After=~ |
| Soft dependencies | Supported | Supported | ~:wants~ / ~Wants=~ |
| Hard dependencies | Supported | Supported | ~:requires~ / ~Requires=~ |
| Environment vars | Supported | Supported | ~:environment~ / ~Environment=~ |
| Environment files | Supported | Supported | ~:environment-file~ / ~EnvironmentFile=~ |
| Working directory | Supported | Supported | ~:working-directory~ / ~WorkingDirectory=~ |
| Custom stop command | Supported | Supported | ~:exec-stop~ / ~ExecStop=~ |
| Custom reload | Supported | Supported | ~:exec-reload~ / ~ExecReload=~ |
| Kill signal | Supported | Supported | ~:kill-signal~ / ~KillSignal=~ |
| Kill mode | Partial | Supported | ~process~, ~mixed~ only (no ~control-group~) |
| Remain after exit | Supported | Supported | ~:remain-after-exit~ / ~RemainAfterExit=~ |
| Success exit status | Supported | Supported | ~:success-exit-status~ / ~SuccessExitStatus=~ |
| Runtime overrides | Supported | Partial | Persistent enable/disable/mask/restart-policy/logging |
| Unit file config | Supported | Supported | ~.el~ files / ~.service~ files |
| Timer services | Supported | Supported | Experimental timer subsystem |
| Process metrics | Supported | Supported | Best-effort RSS/CPU via ~process-attributes~ |
| Log management | Partial | Supported | File-based, per-service; no journal integration |
| Socket activation | Not planned | Supported | Outside scope of userland supervisor |
| Cgroup isolation | Not planned | Supported | Requires PID 1 / kernel integration |
| D-Bus activation | Not planned | Supported | Requires D-Bus integration |
| Notification protocol | Not planned | Supported | ~Type=notify~ requires socket protocol |

** Example Conversions: systemd to supervisor

*** Example 1: Simple Daemon

systemd unit:

#+begin_example
[Unit]
Description=My Background Service
After=network.target

[Service]
Type=simple
ExecStart=/usr/bin/my-daemon --config /etc/my-daemon.conf
Restart=on-failure
RestartSec=5
WorkingDirectory=/var/lib/my-daemon

[Install]
WantedBy=multi-user.target
#+end_example

supervisor unit file (~my-daemon.el~):

#+begin_src emacs-lisp
(:id "my-daemon"
 :description "My Background Service"
 :type simple
 :stage stage3
 :restart on-failure
 :restart-sec 5
 :working-directory "/var/lib/my-daemon")
;; Command: /usr/bin/my-daemon --config /etc/my-daemon.conf
#+end_src

Or inline in config:

#+begin_src emacs-lisp
(setq supervisor-programs
      '(("/usr/bin/my-daemon --config /etc/my-daemon.conf"
         :id "my-daemon"
         :description "My Background Service"
         :type simple
         :stage stage3
         :restart on-failure
         :restart-sec 5
         :working-directory "/var/lib/my-daemon")))
#+end_src

*** Example 2: Oneshot Setup Script

systemd unit:

#+begin_example
[Unit]
Description=Create runtime directories

[Service]
Type=oneshot
ExecStart=/usr/bin/mkdir -p /run/myapp
RemainAfterExit=yes

[Install]
WantedBy=multi-user.target
#+end_example

supervisor unit file (~setup-dirs.el~):

#+begin_src emacs-lisp
(:id "setup-dirs"
 :description "Create runtime directories"
 :type oneshot
 :stage stage1
 :remain-after-exit t)
;; Command: /usr/bin/mkdir -p /run/myapp
#+end_src

*** Example 3: Service with Dependencies

systemd unit:

#+begin_example
[Unit]
Description=Web Application
After=database.service
Requires=database.service
Environment=NODE_ENV=production
Environment=PORT=3000

[Service]
Type=simple
ExecStart=/usr/bin/node /opt/webapp/server.js
Restart=always
ExecStop=/usr/bin/kill -TERM $MAINPID
KillSignal=SIGTERM

[Install]
WantedBy=multi-user.target
#+end_example

supervisor unit file (~webapp.el~):

#+begin_src emacs-lisp
(:id "webapp"
 :description "Web Application"
 :type simple
 :stage stage3
 :after ("database")
 :requires ("database")
 :environment (("NODE_ENV" . "production") ("PORT" . "3000"))
 :restart always
 :exec-stop ("/usr/bin/kill -TERM $MAINPID")
 :kill-signal SIGTERM)
;; Command: /usr/bin/node /opt/webapp/server.js
#+end_src

** Mutator Inventory and Classification

Every state-mutating entry point across all modules, classified by
semantic category.  Classification key:

- *Explicit verb*: user-invoked command that performs exactly one named
  operation on a named target.
- *Unit-definition mutation*: re-reads or modifies the on-disk unit
  definition; state changes are a side-effect of the new definition.
- *Implicit (sentinel)*: triggered automatically by a process exit
  event; not directly user-invoked.
- *Implicit (scheduler)*: triggered automatically by the staging engine
  during startup sequencing; not directly user-invoked.
- *UI-local state*: mutates dashboard-local or display state only
  (buffer-local variables, timers); does not change service runtime
  state.

No toggle/cycle mutators for service policy remain.  Legacy toggle
commands (~toggle-restart~, ~toggle-enabled~, ~toggle-mask~,
~toggle-logging~) were removed in favour of explicit verb replacements.

*** Core Engine (~supervisor-core.el~)

Public entry points that change runtime state:

| Function | Category | State mutated |
|----------+----------+---------------|
| ~supervisor-start~ | Explicit verb | Clears all runtime state, loads overrides, builds plan, starts staged scheduler |
| ~supervisor-stop~ | Explicit verb | Sends graceful stop to all processes (async) |
| ~supervisor-stop-now~ | Explicit verb | Sends hard stop to all processes (sync, for ~kill-emacs-hook~) |
| ~supervisor-daemon-reload~ | Unit-definition mutation | Re-reads unit files, refreshes invalid hash |
| ~supervisor-overrides-load~ | Explicit verb | Reads override hash tables from ~supervisor-overrides-file~ |
| ~supervisor-overrides-save~ | Explicit verb | Writes override hash tables to ~supervisor-overrides-file~ |
| ~supervisor-overrides-clear~ | Explicit verb | Clears all override hash tables and deletes file |

Private helpers called by CLI and dashboard (not direct entry points):

| Function | Category | State mutated |
|----------+----------+---------------|
| ~supervisor--manual-start~ | Explicit verb | Clears failed/stopped flags, spawns process, records ~manually-started~ |
| ~supervisor--manual-stop~ | Explicit verb | Stops process, records ~manually-stopped~, clears ~remain-active~ latch |
| ~supervisor--manual-kill~ | Explicit verb | Sends signal to process, restart policy unchanged |
| ~supervisor--reset-failed~ | Explicit verb | Clears ~failed~, ~oneshot-completed~, ~restart-times~ for target |
| ~supervisor--reload-unit~ | Unit-definition mutation | Re-reads unit file, stops/starts if running, clears stale state |
| ~supervisor--policy-enable~ | Explicit verb | Sets/clears ~enabled-override~ with config normalization |
| ~supervisor--policy-disable~ | Explicit verb | Sets/clears ~enabled-override~ with config normalization |
| ~supervisor--policy-mask~ | Explicit verb | Sets ~mask-override~ |
| ~supervisor--policy-unmask~ | Explicit verb | Clears ~mask-override~ |
| ~supervisor--policy-set-restart~ | Explicit verb | Sets/clears ~restart-override~ with config normalization, cancels timer on ~no~ |
| ~supervisor--policy-set-logging~ | Explicit verb | Sets/clears ~logging~ with config normalization |
| ~supervisor--save-overrides~ | Implicit (scheduler) | Writes override hash tables to ~supervisor-overrides-file~ (called by policy commands) |
| ~supervisor--check-crash-loop~ | Implicit (sentinel) | Records restart timestamp; marks ~failed~ if threshold exceeded |
| ~supervisor--make-process-sentinel~ | Implicit (sentinel) | On exit: removes from ~processes~, records ~last-exit-info~, handles oneshot completion, schedules restart |
| ~supervisor--start-process~ | Implicit (scheduler) | Inserts into ~processes~, clears ~manually-stopped~, records ~start-times~ |
| ~supervisor--handle-oneshot-exit~ | Implicit (sentinel) | Records ~oneshot-completed~ exit code, sets ~remain-active~ latch |
| ~supervisor--transition-state~ | Implicit (scheduler) | Updates ~entry-state~ FSM |
| ~supervisor--reconcile~ | Implicit (daemon-reload) | Diffs running vs desired state, stops/starts as needed |

*** CLI (~supervisor-cli.el~)

All CLI subcommand handlers.  Each dispatches to a core helper.

| Subcommand | Function | Category | Core call | Persists |
|------------+----------+----------+-----------+----------|
| ~start~ | ~supervisor--cli-cmd-start~ | Explicit verb | ~supervisor--manual-start~ | No |
| ~stop~ | ~supervisor--cli-cmd-stop~ | Explicit verb | ~supervisor--manual-stop~ / ~supervisor-stop~ | No |
| ~restart~ | ~supervisor--cli-cmd-restart~ | Explicit verb | ~supervisor--manual-stop~ + ~supervisor--manual-start~ | No |
| ~kill~ | ~supervisor--cli-cmd-kill~ | Explicit verb | ~supervisor--manual-kill~ | No |
| ~enable~ | ~supervisor--cli-cmd-enable~ | Explicit verb | ~supervisor--policy-enable~ + ~save-overrides~ | Yes |
| ~disable~ | ~supervisor--cli-cmd-disable~ | Explicit verb | ~supervisor--policy-disable~ + ~save-overrides~ | Yes |
| ~mask~ | ~supervisor--cli-cmd-mask~ | Explicit verb | ~supervisor--policy-mask~ + ~save-overrides~ | Yes |
| ~unmask~ | ~supervisor--cli-cmd-unmask~ | Explicit verb | ~supervisor--policy-unmask~ + ~save-overrides~ | Yes |
| ~restart-policy~ | ~supervisor--cli-cmd-restart-policy~ | Explicit verb | ~supervisor--policy-set-restart~ + ~save-overrides~ | Yes |
| ~logging~ | ~supervisor--cli-cmd-logging~ | Explicit verb | ~supervisor--policy-set-logging~ + ~save-overrides~ | Yes |
| ~reset-failed~ | ~supervisor--cli-cmd-reset-failed~ | Explicit verb | ~supervisor--reset-failed~ | No |
| ~reload~ | ~supervisor--cli-cmd-reload~ | Unit-definition mutation | ~supervisor--reload-unit~ | No |
| ~daemon-reload~ | ~supervisor--cli-cmd-daemon-reload~ | Unit-definition mutation | ~supervisor-daemon-reload~ | No |

*** Dashboard (~supervisor-dashboard.el~)

All interactive dashboard commands that change state.

| Command | Category | Core call | Persists |
|---------+----------+-----------+----------|
| ~supervisor-dashboard-start~ | Explicit verb | ~supervisor--manual-start~ | No |
| ~supervisor-dashboard-stop~ | Explicit verb | ~supervisor--manual-stop~ | No |
| ~supervisor-dashboard-restart~ | Explicit verb | ~supervisor--manual-stop~ + ~supervisor--manual-start~ | No |
| ~supervisor-dashboard-kill~ | Explicit verb | ~supervisor--manual-kill~ | No |
| ~supervisor-dashboard-kill-force~ | Explicit verb | ~supervisor--manual-kill~ (no confirm) | No |
| ~supervisor-dashboard-reset-failed~ | Explicit verb | ~supervisor--reset-failed~ | No |
| ~supervisor-dashboard-enable~ | Explicit verb | ~supervisor--policy-enable~ + ~save-overrides~ | Yes |
| ~supervisor-dashboard-disable~ | Explicit verb | ~supervisor--policy-disable~ + ~save-overrides~ | Yes |
| ~supervisor-dashboard-mask~ | Explicit verb | ~supervisor--policy-mask~ + ~save-overrides~ | Yes |
| ~supervisor-dashboard-unmask~ | Explicit verb | ~supervisor--policy-unmask~ + ~save-overrides~ | Yes |
| ~supervisor-dashboard-set-restart-policy~ | Explicit verb | ~supervisor--policy-set-restart~ + ~save-overrides~ | Yes |
| ~supervisor-dashboard-set-logging~ | Explicit verb | ~supervisor--policy-set-logging~ + ~save-overrides~ | Yes |
| ~supervisor-dashboard-reload-unit~ | Unit-definition mutation | ~supervisor--reload-unit~ | No |
| ~supervisor-dashboard-daemon-reload~ | Unit-definition mutation | ~supervisor-daemon-reload~ | No |
| ~supervisor-dashboard-cycle-filter~ | UI-local state | Sets buffer-local ~supervisor--dashboard-stage-filter~ | No |
| ~supervisor-dashboard-cycle-tag-filter~ | UI-local state | Sets buffer-local ~supervisor--dashboard-tag-filter~ | No |
| ~supervisor-dashboard-toggle-auto-refresh~ | UI-local state | Creates/cancels buffer-local auto-refresh timer | No |
| ~supervisor-dashboard-toggle-proced-auto-update~ | UI-local state | Toggles ~proced-auto-update-flag~ | No |

*** CLI / Dashboard Parity

Every CLI mutator has a dashboard counterpart with identical semantics.

| Operation | CLI | Dashboard | Same core path |
|-----------+-----+-----------+----------------|
| Start | ~start ID~ | ~l s~ | ~supervisor--manual-start~ |
| Stop | ~stop ID~ | ~l t~ | ~supervisor--manual-stop~ |
| Restart | ~restart ID~ | ~l r~ | stop + start |
| Kill | ~kill ID~ | ~l k~ | ~supervisor--manual-kill~ |
| Reset failed | ~reset-failed ID~ | ~l f~ | ~supervisor--reset-failed~ |
| Enable | ~enable ID~ | ~p e~ | ~supervisor--policy-enable~ |
| Disable | ~disable ID~ | ~p d~ | ~supervisor--policy-disable~ |
| Mask | ~mask ID~ | ~p m~ | ~supervisor--policy-mask~ |
| Unmask | ~unmask ID~ | ~p u~ | ~supervisor--policy-unmask~ |
| Restart policy | ~restart-policy ID POLICY~ | ~p r~ | ~supervisor--policy-set-restart~ |
| Logging | ~logging ID on\vert{}off~ | ~p l~ | ~supervisor--policy-set-logging~ |
| Reload unit | ~reload ID~ | ~l u~ | ~supervisor--reload-unit~ |
| Daemon reload | ~daemon-reload~ | ~X~ (transient) | ~supervisor-daemon-reload~ |

All policy mutations (enable/disable/mask/unmask/restart-policy/logging)
route through shared core policy mutators (~supervisor--policy-*~) that
validate entry existence, reject invalid entries, normalize overrides
against config defaults, and return a status plist.  Both CLI and
dashboard call ~supervisor--save-overrides~ after the core mutator
applies the change.

* Unplanned systemd Directives
:PROPERTIES:
:CUSTOM_ID: unplanned-systemd-directives
:END:

The following systemd directives are not implemented in the current codebase
and are not covered by approved implementation plans in this repository.  They
are listed explicitly for auditability.

| Directive | Category |
|-----------+----------|
| ~DefaultDependencies~ | Default dependencies |
| ~WantedBy~ | Install/target graph |
| ~RequiredBy~ | Install/target graph |
| ~Also~ | Install/target graph |
| ~Alias~ | Install/target graph |
| Target units | Install/target graph |
| ~ProtectSystem~ | Cgroup/namespace hardening |
| ~ProtectHome~ | Cgroup/namespace hardening |
| ~NoNewPrivileges~ | Cgroup/namespace hardening |
| ~PrivateTmp~ | Cgroup/namespace hardening |
| ~PrivateNetwork~ | Cgroup/namespace hardening |
| ~PrivateDevices~ | Cgroup/namespace hardening |
| ~ProtectKernelTunables~ | Cgroup/namespace hardening |
| ~ProtectKernelModules~ | Cgroup/namespace hardening |
| ~ProtectControlGroups~ | Cgroup/namespace hardening |
| ~RestrictAddressFamilies~ | Cgroup/namespace hardening |
| ~RestrictNamespaces~ | Cgroup/namespace hardening |
| ~SystemCallFilter~ | Cgroup/namespace hardening |
| ~MemoryMax~ | Resource limits |
| ~MemoryHigh~ | Resource limits |
| ~CPUQuota~ | Resource limits |
| ~TasksMax~ | Resource limits |
| ~LimitNOFILE~ | Resource limits |
| ~LimitCORE~ | Resource limits |
| ~LimitNPROC~ | Resource limits |
| ~OOMPolicy~ | OOM and failure policy |
| ~FailureAction~ | OOM and failure policy |
| ~SuccessAction~ | OOM and failure policy |
| ~StartLimitBurst~ | OOM and failure policy |
| ~StartLimitIntervalSec~ | OOM and failure policy |
| ~WatchdogSec~ | Watchdog |
| ~WatchdogSignal~ | Watchdog |
| ~LoadCredential~ | Credentials and security |
| ~SetCredential~ | Credentials and security |
| ~DynamicUser~ | Credentials and security |
| ~Type=notify~ | Notification protocol |
| ~NotifyAccess~ | Notification protocol |
| ~Type=socket~ | Socket activation |
| Socket units | Socket activation |
| ~Type=dbus~ | D-Bus activation |
| ~BusName~ | D-Bus activation |
| Path units | Paths and mounts |
| Mount units | Paths and mounts |
| Automount units | Paths and mounts |
| systemd timer units | Timers (supervisor has its own timer subsystem) |
| Slice units | Slices and scopes |
| Scope units | Slices and scopes |
| ~Condition*=~ (all condition directives) | Conditions and assertions |
| ~Assert*=~ (all assertion directives) | Conditions and assertions |

Rationale: these are primarily PID 1 / system-manager concerns (cgroups,
namespaces, boot targets) or require integration with system services (D-Bus,
socket activation) that are outside the scope of a userland Emacs process
supervisor.

* Development
:PROPERTIES:
:CUSTOM_ID: development
:END:

#+begin_src bash
make check
make lint
make test
make test-one TEST=supervisor-test-parse-string-entry
#+end_src

Interactive load:

#+begin_src bash
emacs -Q -l supervisor.el
#+end_src

* License
:PROPERTIES:
:CUSTOM_ID: license
:END:

GPL-3.0-or-later. See ~LICENSE~.
