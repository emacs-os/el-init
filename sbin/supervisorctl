#!/bin/sh
# Stay POSIX shell; GNU coreutils assumptions are fine.
# No bashisms.
# CRITICAL: Must pass ShellCheck.
# Maintainer shell style:
# - Only environment variables should be uppercase.
# - Use set -eu by default; use pipefail only where supported and needed.
# - Use ${...} form for variable expansion.
# - Prefer short-circuit guards (for example: [ "${foo}" = "bar" ] && { ...; })
#   instead of if/then/fi when behavior is equivalent.
# - Prefer case/esac when there is more than one branch.
# - Prefer shell parameter expansion over sed/cut/awk when simple.
# - Use printf for messages and output (avoid echo for non-trivial output).
# - Check external dependencies early with command -v.
# - For temp files, use mktemp and cleanup with trap.
# - Use if/then/fi only when required for correctness or clarity.
# supervisorctl - CLI wrapper for supervisor.el
#
# This is a minimal transport shim that calls supervisor--cli-dispatch via
# emacsclient. All parsing, dispatch, and output formatting happens in Elisp.
#
# Usage: supervisorctl [OPTIONS] COMMAND [ARGS...]
#
# Options:
#   --json           Output JSON instead of human-readable text
#   --socket NAME    Use specific Emacs server socket (emacsclient -s)
#   --server-file P  Use server file for TCP (emacsclient -f)
#   --timeout N      Wait at most N seconds for response (default: 10)
#   --help           Show this help message
#
# Systemctl-compatible commands:
#   status [ID...]              Show unit status (detail with IDs, overview without)
#   list-units [ID...]          List units (overview table)
#   show ID                     Show all properties of a unit
#   start [-- ID...]            Start units
#   stop [-- ID...]             Stop units
#   restart [-- ID...]          Restart units
#   enable [--] ID...           Enable units
#   disable [--] ID...          Disable units
#   kill [--signal SIG] [--] ID Send signal to unit
#   list-dependencies [ID]      Show dependency graph
#   list-timers                 Show timer units
#
# Supervisor-specific commands:
#   reconcile                   Reconcile config and runtime
#   validate                    Validate config and show errors
#   restart-policy (on|off) ID...  Set restart policy
#   logging (on|off) ID...      Set logging policy
#   blame                       Show startup timing info
#   logs [--tail N] [--] ID     View unit log file
#   ping                        Check if supervisor is responsive
#   version                     Show version info

set -eu

# Exit codes (must match supervisor-cli-exit-* constants)
exit_failure=1
exit_invalid_args=2
exit_server_unavailable=3

# Default options
socket_name=""
server_file=""
timeout=""
json_flag=""

warn() {
    printf 'Warning: %s\n' "${1}" >&2
}

die() {
    code="${1}"
    shift
    printf 'Error: %s\n' "${*}" >&2
    exit "${code}"
}

require_command() {
    command -v "${1}" >/dev/null 2>&1 || die "${exit_failure}" "Required command not found: ${1}"
}

# Print help
show_help() {
    sed -n '/^# Usage:/,/^$/p' "${0}" | sed 's/^# *//'
    exit 0
}

# Parse our options (before command)
while [ "${#}" -gt 0 ]; do
    case "${1}" in
        --help|-h|help)
            show_help
            ;;
        --json)
            json_flag="--json"
            shift
            ;;
        --socket|--socket-name|-s)
            [ -n "${2-}" ] || {
                die "${exit_invalid_args}" "--socket requires a name"
            }
            socket_name="${2}"
            shift 2
            ;;
        --server-file|-f)
            [ -n "${2-}" ] || {
                die "${exit_invalid_args}" "--server-file requires a path"
            }
            server_file="${2}"
            shift 2
            ;;
        --timeout|-t)
            [ -n "${2-}" ] || {
                die "${exit_invalid_args}" "--timeout requires a number"
            }
            timeout="${2}"
            shift 2
            ;;
        -*)
            # Unknown option - pass it through to dispatcher
            break
            ;;
        *)
            # First non-option argument (the command)
            break
            ;;
    esac
done

# === Transport validation ===

require_command "emacsclient"
require_command "base64"
require_command "sed"

# Reject conflicting transport options
[ -z "${socket_name}" ] || [ -z "${server_file}" ] || {
    die "${exit_invalid_args}" "--socket and --server-file are mutually exclusive"
}

# Warn about TCP transport (server-file implies TCP, not local socket)
[ -n "${server_file}" ] \
    && warn "Using TCP transport via --server-file. Ensure server is localhost-only."

# === Build command ===

# Build the argument list for the Elisp dispatcher
# We need to escape the arguments properly for Elisp string parsing
escape_for_elisp() {
    # Escape backslashes first, then double quotes
    printf '%s' "${1}" | sed 's/\\/\\\\/g; s/"/\\"/g'
}

# Build a Lisp list of quoted strings from remaining args
build_args_list() {
    result=""
    for arg in "${@}"; do
        escaped="$(escape_for_elisp "${arg}")"
        [ -z "${result}" ] && {
            result="\"${escaped}\""
            continue
        }
        result="${result} \"${escaped}\""
    done
    printf '%s' "${result}"
}

# Add --json to args if set
case "${json_flag}" in
    "")
        args_list="$(build_args_list "${@}")"
        ;;
    *)
        args_list="$(build_args_list "${@}" "--json")"
        ;;
esac

# Build emacsclient command
# Default timeout of 10 seconds to avoid indefinite hangs
default_timeout=10
set -- emacsclient
[ -n "${socket_name}" ] && set -- "${@}" -s "${socket_name}"
[ -n "${server_file}" ] && set -- "${@}" -f "${server_file}"
set -- "${@}" -w "${timeout:-${default_timeout}}"

# The Elisp expression to evaluate
# supervisor--cli-dispatch-for-wrapper returns EXITCODE:BASE64OUTPUT
elisp_expr="(supervisor--cli-dispatch-for-wrapper (list ${args_list}))"
set -- "${@}" --eval "${elisp_expr}"

# Run emacsclient and capture output
# Use --eval to evaluate Elisp and return the result
# emacsclient failed (server unavailable, etc.)
output="$("${@}" 2>&1)" || {
    printf '%s\n' "Error: Cannot connect to Emacs server" >&2
    [ -z "${output-}" ] || printf '%s\n' "${output}" >&2
    exit "${exit_server_unavailable}"
}

# The dispatcher returns format: EXITCODE:BASE64OUTPUT
# emacsclient --eval wraps strings in quotes, so we strip those first

# Remove outer quotes from emacsclient output
stripped="${output#\"}"
stripped="${stripped%\"}"

# Extract exit code (everything before first colon)
exit_code="${stripped%%:*}"

# Validate exit code is a number
case "${exit_code}" in
    ''|*[!0-9]*)
        # Fallback: output raw and exit with failure
        printf '%s\n' "${output}"
        exit "${exit_failure}"
        ;;
esac

# Extract base64 output (everything after first colon) and decode
base64_output="${stripped#*:}"
final_output="$(printf '%s' "${base64_output}" | base64 -d 2>/dev/null)" || {
    printf '%s\n' "Error: Failed to decode output" >&2
    printf '%s\n' "${output}" >&2
    exit "${exit_failure}"
}

# Print output and exit
printf '%s' "${final_output}"
exit "${exit_code}"
