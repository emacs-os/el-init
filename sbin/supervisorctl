#!/bin/sh
# supervisorctl - CLI wrapper for supervisor.el
#
# This is a minimal transport shim that calls supervisor--cli-dispatch via
# emacsclient. All parsing, dispatch, and output formatting happens in Elisp.
#
# Usage: supervisorctl [OPTIONS] COMMAND [ARGS...]
#
# Options:
#   --json           Output JSON instead of human-readable text
#   --socket NAME    Use specific Emacs server socket (emacsclient -s)
#   --server-file P  Use server file for TCP (emacsclient -f)
#   --timeout N      Wait at most N seconds for response
#   --help           Show this help message
#
# Commands:
#   status [ID...]   Show status of entries
#   list [ID...]     Alias for status
#   describe ID      Show detailed info for an entry
#   start [ID...]    Start entries (or all if none specified)
#   stop [ID...]     Stop entries (or all if none specified)
#   restart [ID...]  Restart entries (or all if none specified)
#   reload           Reconcile config without full restart
#   validate         Validate config and show errors
#   enable ID...     Enable entries
#   disable ID...    Disable entries
#   restart-policy (on|off) ID...  Set restart policy
#   logging (on|off) ID...         Set logging policy
#   blame            Show startup timing info
#   graph [ID]       Show dependency graph
#   logs ID [--tail N]  View entry log file
#   kill ID [--signal SIG]  Send signal to process
#   ping             Check if supervisor is responsive
#   version          Show version info

set -e

# Exit codes (must match supervisor-cli-exit-* constants)
exit_failure=1
exit_invalid_args=2
exit_server_unavailable=3

# Default options
socket_name=""
server_file=""
timeout=""
json_flag=""

# Print help
show_help() {
    sed -n '2,/^$/p' "${0}" | sed 's/^# *//'
    exit 0
}

# Parse our options (before command)
while [ "${#}" -gt 0 ]; do
    case "${1}" in
        --help|-h)
            show_help
            ;;
        --json)
            json_flag="--json"
            shift
            ;;
        --socket|--socket-name|-s)
            [ -n "${2-}" ] || {
                echo "Error: --socket requires a name" >&2
                exit "${exit_invalid_args}"
            }
            socket_name="${2}"
            shift 2
            ;;
        --server-file|-f)
            [ -n "${2-}" ] || {
                echo "Error: --server-file requires a path" >&2
                exit "${exit_invalid_args}"
            }
            server_file="${2}"
            shift 2
            ;;
        --timeout|-t)
            [ -n "${2-}" ] || {
                echo "Error: --timeout requires a number" >&2
                exit "${exit_invalid_args}"
            }
            timeout="${2}"
            shift 2
            ;;
        -*)
            # Unknown option - pass it through to dispatcher
            break
            ;;
        *)
            # First non-option argument (the command)
            break
            ;;
    esac
done

# === Transport validation ===

# Reject conflicting transport options
[ -z "${socket_name}" ] || [ -z "${server_file}" ] || {
    echo "Error: --socket and --server-file are mutually exclusive" >&2
    exit "${exit_invalid_args}"
}

# Warn about TCP transport (server-file implies TCP, not local socket)
[ -n "${server_file}" ] \
    && echo "Warning: Using TCP transport via --server-file. Ensure server is localhost-only." >&2

# === Build command ===

# Build the argument list for the Elisp dispatcher
# We need to escape the arguments properly for Elisp string parsing
escape_for_elisp() {
    # Escape backslashes first, then double quotes
    printf '%s' "${1}" | sed 's/\\/\\\\/g; s/"/\\"/g'
}

# Build a Lisp list of quoted strings from remaining args
build_args_list() {
    result=""
    for arg in "${@}"; do
        escaped="$(escape_for_elisp "${arg}")"
        [ -z "${result}" ] && {
            result="\"${escaped}\""
            continue
        }
        result="${result} \"${escaped}\""
    done
    printf '%s' "${result}"
}

# Add --json to args if set
case "${json_flag}" in
    "")
        args_list="$(build_args_list "${@}")"
        ;;
    *)
        args_list="$(build_args_list "${@}" "--json")"
        ;;
esac

# Build emacsclient command
set -- emacsclient
[ -n "${socket_name}" ] && set -- "${@}" -s "${socket_name}"
[ -n "${server_file}" ] && set -- "${@}" -f "${server_file}"
[ -n "${timeout}" ] && set -- "${@}" -w "${timeout}"

# The Elisp expression to evaluate
# supervisor--cli-dispatch-for-wrapper returns EXITCODE:BASE64OUTPUT
elisp_expr="(supervisor--cli-dispatch-for-wrapper (list ${args_list}))"
set -- "${@}" --eval "${elisp_expr}"

# Run emacsclient and capture output
# Use --eval to evaluate Elisp and return the result
# emacsclient failed (server unavailable, etc.)
output="$("${@}" 2>&1)" || {
    echo "Error: Cannot connect to Emacs server" >&2
    [ -z "${output}" ] || echo "${output}" >&2
    exit "${exit_server_unavailable}"
}

# The dispatcher returns format: EXITCODE:BASE64OUTPUT
# emacsclient --eval wraps strings in quotes, so we strip those first

# Remove outer quotes from emacsclient output
stripped="$(printf '%s' "${output}" | sed 's/^"//; s/"$//')"

# Extract exit code (everything before first colon)
exit_code="${stripped%%:*}"

# Validate exit code is a number
printf '%s' "${exit_code}" | grep -qE '^[0-9]+$' || {
    # Fallback: output raw and exit with failure
    echo "${output}"
    exit "${exit_failure}"
}

# Extract base64 output (everything after first colon) and decode
base64_output="${stripped#*:}"
final_output="$(printf '%s' "${base64_output}" | base64 -d 2>/dev/null)" || {
    echo "Error: Failed to decode output" >&2
    echo "${output}" >&2
    exit "${exit_failure}"
}

# Print output and exit
printf '%s' "${final_output}"
exit "${exit_code}"
