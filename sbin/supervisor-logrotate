#!/bin/sh
# Stay POSIX shell; GNU coreutils assumptions are fine.
# No bashisms.
# CRITICAL: Must pass ShellCheck.
# Maintainer shell style:
# - Only environment variables should be uppercase.
# - Use set -eu by default; use pipefail only where supported and needed.
# - Use ${...} form for variable expansion.
# - Prefer short-circuit guards (for example: [ "${foo}" = "bar" ] && { ...; })
#   instead of if/then/fi when behavior is equivalent.
# - Prefer case/esac when there is more than one branch.
# - Prefer shell parameter expansion over sed/cut/awk when simple.
# - Use printf for messages and output (avoid echo for non-trivial output).
# - Check external dependencies early with command -v.
# - For temp files, use mktemp and cleanup with trap.
# - Use if/then/fi only when required for correctness or clarity.
# supervisor-logrotate - rotate and prune supervisor.el log files
#
# Rotates active log files by renaming them with a timestamp suffix,
# optionally signals logd writers to reopen, and prunes old rotated files.
#
# Usage: supervisor-logrotate [OPTIONS]
#
# Options:
#   --log-dir DIR       Log directory to operate on (required)
#   --keep-days N       Prune rotated files older than N days (default: 14)
#   --signal-reopen     Send SIGHUP to logd writers after rotation
#   --pid-dir DIR       Directory for writer PID files (default: same as --log-dir)
#   --dry-run           Print actions without executing
#   --help              Show this help message
#

set -eu

warn() {
    printf 'Warning: %s\n' "${1}" >&2
}

info() {
    printf '%s\n' "${1}"
}

die() {
    code="${1}"
    shift
    printf 'Error: %s\n' "${*}" >&2
    exit "${code}"
}

show_help() {
    sed -n '/^# Usage:/,/^$/p' "${0}" | sed 's/^# *//'
    exit 0
}

# --- Defaults ---
log_dir=""
keep_days=14
signal_reopen=0
pid_dir=""
dry_run=0

# --- Parse arguments ---
while [ "${#}" -gt 0 ]; do
    case "${1}" in
        --help|-h)
            show_help
            ;;
        --log-dir)
            [ -n "${2-}" ] || die 1 "--log-dir requires a directory argument"
            log_dir="${2}"
            shift 2
            ;;
        --keep-days)
            [ -n "${2-}" ] || die 1 "--keep-days requires a number"
            keep_days="${2}"
            shift 2
            ;;
        --signal-reopen)
            signal_reopen=1
            shift
            ;;
        --pid-dir)
            [ -n "${2-}" ] || die 1 "--pid-dir requires a directory argument"
            pid_dir="${2}"
            shift 2
            ;;
        --dry-run)
            dry_run=1
            shift
            ;;
        *)
            die 1 "Unknown option: ${1}"
            ;;
    esac
done

# --- Validate ---
[ -n "${log_dir}" ] || die 1 "--log-dir is required"
[ -d "${log_dir}" ] || die 1 "--log-dir is not a directory: ${log_dir}"

# Validate keep_days is a positive integer
case "${keep_days}" in
    ''|*[!0-9]*) die 1 "--keep-days must be a positive integer: ${keep_days}" ;;
esac

# Default pid-dir to log-dir
[ -n "${pid_dir}" ] || pid_dir="${log_dir}"

# --- Dependencies ---
command -v find >/dev/null 2>&1 || die 1 "Required command not found: find"
command -v date >/dev/null 2>&1 || die 1 "Required command not found: date"

# --- Generate timestamp ---
stamp="$(date +%Y%m%d-%H%M%S)"
info "logrotate: start log_dir=${log_dir} keep_days=${keep_days} signal_reopen=${signal_reopen} dry_run=${dry_run}"

# --- Rotate active files ---
# Active files: log-<id>.log and supervisor.log.
# Rotated files have a timestamp suffix: <base>.YYYYMMDD-HHMMSS[.N].log
# (matching supervisor-logd.c make_rotated_name).  IDs may contain dots
# (e.g. svc.1), so we match the specific timestamp pattern, not just
# "contains a dot".
# Timestamp regex for rotated detection (8 digits, dash, 6 digits at end):
# name matches *.NNNNNNNN-NNNNNN.log or *.NNNNNNNN-NNNNNN.N+.log
is_rotated() {
    case "${1}" in
        # With sequence suffix: base.YYYYMMDD-HHMMSS.N.log[.tar.gz]
        *.[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]-[0-9][0-9][0-9][0-9][0-9][0-9].[0-9]*.log) return 0 ;;
        *.[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]-[0-9][0-9][0-9][0-9][0-9][0-9].[0-9]*.log.tar.gz) return 0 ;;
        # Without sequence suffix: base.YYYYMMDD-HHMMSS.log[.tar.gz]
        *.[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]-[0-9][0-9][0-9][0-9][0-9][0-9].log) return 0 ;;
        *.[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]-[0-9][0-9][0-9][0-9][0-9][0-9].log.tar.gz) return 0 ;;
        *) return 1 ;;
    esac
}

# --- Optional tar compression of rotated files ---
# If tar is available, compress each rotated file into a .tar.gz archive.
# On failure, preserve the uncompressed file and warn.
has_tar=0
command -v tar >/dev/null 2>&1 && has_tar=1

compress_rotated() {
    [ "${has_tar}" = "1" ] || return 0
    src_file="${1}"
    src_base="${src_file##*/}"
    src_dir="${src_file%/*}"
    archive="${src_file}.tar.gz"
    case "${dry_run}" in
        1) printf 'compress: %s -> %s\n' "${src_file}" "${archive}" ;;
        *)
            if tar -C "${src_dir}" -czf "${archive}" "${src_base}" 2>/dev/null; then
                rm -f "${src_file}"
                printf 'compress: %s -> %s\n' "${src_file}" "${archive}"
            else
                warn "Failed to compress ${src_file}; preserving uncompressed"
            fi
            ;;
    esac
}

rotate_file() {
    src="${1}"
    base="${src%.log}"
    dest="${base}.${stamp}.log"
    # Handle collision: append .1, .2, etc.
    if [ -e "${dest}" ]; then
        seq=1
        while [ -e "${base}.${stamp}.${seq}.log" ]; do
            seq=$((seq + 1))
        done
        dest="${base}.${stamp}.${seq}.log"
    fi
    case "${dry_run}" in
        1) printf 'rotate: %s -> %s\n' "${src}" "${dest}" ;;
        *)
            mv "${src}" "${dest}"
            printf 'rotate: %s -> %s\n' "${src}" "${dest}"
            compress_rotated "${dest}"
            ;;
    esac
}

# Rotate supervisor.log if it exists
[ -f "${log_dir}/supervisor.log" ] && rotate_file "${log_dir}/supervisor.log"

# Rotate log-*.log files (active only: skip rotated files with timestamp)
for f in "${log_dir}"/log-*.log; do
    [ -f "${f}" ] || continue
    name="${f##*/}"
    is_rotated "${name}" && continue
    rotate_file "${f}"
done

# --- Signal reopen ---
case "${signal_reopen}" in
    1)
        for pidfile in "${pid_dir}"/logd-*.pid; do
            [ -f "${pidfile}" ] || continue
            pid="$(cat "${pidfile}" 2>/dev/null)" || continue
            # Validate PID is numeric
            case "${pid}" in
                ''|*[!0-9]*) continue ;;
            esac
            # Check if process is alive before signaling
            if kill -0 "${pid}" 2>/dev/null; then
                case "${dry_run}" in
                    1) printf 'signal: SIGHUP -> PID %s (%s)\n' "${pid}" "${pidfile}" ;;
                    *)
                        if kill -HUP "${pid}" 2>/dev/null; then
                            printf 'signal: SIGHUP -> PID %s (%s)\n' "${pid}" "${pidfile}"
                        else
                            warn "Failed to send SIGHUP to PID ${pid}"
                        fi
                        ;;
                esac
            fi
        done
        ;;
esac

# --- Prune old rotated files ---
# Rotated files have timestamp suffixes (YYYYMMDD-HHMMSS).  Use find to
# locate candidates by mtime, then filter with is_rotated() to avoid
# deleting active logs for dotted IDs (e.g. log-svc.1.log).
prune_rotated() {
    dir="${1}"
    days="${2}"
    find "${dir}" -maxdepth 1 \( -name 'supervisor.*.log' -o -name 'log-*.*.log' \
       -o -name 'supervisor.*.log.tar.gz' -o -name 'log-*.*.log.tar.gz' \) -mtime +"${days}" -type f | while IFS= read -r f; do
        name="${f##*/}"
        is_rotated "${name}" || continue
        case "${dry_run}" in
            1) printf 'prune: %s\n' "${f}" ;;
            *)
                rm -f "${f}"
                printf 'prune: %s\n' "${f}"
                ;;
        esac
    done
}

prune_rotated "${log_dir}" "${keep_days}"
info "logrotate: complete"
