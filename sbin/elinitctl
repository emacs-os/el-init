#!/bin/sh
# Stay POSIX shell; GNU coreutils assumptions are fine.
# No bashisms.
# CRITICAL: Must pass ShellCheck.
# Maintainer shell style:
# - Only environment variables should be uppercase.
# - Use set -eu by default; use pipefail only where supported and needed.
# - Use ${...} form for variable expansion.
# - Prefer short-circuit guards (for example: [ "${foo}" = "bar" ] && { ...; })
#   instead of if/then/fi when behavior is equivalent.
# - Prefer case/esac when there is more than one branch.
# - Prefer shell parameter expansion over sed/cut/awk when simple.
# - Use printf for messages and output (avoid echo for non-trivial output).
# - Check external dependencies early with command -v.
# - For temp files, use mktemp and cleanup with trap.
# - Use if/then/fi only when required for correctness or clarity.
# elinitctl - CLI wrapper for elinit
#
# This is a minimal transport shim that calls elinit--cli-dispatch via
# emacsclient. All parsing, dispatch, and output formatting happens in Elisp.
#
# Usage: elinitctl [OPTIONS] COMMAND [ARGS...]
#
# Options:
#   --json           Output JSON instead of human-readable text
#   --socket NAME    Use specific Emacs server socket (emacsclient -s)
#   --server-file P  Use server file for TCP (emacsclient -f)
#   --timeout N      Wait at most N seconds for response (default: 10)
#   --help           Show this help message
#
# Systemctl-compatible commands:
#   status [ID...]              Show unit status (detail with IDs, overview without)
#   list-units [ID...]          List units (overview table)
#   show ID                     Show all properties of a unit
#   start [-- ID...]            Start units
#   stop [-- ID...]             Stop units
#   restart [-- ID...]          Restart units
#   enable [--] ID...           Enable units
#   disable [--] ID...          Disable units
#   mask [--] ID...             Mask units (always disabled)
#   unmask [--] ID...           Unmask units
#   kill [--signal SIG] [--] ID Send signal to unit
#   is-active ID                Test if unit is active (0/3/4)
#   is-enabled ID               Test if unit is enabled (0/1/4)
#   is-failed ID                Test if unit is failed (0/1/4)
#   cat ID                      Show unit file content
#   edit ID                     Edit unit file
#   daemon-reload               Reload unit definitions from disk
#   reload [--] ID...           Hot-reload specific units
#   list-dependencies [ID]      Show dependency graph
#   list-timers                 Show timer units
#
# Elinit-specific commands:
#   verify                      Verify config and show errors
#   reset-failed [--] [ID...]   Reset failed state for units
#   restart-policy POLICY ID...   Set restart policy (no|on-success|on-failure|always)
#   logging (on|off) ID...      Set logging policy
#   blame                       Show startup timing info
#   logs [--tail N] [--] ID     View unit log file
#   journal -u ID [-n N] [-p err] [-f] [--since TS] [--until TS]  Structured log records
#   ping                        Check if elinit is responsive
#   version                     Show version info

set -eu

# Exit codes (must match elinit-cli-exit-* constants)
exit_failure=1
exit_invalid_args=2
exit_server_unavailable=69  # EX_UNAVAILABLE (sysexits.h), avoids systemctl code collision

# Default options
socket_name=""
server_file=""
timeout=""
json_flag=""

warn() {
    printf 'Warning: %s\n' "${1}" >&2
}

die() {
    code="${1}"
    shift
    printf 'Error: %s\n' "${*}" >&2
    exit "${code}"
}

require_command() {
    command -v "${1}" >/dev/null 2>&1 || die "${exit_failure}" "Required command not found: ${1}"
}

# Print help
show_help() {
    sed -n '/^# Usage:/,/^$/p' "${0}" | sed 's/^# *//'
    exit 0
}

# Parse our options (before command)
while [ "${#}" -gt 0 ]; do
    case "${1}" in
        --help|-h|help)
            show_help
            ;;
        --json)
            json_flag="--json"
            shift
            ;;
        --socket|--socket-name|-s)
            [ -n "${2-}" ] || {
                die "${exit_invalid_args}" "--socket requires a name"
            }
            socket_name="${2}"
            shift 2
            ;;
        --server-file|-f)
            [ -n "${2-}" ] || {
                die "${exit_invalid_args}" "--server-file requires a path"
            }
            server_file="${2}"
            shift 2
            ;;
        --timeout|-t)
            [ -n "${2-}" ] || {
                die "${exit_invalid_args}" "--timeout requires a number"
            }
            timeout="${2}"
            shift 2
            ;;
        -*)
            # Unknown option - pass it through to dispatcher
            break
            ;;
        *)
            # First non-option argument (the command)
            break
            ;;
    esac
done

# === Transport validation ===

require_command "emacsclient"
require_command "base64"
require_command "sed"

# Reject conflicting transport options
[ -z "${socket_name}" ] || [ -z "${server_file}" ] || {
    die "${exit_invalid_args}" "--socket and --server-file are mutually exclusive"
}

# Warn about TCP transport (server-file implies TCP, not local socket)
[ -n "${server_file}" ] \
    && warn "Using TCP transport via --server-file. Ensure server is localhost-only."

# === Build command ===

# Build the argument list for the Elisp dispatcher
# We need to escape the arguments properly for Elisp string parsing
escape_for_elisp() {
    # Escape backslashes first, then double quotes
    printf '%s' "${1}" | sed 's/\\/\\\\/g; s/"/\\"/g'
}

# Build a Lisp list of quoted strings from remaining args
build_args_list() {
    result=""
    for arg in "${@}"; do
        escaped="$(escape_for_elisp "${arg}")"
        [ -z "${result}" ] && {
            result="\"${escaped}\""
            continue
        }
        result="${result} \"${escaped}\""
    done
    printf '%s' "${result}"
}

# Add --json to args if set
case "${json_flag}" in
    "")
        args_list="$(build_args_list "${@}")"
        ;;
    *)
        args_list="$(build_args_list "${@}" "--json")"
        ;;
esac

# Build emacsclient command
# Default timeout of 10 seconds to avoid indefinite hangs
default_timeout=10
set -- emacsclient
[ -n "${socket_name}" ] && set -- "${@}" -s "${socket_name}"
[ -n "${server_file}" ] && set -- "${@}" -f "${server_file}"
set -- "${@}" -w "${timeout:-${default_timeout}}"

# The Elisp expression to evaluate
# elinit--cli-dispatch-for-wrapper returns EXITCODE:BASE64OUTPUT
elisp_expr="(elinit--cli-dispatch-for-wrapper (list ${args_list}))"
set -- "${@}" --eval "${elisp_expr}"

# Run emacsclient and capture output
# Use --eval to evaluate Elisp and return the result
# emacsclient failed (server unavailable, etc.)
output="$("${@}" 2>&1)" || {
    printf '%s\n' "Error: Cannot connect to Emacs server" >&2
    [ -z "${output-}" ] || printf '%s\n' "${output}" >&2
    exit "${exit_server_unavailable}"
}

# The dispatcher returns format: EXITCODE:BASE64OUTPUT
# emacsclient --eval wraps strings in quotes, so we strip those first

# Remove outer quotes from emacsclient output
stripped="${output#\"}"
stripped="${stripped%\"}"

# Handle FOLLOW protocol for journal -f streaming
case "${stripped}" in
    FOLLOW:*)
        # Parse FOLLOW:<base64>\t<follow_file>\t<session_id>
        # Tab-delimited to avoid conflicts with : in unit IDs / paths
        rest="${stripped#FOLLOW:}"
        _tab="$(printf '\t')"
        follow_b64="${rest%%"${_tab}"*}"
        rest="${rest#*"${_tab}"}"
        follow_file="${rest%%"${_tab}"*}"
        follow_session="${rest#*"${_tab}"}"

        # Decode and print initial output
        initial="$(printf '%s' "${follow_b64}" | base64 -d 2>/dev/null)" || {
            printf '%s\n' "Error: Failed to decode initial output" >&2
            exit "${exit_failure}"
        }
        [ -n "${initial}" ] && printf '%s\n' "${initial}"

        # Cleanup: stop Elisp session and kill tail
        follow_cleanup() {
            set -- emacsclient
            [ -n "${socket_name}" ] && set -- "${@}" -s "${socket_name}"
            [ -n "${server_file}" ] && set -- "${@}" -f "${server_file}"
            set -- "${@}" --eval \
                "(elinit--cli-journal-follow-stop \"${follow_session}\")"
            "${@}" >/dev/null 2>&1 || true
            if [ -n "${tail_pid-}" ]; then
                kill "${tail_pid}" 2>/dev/null || true
            fi
            exit 0
        }
        trap follow_cleanup INT TERM

        # Stream follow file from start (not last 10 lines default)
        tail -n +1 -f "${follow_file}" &
        tail_pid="${!}"
        wait "${tail_pid}" 2>/dev/null || true
        follow_cleanup
        ;;
esac

# Extract exit code (everything before first colon)
exit_code="${stripped%%:*}"

# Validate exit code is a number
case "${exit_code}" in
    ''|*[!0-9]*)
        # Fallback: output raw and exit with failure
        printf '%s\n' "${output}"
        exit "${exit_failure}"
        ;;
esac

# Extract base64 output (everything after first colon) and decode
base64_output="${stripped#*:}"
final_output="$(printf '%s' "${base64_output}" | base64 -d 2>/dev/null)" || {
    printf '%s\n' "Error: Failed to decode output" >&2
    printf '%s\n' "${output}" >&2
    exit "${exit_failure}"
}

# Print output and exit
# Add trailing newline for human-readable output; JSON is already complete.
case "${json_flag}" in
    "") [ -n "${final_output}" ] && printf '%s\n' "${final_output}" ;;
    *)  printf '%s' "${final_output}" ;;
esac
exit "${exit_code}"
