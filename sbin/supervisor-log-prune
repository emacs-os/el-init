#!/bin/sh
# Stay POSIX shell; GNU coreutils assumptions are fine.
# No bashisms.
# CRITICAL: Must pass ShellCheck.
# Maintainer shell style:
# - Only environment variables should be uppercase.
# - Use set -eu by default; use pipefail only where supported and needed.
# - Use ${...} form for variable expansion.
# - Prefer short-circuit guards (for example: [ "${foo}" = "bar" ] && { ...; })
#   instead of if/then/fi when behavior is equivalent.
# - Prefer case/esac when there is more than one branch.
# - Prefer shell parameter expansion over sed/cut/awk when simple.
# - Use printf for messages and output (avoid echo for non-trivial output).
# - Check external dependencies early with command -v.
# - For temp files, use mktemp and cleanup with trap.
# - Use if/then/fi only when required for correctness or clarity.
# supervisor-log-prune - enforce a hard cap on total log directory size
#
# Deletes oldest rotated log files first until the directory is at or
# below the cap.  Active log files are never deleted.  Uses an exclusive
# lock file to prevent concurrent prune races.
#
# Usage: supervisor-log-prune [OPTIONS]
#
# Options:
#   --log-dir DIR          Log directory to operate on (required)
#   --max-total-bytes N    Hard cap on total directory size (default: 1073741824)
#   --lock-file PATH       Exclusive lock file path (default: <log-dir>/.prune.lock)
#   --protect-id ID        Never delete log-<ID>.log (repeatable)
#   --dry-run              Print actions without executing
#   --help                 Show this help message
#

set -eu

warn() {
    printf 'Warning: %s\n' "${1}" >&2
}

info() {
    printf '%s\n' "${1}"
}

die() {
    code="${1}"
    shift
    printf 'Error: %s\n' "${*}" >&2
    exit "${code}"
}

show_help() {
    sed -n '/^# Usage:/,/^$/p' "${0}" | sed 's/^# *//'
    exit 0
}

# --- Defaults ---
log_dir=""
max_total_bytes=1073741824
lock_file=""
protected_ids=""
dry_run=0

# --- Parse arguments ---
while [ "${#}" -gt 0 ]; do
    case "${1}" in
        --help|-h)
            show_help
            ;;
        --log-dir)
            [ -n "${2-}" ] || die 1 "--log-dir requires a directory argument"
            log_dir="${2}"
            shift 2
            ;;
        --max-total-bytes)
            [ -n "${2-}" ] || die 1 "--max-total-bytes requires a number"
            max_total_bytes="${2}"
            shift 2
            ;;
        --lock-file)
            [ -n "${2-}" ] || die 1 "--lock-file requires a path argument"
            lock_file="${2}"
            shift 2
            ;;
        --protect-id)
            [ -n "${2-}" ] || die 1 "--protect-id requires an ID argument"
            protected_ids="${protected_ids}
log-${2}.log"
            shift 2
            ;;
        --dry-run)
            dry_run=1
            shift
            ;;
        *)
            die 1 "Unknown option: ${1}"
            ;;
    esac
done

# --- Validate ---
[ -n "${log_dir}" ] || die 1 "--log-dir is required"
[ -d "${log_dir}" ] || die 1 "--log-dir is not a directory: ${log_dir}"

# Validate max_total_bytes is a positive integer
case "${max_total_bytes}" in
    ''|*[!0-9]*) die 1 "--max-total-bytes must be a positive integer: ${max_total_bytes}" ;;
esac

# Default lock-file to <log-dir>/.prune.lock
[ -n "${lock_file}" ] || lock_file="${log_dir}/.prune.lock"

# --- Dependencies ---
command -v flock >/dev/null 2>&1 || die 1 "Required command not found: flock"
command -v find  >/dev/null 2>&1 || die 1 "Required command not found: find"
command -v sort  >/dev/null 2>&1 || die 1 "Required command not found: sort"
command -v awk   >/dev/null 2>&1 || die 1 "Required command not found: awk"
command -v stat  >/dev/null 2>&1 || die 1 "Required command not found: stat"

# --- Optional: fuser for runtime active-file detection ---
# When available, fuser detects files currently held open by a process
# (e.g. a logd writer), protecting active logs whose service ID happens
# to contain a timestamp pattern.  Soft dependency: falls back to the
# children-based guard and --protect-id when fuser is absent.
has_fuser=0
command -v fuser >/dev/null 2>&1 && has_fuser=1

# --- Acquire exclusive lock (non-blocking) ---
# Open the lock file on fd 9 for flock
exec 9>"${lock_file}"
flock -n 9 || {
    info "prune: lock busy lock_file=${lock_file}; skipping"
    exit 0
}

# --- Active vs rotated file detection ---
# Reuse the exact is_rotated() pattern from sbin/supervisor-logrotate.
is_rotated() {
    case "${1}" in
        # With sequence suffix: base.YYYYMMDD-HHMMSS.N.log
        *.[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]-[0-9][0-9][0-9][0-9][0-9][0-9].[0-9]*.log) return 0 ;;
        # Without sequence suffix: base.YYYYMMDD-HHMMSS.log
        *.[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]-[0-9][0-9][0-9][0-9][0-9][0-9].log) return 0 ;;
        *) return 1 ;;
    esac
}

# --- Recover parent active filename from a rotated filename ---
# Strips the rightmost .YYYYMMDD-HHMMSS[.N].log suffix and appends .log.
# e.g., log-svc.20250101-120000.log   -> log-svc.log
#       log-svc.20250101-120000.3.log -> log-svc.log
#       log-svc.1.20250101-120000.log -> log-svc.1.log
rotated_parent_name() {
    printf '%s' "${1}" | sed 's/\.[0-9]\{8\}-[0-9]\{6\}\(\.[0-9]\{1,\}\)\{0,1\}\.log$/.log/'
}

# --- Compute total directory size ---
# Use du -sb for total bytes (GNU coreutils).
dir_total_bytes() {
    du -sb "${1}" | awk '{ print $1 }'
}

# --- File size in bytes ---
file_size_bytes() {
    stat --format='%s' "${1}" 2>/dev/null || wc -c < "${1}"
}

# --- Compute total and check cap ---
total="$(dir_total_bytes "${log_dir}")"
info "prune: start log_dir=${log_dir} total_bytes=${total} max_total_bytes=${max_total_bytes} dry_run=${dry_run}"
[ "${total}" -gt "${max_total_bytes}" ] || {
    info "prune: no action (under cap)"
    exit 0
}

# --- Collect rotated files sorted by mtime oldest-first ---
# find -printf '%T@ %p\n' gives epoch.frac path; sort -n gives oldest first.
rotated_files=""
rotated_files="$(find "${log_dir}" -maxdepth 1 -type f \
    \( -name 'supervisor.*.log' -o -name 'log-*.*.log' \) \
    -printf '%T@ %p\n' | sort -n | awk '{ print $2 }')"

[ -n "${rotated_files}" ] || {
    info "prune: no rotated candidates"
    exit 0
}

# --- Build protection metadata ---
# Compute parent names for all rotated files (shared by three guards).
parent_names="$(printf '%s\n' "${rotated_files}" | while IFS= read -r cf; do
    cname="${cf##*/}"
    is_rotated "${cname}" || continue
    printf '%s\n' "$(rotated_parent_name "${cname}")"
done)"

# confirmed_active: parent basenames that have at least one rotated
# child (confirms the parent as an active log, not a rotated file).
confirmed_active="$(printf '%s\n' "${parent_names}" | sort -u)"

# multi_child_parents: parent basenames with 2+ rotated children.
# When the parent active log has been removed (service deleted), the
# presence of siblings still confirms these are rotated children of
# the same (now-removed) service.
multi_child_parents="$(printf '%s\n' "${parent_names}" | sort | uniq -d)"

# Merge confirmed_active + --protect-id into the protected set.
protected_set="${confirmed_active}${protected_ids}"

# --- Delete oldest rotated files until under cap ---
excess=$((total - max_total_bytes))

printf '%s\n' "${rotated_files}" | while IFS= read -r f; do
    [ "${excess}" -gt 0 ] || break
    name="${f##*/}"
    is_rotated "${name}" || continue

    # Skip protected files (confirmed active parents or --protect-id).
    if [ -n "${protected_set}" ] && \
       printf '%s\n' "${protected_set}" | grep -qxF "${name}"; then
        continue
    fi

    # Confirm this file is genuinely rotated before deleting.
    # A file is confirmed rotated when:
    #  (a) Its parent active log exists (e.g. log-svc.log for
    #      log-svc.20250101-120000.log), OR
    #  (b) It has sibling rotated files with the same parent
    #      (confirms a now-removed service once existed).
    # Without either signal, the file may be an active log for a
    # service whose ID contains a timestamp pattern â€” preserve it.
    parent_name="$(rotated_parent_name "${name}")"
    if ! [ -f "${log_dir}/${parent_name}" ]; then
        if [ -z "${multi_child_parents}" ] || \
           ! printf '%s\n' "${multi_child_parents}" | grep -qxF "${parent_name}"; then
            continue
        fi
    fi

    # Skip files currently open by a process (active logd writer).
    # Belt-and-suspenders: catches the rare case where two services
    # exist such that one's rotated-child name collides with the
    # other's active log name (e.g. services "svc" and
    # "svc.20250101-120000" both running).
    [ "${has_fuser}" = "1" ] && fuser "${f}" >/dev/null 2>&1 && continue

    fsize="$(file_size_bytes "${f}")"
    case "${dry_run}" in
        1) printf 'prune: %s (%s bytes)\n' "${f}" "${fsize}" ;;
        *)
            rm -f "${f}"
            printf 'prune: %s (%s bytes)\n' "${f}" "${fsize}"
            ;;
    esac
    excess=$((excess - fsize))
done

info "prune: complete"
